package bnet

import (
	"context"
	"fmt"
	"net/url"
)

// GetUserSystemOverridesRequest are the request parameters for operation .GetUserSystemOverrides
type GetUserSystemOverridesRequest struct {
}

// GetUserSystemOverrides: Get the user-specific system overrides that should be respected alongside
// common systems.
//
// URL: /UserSystemOverrides/
//
// Operation: .GetUserSystemOverrides
func (a API) GetUserSystemOverrides(ctx context.Context, req GetUserSystemOverridesRequest) (*ServerResponse[map[string]CoreSystem], error) {
	//	{
	//	  "description": "Get the user-specific system overrides that should be respected alongside common systems.",
	//	  "operationId": ".GetUserSystemOverrides",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/DictionaryOfstringAndCoreSystem"
	//	    }
	//	  },
	//	  "tags": [
	//	    ""
	//	  ]
	//	}
	var resp ServerResponse[map[string]CoreSystem]
	err := a.client.Do(ctx, ClientRequest{Operation: ".GetUserSystemOverrides",
		Method:   "GET",
		PathSpec: "/UserSystemOverrides/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// UserGetMembershipDataForCurrentUserRequest are the request parameters for operation
// User.GetMembershipDataForCurrentUser
type UserGetMembershipDataForCurrentUserRequest struct {
}

// UserGetMembershipDataForCurrentUser: Returns a list of accounts associated with signed in user. This
// is useful for OAuth implementations that do not give you access to the token response.
//
// URL: /User/GetMembershipsForCurrentUser/
//
// Operation: User.GetMembershipDataForCurrentUser
//
// Scope: oauth2 [ReadBasicUserProfile]
func (a API) UserGetMembershipDataForCurrentUser(ctx context.Context, req UserGetMembershipDataForCurrentUserRequest) (*ServerResponse[UserMembershipData], error) {
	//	{
	//	  "description": "Returns a list of accounts associated with signed in user. This is useful for OAuth implementations that do not give you access to the token response.",
	//	  "operationId": "User.GetMembershipDataForCurrentUser",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/User.UserMembershipData"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "ReadBasicUserProfile"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "User"
	//	  ]
	//	}
	var resp ServerResponse[UserMembershipData]
	err := a.client.Do(ctx, ClientRequest{Operation: "User.GetMembershipDataForCurrentUser",
		Method:   "GET",
		PathSpec: "/User/GetMembershipsForCurrentUser/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// UserGetAvailableThemesRequest are the request parameters for operation User.GetAvailableThemes
type UserGetAvailableThemesRequest struct {
}

// UserGetAvailableThemes: Returns a list of all available user themes.
//
// URL: /User/GetAvailableThemes/
//
// Operation: User.GetAvailableThemes
func (a API) UserGetAvailableThemes(ctx context.Context, req UserGetAvailableThemesRequest) (*ServerResponse[[]UserTheme], error) {
	//	{
	//	  "description": "Returns a list of all available user themes.",
	//	  "operationId": "User.GetAvailableThemes",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/ListOfUserTheme"
	//	    }
	//	  },
	//	  "tags": [
	//	    "User"
	//	  ]
	//	}
	var resp ServerResponse[[]UserTheme]
	err := a.client.Do(ctx, ClientRequest{Operation: "User.GetAvailableThemes",
		Method:   "GET",
		PathSpec: "/User/GetAvailableThemes/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// TrendingGetTrendingCategoriesRequest are the request parameters for operation
// Trending.GetTrendingCategories
type TrendingGetTrendingCategoriesRequest struct {
}

// TrendingGetTrendingCategories: Returns trending items for Bungie.net, collapsed into the first page
// of items per category. For pagination within a category, call GetTrendingCategory.
//
// URL: /Trending/Categories/
//
// Operation: Trending.GetTrendingCategories
func (a API) TrendingGetTrendingCategories(ctx context.Context, req TrendingGetTrendingCategoriesRequest) (*ServerResponse[TrendingCategories], error) {
	//	{
	//	  "description": "Returns trending items for Bungie.net, collapsed into the first page of items per category. For pagination within a category, call GetTrendingCategory.",
	//	  "operationId": "Trending.GetTrendingCategories",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Trending.TrendingCategories"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Trending"
	//	  ]
	//	}
	var resp ServerResponse[TrendingCategories]
	err := a.client.Do(ctx, ClientRequest{Operation: "Trending.GetTrendingCategories",
		Method:   "GET",
		PathSpec: "/Trending/Categories/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// TokensGetBungieRewardsListRequest are the request parameters for operation
// Tokens.GetBungieRewardsList
type TokensGetBungieRewardsListRequest struct {
}

// TokensGetBungieRewardsList: Returns a list of the current bungie rewards
//
// URL: /Tokens/Rewards/BungieRewards/
//
// Operation: Tokens.GetBungieRewardsList
func (a API) TokensGetBungieRewardsList(ctx context.Context, req TokensGetBungieRewardsListRequest) (*ServerResponse[map[string]BungieRewardDisplay], error) {
	//	{
	//	  "description": "Returns a list of the current bungie rewards",
	//	  "operationId": "Tokens.GetBungieRewardsList",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/DictionaryOfstringAndBungieRewardDisplay"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Tokens"
	//	  ]
	//	}
	var resp ServerResponse[map[string]BungieRewardDisplay]
	err := a.client.Do(ctx, ClientRequest{Operation: "Tokens.GetBungieRewardsList",
		Method:   "GET",
		PathSpec: "/Tokens/Rewards/BungieRewards/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// TokensForceDropsRepairRequest are the request parameters for operation Tokens.ForceDropsRepair
type TokensForceDropsRepairRequest struct {
}

// TokensForceDropsRepair: Twitch Drops self-repair function - scans twitch for drops not marked as
// fulfilled and resyncs them.
//
// URL: /Tokens/Partner/ForceDropsRepair/
//
// Operation: Tokens.ForceDropsRepair
//
// Scope: oauth2 [PartnerOfferGrant]
func (a API) TokensForceDropsRepair(ctx context.Context, req TokensForceDropsRepairRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "Twitch Drops self-repair function - scans twitch for drops not marked as fulfilled and resyncs them.",
	//	  "operationId": "Tokens.ForceDropsRepair",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "PartnerOfferGrant"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Tokens"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "Tokens.ForceDropsRepair",
		Method:   "POST",
		PathSpec: "/Tokens/Partner/ForceDropsRepair/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// TokensClaimPartnerOfferRequest are the request parameters for operation Tokens.ClaimPartnerOffer
type TokensClaimPartnerOfferRequest struct {

	// Required.
	Body PartnerOfferClaimRequestBody
}

// TokensClaimPartnerOffer: Claim a partner offer as the authenticated user.
//
// URL: /Tokens/Partner/ClaimOffer/
//
// Operation: Tokens.ClaimPartnerOffer
//
// Scope: oauth2 [PartnerOfferGrant]
func (a API) TokensClaimPartnerOffer(ctx context.Context, req TokensClaimPartnerOfferRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "Claim a partner offer as the authenticated user.",
	//	  "operationId": "Tokens.ClaimPartnerOffer",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Tokens.PartnerOfferClaimRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "PartnerOfferGrant"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Tokens"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "Tokens.ClaimPartnerOffer",
		Method:   "POST",
		PathSpec: "/Tokens/Partner/ClaimOffer/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// SocialGetFriendRequestListRequest are the request parameters for operation
// Social.GetFriendRequestList
type SocialGetFriendRequestListRequest struct {
}

// SocialGetFriendRequestList: Returns your friend request queue.
//
// URL: /Social/Friends/Requests/
//
// Operation: Social.GetFriendRequestList
//
// Scope: oauth2 [ReadUserData]
func (a API) SocialGetFriendRequestList(ctx context.Context, req SocialGetFriendRequestListRequest) (*ServerResponse[BungieFriendRequestListResponse], error) {
	//	{
	//	  "description": "Returns your friend request queue.",
	//	  "operationId": "Social.GetFriendRequestList",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Social.Friends.BungieFriendRequestListResponse"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "ReadUserData"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Social"
	//	  ]
	//	}
	var resp ServerResponse[BungieFriendRequestListResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Social.GetFriendRequestList",
		Method:   "GET",
		PathSpec: "/Social/Friends/Requests/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// SocialGetFriendListRequest are the request parameters for operation Social.GetFriendList
type SocialGetFriendListRequest struct {
}

// SocialGetFriendList: Returns your Bungie Friend list
//
// URL: /Social/Friends/
//
// Operation: Social.GetFriendList
//
// Scope: oauth2 [ReadUserData]
func (a API) SocialGetFriendList(ctx context.Context, req SocialGetFriendListRequest) (*ServerResponse[BungieFriendListResponse], error) {
	//	{
	//	  "description": "Returns your Bungie Friend list",
	//	  "operationId": "Social.GetFriendList",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Social.Friends.BungieFriendListResponse"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "ReadUserData"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Social"
	//	  ]
	//	}
	var resp ServerResponse[BungieFriendListResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Social.GetFriendList",
		Method:   "GET",
		PathSpec: "/Social/Friends/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GetCommonSettingsRequest are the request parameters for operation .GetCommonSettings
type GetCommonSettingsRequest struct {
}

// GetCommonSettings: Get the common settings used by the Bungie.Net environment.
//
// URL: /Settings/
//
// Operation: .GetCommonSettings
func (a API) GetCommonSettings(ctx context.Context, req GetCommonSettingsRequest) (*ServerResponse[CoreSettingsConfiguration], error) {
	//	{
	//	  "description": "Get the common settings used by the Bungie.Net environment.",
	//	  "operationId": ".GetCommonSettings",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Common.Models.CoreSettingsConfiguration"
	//	    }
	//	  },
	//	  "tags": [
	//	    ""
	//	  ]
	//	}
	var resp ServerResponse[CoreSettingsConfiguration]
	err := a.client.Do(ctx, ClientRequest{Operation: ".GetCommonSettings",
		Method:   "GET",
		PathSpec: "/Settings/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2GroupSearchRequest are the request parameters for operation GroupV2.GroupSearch
type GroupV2GroupSearchRequest struct {

	// Required.
	Body GroupQuery
}

// GroupV2GroupSearch: Search for Groups.
//
// URL: /GroupV2/Search/
//
// Operation: GroupV2.GroupSearch
func (a API) GroupV2GroupSearch(ctx context.Context, req GroupV2GroupSearchRequest) (*ServerResponse[GroupSearchResponse], error) {
	//	{
	//	  "description": "Search for Groups.",
	//	  "operationId": "GroupV2.GroupSearch",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupQuery"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/GroupsV2.GroupSearchResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[GroupSearchResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GroupSearch",
		Method:   "POST",
		PathSpec: "/GroupV2/Search/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// GroupV2GetGroupByNameV2Request are the request parameters for operation GroupV2.GetGroupByNameV2
type GroupV2GetGroupByNameV2Request struct {

	// Required.
	Body GroupNameSearchRequestBody
}

// GroupV2GetGroupByNameV2: Get information about a specific group with the given name and type. The
// POST version.
//
// URL: /GroupV2/NameV2/
//
// Operation: GroupV2.GetGroupByNameV2
func (a API) GroupV2GetGroupByNameV2(ctx context.Context, req GroupV2GetGroupByNameV2Request) (*ServerResponse[GroupResponse], error) {
	//	{
	//	  "description": "Get information about a specific group with the given name and type. The POST version.",
	//	  "operationId": "GroupV2.GetGroupByNameV2",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupNameSearchRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/GroupsV2.GroupResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[GroupResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetGroupByNameV2",
		Method:   "POST",
		PathSpec: "/GroupV2/NameV2/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// GroupV2GetAvailableThemesRequest are the request parameters for operation GroupV2.GetAvailableThemes
type GroupV2GetAvailableThemesRequest struct {
}

// GroupV2GetAvailableThemes: Returns a list of all available group themes.
//
// URL: /GroupV2/GetAvailableThemes/
//
// Operation: GroupV2.GetAvailableThemes
func (a API) GroupV2GetAvailableThemes(ctx context.Context, req GroupV2GetAvailableThemesRequest) (*ServerResponse[[]GroupTheme], error) {
	//	{
	//	  "description": "Returns a list of all available group themes.",
	//	  "operationId": "GroupV2.GetAvailableThemes",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/ListOfGroupTheme"
	//	    }
	//	  },
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[[]GroupTheme]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetAvailableThemes",
		Method:   "GET",
		PathSpec: "/GroupV2/GetAvailableThemes/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2GetAvailableAvatarsRequest are the request parameters for operation
// GroupV2.GetAvailableAvatars
type GroupV2GetAvailableAvatarsRequest struct {
}

// GroupV2GetAvailableAvatars: Returns a list of all available group avatars for the signed-in user.
//
// URL: /GroupV2/GetAvailableAvatars/
//
// Operation: GroupV2.GetAvailableAvatars
func (a API) GroupV2GetAvailableAvatars(ctx context.Context, req GroupV2GetAvailableAvatarsRequest) (*ServerResponse[map[int32]string], error) {
	//	{
	//	  "description": "Returns a list of all available group avatars for the signed-in user.",
	//	  "operationId": "GroupV2.GetAvailableAvatars",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/DictionaryOfint32Andstring"
	//	    }
	//	  },
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[map[int32]string]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetAvailableAvatars",
		Method:   "GET",
		PathSpec: "/GroupV2/GetAvailableAvatars/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GetGlobalAlertsRequest are the request parameters for operation .GetGlobalAlerts
type GetGlobalAlertsRequest struct {

	// Determines whether Streaming Alerts are included in results
	Includestreaming bool
}

// GetGlobalAlerts: Gets any active global alert for display in the forum banners, help pages, etc.
// Usually used for DOC alerts.
//
// URL: /GlobalAlerts/
//
// Operation: .GetGlobalAlerts
func (a API) GetGlobalAlerts(ctx context.Context, req GetGlobalAlertsRequest) (*ServerResponse[[]GlobalAlert], error) {
	//	{
	//	  "description": "Gets any active global alert for display in the forum banners, help pages, etc. Usually used for DOC alerts.",
	//	  "operationId": ".GetGlobalAlerts",
	//	  "parameters": [
	//	    {
	//	      "description": "Determines whether Streaming Alerts are included in results",
	//	      "in": "query",
	//	      "name": "includestreaming",
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/CEListOfGlobalAlert"
	//	    }
	//	  },
	//	  "tags": [
	//	    ""
	//	  ]
	//	}
	var resp ServerResponse[[]GlobalAlert]
	err := a.client.Do(ctx, ClientRequest{Operation: ".GetGlobalAlerts",
		Method:   "GET",
		PathSpec: "/GlobalAlerts/", PathParams: map[string]string{}, QueryParams: url.Values{
			"includestreaming": {fmt.Sprint(req.Includestreaming)},
		}}, &resp)
	return &resp, err
}

// GetAvailableLocalesRequest are the request parameters for operation .GetAvailableLocales
type GetAvailableLocalesRequest struct {
}

// GetAvailableLocales: List of available localization cultures
//
// URL: /GetAvailableLocales/
//
// Operation: .GetAvailableLocales
func (a API) GetAvailableLocales(ctx context.Context, req GetAvailableLocalesRequest) (*ServerResponse[map[string]string], error) {
	//	{
	//	  "description": "List of available localization cultures",
	//	  "operationId": ".GetAvailableLocales",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/CEDictionaryOfstringAndstring"
	//	    }
	//	  },
	//	  "tags": [
	//	    ""
	//	  ]
	//	}
	var resp ServerResponse[map[string]string]
	err := a.client.Do(ctx, ClientRequest{Operation: ".GetAvailableLocales",
		Method:   "GET",
		PathSpec: "/GetAvailableLocales/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// ForumGetRecruitmentThreadSummariesRequest are the request parameters for operation
// Forum.GetRecruitmentThreadSummaries
type ForumGetRecruitmentThreadSummariesRequest struct {

	// Required.
	Body []Int64
}

// ForumGetRecruitmentThreadSummaries: Allows the caller to get a list of to 25 recruitment thread
// summary information objects.
//
// URL: /Forum/Recruit/Summaries/
//
// Operation: Forum.GetRecruitmentThreadSummaries
func (a API) ForumGetRecruitmentThreadSummaries(ctx context.Context, req ForumGetRecruitmentThreadSummariesRequest) (*ServerResponse[[]ForumRecruitmentDetail], error) {
	//	{
	//	  "description": "Allows the caller to get a list of to 25 recruitment thread summary information objects.",
	//	  "operationId": "Forum.GetRecruitmentThreadSummaries",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "items": {
	//	            "format": "int64",
	//	            "type": "integer"
	//	          },
	//	          "type": "array"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/CEListOfForumRecruitmentDetail"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Forum"
	//	  ]
	//	}
	var resp ServerResponse[[]ForumRecruitmentDetail]
	err := a.client.Do(ctx, ClientRequest{Operation: "Forum.GetRecruitmentThreadSummaries",
		Method:   "POST",
		PathSpec: "/Forum/Recruit/Summaries/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// ForumGetForumTagSuggestionsRequest are the request parameters for operation
// Forum.GetForumTagSuggestions
type ForumGetForumTagSuggestionsRequest struct {

	// The partial tag input to generate suggestions from.
	Partialtag string
}

// ForumGetForumTagSuggestions: Gets tag suggestions based on partial text entry, matching them with
// other tags previously used in the forums.
//
// URL: /Forum/GetForumTagSuggestions/
//
// Operation: Forum.GetForumTagSuggestions
func (a API) ForumGetForumTagSuggestions(ctx context.Context, req ForumGetForumTagSuggestionsRequest) (*ServerResponse[[]TagResponse], error) {
	//	{
	//	  "description": "Gets tag suggestions based on partial text entry, matching them with other tags previously used in the forums.",
	//	  "operationId": "Forum.GetForumTagSuggestions",
	//	  "parameters": [
	//	    {
	//	      "description": "The partial tag input to generate suggestions from.",
	//	      "in": "query",
	//	      "name": "partialtag",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/ListOfTagResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Forum"
	//	  ]
	//	}
	var resp ServerResponse[[]TagResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Forum.GetForumTagSuggestions",
		Method:   "GET",
		PathSpec: "/Forum/GetForumTagSuggestions/", PathParams: map[string]string{}, QueryParams: url.Values{
			"partialtag": {fmt.Sprint(req.Partialtag)},
		}}, &resp)
	return &resp, err
}

// Destiny2GetPublicVendorsRequest are the request parameters for operation Destiny2.GetPublicVendors
type Destiny2GetPublicVendorsRequest struct {

	// A comma separated list of components to return (as strings or numeric values). See the
	// DestinyComponentType enum for valid components to request. You must request at least one component
	// to receive results.
	Components []ComponentType
}

// Destiny2GetPublicVendors: Get items available from vendors where the vendors have items for sale
// that are common for everyone. If any portion of the Vendor's available inventory is character or
// account specific, we will be unable to return their data from this endpoint due to the way that
// available inventory is computed. As I am often guilty of saying: 'It's a long story...'
//
// URL: /Destiny2/Vendors/
//
// Operation: Destiny2.GetPublicVendors
func (a API) Destiny2GetPublicVendors(ctx context.Context, req Destiny2GetPublicVendorsRequest) (*ServerResponse[PublicVendorsResponse], error) {
	//	{
	//	  "description": "Get items available from vendors where the vendors have items for sale that are common for everyone. If any portion of the Vendor's available inventory is character or account specific, we will be unable to return their data from this endpoint due to the way that available inventory is computed. As I am often guilty of saying: 'It's a long story...'",
	//	  "operationId": "Destiny2.GetPublicVendors",
	//	  "parameters": [
	//	    {
	//	      "description": "A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results.",
	//	      "in": "query",
	//	      "name": "components",
	//	      "schema": {
	//	        "items": {
	//	          "description": "Represents the possible components that can be returned from Destiny \"Get\" calls such as GetProfile, GetCharacter, GetVendor etc...\r\nWhen making one of these requests, you will pass one or more of these components as a comma separated list in the \"?components=\" querystring parameter. For instance, if you want baseline Profile data, Character Data, and character progressions, you would pass \"?components=Profiles,Characters,CharacterProgressions\" You may use either the numerical or string values.",
	//	          "format": "int32",
	//	          "type": "integer",
	//	          "x-enum-is-bitmask": false,
	//	          "x-enum-reference": {
	//	            "$ref": "#/components/schemas/Destiny.DestinyComponentType"
	//	          }
	//	        },
	//	        "type": "array"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Responses.DestinyPublicVendorsResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2",
	//	    "Preview"
	//	  ],
	//	  "x-preview": true
	//	}
	var resp ServerResponse[PublicVendorsResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetPublicVendors",
		Method:   "GET",
		PathSpec: "/Destiny2/Vendors/", PathParams: map[string]string{}, QueryParams: url.Values{
			"components": {joinArray(req.Components)},
		}}, &resp)
	return &resp, err
}

// Destiny2GetHistoricalStatsDefinitionRequest are the request parameters for operation
// Destiny2.GetHistoricalStatsDefinition
type Destiny2GetHistoricalStatsDefinitionRequest struct {
}

// Destiny2GetHistoricalStatsDefinition: Gets historical stats definitions.
//
// URL: /Destiny2/Stats/Definition/
//
// Operation: Destiny2.GetHistoricalStatsDefinition
func (a API) Destiny2GetHistoricalStatsDefinition(ctx context.Context, req Destiny2GetHistoricalStatsDefinitionRequest) (*ServerResponse[map[string]HistoricalStatsDefinition], error) {
	//	{
	//	  "description": "Gets historical stats definitions.",
	//	  "operationId": "Destiny2.GetHistoricalStatsDefinition",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/ReadOnlyDictionaryOfstringAndDestinyHistoricalStatsDefinition"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[map[string]HistoricalStatsDefinition]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetHistoricalStatsDefinition",
		Method:   "GET",
		PathSpec: "/Destiny2/Stats/Definition/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// Destiny2GetPublicMilestonesRequest are the request parameters for operation
// Destiny2.GetPublicMilestones
type Destiny2GetPublicMilestonesRequest struct {
}

// Destiny2GetPublicMilestones: Gets public information about currently available Milestones.
//
// URL: /Destiny2/Milestones/
//
// Operation: Destiny2.GetPublicMilestones
func (a API) Destiny2GetPublicMilestones(ctx context.Context, req Destiny2GetPublicMilestonesRequest) (*ServerResponse[map[uint32]PublicMilestone], error) {
	//	{
	//	  "description": "Gets public information about currently available Milestones.",
	//	  "operationId": "Destiny2.GetPublicMilestones",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/DictionaryOfuint32AndDestinyPublicMilestone"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[map[uint32]PublicMilestone]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetPublicMilestones",
		Method:   "GET",
		PathSpec: "/Destiny2/Milestones/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// Destiny2GetDestinyManifestRequest are the request parameters for operation
// Destiny2.GetDestinyManifest
type Destiny2GetDestinyManifestRequest struct {
}

// Destiny2GetDestinyManifest: Returns the current version of the manifest as a json object.
//
// URL: /Destiny2/Manifest/
//
// Operation: Destiny2.GetDestinyManifest
func (a API) Destiny2GetDestinyManifest(ctx context.Context, req Destiny2GetDestinyManifestRequest) (*ServerResponse[Manifest], error) {
	//	{
	//	  "description": "Returns the current version of the manifest as a json object.",
	//	  "operationId": "Destiny2.GetDestinyManifest",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Config.DestinyManifest"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[Manifest]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetDestinyManifest",
		Method:   "GET",
		PathSpec: "/Destiny2/Manifest/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// Destiny2GetClanBannerSourceRequest are the request parameters for operation
// Destiny2.GetClanBannerSource
type Destiny2GetClanBannerSourceRequest struct {
}

// Destiny2GetClanBannerSource: Returns the dictionary of values for the Clan Banner
//
// URL: /Destiny2/Clan/ClanBannerDictionary/
//
// Operation: Destiny2.GetClanBannerSource
func (a API) Destiny2GetClanBannerSource(ctx context.Context, req Destiny2GetClanBannerSourceRequest) (*ServerResponse[ClanBannerSource], error) {
	//	{
	//	  "description": "Returns the dictionary of values for the Clan Banner",
	//	  "operationId": "Destiny2.GetClanBannerSource",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Config.ClanBanner.ClanBannerSource"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[ClanBannerSource]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetClanBannerSource",
		Method:   "GET",
		PathSpec: "/Destiny2/Clan/ClanBannerDictionary/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// Destiny2AwaInitializeRequestRequest are the request parameters for operation
// Destiny2.AwaInitializeRequest
type Destiny2AwaInitializeRequestRequest struct {

	// Required.
	Body AwaPermissionRequested
}

// Destiny2AwaInitializeRequest: Initialize a request to perform an advanced write action.
//
// URL: /Destiny2/Awa/Initialize/
//
// Operation: Destiny2.AwaInitializeRequest
//
// Scope: oauth2 [AdvancedWriteActions]
func (a API) Destiny2AwaInitializeRequest(ctx context.Context, req Destiny2AwaInitializeRequestRequest) (*ServerResponse[AwaInitializeResponse], error) {
	//	{
	//	  "description": "Initialize a request to perform an advanced write action.",
	//	  "operationId": "Destiny2.AwaInitializeRequest",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Destiny.Advanced.AwaPermissionRequested"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Advanced.AwaInitializeResponse"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdvancedWriteActions"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[AwaInitializeResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.AwaInitializeRequest",
		Method:   "POST",
		PathSpec: "/Destiny2/Awa/Initialize/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// Destiny2AwaProvideAuthorizationResultRequest are the request parameters for operation
// Destiny2.AwaProvideAuthorizationResult
type Destiny2AwaProvideAuthorizationResultRequest struct {

	// Required.
	Body AwaUserResponse
}

// Destiny2AwaProvideAuthorizationResult: Provide the result of the user interaction. Called by the
// Bungie Destiny App to approve or reject a request.
//
// URL: /Destiny2/Awa/AwaProvideAuthorizationResult/
//
// Operation: Destiny2.AwaProvideAuthorizationResult
func (a API) Destiny2AwaProvideAuthorizationResult(ctx context.Context, req Destiny2AwaProvideAuthorizationResultRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Provide the result of the user interaction. Called by the Bungie Destiny App to approve or reject a request.",
	//	  "operationId": "Destiny2.AwaProvideAuthorizationResult",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Destiny.Advanced.AwaUserResponse"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.AwaProvideAuthorizationResult",
		Method:   "POST",
		PathSpec: "/Destiny2/Awa/AwaProvideAuthorizationResult/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// Destiny2UpdateLoadoutIdentifiersRequest are the request parameters for operation
// Destiny2.UpdateLoadoutIdentifiers
type Destiny2UpdateLoadoutIdentifiersRequest struct {

	// Required.
	Body LoadoutUpdateActionRequestBody
}

// Destiny2UpdateLoadoutIdentifiers: Update the color, icon, and name of a loadout.
//
// URL: /Destiny2/Actions/Loadouts/UpdateLoadoutIdentifiers/
//
// Operation: Destiny2.UpdateLoadoutIdentifiers
//
// Scope: oauth2 [MoveEquipDestinyItems]
func (a API) Destiny2UpdateLoadoutIdentifiers(ctx context.Context, req Destiny2UpdateLoadoutIdentifiersRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Update the color, icon, and name of a loadout.",
	//	  "operationId": "Destiny2.UpdateLoadoutIdentifiers",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Destiny.Requests.Actions.DestinyLoadoutUpdateActionRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "MoveEquipDestinyItems"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Destiny2"
	//	  ],
	//	  "x-documentation-attributes": {
	//	    "ThrottleSecondsBetweenActionPerUser": "1"
	//	  }
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.UpdateLoadoutIdentifiers",
		Method:   "POST",
		PathSpec: "/Destiny2/Actions/Loadouts/UpdateLoadoutIdentifiers/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// Destiny2SnapshotLoadoutRequest are the request parameters for operation Destiny2.SnapshotLoadout
type Destiny2SnapshotLoadoutRequest struct {

	// Required.
	Body LoadoutUpdateActionRequestBody
}

// Destiny2SnapshotLoadout: Snapshot a loadout with the currently equipped items.
//
// URL: /Destiny2/Actions/Loadouts/SnapshotLoadout/
//
// Operation: Destiny2.SnapshotLoadout
//
// Scope: oauth2 [MoveEquipDestinyItems]
func (a API) Destiny2SnapshotLoadout(ctx context.Context, req Destiny2SnapshotLoadoutRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Snapshot a loadout with the currently equipped items.",
	//	  "operationId": "Destiny2.SnapshotLoadout",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Destiny.Requests.Actions.DestinyLoadoutUpdateActionRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "MoveEquipDestinyItems"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Destiny2"
	//	  ],
	//	  "x-documentation-attributes": {
	//	    "ThrottleSecondsBetweenActionPerUser": "1"
	//	  }
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.SnapshotLoadout",
		Method:   "POST",
		PathSpec: "/Destiny2/Actions/Loadouts/SnapshotLoadout/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// Destiny2EquipLoadoutRequest are the request parameters for operation Destiny2.EquipLoadout
type Destiny2EquipLoadoutRequest struct {

	// Required.
	Body LoadoutActionRequestBody
}

// Destiny2EquipLoadout: Equip a loadout. You must have a valid Destiny Account, and either be in a
// social space, in orbit, or offline.
//
// URL: /Destiny2/Actions/Loadouts/EquipLoadout/
//
// Operation: Destiny2.EquipLoadout
//
// Scope: oauth2 [MoveEquipDestinyItems]
func (a API) Destiny2EquipLoadout(ctx context.Context, req Destiny2EquipLoadoutRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Equip a loadout. You must have a valid Destiny Account, and either be in a social space, in orbit, or offline.",
	//	  "operationId": "Destiny2.EquipLoadout",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Destiny.Requests.Actions.DestinyLoadoutActionRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "MoveEquipDestinyItems"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Destiny2"
	//	  ],
	//	  "x-documentation-attributes": {
	//	    "ThrottleSecondsBetweenActionPerUser": "1"
	//	  }
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.EquipLoadout",
		Method:   "POST",
		PathSpec: "/Destiny2/Actions/Loadouts/EquipLoadout/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// Destiny2ClearLoadoutRequest are the request parameters for operation Destiny2.ClearLoadout
type Destiny2ClearLoadoutRequest struct {

	// Required.
	Body LoadoutActionRequestBody
}

// Destiny2ClearLoadout: Clear the identifiers and items of a loadout.
//
// URL: /Destiny2/Actions/Loadouts/ClearLoadout/
//
// Operation: Destiny2.ClearLoadout
//
// Scope: oauth2 [MoveEquipDestinyItems]
func (a API) Destiny2ClearLoadout(ctx context.Context, req Destiny2ClearLoadoutRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Clear the identifiers and items of a loadout.",
	//	  "operationId": "Destiny2.ClearLoadout",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Destiny.Requests.Actions.DestinyLoadoutActionRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "MoveEquipDestinyItems"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Destiny2"
	//	  ],
	//	  "x-documentation-attributes": {
	//	    "ThrottleSecondsBetweenActionPerUser": "1"
	//	  }
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.ClearLoadout",
		Method:   "POST",
		PathSpec: "/Destiny2/Actions/Loadouts/ClearLoadout/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// Destiny2TransferItemRequest are the request parameters for operation Destiny2.TransferItem
type Destiny2TransferItemRequest struct {

	// Required.
	Body ItemTransferRequestBody
}

// Destiny2TransferItem: Transfer an item to/from your vault. You must have a valid Destiny account.
// You must also pass BOTH a reference AND an instance ID if it's an instanced item. itshappening.gif
//
// URL: /Destiny2/Actions/Items/TransferItem/
//
// Operation: Destiny2.TransferItem
//
// Scope: oauth2 [MoveEquipDestinyItems]
func (a API) Destiny2TransferItem(ctx context.Context, req Destiny2TransferItemRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Transfer an item to/from your vault. You must have a valid Destiny account. You must also pass BOTH a reference AND an instance ID if it's an instanced item. itshappening.gif",
	//	  "operationId": "Destiny2.TransferItem",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Destiny.Requests.DestinyItemTransferRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "MoveEquipDestinyItems"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Destiny2"
	//	  ],
	//	  "x-documentation-attributes": {
	//	    "ThrottleSecondsBetweenActionPerUser": "0.1"
	//	  }
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.TransferItem",
		Method:   "POST",
		PathSpec: "/Destiny2/Actions/Items/TransferItem/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// Destiny2SetQuestTrackedStateRequest are the request parameters for operation
// Destiny2.SetQuestTrackedState
type Destiny2SetQuestTrackedStateRequest struct {

	// Required.
	Body ItemStateRequestBody
}

// Destiny2SetQuestTrackedState: Set the Tracking State for an instanced item, if that item is a Quest
// or Bounty. You must have a valid Destiny Account. Yeah, it's an item.
//
// URL: /Destiny2/Actions/Items/SetTrackedState/
//
// Operation: Destiny2.SetQuestTrackedState
//
// Scope: oauth2 [MoveEquipDestinyItems]
func (a API) Destiny2SetQuestTrackedState(ctx context.Context, req Destiny2SetQuestTrackedStateRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Set the Tracking State for an instanced item, if that item is a Quest or Bounty. You must have a valid Destiny Account. Yeah, it's an item.",
	//	  "operationId": "Destiny2.SetQuestTrackedState",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Destiny.Requests.Actions.DestinyItemStateRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "MoveEquipDestinyItems"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Destiny2"
	//	  ],
	//	  "x-documentation-attributes": {
	//	    "ThrottleSecondsBetweenActionPerUser": "1"
	//	  }
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.SetQuestTrackedState",
		Method:   "POST",
		PathSpec: "/Destiny2/Actions/Items/SetTrackedState/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// Destiny2SetItemLockStateRequest are the request parameters for operation Destiny2.SetItemLockState
type Destiny2SetItemLockStateRequest struct {

	// Required.
	Body ItemStateRequestBody
}

// Destiny2SetItemLockState: Set the Lock State for an instanced item. You must have a valid Destiny
// Account.
//
// URL: /Destiny2/Actions/Items/SetLockState/
//
// Operation: Destiny2.SetItemLockState
//
// Scope: oauth2 [MoveEquipDestinyItems]
func (a API) Destiny2SetItemLockState(ctx context.Context, req Destiny2SetItemLockStateRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Set the Lock State for an instanced item. You must have a valid Destiny Account.",
	//	  "operationId": "Destiny2.SetItemLockState",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Destiny.Requests.Actions.DestinyItemStateRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "MoveEquipDestinyItems"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Destiny2"
	//	  ],
	//	  "x-documentation-attributes": {
	//	    "ThrottleSecondsBetweenActionPerUser": "0.1"
	//	  }
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.SetItemLockState",
		Method:   "POST",
		PathSpec: "/Destiny2/Actions/Items/SetLockState/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// Destiny2PullFromPostmasterRequest are the request parameters for operation
// Destiny2.PullFromPostmaster
type Destiny2PullFromPostmasterRequest struct {

	// Required.
	Body PostmasterTransferRequestBody
}

// Destiny2PullFromPostmaster: Extract an item from the Postmaster, with whatever implications that may
// entail. You must have a valid Destiny account. You must also pass BOTH a reference AND an instance
// ID if it's an instanced item.
//
// URL: /Destiny2/Actions/Items/PullFromPostmaster/
//
// Operation: Destiny2.PullFromPostmaster
//
// Scope: oauth2 [MoveEquipDestinyItems]
func (a API) Destiny2PullFromPostmaster(ctx context.Context, req Destiny2PullFromPostmasterRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Extract an item from the Postmaster, with whatever implications that may entail. You must have a valid Destiny account. You must also pass BOTH a reference AND an instance ID if it's an instanced item.",
	//	  "operationId": "Destiny2.PullFromPostmaster",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Destiny.Requests.Actions.DestinyPostmasterTransferRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "MoveEquipDestinyItems"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Destiny2"
	//	  ],
	//	  "x-documentation-attributes": {
	//	    "ThrottleSecondsBetweenActionPerUser": "0.1"
	//	  }
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.PullFromPostmaster",
		Method:   "POST",
		PathSpec: "/Destiny2/Actions/Items/PullFromPostmaster/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// Destiny2InsertSocketPlugFreeRequest are the request parameters for operation
// Destiny2.InsertSocketPlugFree
type Destiny2InsertSocketPlugFreeRequest struct {

	// Required.
	Body InsertPlugsFreeActionRequestBody
}

// Destiny2InsertSocketPlugFree: Insert a 'free' plug into an item's socket. This does not require
// 'Advanced Write Action' authorization and is available to 3rd-party apps, but will only work on
// 'free and reversible' socket actions (Perks, Armor Mods, Shaders, Ornaments, etc.). You must have a
// valid Destiny Account, and the character must either be in a social space, in orbit, or offline.
//
// URL: /Destiny2/Actions/Items/InsertSocketPlugFree/
//
// Operation: Destiny2.InsertSocketPlugFree
//
// Scope: oauth2 [MoveEquipDestinyItems]
func (a API) Destiny2InsertSocketPlugFree(ctx context.Context, req Destiny2InsertSocketPlugFreeRequest) (*ServerResponse[ItemChangeResponse], error) {
	//	{
	//	  "description": "Insert a 'free' plug into an item's socket. This does not require 'Advanced Write Action' authorization and is available to 3rd-party apps, but will only work on 'free and reversible' socket actions (Perks, Armor Mods, Shaders, Ornaments, etc.). You must have a valid Destiny Account, and the character must either be in a social space, in orbit, or offline.",
	//	  "operationId": "Destiny2.InsertSocketPlugFree",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Destiny.Requests.Actions.DestinyInsertPlugsFreeActionRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Responses.DestinyItemChangeResponse"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "MoveEquipDestinyItems"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Destiny2",
	//	    "Preview"
	//	  ],
	//	  "x-documentation-attributes": {
	//	    "ThrottleSecondsBetweenActionPerUser": "0.5"
	//	  },
	//	  "x-preview": true
	//	}
	var resp ServerResponse[ItemChangeResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.InsertSocketPlugFree",
		Method:   "POST",
		PathSpec: "/Destiny2/Actions/Items/InsertSocketPlugFree/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// Destiny2InsertSocketPlugRequest are the request parameters for operation Destiny2.InsertSocketPlug
type Destiny2InsertSocketPlugRequest struct {

	// Required.
	Body InsertPlugsActionRequestBody
}

// Destiny2InsertSocketPlug: Insert a plug into a socketed item. I know how it sounds, but I assure you
// it's much more G-rated than you might be guessing. We haven't decided yet whether this will be able
// to insert plugs that have side effects, but if we do it will require special scope permission for an
// application attempting to do so. You must have a valid Destiny Account, and either be in a social
// space, in orbit, or offline. Request must include proof of permission for 'InsertPlugs' from the
// account owner.
//
// URL: /Destiny2/Actions/Items/InsertSocketPlug/
//
// Operation: Destiny2.InsertSocketPlug
//
// Scope: oauth2 [AdvancedWriteActions]
func (a API) Destiny2InsertSocketPlug(ctx context.Context, req Destiny2InsertSocketPlugRequest) (*ServerResponse[ItemChangeResponse], error) {
	//	{
	//	  "description": "Insert a plug into a socketed item. I know how it sounds, but I assure you it's much more G-rated than you might be guessing. We haven't decided yet whether this will be able to insert plugs that have side effects, but if we do it will require special scope permission for an application attempting to do so. You must have a valid Destiny Account, and either be in a social space, in orbit, or offline. Request must include proof of permission for 'InsertPlugs' from the account owner.",
	//	  "operationId": "Destiny2.InsertSocketPlug",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Destiny.Requests.Actions.DestinyInsertPlugsActionRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Responses.DestinyItemChangeResponse"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdvancedWriteActions"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Destiny2",
	//	    "Preview"
	//	  ],
	//	  "x-documentation-attributes": {
	//	    "ThrottleSecondsBetweenActionPerUser": "0.5"
	//	  },
	//	  "x-preview": true
	//	}
	var resp ServerResponse[ItemChangeResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.InsertSocketPlug",
		Method:   "POST",
		PathSpec: "/Destiny2/Actions/Items/InsertSocketPlug/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// Destiny2EquipItemsRequest are the request parameters for operation Destiny2.EquipItems
type Destiny2EquipItemsRequest struct {

	// Required.
	Body ItemSetActionRequestBody
}

// Destiny2EquipItems: Equip a list of items by itemInstanceIds. You must have a valid Destiny Account,
// and either be in a social space, in orbit, or offline. Any items not found on your character will be
// ignored.
//
// URL: /Destiny2/Actions/Items/EquipItems/
//
// Operation: Destiny2.EquipItems
//
// Scope: oauth2 [MoveEquipDestinyItems]
func (a API) Destiny2EquipItems(ctx context.Context, req Destiny2EquipItemsRequest) (*ServerResponse[EquipItemResults], error) {
	//	{
	//	  "description": "Equip a list of items by itemInstanceIds. You must have a valid Destiny Account, and either be in a social space, in orbit, or offline. Any items not found on your character will be ignored.",
	//	  "operationId": "Destiny2.EquipItems",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Destiny.Requests.Actions.DestinyItemSetActionRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.DestinyEquipItemResults"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "MoveEquipDestinyItems"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Destiny2"
	//	  ],
	//	  "x-documentation-attributes": {
	//	    "ThrottleSecondsBetweenActionPerUser": "0.1"
	//	  }
	//	}
	var resp ServerResponse[EquipItemResults]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.EquipItems",
		Method:   "POST",
		PathSpec: "/Destiny2/Actions/Items/EquipItems/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// Destiny2EquipItemRequest are the request parameters for operation Destiny2.EquipItem
type Destiny2EquipItemRequest struct {

	// Required.
	Body ItemActionRequestBody
}

// Destiny2EquipItem: Equip an item. You must have a valid Destiny Account, and either be in a social
// space, in orbit, or offline.
//
// URL: /Destiny2/Actions/Items/EquipItem/
//
// Operation: Destiny2.EquipItem
//
// Scope: oauth2 [MoveEquipDestinyItems]
func (a API) Destiny2EquipItem(ctx context.Context, req Destiny2EquipItemRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Equip an item. You must have a valid Destiny Account, and either be in a social space, in orbit, or offline.",
	//	  "operationId": "Destiny2.EquipItem",
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Destiny.Requests.Actions.DestinyItemActionRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "MoveEquipDestinyItems"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Destiny2"
	//	  ],
	//	  "x-documentation-attributes": {
	//	    "ThrottleSecondsBetweenActionPerUser": "0.1"
	//	  }
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.EquipItem",
		Method:   "POST",
		PathSpec: "/Destiny2/Actions/Items/EquipItem/", PathParams: map[string]string{}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// AppGetBungieApplicationsRequest are the request parameters for operation App.GetBungieApplications
type AppGetBungieApplicationsRequest struct {
}

// AppGetBungieApplications: Get list of applications created by Bungie.
//
// URL: /App/FirstParty/
//
// Operation: App.GetBungieApplications
func (a API) AppGetBungieApplications(ctx context.Context, req AppGetBungieApplicationsRequest) (*ServerResponse[[]Application], error) {
	//	{
	//	  "description": "Get list of applications created by Bungie.",
	//	  "operationId": "App.GetBungieApplications",
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/IEnumerableOfApplication"
	//	    }
	//	  },
	//	  "tags": [
	//	    "App"
	//	  ]
	//	}
	var resp ServerResponse[[]Application]
	err := a.client.Do(ctx, ClientRequest{Operation: "App.GetBungieApplications",
		Method:   "GET",
		PathSpec: "/App/FirstParty/", PathParams: map[string]string{}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// UserSearchByGlobalNamePostRequest are the request parameters for operation
// User.SearchByGlobalNamePost
type UserSearchByGlobalNamePostRequest struct {

	// The zero-based page of results you desire.
	// Required.
	Page int32

	// Required.
	Body UserSearchPrefixRequestBody
}

// UserSearchByGlobalNamePost: Given the prefix of a global display name, returns all users who share
// that name.
//
// URL: /User/Search/GlobalName/{page}/
//
// Operation: User.SearchByGlobalNamePost
func (a API) UserSearchByGlobalNamePost(ctx context.Context, req UserSearchByGlobalNamePostRequest) (*ServerResponse[UserSearchResponse], error) {
	//	{
	//	  "description": "Given the prefix of a global display name, returns all users who share that name.",
	//	  "operationId": "User.SearchByGlobalNamePost",
	//	  "parameters": [
	//	    {
	//	      "description": "The zero-based page of results you desire.",
	//	      "in": "path",
	//	      "name": "page",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/User.UserSearchPrefixRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/User.UserSearchResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "User"
	//	  ]
	//	}
	var resp ServerResponse[UserSearchResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "User.SearchByGlobalNamePost",
		Method:   "POST",
		PathSpec: "/User/Search/GlobalName/{page}/", PathParams: map[string]string{
			"page": fmt.Sprint(req.Page),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// UserGetSanitizedPlatformDisplayNamesRequest are the request parameters for operation
// User.GetSanitizedPlatformDisplayNames
type UserGetSanitizedPlatformDisplayNamesRequest struct {

	// The requested membership id to load.
	// Required.
	MembershipID Int64
}

// UserGetSanitizedPlatformDisplayNames: Gets a list of all display names linked to this membership id
// but sanitized (profanity filtered). Obeys all visibility rules of calling user and is heavily
// cached.
//
// URL: /User/GetSanitizedPlatformDisplayNames/{membershipId}/
//
// Operation: User.GetSanitizedPlatformDisplayNames
func (a API) UserGetSanitizedPlatformDisplayNames(ctx context.Context, req UserGetSanitizedPlatformDisplayNamesRequest) (*ServerResponse[map[string]string], error) {
	//	{
	//	  "description": "Gets a list of all display names linked to this membership id but sanitized (profanity filtered). Obeys all visibility rules of calling user and is heavily cached.",
	//	  "operationId": "User.GetSanitizedPlatformDisplayNames",
	//	  "parameters": [
	//	    {
	//	      "description": "The requested membership id to load.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/CEDictionaryOfBungieCredentialTypeAndstring"
	//	    }
	//	  },
	//	  "tags": [
	//	    "User"
	//	  ]
	//	}
	var resp ServerResponse[map[string]string]
	err := a.client.Do(ctx, ClientRequest{Operation: "User.GetSanitizedPlatformDisplayNames",
		Method:   "GET",
		PathSpec: "/User/GetSanitizedPlatformDisplayNames/{membershipId}/", PathParams: map[string]string{
			"membershipId": fmt.Sprint(req.MembershipID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// UserGetCredentialTypesForTargetAccountRequest are the request parameters for operation
// User.GetCredentialTypesForTargetAccount
type UserGetCredentialTypesForTargetAccountRequest struct {

	// The user's membership id
	// Required.
	MembershipID Int64
}

// UserGetCredentialTypesForTargetAccount: Returns a list of credential types attached to the requested
// account
//
// URL: /User/GetCredentialTypesForTargetAccount/{membershipId}/
//
// Operation: User.GetCredentialTypesForTargetAccount
func (a API) UserGetCredentialTypesForTargetAccount(ctx context.Context, req UserGetCredentialTypesForTargetAccountRequest) (*ServerResponse[[]GetCredentialTypesForAccountResponse], error) {
	//	{
	//	  "description": "Returns a list of credential types attached to the requested account",
	//	  "operationId": "User.GetCredentialTypesForTargetAccount",
	//	  "parameters": [
	//	    {
	//	      "description": "The user's membership id",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/ListOfGetCredentialTypesForAccountResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "User"
	//	  ]
	//	}
	var resp ServerResponse[[]GetCredentialTypesForAccountResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "User.GetCredentialTypesForTargetAccount",
		Method:   "GET",
		PathSpec: "/User/GetCredentialTypesForTargetAccount/{membershipId}/", PathParams: map[string]string{
			"membershipId": fmt.Sprint(req.MembershipID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// UserGetBungieNetUserByIdRequest are the request parameters for operation User.GetBungieNetUserById
type UserGetBungieNetUserByIdRequest struct {

	// The requested Bungie.net membership id.
	// Required.
	Id Int64
}

// UserGetBungieNetUserById: Loads a bungienet user by membership id.
//
// URL: /User/GetBungieNetUserById/{id}/
//
// Operation: User.GetBungieNetUserById
func (a API) UserGetBungieNetUserById(ctx context.Context, req UserGetBungieNetUserByIdRequest) (*ServerResponse[GeneralUser], error) {
	//	{
	//	  "description": "Loads a bungienet user by membership id.",
	//	  "operationId": "User.GetBungieNetUserById",
	//	  "parameters": [
	//	    {
	//	      "description": "The requested Bungie.net membership id.",
	//	      "in": "path",
	//	      "name": "id",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/User.GeneralUser"
	//	    }
	//	  },
	//	  "tags": [
	//	    "User"
	//	  ]
	//	}
	var resp ServerResponse[GeneralUser]
	err := a.client.Do(ctx, ClientRequest{Operation: "User.GetBungieNetUserById",
		Method:   "GET",
		PathSpec: "/User/GetBungieNetUserById/{id}/", PathParams: map[string]string{
			"id": fmt.Sprint(req.Id),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// TokensGetBungieRewardsForUserRequest are the request parameters for operation
// Tokens.GetBungieRewardsForUser
type TokensGetBungieRewardsForUserRequest struct {

	// bungie.net user membershipId for requested user rewards. If not self, elevated permissions are
	// required.
	// Required.
	MembershipID Int64
}

// TokensGetBungieRewardsForUser: Returns the bungie rewards for the targeted user.
//
// URL: /Tokens/Rewards/GetRewardsForUser/{membershipId}/
//
// Operation: Tokens.GetBungieRewardsForUser
//
// Scope: oauth2 [ReadAndApplyTokens]
func (a API) TokensGetBungieRewardsForUser(ctx context.Context, req TokensGetBungieRewardsForUserRequest) (*ServerResponse[map[string]BungieRewardDisplay], error) {
	//	{
	//	  "description": "Returns the bungie rewards for the targeted user.",
	//	  "operationId": "Tokens.GetBungieRewardsForUser",
	//	  "parameters": [
	//	    {
	//	      "description": "bungie.net user membershipId for requested user rewards. If not self, elevated permissions are required.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/DictionaryOfstringAndBungieRewardDisplay"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "ReadAndApplyTokens"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Tokens"
	//	  ]
	//	}
	var resp ServerResponse[map[string]BungieRewardDisplay]
	err := a.client.Do(ctx, ClientRequest{Operation: "Tokens.GetBungieRewardsForUser",
		Method:   "GET",
		PathSpec: "/Tokens/Rewards/GetRewardsForUser/{membershipId}/", PathParams: map[string]string{
			"membershipId": fmt.Sprint(req.MembershipID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// SocialRemoveFriendRequestRequest are the request parameters for operation Social.RemoveFriendRequest
type SocialRemoveFriendRequestRequest struct {

	// The membership id of the user you wish to remove.
	// Required.
	MembershipID string
}

// SocialRemoveFriendRequest: Remove a friend relationship with the target user. The user must be on
// your outgoing request friend list, though no error will occur if they are not.
//
// URL: /Social/Friends/Requests/Remove/{membershipId}/
//
// Operation: Social.RemoveFriendRequest
//
// Scope: oauth2 [BnetWrite]
func (a API) SocialRemoveFriendRequest(ctx context.Context, req SocialRemoveFriendRequestRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "Remove a friend relationship with the target user. The user must be on your outgoing request friend list, though no error will occur if they are not.",
	//	  "operationId": "Social.RemoveFriendRequest",
	//	  "parameters": [
	//	    {
	//	      "description": "The membership id of the user you wish to remove.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "BnetWrite"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Social"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "Social.RemoveFriendRequest",
		Method:   "POST",
		PathSpec: "/Social/Friends/Requests/Remove/{membershipId}/", PathParams: map[string]string{
			"membershipId": fmt.Sprint(req.MembershipID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// SocialDeclineFriendRequestRequest are the request parameters for operation
// Social.DeclineFriendRequest
type SocialDeclineFriendRequestRequest struct {

	// The membership id of the user you wish to decline.
	// Required.
	MembershipID string
}

// SocialDeclineFriendRequest: Declines a friend relationship with the target user. The user must be on
// your incoming friend request list, though no error will occur if they are not.
//
// URL: /Social/Friends/Requests/Decline/{membershipId}/
//
// Operation: Social.DeclineFriendRequest
//
// Scope: oauth2 [BnetWrite]
func (a API) SocialDeclineFriendRequest(ctx context.Context, req SocialDeclineFriendRequestRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "Declines a friend relationship with the target user. The user must be on your incoming friend request list, though no error will occur if they are not.",
	//	  "operationId": "Social.DeclineFriendRequest",
	//	  "parameters": [
	//	    {
	//	      "description": "The membership id of the user you wish to decline.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "BnetWrite"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Social"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "Social.DeclineFriendRequest",
		Method:   "POST",
		PathSpec: "/Social/Friends/Requests/Decline/{membershipId}/", PathParams: map[string]string{
			"membershipId": fmt.Sprint(req.MembershipID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// SocialAcceptFriendRequestRequest are the request parameters for operation Social.AcceptFriendRequest
type SocialAcceptFriendRequestRequest struct {

	// The membership id of the user you wish to accept.
	// Required.
	MembershipID string
}

// SocialAcceptFriendRequest: Accepts a friend relationship with the target user. The user must be on
// your incoming friend request list, though no error will occur if they are not.
//
// URL: /Social/Friends/Requests/Accept/{membershipId}/
//
// Operation: Social.AcceptFriendRequest
//
// Scope: oauth2 [BnetWrite]
func (a API) SocialAcceptFriendRequest(ctx context.Context, req SocialAcceptFriendRequestRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "Accepts a friend relationship with the target user. The user must be on your incoming friend request list, though no error will occur if they are not.",
	//	  "operationId": "Social.AcceptFriendRequest",
	//	  "parameters": [
	//	    {
	//	      "description": "The membership id of the user you wish to accept.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "BnetWrite"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Social"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "Social.AcceptFriendRequest",
		Method:   "POST",
		PathSpec: "/Social/Friends/Requests/Accept/{membershipId}/", PathParams: map[string]string{
			"membershipId": fmt.Sprint(req.MembershipID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// SocialRemoveFriendRequest are the request parameters for operation Social.RemoveFriend
type SocialRemoveFriendRequest struct {

	// The membership id of the user you wish to remove.
	// Required.
	MembershipID string
}

// SocialRemoveFriend: Remove a friend relationship with the target user. The user must be on your
// friend list, though no error will occur if they are not.
//
// URL: /Social/Friends/Remove/{membershipId}/
//
// Operation: Social.RemoveFriend
//
// Scope: oauth2 [BnetWrite]
func (a API) SocialRemoveFriend(ctx context.Context, req SocialRemoveFriendRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "Remove a friend relationship with the target user. The user must be on your friend list, though no error will occur if they are not.",
	//	  "operationId": "Social.RemoveFriend",
	//	  "parameters": [
	//	    {
	//	      "description": "The membership id of the user you wish to remove.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "BnetWrite"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Social"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "Social.RemoveFriend",
		Method:   "POST",
		PathSpec: "/Social/Friends/Remove/{membershipId}/", PathParams: map[string]string{
			"membershipId": fmt.Sprint(req.MembershipID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// SocialIssueFriendRequestRequest are the request parameters for operation Social.IssueFriendRequest
type SocialIssueFriendRequestRequest struct {

	// The membership id of the user you wish to add.
	// Required.
	MembershipID string
}

// SocialIssueFriendRequest: Requests a friend relationship with the target user. Any of the target
// user's linked membership ids are valid inputs.
//
// URL: /Social/Friends/Add/{membershipId}/
//
// Operation: Social.IssueFriendRequest
//
// Scope: oauth2 [BnetWrite]
func (a API) SocialIssueFriendRequest(ctx context.Context, req SocialIssueFriendRequestRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "Requests a friend relationship with the target user. Any of the target user's linked membership ids are valid inputs.",
	//	  "operationId": "Social.IssueFriendRequest",
	//	  "parameters": [
	//	    {
	//	      "description": "The membership id of the user you wish to add.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "BnetWrite"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Social"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "Social.IssueFriendRequest",
		Method:   "POST",
		PathSpec: "/Social/Friends/Add/{membershipId}/", PathParams: map[string]string{
			"membershipId": fmt.Sprint(req.MembershipID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2AddOptionalConversationRequest are the request parameters for operation
// GroupV2.AddOptionalConversation
type GroupV2AddOptionalConversationRequest struct {

	// Group ID of the group to edit.
	// Required.
	GroupID Int64

	// Required.
	Body GroupOptionalConversationAddRequestBody
}

// GroupV2AddOptionalConversation: Add a new optional conversation/chat channel. Requires admin
// permissions to the group.
//
// URL: /GroupV2/{groupId}/OptionalConversations/Add/
//
// Operation: GroupV2.AddOptionalConversation
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2AddOptionalConversation(ctx context.Context, req GroupV2AddOptionalConversationRequest) (*ServerResponse[Int64], error) {
	//	{
	//	  "description": "Add a new optional conversation/chat channel. Requires admin permissions to the group.",
	//	  "operationId": "GroupV2.AddOptionalConversation",
	//	  "parameters": [
	//	    {
	//	      "description": "Group ID of the group to edit.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupOptionalConversationAddRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int64"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[Int64]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.AddOptionalConversation",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/OptionalConversations/Add/", PathParams: map[string]string{
			"groupId": fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// GroupV2GetGroupOptionalConversationsRequest are the request parameters for operation
// GroupV2.GetGroupOptionalConversations
type GroupV2GetGroupOptionalConversationsRequest struct {

	// Requested group's id.
	// Required.
	GroupID Int64
}

// GroupV2GetGroupOptionalConversations: Gets a list of available optional conversation channels and
// their settings.
//
// URL: /GroupV2/{groupId}/OptionalConversations/
//
// Operation: GroupV2.GetGroupOptionalConversations
func (a API) GroupV2GetGroupOptionalConversations(ctx context.Context, req GroupV2GetGroupOptionalConversationsRequest) (*ServerResponse[[]GroupOptionalConversation], error) {
	//	{
	//	  "description": "Gets a list of available optional conversation channels and their settings.",
	//	  "operationId": "GroupV2.GetGroupOptionalConversations",
	//	  "parameters": [
	//	    {
	//	      "description": "Requested group's id.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/CEListOfGroupOptionalConversation"
	//	    }
	//	  },
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[[]GroupOptionalConversation]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetGroupOptionalConversations",
		Method:   "GET",
		PathSpec: "/GroupV2/{groupId}/OptionalConversations/", PathParams: map[string]string{
			"groupId": fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2GetPendingMembershipsRequest are the request parameters for operation
// GroupV2.GetPendingMemberships
type GroupV2GetPendingMembershipsRequest struct {

	// Page number (starting with 1). Each page has a fixed size of 50 items per page.
	// Required.
	Currentpage int32

	// ID of the group.
	// Required.
	GroupID Int64
}

// GroupV2GetPendingMemberships: Get the list of users who are awaiting a decision on their application
// to join a given group. Modified to include application info.
//
// URL: /GroupV2/{groupId}/Members/Pending/
//
// Operation: GroupV2.GetPendingMemberships
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2GetPendingMemberships(ctx context.Context, req GroupV2GetPendingMembershipsRequest) (*ServerResponse[SearchResult[GroupMemberApplication]], error) {
	//	{
	//	  "description": "Get the list of users who are awaiting a decision on their application to join a given group. Modified to include application info.",
	//	  "operationId": "GroupV2.GetPendingMemberships",
	//	  "parameters": [
	//	    {
	//	      "description": "Page number (starting with 1). Each page has a fixed size of 50 items per page.",
	//	      "in": "path",
	//	      "name": "currentpage",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "ID of the group.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/SearchResultOfGroupMemberApplication"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[SearchResult[GroupMemberApplication]]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetPendingMemberships",
		Method:   "GET",
		PathSpec: "/GroupV2/{groupId}/Members/Pending/", PathParams: map[string]string{
			"currentpage": fmt.Sprint(req.Currentpage),
			"groupId":     fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2GetInvitedIndividualsRequest are the request parameters for operation
// GroupV2.GetInvitedIndividuals
type GroupV2GetInvitedIndividualsRequest struct {

	// Page number (starting with 1). Each page has a fixed size of 50 items per page.
	// Required.
	Currentpage int32

	// ID of the group.
	// Required.
	GroupID Int64
}

// GroupV2GetInvitedIndividuals: Get the list of users who have been invited into the group.
//
// URL: /GroupV2/{groupId}/Members/InvitedIndividuals/
//
// Operation: GroupV2.GetInvitedIndividuals
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2GetInvitedIndividuals(ctx context.Context, req GroupV2GetInvitedIndividualsRequest) (*ServerResponse[SearchResult[GroupMemberApplication]], error) {
	//	{
	//	  "description": "Get the list of users who have been invited into the group.",
	//	  "operationId": "GroupV2.GetInvitedIndividuals",
	//	  "parameters": [
	//	    {
	//	      "description": "Page number (starting with 1). Each page has a fixed size of 50 items per page.",
	//	      "in": "path",
	//	      "name": "currentpage",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "ID of the group.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/SearchResultOfGroupMemberApplication"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[SearchResult[GroupMemberApplication]]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetInvitedIndividuals",
		Method:   "GET",
		PathSpec: "/GroupV2/{groupId}/Members/InvitedIndividuals/", PathParams: map[string]string{
			"currentpage": fmt.Sprint(req.Currentpage),
			"groupId":     fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2DenyPendingForListRequest are the request parameters for operation GroupV2.DenyPendingForList
type GroupV2DenyPendingForListRequest struct {

	// ID of the group.
	// Required.
	GroupID Int64

	// Required.
	Body GroupApplicationListRequestBody
}

// GroupV2DenyPendingForList: Deny all of the pending users for the given group that match the
// passed-in .
//
// URL: /GroupV2/{groupId}/Members/DenyList/
//
// Operation: GroupV2.DenyPendingForList
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2DenyPendingForList(ctx context.Context, req GroupV2DenyPendingForListRequest) (*ServerResponse[[]EntityActionResult], error) {
	//	{
	//	  "description": "Deny all of the pending users for the given group that match the passed-in .",
	//	  "operationId": "GroupV2.DenyPendingForList",
	//	  "parameters": [
	//	    {
	//	      "description": "ID of the group.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupApplicationListRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/ListOfEntityActionResult"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[[]EntityActionResult]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.DenyPendingForList",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/Members/DenyList/", PathParams: map[string]string{
			"groupId": fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// GroupV2DenyAllPendingRequest are the request parameters for operation GroupV2.DenyAllPending
type GroupV2DenyAllPendingRequest struct {

	// ID of the group.
	// Required.
	GroupID Int64

	// Required.
	Body GroupApplicationRequestBody
}

// GroupV2DenyAllPending: Deny all of the pending users for the given group.
//
// URL: /GroupV2/{groupId}/Members/DenyAll/
//
// Operation: GroupV2.DenyAllPending
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2DenyAllPending(ctx context.Context, req GroupV2DenyAllPendingRequest) (*ServerResponse[[]EntityActionResult], error) {
	//	{
	//	  "description": "Deny all of the pending users for the given group.",
	//	  "operationId": "GroupV2.DenyAllPending",
	//	  "parameters": [
	//	    {
	//	      "description": "ID of the group.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupApplicationRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/ListOfEntityActionResult"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[[]EntityActionResult]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.DenyAllPending",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/Members/DenyAll/", PathParams: map[string]string{
			"groupId": fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// GroupV2ApprovePendingForListRequest are the request parameters for operation
// GroupV2.ApprovePendingForList
type GroupV2ApprovePendingForListRequest struct {

	// ID of the group.
	// Required.
	GroupID Int64

	// Required.
	Body GroupApplicationListRequestBody
}

// GroupV2ApprovePendingForList: Approve all of the pending users for the given group.
//
// URL: /GroupV2/{groupId}/Members/ApproveList/
//
// Operation: GroupV2.ApprovePendingForList
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2ApprovePendingForList(ctx context.Context, req GroupV2ApprovePendingForListRequest) (*ServerResponse[[]EntityActionResult], error) {
	//	{
	//	  "description": "Approve all of the pending users for the given group.",
	//	  "operationId": "GroupV2.ApprovePendingForList",
	//	  "parameters": [
	//	    {
	//	      "description": "ID of the group.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupApplicationListRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/ListOfEntityActionResult"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[[]EntityActionResult]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.ApprovePendingForList",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/Members/ApproveList/", PathParams: map[string]string{
			"groupId": fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// GroupV2ApproveAllPendingRequest are the request parameters for operation GroupV2.ApproveAllPending
type GroupV2ApproveAllPendingRequest struct {

	// ID of the group.
	// Required.
	GroupID Int64

	// Required.
	Body GroupApplicationRequestBody
}

// GroupV2ApproveAllPending: Approve all of the pending users for the given group.
//
// URL: /GroupV2/{groupId}/Members/ApproveAll/
//
// Operation: GroupV2.ApproveAllPending
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2ApproveAllPending(ctx context.Context, req GroupV2ApproveAllPendingRequest) (*ServerResponse[[]EntityActionResult], error) {
	//	{
	//	  "description": "Approve all of the pending users for the given group.",
	//	  "operationId": "GroupV2.ApproveAllPending",
	//	  "parameters": [
	//	    {
	//	      "description": "ID of the group.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupApplicationRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/ListOfEntityActionResult"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[[]EntityActionResult]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.ApproveAllPending",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/Members/ApproveAll/", PathParams: map[string]string{
			"groupId": fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// GroupV2GetMembersOfGroupRequest are the request parameters for operation GroupV2.GetMembersOfGroup
type GroupV2GetMembersOfGroupRequest struct {

	// Page number (starting with 1). Each page has a fixed size of 50 items per page.
	// Required.
	Currentpage int32

	// The ID of the group.
	// Required.
	GroupID Int64

	// Filter out other member types. Use None for all members.
	MemberType RuntimeGroupMemberType

	// The name fragment upon which a search should be executed for members with matching display or unique
	// names.
	NameSearch string
}

// GroupV2GetMembersOfGroup: Get the list of members in a given group.
//
// URL: /GroupV2/{groupId}/Members/
//
// Operation: GroupV2.GetMembersOfGroup
func (a API) GroupV2GetMembersOfGroup(ctx context.Context, req GroupV2GetMembersOfGroupRequest) (*ServerResponse[SearchResult[GroupMember]], error) {
	//	{
	//	  "description": "Get the list of members in a given group.",
	//	  "operationId": "GroupV2.GetMembersOfGroup",
	//	  "parameters": [
	//	    {
	//	      "description": "Page number (starting with 1). Each page has a fixed size of 50 items per page.",
	//	      "in": "path",
	//	      "name": "currentpage",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The ID of the group.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Filter out other member types. Use None for all members.",
	//	      "in": "query",
	//	      "name": "memberType",
	//	      "schema": {
	//	        "description": "The member levels used by all V2 Groups API. Individual group types use their own mappings in their native storage (general uses BnetDbGroupMemberType and D2 clans use ClanMemberLevel), but they are all translated to this in the runtime api. These runtime values should NEVER be stored anywhere, so the values can be changed as necessary.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/GroupsV2.RuntimeGroupMemberType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "The name fragment upon which a search should be executed for members with matching display or unique names.",
	//	      "in": "query",
	//	      "name": "nameSearch",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/SearchResultOfGroupMember"
	//	    }
	//	  },
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[SearchResult[GroupMember]]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetMembersOfGroup",
		Method:   "GET",
		PathSpec: "/GroupV2/{groupId}/Members/", PathParams: map[string]string{
			"currentpage": fmt.Sprint(req.Currentpage),
			"groupId":     fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{
			"memberType": {fmt.Sprint(req.MemberType)},
			"nameSearch": {fmt.Sprint(req.NameSearch)},
		}}, &resp)
	return &resp, err
}

// GroupV2GetGroupEditHistoryRequest are the request parameters for operation
// GroupV2.GetGroupEditHistory
type GroupV2GetGroupEditHistoryRequest struct {

	// Page number (starting with 1). Each page has a fixed size of 50 entries.
	// Required.
	Currentpage int32

	// Group ID whose edit history you are fetching
	// Required.
	GroupID Int64
}

// GroupV2GetGroupEditHistory: Get the list of edits made to a given group. Only accessible to group
// Admins and above.
//
// URL: /GroupV2/{groupId}/EditHistory/
//
// Operation: GroupV2.GetGroupEditHistory
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2GetGroupEditHistory(ctx context.Context, req GroupV2GetGroupEditHistoryRequest) (*ServerResponse[SearchResult[GroupEditHistory]], error) {
	//	{
	//	  "description": "Get the list of edits made to a given group. Only accessible to group Admins and above.",
	//	  "operationId": "GroupV2.GetGroupEditHistory",
	//	  "parameters": [
	//	    {
	//	      "description": "Page number (starting with 1). Each page has a fixed size of 50 entries.",
	//	      "in": "path",
	//	      "name": "currentpage",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Group ID whose edit history you are fetching",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/SearchResultOfGroupEditHistory"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[SearchResult[GroupEditHistory]]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetGroupEditHistory",
		Method:   "GET",
		PathSpec: "/GroupV2/{groupId}/EditHistory/", PathParams: map[string]string{
			"currentpage": fmt.Sprint(req.Currentpage),
			"groupId":     fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2EditFounderOptionsRequest are the request parameters for operation GroupV2.EditFounderOptions
type GroupV2EditFounderOptionsRequest struct {

	// Group ID of the group to edit.
	// Required.
	GroupID Int64

	// Required.
	Body GroupOptionsEditAction
}

// GroupV2EditFounderOptions: Edit group options only available to a founder. You must have suitable
// permissions in the group to perform this operation.
//
// URL: /GroupV2/{groupId}/EditFounderOptions/
//
// Operation: GroupV2.EditFounderOptions
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2EditFounderOptions(ctx context.Context, req GroupV2EditFounderOptionsRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Edit group options only available to a founder. You must have suitable permissions in the group to perform this operation.",
	//	  "operationId": "GroupV2.EditFounderOptions",
	//	  "parameters": [
	//	    {
	//	      "description": "Group ID of the group to edit.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupOptionsEditAction"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.EditFounderOptions",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/EditFounderOptions/", PathParams: map[string]string{
			"groupId": fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// GroupV2EditClanBannerRequest are the request parameters for operation GroupV2.EditClanBanner
type GroupV2EditClanBannerRequest struct {

	// Group ID of the group to edit.
	// Required.
	GroupID Int64

	// Required.
	Body ClanBanner
}

// GroupV2EditClanBanner: Edit an existing group's clan banner. You must have suitable permissions in
// the group to perform this operation. All fields are required.
//
// URL: /GroupV2/{groupId}/EditClanBanner/
//
// Operation: GroupV2.EditClanBanner
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2EditClanBanner(ctx context.Context, req GroupV2EditClanBannerRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Edit an existing group's clan banner. You must have suitable permissions in the group to perform this operation. All fields are required.",
	//	  "operationId": "GroupV2.EditClanBanner",
	//	  "parameters": [
	//	    {
	//	      "description": "Group ID of the group to edit.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/GroupsV2.ClanBanner"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.EditClanBanner",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/EditClanBanner/", PathParams: map[string]string{
			"groupId": fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// GroupV2EditGroupRequest are the request parameters for operation GroupV2.EditGroup
type GroupV2EditGroupRequest struct {

	// Group ID of the group to edit.
	// Required.
	GroupID Int64

	// Required.
	Body GroupEditAction
}

// GroupV2EditGroup: Edit an existing group. You must have suitable permissions in the group to perform
// this operation. This latest revision will only edit the fields you pass in - pass null for
// properties you want to leave unaltered.
//
// URL: /GroupV2/{groupId}/Edit/
//
// Operation: GroupV2.EditGroup
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2EditGroup(ctx context.Context, req GroupV2EditGroupRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Edit an existing group. You must have suitable permissions in the group to perform this operation. This latest revision will only edit the fields you pass in - pass null for properties you want to leave unaltered.",
	//	  "operationId": "GroupV2.EditGroup",
	//	  "parameters": [
	//	    {
	//	      "description": "Group ID of the group to edit.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupEditAction"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.EditGroup",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/Edit/", PathParams: map[string]string{
			"groupId": fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// GroupV2GetBannedMembersOfGroupRequest are the request parameters for operation
// GroupV2.GetBannedMembersOfGroup
type GroupV2GetBannedMembersOfGroupRequest struct {

	// Page number (starting with 1). Each page has a fixed size of 50 entries.
	// Required.
	Currentpage int32

	// Group ID whose banned members you are fetching
	// Required.
	GroupID Int64
}

// GroupV2GetBannedMembersOfGroup: Get the list of banned members in a given group. Only accessible to
// group Admins and above. Not applicable to all groups. Check group features.
//
// URL: /GroupV2/{groupId}/Banned/
//
// Operation: GroupV2.GetBannedMembersOfGroup
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2GetBannedMembersOfGroup(ctx context.Context, req GroupV2GetBannedMembersOfGroupRequest) (*ServerResponse[SearchResult[GroupBan]], error) {
	//	{
	//	  "description": "Get the list of banned members in a given group. Only accessible to group Admins and above. Not applicable to all groups. Check group features.",
	//	  "operationId": "GroupV2.GetBannedMembersOfGroup",
	//	  "parameters": [
	//	    {
	//	      "description": "Page number (starting with 1). Each page has a fixed size of 50 entries.",
	//	      "in": "path",
	//	      "name": "currentpage",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Group ID whose banned members you are fetching",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/SearchResultOfGroupBan"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[SearchResult[GroupBan]]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetBannedMembersOfGroup",
		Method:   "GET",
		PathSpec: "/GroupV2/{groupId}/Banned/", PathParams: map[string]string{
			"currentpage": fmt.Sprint(req.Currentpage),
			"groupId":     fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2GetAdminsAndFounderOfGroupRequest are the request parameters for operation
// GroupV2.GetAdminsAndFounderOfGroup
type GroupV2GetAdminsAndFounderOfGroupRequest struct {

	// Page number (starting with 1). Each page has a fixed size of 50 items per page.
	// Required.
	Currentpage int32

	// The ID of the group.
	// Required.
	GroupID Int64
}

// GroupV2GetAdminsAndFounderOfGroup: Get the list of members in a given group who are of admin level
// or higher.
//
// URL: /GroupV2/{groupId}/AdminsAndFounder/
//
// Operation: GroupV2.GetAdminsAndFounderOfGroup
func (a API) GroupV2GetAdminsAndFounderOfGroup(ctx context.Context, req GroupV2GetAdminsAndFounderOfGroupRequest) (*ServerResponse[SearchResult[GroupMember]], error) {
	//	{
	//	  "description": "Get the list of members in a given group who are of admin level or higher.",
	//	  "operationId": "GroupV2.GetAdminsAndFounderOfGroup",
	//	  "parameters": [
	//	    {
	//	      "description": "Page number (starting with 1). Each page has a fixed size of 50 items per page.",
	//	      "in": "path",
	//	      "name": "currentpage",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The ID of the group.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/SearchResultOfGroupMember"
	//	    }
	//	  },
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[SearchResult[GroupMember]]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetAdminsAndFounderOfGroup",
		Method:   "GET",
		PathSpec: "/GroupV2/{groupId}/AdminsAndFounder/", PathParams: map[string]string{
			"currentpage": fmt.Sprint(req.Currentpage),
			"groupId":     fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2GetGroupRequest are the request parameters for operation GroupV2.GetGroup
type GroupV2GetGroupRequest struct {

	// Requested group's id.
	// Required.
	GroupID Int64
}

// GroupV2GetGroup: Get information about a specific group of the given ID.
//
// URL: /GroupV2/{groupId}/
//
// Operation: GroupV2.GetGroup
func (a API) GroupV2GetGroup(ctx context.Context, req GroupV2GetGroupRequest) (*ServerResponse[GroupResponse], error) {
	//	{
	//	  "description": "Get information about a specific group of the given ID.",
	//	  "operationId": "GroupV2.GetGroup",
	//	  "parameters": [
	//	    {
	//	      "description": "Requested group's id.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/GroupsV2.GroupResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[GroupResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetGroup",
		Method:   "GET",
		PathSpec: "/GroupV2/{groupId}/", PathParams: map[string]string{
			"groupId": fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2GetUserClanInviteSettingRequest are the request parameters for operation
// GroupV2.GetUserClanInviteSetting
type GroupV2GetUserClanInviteSettingRequest struct {

	// The Destiny membership type of the account we wish to access settings.
	// Required.
	MType BungieMembershipType
}

// GroupV2GetUserClanInviteSetting: Gets the state of the user's clan invite preferences for a
// particular membership type - true if they wish to be invited to clans, false otherwise.
//
// URL: /GroupV2/GetUserClanInviteSetting/{mType}/
//
// Operation: GroupV2.GetUserClanInviteSetting
//
// Scope: oauth2 [ReadUserData]
func (a API) GroupV2GetUserClanInviteSetting(ctx context.Context, req GroupV2GetUserClanInviteSettingRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "Gets the state of the user's clan invite preferences for a particular membership type - true if they wish to be invited to clans, false otherwise.",
	//	  "operationId": "GroupV2.GetUserClanInviteSetting",
	//	  "parameters": [
	//	    {
	//	      "description": "The Destiny membership type of the account we wish to access settings.",
	//	      "in": "path",
	//	      "name": "mType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "ReadUserData"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetUserClanInviteSetting",
		Method:   "GET",
		PathSpec: "/GroupV2/GetUserClanInviteSetting/{mType}/", PathParams: map[string]string{
			"mType": fmt.Sprint(req.MType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// ForumGetPollRequest are the request parameters for operation Forum.GetPoll
type ForumGetPollRequest struct {

	// The post id of the topic that has the poll.
	// Required.
	TopicID Int64
}

// ForumGetPoll: Gets the specified forum poll.
//
// URL: /Forum/Poll/{topicId}/
//
// Operation: Forum.GetPoll
func (a API) ForumGetPoll(ctx context.Context, req ForumGetPollRequest) (*ServerResponse[PostSearchResponse], error) {
	//	{
	//	  "description": "Gets the specified forum poll.",
	//	  "operationId": "Forum.GetPoll",
	//	  "parameters": [
	//	    {
	//	      "description": "The post id of the topic that has the poll.",
	//	      "in": "path",
	//	      "name": "topicId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Forum.PostSearchResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Forum"
	//	  ]
	//	}
	var resp ServerResponse[PostSearchResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Forum.GetPoll",
		Method:   "GET",
		PathSpec: "/Forum/Poll/{topicId}/", PathParams: map[string]string{
			"topicId": fmt.Sprint(req.TopicID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// ForumGetTopicForContentRequest are the request parameters for operation Forum.GetTopicForContent
type ForumGetTopicForContentRequest struct {

	// Required.
	ContentID Int64
}

// ForumGetTopicForContent: Gets the post Id for the given content item's comments, if it exists.
//
// URL: /Forum/GetTopicForContent/{contentId}/
//
// Operation: Forum.GetTopicForContent
func (a API) ForumGetTopicForContent(ctx context.Context, req ForumGetTopicForContentRequest) (*ServerResponse[Int64], error) {
	//	{
	//	  "description": "Gets the post Id for the given content item's comments, if it exists.",
	//	  "operationId": "Forum.GetTopicForContent",
	//	  "parameters": [
	//	    {
	//	      "in": "path",
	//	      "name": "contentId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int64"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Forum"
	//	  ]
	//	}
	var resp ServerResponse[Int64]
	err := a.client.Do(ctx, ClientRequest{Operation: "Forum.GetTopicForContent",
		Method:   "GET",
		PathSpec: "/Forum/GetTopicForContent/{contentId}/", PathParams: map[string]string{
			"contentId": fmt.Sprint(req.ContentID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// ForumGetPostAndParentAwaitingApprovalRequest are the request parameters for operation
// Forum.GetPostAndParentAwaitingApproval
type ForumGetPostAndParentAwaitingApprovalRequest struct {

	// Required.
	ChildPostID Int64

	// If this value is not null or empty, banned posts are requested to be returned
	Showbanned string
}

// ForumGetPostAndParentAwaitingApproval: Returns the post specified and its immediate parent of posts
// that are awaiting approval.
//
// URL: /Forum/GetPostAndParentAwaitingApproval/{childPostId}/
//
// Operation: Forum.GetPostAndParentAwaitingApproval
func (a API) ForumGetPostAndParentAwaitingApproval(ctx context.Context, req ForumGetPostAndParentAwaitingApprovalRequest) (*ServerResponse[PostSearchResponse], error) {
	//	{
	//	  "description": "Returns the post specified and its immediate parent of posts that are awaiting approval.",
	//	  "operationId": "Forum.GetPostAndParentAwaitingApproval",
	//	  "parameters": [
	//	    {
	//	      "in": "path",
	//	      "name": "childPostId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "If this value is not null or empty, banned posts are requested to be returned",
	//	      "in": "query",
	//	      "name": "showbanned",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Forum.PostSearchResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Forum"
	//	  ]
	//	}
	var resp ServerResponse[PostSearchResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Forum.GetPostAndParentAwaitingApproval",
		Method:   "GET",
		PathSpec: "/Forum/GetPostAndParentAwaitingApproval/{childPostId}/", PathParams: map[string]string{
			"childPostId": fmt.Sprint(req.ChildPostID),
		}, QueryParams: url.Values{
			"showbanned": {fmt.Sprint(req.Showbanned)},
		}}, &resp)
	return &resp, err
}

// ForumGetPostAndParentRequest are the request parameters for operation Forum.GetPostAndParent
type ForumGetPostAndParentRequest struct {

	// Required.
	ChildPostID Int64

	// If this value is not null or empty, banned posts are requested to be returned
	Showbanned string
}

// ForumGetPostAndParent: Returns the post specified and its immediate parent.
//
// URL: /Forum/GetPostAndParent/{childPostId}/
//
// Operation: Forum.GetPostAndParent
func (a API) ForumGetPostAndParent(ctx context.Context, req ForumGetPostAndParentRequest) (*ServerResponse[PostSearchResponse], error) {
	//	{
	//	  "description": "Returns the post specified and its immediate parent.",
	//	  "operationId": "Forum.GetPostAndParent",
	//	  "parameters": [
	//	    {
	//	      "in": "path",
	//	      "name": "childPostId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "If this value is not null or empty, banned posts are requested to be returned",
	//	      "in": "query",
	//	      "name": "showbanned",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Forum.PostSearchResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Forum"
	//	  ]
	//	}
	var resp ServerResponse[PostSearchResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Forum.GetPostAndParent",
		Method:   "GET",
		PathSpec: "/Forum/GetPostAndParent/{childPostId}/", PathParams: map[string]string{
			"childPostId": fmt.Sprint(req.ChildPostID),
		}, QueryParams: url.Values{
			"showbanned": {fmt.Sprint(req.Showbanned)},
		}}, &resp)
	return &resp, err
}

// FireteamFinderGetListingRequest are the request parameters for operation FireteamFinder.GetListing
type FireteamFinderGetListingRequest struct {

	// The ID of the listing to retrieve.
	// Required.
	ListingID Int64
}

// FireteamFinderGetListing: Retrieves a Fireteam listing.
//
// URL: /FireteamFinder/Listing/{listingId}/
//
// Operation: FireteamFinder.GetListing
func (a API) FireteamFinderGetListing(ctx context.Context, req FireteamFinderGetListingRequest) (*ServerResponse[FireteamFinderListing], error) {
	//	{
	//	  "description": "Retrieves a Fireteam listing.",
	//	  "operationId": "FireteamFinder.GetListing",
	//	  "parameters": [
	//	    {
	//	      "description": "The ID of the listing to retrieve.",
	//	      "in": "path",
	//	      "name": "listingId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderListing"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderListing]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.GetListing",
		Method:   "GET",
		PathSpec: "/FireteamFinder/Listing/{listingId}/", PathParams: map[string]string{
			"listingId": fmt.Sprint(req.ListingID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// FireteamGetActivePrivateClanFireteamCountRequest are the request parameters for operation
// Fireteam.GetActivePrivateClanFireteamCount
type FireteamGetActivePrivateClanFireteamCountRequest struct {

	// The group id of the clan.
	// Required.
	GroupID Int64
}

// FireteamGetActivePrivateClanFireteamCount: Gets a count of all active non-public fireteams for the
// specified clan. Maximum value returned is 25.
//
// URL: /Fireteam/Clan/{groupId}/ActiveCount/
//
// Operation: Fireteam.GetActivePrivateClanFireteamCount
//
// Scope: oauth2 [ReadGroups]
func (a API) FireteamGetActivePrivateClanFireteamCount(ctx context.Context, req FireteamGetActivePrivateClanFireteamCountRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Gets a count of all active non-public fireteams for the specified clan. Maximum value returned is 25.",
	//	  "operationId": "Fireteam.GetActivePrivateClanFireteamCount",
	//	  "parameters": [
	//	    {
	//	      "description": "The group id of the clan.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "ReadGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Fireteam"
	//	  ]
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "Fireteam.GetActivePrivateClanFireteamCount",
		Method:   "GET",
		PathSpec: "/Fireteam/Clan/{groupId}/ActiveCount/", PathParams: map[string]string{
			"groupId": fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// Destiny2ReportOffensivePostGameCarnageReportPlayerRequest are the request parameters for operation
// Destiny2.ReportOffensivePostGameCarnageReportPlayer
type Destiny2ReportOffensivePostGameCarnageReportPlayerRequest struct {

	// The ID of the activity where you ran into the brigand that you're reporting.
	// Required.
	ActivityID Int64

	// Required.
	Body ReportOffensePgcrRequestBody
}

// Destiny2ReportOffensivePostGameCarnageReportPlayer: Report a player that you met in an activity that
// was engaging in ToS-violating activities. Both you and the offending player must have played in the
// activityId passed in. Please use this judiciously and only when you have strong suspicions of
// violation, pretty please.
//
// URL: /Destiny2/Stats/PostGameCarnageReport/{activityId}/Report/
//
// Operation: Destiny2.ReportOffensivePostGameCarnageReportPlayer
//
// Scope: oauth2 [BnetWrite]
func (a API) Destiny2ReportOffensivePostGameCarnageReportPlayer(ctx context.Context, req Destiny2ReportOffensivePostGameCarnageReportPlayerRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Report a player that you met in an activity that was engaging in ToS-violating activities. Both you and the offending player must have played in the activityId passed in. Please use this judiciously and only when you have strong suspicions of violation, pretty please.",
	//	  "operationId": "Destiny2.ReportOffensivePostGameCarnageReportPlayer",
	//	  "parameters": [
	//	    {
	//	      "description": "The ID of the activity where you ran into the brigand that you're reporting.",
	//	      "in": "path",
	//	      "name": "activityId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/Destiny.Reporting.Requests.DestinyReportOffensePgcrRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "BnetWrite"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.ReportOffensivePostGameCarnageReportPlayer",
		Method:   "POST",
		PathSpec: "/Destiny2/Stats/PostGameCarnageReport/{activityId}/Report/", PathParams: map[string]string{
			"activityId": fmt.Sprint(req.ActivityID),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// Destiny2GetPostGameCarnageReportRequest are the request parameters for operation
// Destiny2.GetPostGameCarnageReport
type Destiny2GetPostGameCarnageReportRequest struct {

	// The ID of the activity whose PGCR is requested.
	// Required.
	ActivityID Int64
}

// Destiny2GetPostGameCarnageReport: Gets the available post game carnage report for the activity ID.
//
// URL: /Destiny2/Stats/PostGameCarnageReport/{activityId}/
//
// Operation: Destiny2.GetPostGameCarnageReport
func (a API) Destiny2GetPostGameCarnageReport(ctx context.Context, req Destiny2GetPostGameCarnageReportRequest) (*ServerResponse[PostGameCarnageReportData], error) {
	//	{
	//	  "description": "Gets the available post game carnage report for the activity ID.",
	//	  "operationId": "Destiny2.GetPostGameCarnageReport",
	//	  "parameters": [
	//	    {
	//	      "description": "The ID of the activity whose PGCR is requested.",
	//	      "in": "path",
	//	      "name": "activityId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.HistoricalStats.DestinyPostGameCarnageReportData"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[PostGameCarnageReportData]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetPostGameCarnageReport",
		Method:   "GET",
		PathSpec: "/Destiny2/Stats/PostGameCarnageReport/{activityId}/", PathParams: map[string]string{
			"activityId": fmt.Sprint(req.ActivityID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// Destiny2GetClanLeaderboardsRequest are the request parameters for operation
// Destiny2.GetClanLeaderboards
type Destiny2GetClanLeaderboardsRequest struct {

	// Group ID of the clan whose leaderboards you wish to fetch.
	// Required.
	GroupID Int64

	// Maximum number of top players to return. Use a large number to get entire leaderboard.
	Maxtop int32

	// List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType
	// for valid values, and pass in string representation, comma delimited.
	Modes string

	// ID of stat to return rather than returning all Leaderboard stats.
	Statid string
}

// Destiny2GetClanLeaderboards: Gets leaderboards with the signed in user's friends and the supplied
// destinyMembershipId as the focus. PREVIEW: This endpoint is still in beta, and may experience rough
// edges. The schema is in final form, but there may be bugs that prevent desirable operation.
//
// URL: /Destiny2/Stats/Leaderboards/Clans/{groupId}/
//
// Operation: Destiny2.GetClanLeaderboards
func (a API) Destiny2GetClanLeaderboards(ctx context.Context, req Destiny2GetClanLeaderboardsRequest) (*ServerResponse[map[string]map[string]Leaderboard], error) {
	//	{
	//	  "description": "Gets leaderboards with the signed in user's friends and the supplied destinyMembershipId as the focus. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is in final form, but there may be bugs that prevent desirable operation.",
	//	  "operationId": "Destiny2.GetClanLeaderboards",
	//	  "parameters": [
	//	    {
	//	      "description": "Group ID of the clan whose leaderboards you wish to fetch.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Maximum number of top players to return. Use a large number to get entire leaderboard.",
	//	      "in": "query",
	//	      "name": "maxtop",
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited.",
	//	      "in": "query",
	//	      "name": "modes",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "ID of stat to return rather than returning all Leaderboard stats.",
	//	      "in": "query",
	//	      "name": "statid",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.HistoricalStats.DestinyLeaderboardResults"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2",
	//	    "Preview"
	//	  ],
	//	  "x-preview": true
	//	}
	var resp ServerResponse[map[string]map[string]Leaderboard]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetClanLeaderboards",
		Method:   "GET",
		PathSpec: "/Destiny2/Stats/Leaderboards/Clans/{groupId}/", PathParams: map[string]string{
			"groupId": fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{
			"maxtop": {fmt.Sprint(req.Maxtop)},
			"modes":  {fmt.Sprint(req.Modes)},
			"statid": {fmt.Sprint(req.Statid)},
		}}, &resp)
	return &resp, err
}

// Destiny2GetClanAggregateStatsRequest are the request parameters for operation
// Destiny2.GetClanAggregateStats
type Destiny2GetClanAggregateStatsRequest struct {

	// Group ID of the clan whose leaderboards you wish to fetch.
	// Required.
	GroupID Int64

	// List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType
	// for valid values, and pass in string representation, comma delimited.
	Modes string
}

// Destiny2GetClanAggregateStats: Gets aggregated stats for a clan using the same categories as the
// clan leaderboards. PREVIEW: This endpoint is still in beta, and may experience rough edges. The
// schema is in final form, but there may be bugs that prevent desirable operation.
//
// URL: /Destiny2/Stats/AggregateClanStats/{groupId}/
//
// Operation: Destiny2.GetClanAggregateStats
func (a API) Destiny2GetClanAggregateStats(ctx context.Context, req Destiny2GetClanAggregateStatsRequest) (*ServerResponse[[]ClanAggregateStat], error) {
	//	{
	//	  "description": "Gets aggregated stats for a clan using the same categories as the clan leaderboards. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is in final form, but there may be bugs that prevent desirable operation.",
	//	  "operationId": "Destiny2.GetClanAggregateStats",
	//	  "parameters": [
	//	    {
	//	      "description": "Group ID of the clan whose leaderboards you wish to fetch.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited.",
	//	      "in": "query",
	//	      "name": "modes",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/ListOfDestinyClanAggregateStat"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2",
	//	    "Preview"
	//	  ],
	//	  "x-preview": true
	//	}
	var resp ServerResponse[[]ClanAggregateStat]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetClanAggregateStats",
		Method:   "GET",
		PathSpec: "/Destiny2/Stats/AggregateClanStats/{groupId}/", PathParams: map[string]string{
			"groupId": fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{
			"modes": {fmt.Sprint(req.Modes)},
		}}, &resp)
	return &resp, err
}

// Destiny2SearchDestinyPlayerByBungieNameRequest are the request parameters for operation
// Destiny2.SearchDestinyPlayerByBungieName
type Destiny2SearchDestinyPlayerByBungieNameRequest struct {

	// A valid non-BungieNet membership type, or All. Indicates which memberships to return. You probably
	// want this set to All.
	// Required.
	MembershipType BungieMembershipType

	// Required.
	Body ExactSearchRequestBody
}

// Destiny2SearchDestinyPlayerByBungieName: Returns a list of Destiny memberships given a global Bungie
// Display Name. This method will hide overridden memberships due to cross save.
//
// URL: /Destiny2/SearchDestinyPlayerByBungieName/{membershipType}/
//
// Operation: Destiny2.SearchDestinyPlayerByBungieName
func (a API) Destiny2SearchDestinyPlayerByBungieName(ctx context.Context, req Destiny2SearchDestinyPlayerByBungieNameRequest) (*ServerResponse[[]UserInfoCard], error) {
	//	{
	//	  "description": "Returns a list of Destiny memberships given a global Bungie Display Name. This method will hide overridden memberships due to cross save.",
	//	  "operationId": "Destiny2.SearchDestinyPlayerByBungieName",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid non-BungieNet membership type, or All. Indicates which memberships to return. You probably want this set to All.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/User.ExactSearchRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/IEnumerableOfUserInfoCard"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[[]UserInfoCard]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.SearchDestinyPlayerByBungieName",
		Method:   "POST",
		PathSpec: "/Destiny2/SearchDestinyPlayerByBungieName/{membershipType}/", PathParams: map[string]string{
			"membershipType": fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// Destiny2GetPublicMilestoneContentRequest are the request parameters for operation
// Destiny2.GetPublicMilestoneContent
type Destiny2GetPublicMilestoneContentRequest struct {

	// The identifier for the milestone to be returned.
	// Required.
	MilestoneHash uint32
}

// Destiny2GetPublicMilestoneContent: Gets custom localized content for the milestone of the given
// hash, if it exists.
//
// URL: /Destiny2/Milestones/{milestoneHash}/Content/
//
// Operation: Destiny2.GetPublicMilestoneContent
func (a API) Destiny2GetPublicMilestoneContent(ctx context.Context, req Destiny2GetPublicMilestoneContentRequest) (*ServerResponse[MilestoneContent], error) {
	//	{
	//	  "description": "Gets custom localized content for the milestone of the given hash, if it exists.",
	//	  "operationId": "Destiny2.GetPublicMilestoneContent",
	//	  "parameters": [
	//	    {
	//	      "description": "The identifier for the milestone to be returned.",
	//	      "in": "path",
	//	      "name": "milestoneHash",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "uint32",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Milestones.DestinyMilestoneContent"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[MilestoneContent]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetPublicMilestoneContent",
		Method:   "GET",
		PathSpec: "/Destiny2/Milestones/{milestoneHash}/Content/", PathParams: map[string]string{
			"milestoneHash": fmt.Sprint(req.MilestoneHash),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// Destiny2GetClanWeeklyRewardStateRequest are the request parameters for operation
// Destiny2.GetClanWeeklyRewardState
type Destiny2GetClanWeeklyRewardStateRequest struct {

	// A valid group id of clan.
	// Required.
	GroupID Int64
}

// Destiny2GetClanWeeklyRewardState: Returns information on the weekly clan rewards and if the clan has
// earned them or not. Note that this will always report rewards as not redeemed.
//
// URL: /Destiny2/Clan/{groupId}/WeeklyRewardState/
//
// Operation: Destiny2.GetClanWeeklyRewardState
func (a API) Destiny2GetClanWeeklyRewardState(ctx context.Context, req Destiny2GetClanWeeklyRewardStateRequest) (*ServerResponse[Milestone], error) {
	//	{
	//	  "description": "Returns information on the weekly clan rewards and if the clan has earned them or not. Note that this will always report rewards as not redeemed.",
	//	  "operationId": "Destiny2.GetClanWeeklyRewardState",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid group id of clan.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Milestones.DestinyMilestone"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[Milestone]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetClanWeeklyRewardState",
		Method:   "GET",
		PathSpec: "/Destiny2/Clan/{groupId}/WeeklyRewardState/", PathParams: map[string]string{
			"groupId": fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// Destiny2AwaGetActionTokenRequest are the request parameters for operation Destiny2.AwaGetActionToken
type Destiny2AwaGetActionTokenRequest struct {

	// The identifier for the advanced write action request.
	// Required.
	CorrelationID string
}

// Destiny2AwaGetActionToken: Returns the action token if user approves the request.
//
// URL: /Destiny2/Awa/GetActionToken/{correlationId}/
//
// Operation: Destiny2.AwaGetActionToken
//
// Scope: oauth2 [AdvancedWriteActions]
func (a API) Destiny2AwaGetActionToken(ctx context.Context, req Destiny2AwaGetActionTokenRequest) (*ServerResponse[AwaAuthorizationResult], error) {
	//	{
	//	  "description": "Returns the action token if user approves the request.",
	//	  "operationId": "Destiny2.AwaGetActionToken",
	//	  "parameters": [
	//	    {
	//	      "description": "The identifier for the advanced write action request.",
	//	      "in": "path",
	//	      "name": "correlationId",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Advanced.AwaAuthorizationResult"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdvancedWriteActions"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[AwaAuthorizationResult]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.AwaGetActionToken",
		Method:   "GET",
		PathSpec: "/Destiny2/Awa/GetActionToken/{correlationId}/", PathParams: map[string]string{
			"correlationId": fmt.Sprint(req.CorrelationID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// ContentSearchContentWithTextRequest are the request parameters for operation
// Content.SearchContentWithText
type ContentSearchContentWithTextRequest struct {

	// Content type tag: Help, News, etc. Supply multiple ctypes separated by space.
	Ctype string

	// Page number for the search results, starting with page 1.
	Currentpage int32

	// Not used.
	Head bool

	// Required.
	Locale string

	// Word or phrase for the search.
	Searchtext string

	// For analytics, hint at the part of the app that triggered the search. Optional.
	Source string

	// Tag used on the content to be searched.
	Tag string
}

// ContentSearchContentWithText: Gets content based on querystring information passed in. Provides
// basic search and text search capabilities.
//
// URL: /Content/Search/{locale}/
//
// Operation: Content.SearchContentWithText
func (a API) ContentSearchContentWithText(ctx context.Context, req ContentSearchContentWithTextRequest) (*ServerResponse[SearchResult[ContentItemPublicContract]], error) {
	//	{
	//	  "description": "Gets content based on querystring information passed in. Provides basic search and text search capabilities.",
	//	  "operationId": "Content.SearchContentWithText",
	//	  "parameters": [
	//	    {
	//	      "description": "Content type tag: Help, News, etc. Supply multiple ctypes separated by space.",
	//	      "in": "query",
	//	      "name": "ctype",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "Page number for the search results, starting with page 1.",
	//	      "in": "query",
	//	      "name": "currentpage",
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Not used.",
	//	      "in": "query",
	//	      "name": "head",
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "locale",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "Word or phrase for the search.",
	//	      "in": "query",
	//	      "name": "searchtext",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "For analytics, hint at the part of the app that triggered the search. Optional.",
	//	      "in": "query",
	//	      "name": "source",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "Tag used on the content to be searched.",
	//	      "in": "query",
	//	      "name": "tag",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/SearchResultOfContentItemPublicContract"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Content"
	//	  ]
	//	}
	var resp ServerResponse[SearchResult[ContentItemPublicContract]]
	err := a.client.Do(ctx, ClientRequest{Operation: "Content.SearchContentWithText",
		Method:   "GET",
		PathSpec: "/Content/Search/{locale}/", PathParams: map[string]string{
			"locale": fmt.Sprint(req.Locale),
		}, QueryParams: url.Values{
			"ctype":       {fmt.Sprint(req.Ctype)},
			"currentpage": {fmt.Sprint(req.Currentpage)},
			"head":        {fmt.Sprint(req.Head)},
			"searchtext":  {fmt.Sprint(req.Searchtext)},
			"source":      {fmt.Sprint(req.Source)},
			"tag":         {fmt.Sprint(req.Tag)},
		}}, &resp)
	return &resp, err
}

// ContentRssNewsArticlesRequest are the request parameters for operation Content.RssNewsArticles
type ContentRssNewsArticlesRequest struct {

	// Optionally filter response to only include news items in a certain category.
	Categoryfilter string

	// Optionally include full content body for each news item.
	Includebody bool

	// Zero-based pagination token for paging through result sets.
	// Required.
	PageToken string
}

// ContentRssNewsArticles: Returns a JSON string response that is the RSS feed for news articles.
//
// URL: /Content/Rss/NewsArticles/{pageToken}/
//
// Operation: Content.RssNewsArticles
func (a API) ContentRssNewsArticles(ctx context.Context, req ContentRssNewsArticlesRequest) (*ServerResponse[NewsArticleRssResponse], error) {
	//	{
	//	  "description": "Returns a JSON string response that is the RSS feed for news articles.",
	//	  "operationId": "Content.RssNewsArticles",
	//	  "parameters": [
	//	    {
	//	      "description": "Optionally filter response to only include news items in a certain category.",
	//	      "in": "query",
	//	      "name": "categoryfilter",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "Optionally include full content body for each news item.",
	//	      "in": "query",
	//	      "name": "includebody",
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    },
	//	    {
	//	      "description": "Zero-based pagination token for paging through result sets.",
	//	      "in": "path",
	//	      "name": "pageToken",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Content.NewsArticleRssResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Content"
	//	  ]
	//	}
	var resp ServerResponse[NewsArticleRssResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Content.RssNewsArticles",
		Method:   "GET",
		PathSpec: "/Content/Rss/NewsArticles/{pageToken}/", PathParams: map[string]string{
			"pageToken": fmt.Sprint(req.PageToken),
		}, QueryParams: url.Values{
			"categoryfilter": {fmt.Sprint(req.Categoryfilter)},
			"includebody":    {fmt.Sprint(req.Includebody)},
		}}, &resp)
	return &resp, err
}

// ContentGetContentTypeRequest are the request parameters for operation Content.GetContentType
type ContentGetContentTypeRequest struct {

	// Required.
	Type string
}

// ContentGetContentType: Gets an object describing a particular variant of content.
//
// URL: /Content/GetContentType/{type}/
//
// Operation: Content.GetContentType
func (a API) ContentGetContentType(ctx context.Context, req ContentGetContentTypeRequest) (*ServerResponse[ContentTypeDescription], error) {
	//	{
	//	  "description": "Gets an object describing a particular variant of content.",
	//	  "operationId": "Content.GetContentType",
	//	  "parameters": [
	//	    {
	//	      "in": "path",
	//	      "name": "type",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Content.Models.ContentTypeDescription"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Content"
	//	  ]
	//	}
	var resp ServerResponse[ContentTypeDescription]
	err := a.client.Do(ctx, ClientRequest{Operation: "Content.GetContentType",
		Method:   "GET",
		PathSpec: "/Content/GetContentType/{type}/", PathParams: map[string]string{
			"type": fmt.Sprint(req.Type),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// AppGetApplicationApiUsageRequest are the request parameters for operation App.GetApplicationApiUsage
type AppGetApplicationApiUsageRequest struct {

	// ID of the application to get usage statistics.
	// Required.
	ApplicationID int32

	// End time for query. Goes to now if not specified.
	End Timestamp

	// Start time for query. Goes to 24 hours ago if not specified.
	Start Timestamp
}

// AppGetApplicationApiUsage: Get API usage by application for time frame specified. You can go as far
// back as 30 days ago, and can ask for up to a 48 hour window of time in a single request. You must be
// authenticated with at least the ReadUserData permission to access this endpoint.
//
// URL: /App/ApiUsage/{applicationId}/
//
// Operation: App.GetApplicationApiUsage
//
// Scope: oauth2 [ReadUserData]
func (a API) AppGetApplicationApiUsage(ctx context.Context, req AppGetApplicationApiUsageRequest) (*ServerResponse[ApiUsage], error) {
	//	{
	//	  "description": "Get API usage by application for time frame specified. You can go as far back as 30 days ago, and can ask for up to a 48 hour window of time in a single request. You must be authenticated with at least the ReadUserData permission to access this endpoint.",
	//	  "operationId": "App.GetApplicationApiUsage",
	//	  "parameters": [
	//	    {
	//	      "description": "ID of the application to get usage statistics.",
	//	      "in": "path",
	//	      "name": "applicationId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "End time for query. Goes to now if not specified.",
	//	      "in": "query",
	//	      "name": "end",
	//	      "schema": {
	//	        "format": "date-time",
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "Start time for query. Goes to 24 hours ago if not specified.",
	//	      "in": "query",
	//	      "name": "start",
	//	      "schema": {
	//	        "format": "date-time",
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Applications.ApiUsage"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "ReadUserData"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "App"
	//	  ]
	//	}
	var resp ServerResponse[ApiUsage]
	err := a.client.Do(ctx, ClientRequest{Operation: "App.GetApplicationApiUsage",
		Method:   "GET",
		PathSpec: "/App/ApiUsage/{applicationId}/", PathParams: map[string]string{
			"applicationId": fmt.Sprint(req.ApplicationID),
		}, QueryParams: url.Values{
			"end":   {fmt.Sprint(req.End)},
			"start": {fmt.Sprint(req.Start)},
		}}, &resp)
	return &resp, err
}

// UserSearchByGlobalNamePrefixRequest are the request parameters for operation
// User.SearchByGlobalNamePrefix
type UserSearchByGlobalNamePrefixRequest struct {

	// The display name prefix you're looking for.
	// Required.
	DisplayNamePrefix string

	// The zero-based page of results you desire.
	// Required.
	Page int32
}

// UserSearchByGlobalNamePrefix: [OBSOLETE] Do not use this to search users, use SearchByGlobalNamePost
// instead.
//
// URL: /User/Search/Prefix/{displayNamePrefix}/{page}/
//
// Operation: User.SearchByGlobalNamePrefix
func (a API) UserSearchByGlobalNamePrefix(ctx context.Context, req UserSearchByGlobalNamePrefixRequest) (*ServerResponse[UserSearchResponse], error) {
	//	{
	//	  "description": "[OBSOLETE] Do not use this to search users, use SearchByGlobalNamePost instead.",
	//	  "operationId": "User.SearchByGlobalNamePrefix",
	//	  "parameters": [
	//	    {
	//	      "description": "The display name prefix you're looking for.",
	//	      "in": "path",
	//	      "name": "displayNamePrefix",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "The zero-based page of results you desire.",
	//	      "in": "path",
	//	      "name": "page",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/User.UserSearchResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "User"
	//	  ]
	//	}
	var resp ServerResponse[UserSearchResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "User.SearchByGlobalNamePrefix",
		Method:   "GET",
		PathSpec: "/User/Search/Prefix/{displayNamePrefix}/{page}/", PathParams: map[string]string{
			"displayNamePrefix": fmt.Sprint(req.DisplayNamePrefix),
			"page":              fmt.Sprint(req.Page),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// UserGetMembershipDataByIdRequest are the request parameters for operation User.GetMembershipDataById
type UserGetMembershipDataByIdRequest struct {

	// The membership ID of the target user.
	// Required.
	MembershipID Int64

	// Type of the supplied membership ID.
	// Required.
	MembershipType BungieMembershipType
}

// UserGetMembershipDataById: Returns a list of accounts associated with the supplied membership ID and
// membership type. This will include all linked accounts (even when hidden) if supplied credentials
// permit it.
//
// URL: /User/GetMembershipsById/{membershipId}/{membershipType}/
//
// Operation: User.GetMembershipDataById
func (a API) UserGetMembershipDataById(ctx context.Context, req UserGetMembershipDataByIdRequest) (*ServerResponse[UserMembershipData], error) {
	//	{
	//	  "description": "Returns a list of accounts associated with the supplied membership ID and membership type. This will include all linked accounts (even when hidden) if supplied credentials permit it.",
	//	  "operationId": "User.GetMembershipDataById",
	//	  "parameters": [
	//	    {
	//	      "description": "The membership ID of the target user.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Type of the supplied membership ID.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/User.UserMembershipData"
	//	    }
	//	  },
	//	  "tags": [
	//	    "User"
	//	  ]
	//	}
	var resp ServerResponse[UserMembershipData]
	err := a.client.Do(ctx, ClientRequest{Operation: "User.GetMembershipDataById",
		Method:   "GET",
		PathSpec: "/User/GetMembershipsById/{membershipId}/{membershipType}/", PathParams: map[string]string{
			"membershipId":   fmt.Sprint(req.MembershipID),
			"membershipType": fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// UserGetMembershipFromHardLinkedCredentialRequest are the request parameters for operation
// User.GetMembershipFromHardLinkedCredential
type UserGetMembershipFromHardLinkedCredentialRequest struct {

	// The credential to look up. Must be a valid SteamID64.
	// Required.
	Credential string

	// The credential type. 'SteamId' is the only valid value at present.
	// Required.
	CrType BungieCredentialType
}

// UserGetMembershipFromHardLinkedCredential: Gets any hard linked membership given a credential. Only
// works for credentials that are public (just SteamID64 right now). Cross Save aware.
//
// URL: /User/GetMembershipFromHardLinkedCredential/{crType}/{credential}/
//
// Operation: User.GetMembershipFromHardLinkedCredential
func (a API) UserGetMembershipFromHardLinkedCredential(ctx context.Context, req UserGetMembershipFromHardLinkedCredentialRequest) (*ServerResponse[HardLinkedUserMembership], error) {
	//	{
	//	  "description": "Gets any hard linked membership given a credential. Only works for credentials that are public (just SteamID64 right now). Cross Save aware.",
	//	  "operationId": "User.GetMembershipFromHardLinkedCredential",
	//	  "parameters": [
	//	    {
	//	      "description": "The credential to look up. Must be a valid SteamID64.",
	//	      "in": "path",
	//	      "name": "credential",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "The credential type. 'SteamId' is the only valid value at present.",
	//	      "in": "path",
	//	      "name": "crType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of credentials the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.CredentialType.",
	//	        "format": "byte",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieCredentialType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/User.HardLinkedUserMembership"
	//	    }
	//	  },
	//	  "tags": [
	//	    "User"
	//	  ]
	//	}
	var resp ServerResponse[HardLinkedUserMembership]
	err := a.client.Do(ctx, ClientRequest{Operation: "User.GetMembershipFromHardLinkedCredential",
		Method:   "GET",
		PathSpec: "/User/GetMembershipFromHardLinkedCredential/{crType}/{credential}/", PathParams: map[string]string{
			"credential": fmt.Sprint(req.Credential),
			"crType":     fmt.Sprint(req.CrType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// TrendingGetTrendingEntryDetailRequest are the request parameters for operation
// Trending.GetTrendingEntryDetail
type TrendingGetTrendingEntryDetailRequest struct {

	// The identifier for the entity to be returned.
	// Required.
	Identifier string

	// The type of entity to be returned.
	// Required.
	TrendingEntryType TrendingEntryType
}

// TrendingGetTrendingEntryDetail: Returns the detailed results for a specific trending entry. Note
// that trending entries are uniquely identified by a combination of *both* the TrendingEntryType *and*
// the identifier: the identifier alone is not guaranteed to be globally unique.
//
// URL: /Trending/Details/{trendingEntryType}/{identifier}/
//
// Operation: Trending.GetTrendingEntryDetail
func (a API) TrendingGetTrendingEntryDetail(ctx context.Context, req TrendingGetTrendingEntryDetailRequest) (*ServerResponse[TrendingDetail], error) {
	//	{
	//	  "description": "Returns the detailed results for a specific trending entry. Note that trending entries are uniquely identified by a combination of *both* the TrendingEntryType *and* the identifier: the identifier alone is not guaranteed to be globally unique.",
	//	  "operationId": "Trending.GetTrendingEntryDetail",
	//	  "parameters": [
	//	    {
	//	      "description": "The identifier for the entity to be returned.",
	//	      "in": "path",
	//	      "name": "identifier",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "The type of entity to be returned.",
	//	      "in": "path",
	//	      "name": "trendingEntryType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The known entity types that you can have returned from Trending.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Trending.TrendingEntryType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Trending.TrendingDetail"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Trending"
	//	  ]
	//	}
	var resp ServerResponse[TrendingDetail]
	err := a.client.Do(ctx, ClientRequest{Operation: "Trending.GetTrendingEntryDetail",
		Method:   "GET",
		PathSpec: "/Trending/Details/{trendingEntryType}/{identifier}/", PathParams: map[string]string{
			"identifier":        fmt.Sprint(req.Identifier),
			"trendingEntryType": fmt.Sprint(req.TrendingEntryType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// TrendingGetTrendingCategoryRequest are the request parameters for operation
// Trending.GetTrendingCategory
type TrendingGetTrendingCategoryRequest struct {

	// The ID of the category for whom you want additional results.
	// Required.
	CategoryID string

	// The page # of results to return.
	// Required.
	PageNumber int32
}

// TrendingGetTrendingCategory: Returns paginated lists of trending items for a category.
//
// URL: /Trending/Categories/{categoryId}/{pageNumber}/
//
// Operation: Trending.GetTrendingCategory
func (a API) TrendingGetTrendingCategory(ctx context.Context, req TrendingGetTrendingCategoryRequest) (*ServerResponse[SearchResult[TrendingEntry]], error) {
	//	{
	//	  "description": "Returns paginated lists of trending items for a category.",
	//	  "operationId": "Trending.GetTrendingCategory",
	//	  "parameters": [
	//	    {
	//	      "description": "The ID of the category for whom you want additional results.",
	//	      "in": "path",
	//	      "name": "categoryId",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "The page # of results to return.",
	//	      "in": "path",
	//	      "name": "pageNumber",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/SearchResultOfTrendingEntry"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Trending"
	//	  ]
	//	}
	var resp ServerResponse[SearchResult[TrendingEntry]]
	err := a.client.Do(ctx, ClientRequest{Operation: "Trending.GetTrendingCategory",
		Method:   "GET",
		PathSpec: "/Trending/Categories/{categoryId}/{pageNumber}/", PathParams: map[string]string{
			"categoryId": fmt.Sprint(req.CategoryID),
			"pageNumber": fmt.Sprint(req.PageNumber),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// TokensGetBungieRewardsForPlatformUserRequest are the request parameters for operation
// Tokens.GetBungieRewardsForPlatformUser
type TokensGetBungieRewardsForPlatformUserRequest struct {

	// users platform membershipId for requested user rewards. If not self, elevated permissions are
	// required.
	// Required.
	MembershipID Int64

	// The target Destiny 2 membership type.
	// Required.
	MembershipType BungieMembershipType
}

// TokensGetBungieRewardsForPlatformUser: Returns the bungie rewards for the targeted user when a
// platform membership Id and Type are used.
//
// URL: /Tokens/Rewards/GetRewardsForPlatformUser/{membershipId}/{membershipType}/
//
// Operation: Tokens.GetBungieRewardsForPlatformUser
//
// Scope: oauth2 [ReadAndApplyTokens]
func (a API) TokensGetBungieRewardsForPlatformUser(ctx context.Context, req TokensGetBungieRewardsForPlatformUserRequest) (*ServerResponse[map[string]BungieRewardDisplay], error) {
	//	{
	//	  "description": "Returns the bungie rewards for the targeted user when a platform membership Id and Type are used.",
	//	  "operationId": "Tokens.GetBungieRewardsForPlatformUser",
	//	  "parameters": [
	//	    {
	//	      "description": "users platform membershipId for requested user rewards. If not self, elevated permissions are required.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The target Destiny 2 membership type.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/DictionaryOfstringAndBungieRewardDisplay"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "ReadAndApplyTokens"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Tokens"
	//	  ]
	//	}
	var resp ServerResponse[map[string]BungieRewardDisplay]
	err := a.client.Do(ctx, ClientRequest{Operation: "Tokens.GetBungieRewardsForPlatformUser",
		Method:   "GET",
		PathSpec: "/Tokens/Rewards/GetRewardsForPlatformUser/{membershipId}/{membershipType}/", PathParams: map[string]string{
			"membershipId":   fmt.Sprint(req.MembershipID),
			"membershipType": fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// TokensGetPartnerRewardHistoryRequest are the request parameters for operation
// Tokens.GetPartnerRewardHistory
type TokensGetPartnerRewardHistoryRequest struct {

	// The partner application identifier.
	// Required.
	PartnerApplicationID int32

	// The bungie.net user to return reward history for.
	// Required.
	TargetBnetMembershipID Int64
}

// TokensGetPartnerRewardHistory: Returns the partner rewards history of the targeted user, both
// partner offers and Twitch drops.
//
// URL: /Tokens/Partner/History/{targetBnetMembershipId}/Application/{partnerApplicationId}/
//
// Operation: Tokens.GetPartnerRewardHistory
//
// Scope: oauth2 [PartnerOfferGrant]
func (a API) TokensGetPartnerRewardHistory(ctx context.Context, req TokensGetPartnerRewardHistoryRequest) (*ServerResponse[PartnerRewardHistoryResponse], error) {
	//	{
	//	  "description": "Returns the partner rewards history of the targeted user, both partner offers and Twitch drops.",
	//	  "operationId": "Tokens.GetPartnerRewardHistory",
	//	  "parameters": [
	//	    {
	//	      "description": "The partner application identifier.",
	//	      "in": "path",
	//	      "name": "partnerApplicationId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The bungie.net user to return reward history for.",
	//	      "in": "path",
	//	      "name": "targetBnetMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Tokens.PartnerRewardHistoryResponse"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "PartnerOfferGrant"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Tokens"
	//	  ]
	//	}
	var resp ServerResponse[PartnerRewardHistoryResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Tokens.GetPartnerRewardHistory",
		Method:   "GET",
		PathSpec: "/Tokens/Partner/History/{targetBnetMembershipId}/Application/{partnerApplicationId}/", PathParams: map[string]string{
			"partnerApplicationId":   fmt.Sprint(req.PartnerApplicationID),
			"targetBnetMembershipId": fmt.Sprint(req.TargetBnetMembershipID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// TokensGetPartnerOfferSkuHistoryRequest are the request parameters for operation
// Tokens.GetPartnerOfferSkuHistory
type TokensGetPartnerOfferSkuHistoryRequest struct {

	// The partner application identifier.
	// Required.
	PartnerApplicationID int32

	// The bungie.net user to apply missing offers to. If not self, elevated permissions are required.
	// Required.
	TargetBnetMembershipID Int64
}

// TokensGetPartnerOfferSkuHistory: Returns the partner sku and offer history of the targeted user.
// Elevated permissions are required to see users that are not yourself.
//
// URL: /Tokens/Partner/History/{partnerApplicationId}/{targetBnetMembershipId}/
//
// Operation: Tokens.GetPartnerOfferSkuHistory
//
// Scope: oauth2 [PartnerOfferGrant]
func (a API) TokensGetPartnerOfferSkuHistory(ctx context.Context, req TokensGetPartnerOfferSkuHistoryRequest) (*ServerResponse[[]PartnerOfferSkuHistoryResponse], error) {
	//	{
	//	  "description": "Returns the partner sku and offer history of the targeted user. Elevated permissions are required to see users that are not yourself.",
	//	  "operationId": "Tokens.GetPartnerOfferSkuHistory",
	//	  "parameters": [
	//	    {
	//	      "description": "The partner application identifier.",
	//	      "in": "path",
	//	      "name": "partnerApplicationId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The bungie.net user to apply missing offers to. If not self, elevated permissions are required.",
	//	      "in": "path",
	//	      "name": "targetBnetMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/CEListOfPartnerOfferSkuHistoryResponse"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "PartnerOfferGrant"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Tokens"
	//	  ]
	//	}
	var resp ServerResponse[[]PartnerOfferSkuHistoryResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Tokens.GetPartnerOfferSkuHistory",
		Method:   "GET",
		PathSpec: "/Tokens/Partner/History/{partnerApplicationId}/{targetBnetMembershipId}/", PathParams: map[string]string{
			"partnerApplicationId":   fmt.Sprint(req.PartnerApplicationID),
			"targetBnetMembershipId": fmt.Sprint(req.TargetBnetMembershipID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// TokensApplyMissingPartnerOffersWithoutClaimRequest are the request parameters for operation
// Tokens.ApplyMissingPartnerOffersWithoutClaim
type TokensApplyMissingPartnerOffersWithoutClaimRequest struct {

	// The partner application identifier.
	// Required.
	PartnerApplicationID int32

	// The bungie.net user to apply missing offers to. If not self, elevated permissions are required.
	// Required.
	TargetBnetMembershipID Int64
}

// TokensApplyMissingPartnerOffersWithoutClaim: Apply a partner offer to the targeted user. This
// endpoint does not claim a new offer, but any already claimed offers will be applied to the game if
// not already.
//
// URL: /Tokens/Partner/ApplyMissingOffers/{partnerApplicationId}/{targetBnetMembershipId}/
//
// Operation: Tokens.ApplyMissingPartnerOffersWithoutClaim
//
// Scope: oauth2 [PartnerOfferGrant]
func (a API) TokensApplyMissingPartnerOffersWithoutClaim(ctx context.Context, req TokensApplyMissingPartnerOffersWithoutClaimRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "Apply a partner offer to the targeted user. This endpoint does not claim a new offer, but any already claimed offers will be applied to the game if not already.",
	//	  "operationId": "Tokens.ApplyMissingPartnerOffersWithoutClaim",
	//	  "parameters": [
	//	    {
	//	      "description": "The partner application identifier.",
	//	      "in": "path",
	//	      "name": "partnerApplicationId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The bungie.net user to apply missing offers to. If not self, elevated permissions are required.",
	//	      "in": "path",
	//	      "name": "targetBnetMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "PartnerOfferGrant"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Tokens"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "Tokens.ApplyMissingPartnerOffersWithoutClaim",
		Method:   "POST",
		PathSpec: "/Tokens/Partner/ApplyMissingOffers/{partnerApplicationId}/{targetBnetMembershipId}/", PathParams: map[string]string{
			"partnerApplicationId":   fmt.Sprint(req.PartnerApplicationID),
			"targetBnetMembershipId": fmt.Sprint(req.TargetBnetMembershipID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// SocialGetPlatformFriendListRequest are the request parameters for operation
// Social.GetPlatformFriendList
type SocialGetPlatformFriendListRequest struct {

	// The platform friend type.
	// Required.
	FriendPlatform PlatformFriendType

	// The zero based page to return. Page size is 100.
	// Required.
	Page string
}

// SocialGetPlatformFriendList: Gets the platform friend of the requested type, with additional
// information if they have Bungie accounts. Must have a recent login session with said platform.
//
// URL: /Social/PlatformFriends/{friendPlatform}/{page}/
//
// Operation: Social.GetPlatformFriendList
func (a API) SocialGetPlatformFriendList(ctx context.Context, req SocialGetPlatformFriendListRequest) (*ServerResponse[PlatformFriendResponse], error) {
	//	{
	//	  "description": "Gets the platform friend of the requested type, with additional information if they have Bungie accounts. Must have a recent login session with said platform.",
	//	  "operationId": "Social.GetPlatformFriendList",
	//	  "parameters": [
	//	    {
	//	      "description": "The platform friend type.",
	//	      "in": "path",
	//	      "name": "friendPlatform",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Social.Friends.PlatformFriendType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "The zero based page to return. Page size is 100.",
	//	      "in": "path",
	//	      "name": "page",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Social.Friends.PlatformFriendResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Social"
	//	  ]
	//	}
	var resp ServerResponse[PlatformFriendResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Social.GetPlatformFriendList",
		Method:   "GET",
		PathSpec: "/Social/PlatformFriends/{friendPlatform}/{page}/", PathParams: map[string]string{
			"friendPlatform": fmt.Sprint(req.FriendPlatform),
			"page":           fmt.Sprint(req.Page),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2EditOptionalConversationRequest are the request parameters for operation
// GroupV2.EditOptionalConversation
type GroupV2EditOptionalConversationRequest struct {

	// Conversation Id of the channel being edited.
	// Required.
	ConversationID Int64

	// Group ID of the group to edit.
	// Required.
	GroupID Int64

	// Required.
	Body GroupOptionalConversationEditRequestBody
}

// GroupV2EditOptionalConversation: Edit the settings of an optional conversation/chat channel.
// Requires admin permissions to the group.
//
// URL: /GroupV2/{groupId}/OptionalConversations/Edit/{conversationId}/
//
// Operation: GroupV2.EditOptionalConversation
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2EditOptionalConversation(ctx context.Context, req GroupV2EditOptionalConversationRequest) (*ServerResponse[Int64], error) {
	//	{
	//	  "description": "Edit the settings of an optional conversation/chat channel. Requires admin permissions to the group.",
	//	  "operationId": "GroupV2.EditOptionalConversation",
	//	  "parameters": [
	//	    {
	//	      "description": "Conversation Id of the channel being edited.",
	//	      "in": "path",
	//	      "name": "conversationId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Group ID of the group to edit.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupOptionalConversationEditRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int64"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[Int64]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.EditOptionalConversation",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/OptionalConversations/Edit/{conversationId}/", PathParams: map[string]string{
			"conversationId": fmt.Sprint(req.ConversationID),
			"groupId":        fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// GroupV2GetRecommendedGroupsRequest are the request parameters for operation
// GroupV2.GetRecommendedGroups
type GroupV2GetRecommendedGroupsRequest struct {

	// Requested range in which to pull recommended groups
	// Required.
	CreateDateRange GroupDateRange

	// Type of groups requested
	// Required.
	GroupType GroupType
}

// GroupV2GetRecommendedGroups: Gets groups recommended for you based on the groups to whom those you
// follow belong.
//
// URL: /GroupV2/Recommended/{groupType}/{createDateRange}/
//
// Operation: GroupV2.GetRecommendedGroups
//
// Scope: oauth2 [ReadGroups]
func (a API) GroupV2GetRecommendedGroups(ctx context.Context, req GroupV2GetRecommendedGroupsRequest) (*ServerResponse[[]GroupV2Card], error) {
	//	{
	//	  "description": "Gets groups recommended for you based on the groups to whom those you follow belong.",
	//	  "operationId": "GroupV2.GetRecommendedGroups",
	//	  "parameters": [
	//	    {
	//	      "description": "Requested range in which to pull recommended groups",
	//	      "in": "path",
	//	      "name": "createDateRange",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupDateRange"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Type of groups requested",
	//	      "in": "path",
	//	      "name": "groupType",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/ListOfGroupV2Card"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "ReadGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[[]GroupV2Card]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetRecommendedGroups",
		Method:   "POST",
		PathSpec: "/GroupV2/Recommended/{groupType}/{createDateRange}/", PathParams: map[string]string{
			"createDateRange": fmt.Sprint(req.CreateDateRange),
			"groupType":       fmt.Sprint(req.GroupType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2GetGroupByNameRequest are the request parameters for operation GroupV2.GetGroupByName
type GroupV2GetGroupByNameRequest struct {

	// Exact name of the group to find.
	// Required.
	GroupName string

	// Type of group to find.
	// Required.
	GroupType GroupType
}

// GroupV2GetGroupByName: Get information about a specific group with the given name and type.
//
// URL: /GroupV2/Name/{groupName}/{groupType}/
//
// Operation: GroupV2.GetGroupByName
func (a API) GroupV2GetGroupByName(ctx context.Context, req GroupV2GetGroupByNameRequest) (*ServerResponse[GroupResponse], error) {
	//	{
	//	  "description": "Get information about a specific group with the given name and type.",
	//	  "operationId": "GroupV2.GetGroupByName",
	//	  "parameters": [
	//	    {
	//	      "description": "Exact name of the group to find.",
	//	      "in": "path",
	//	      "name": "groupName",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "Type of group to find.",
	//	      "in": "path",
	//	      "name": "groupType",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/GroupsV2.GroupResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[GroupResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetGroupByName",
		Method:   "GET",
		PathSpec: "/GroupV2/Name/{groupName}/{groupType}/", PathParams: map[string]string{
			"groupName": fmt.Sprint(req.GroupName),
			"groupType": fmt.Sprint(req.GroupType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// FireteamGetClanFireteamRequest are the request parameters for operation Fireteam.GetClanFireteam
type FireteamGetClanFireteamRequest struct {

	// The unique id of the fireteam.
	// Required.
	FireteamID Int64

	// The group id of the clan.
	// Required.
	GroupID Int64
}

// FireteamGetClanFireteam: Gets a specific fireteam.
//
// URL: /Fireteam/Clan/{groupId}/Summary/{fireteamId}/
//
// Operation: Fireteam.GetClanFireteam
//
// Scope: oauth2 [ReadGroups]
func (a API) FireteamGetClanFireteam(ctx context.Context, req FireteamGetClanFireteamRequest) (*ServerResponse[FireteamResponse], error) {
	//	{
	//	  "description": "Gets a specific fireteam.",
	//	  "operationId": "Fireteam.GetClanFireteam",
	//	  "parameters": [
	//	    {
	//	      "description": "The unique id of the fireteam.",
	//	      "in": "path",
	//	      "name": "fireteamId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The group id of the clan.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Fireteam.FireteamResponse"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "ReadGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Fireteam"
	//	  ]
	//	}
	var resp ServerResponse[FireteamResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Fireteam.GetClanFireteam",
		Method:   "GET",
		PathSpec: "/Fireteam/Clan/{groupId}/Summary/{fireteamId}/", PathParams: map[string]string{
			"fireteamId": fmt.Sprint(req.FireteamID),
			"groupId":    fmt.Sprint(req.GroupID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// Destiny2GetLinkedProfilesRequest are the request parameters for operation Destiny2.GetLinkedProfiles
type Destiny2GetLinkedProfilesRequest struct {

	// (optional) if set to 'true', all memberships regardless of whether they're obscured by overrides
	// will be returned. Normal privacy restrictions on account linking will still apply no matter what.
	GetAllMemberships bool

	// The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership
	// ID matches its Membership Type: don't pass us a PSN membership ID and the XBox membership type, it's
	// not going to work!
	// Required.
	MembershipID Int64

	// The type for the membership whose linked Destiny accounts you want returned.
	// Required.
	MembershipType BungieMembershipType
}

// Destiny2GetLinkedProfiles: Returns a summary information about all profiles linked to the requesting
// membership type/membership ID that have valid Destiny information. The passed-in Membership
// Type/Membership ID may be a Bungie.Net membership or a Destiny membership. It only returns the
// minimal amount of data to begin making more substantive requests, but will hopefully serve as a
// useful alternative to UserServices for people who just care about Destiny data. Note that it will
// only return linked accounts whose linkages you are allowed to view.
//
// URL: /Destiny2/{membershipType}/Profile/{membershipId}/LinkedProfiles/
//
// Operation: Destiny2.GetLinkedProfiles
func (a API) Destiny2GetLinkedProfiles(ctx context.Context, req Destiny2GetLinkedProfilesRequest) (*ServerResponse[LinkedProfilesResponse], error) {
	//	{
	//	  "description": "Returns a summary information about all profiles linked to the requesting membership type/membership ID that have valid Destiny information. The passed-in Membership Type/Membership ID may be a Bungie.Net membership or a Destiny membership. It only returns the minimal amount of data to begin making more substantive requests, but will hopefully serve as a useful alternative to UserServices for people who just care about Destiny data. Note that it will only return linked accounts whose linkages you are allowed to view.",
	//	  "operationId": "Destiny2.GetLinkedProfiles",
	//	  "parameters": [
	//	    {
	//	      "description": "(optional) if set to 'true', all memberships regardless of whether they're obscured by overrides will be returned. Normal privacy restrictions on account linking will still apply no matter what.",
	//	      "in": "query",
	//	      "name": "getAllMemberships",
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    },
	//	    {
	//	      "description": "The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don't pass us a PSN membership ID and the XBox membership type, it's not going to work!",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The type for the membership whose linked Destiny accounts you want returned.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Responses.DestinyLinkedProfilesResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[LinkedProfilesResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetLinkedProfiles",
		Method:   "GET",
		PathSpec: "/Destiny2/{membershipType}/Profile/{membershipId}/LinkedProfiles/", PathParams: map[string]string{
			"membershipId":   fmt.Sprint(req.MembershipID),
			"membershipType": fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{
			"getAllMemberships": {fmt.Sprint(req.GetAllMemberships)},
		}}, &resp)
	return &resp, err
}

// Destiny2GetProfileRequest are the request parameters for operation Destiny2.GetProfile
type Destiny2GetProfileRequest struct {

	// A comma separated list of components to return (as strings or numeric values). See the
	// DestinyComponentType enum for valid components to request. You must request at least one component
	// to receive results.
	Components []ComponentType

	// Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid non-BungieNet membership type.
	// Required.
	MembershipType BungieMembershipType
}

// Destiny2GetProfile: Returns Destiny Profile information for the supplied membership.
//
// URL: /Destiny2/{membershipType}/Profile/{destinyMembershipId}/
//
// Operation: Destiny2.GetProfile
func (a API) Destiny2GetProfile(ctx context.Context, req Destiny2GetProfileRequest) (*ServerResponse[ProfileResponse], error) {
	//	{
	//	  "description": "Returns Destiny Profile information for the supplied membership.",
	//	  "operationId": "Destiny2.GetProfile",
	//	  "parameters": [
	//	    {
	//	      "description": "A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results.",
	//	      "in": "query",
	//	      "name": "components",
	//	      "schema": {
	//	        "items": {
	//	          "description": "Represents the possible components that can be returned from Destiny \"Get\" calls such as GetProfile, GetCharacter, GetVendor etc...\r\nWhen making one of these requests, you will pass one or more of these components as a comma separated list in the \"?components=\" querystring parameter. For instance, if you want baseline Profile data, Character Data, and character progressions, you would pass \"?components=Profiles,Characters,CharacterProgressions\" You may use either the numerical or string values.",
	//	          "format": "int32",
	//	          "type": "integer",
	//	          "x-enum-is-bitmask": false,
	//	          "x-enum-reference": {
	//	            "$ref": "#/components/schemas/Destiny.DestinyComponentType"
	//	          }
	//	        },
	//	        "type": "array"
	//	      }
	//	    },
	//	    {
	//	      "description": "Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid non-BungieNet membership type.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Responses.DestinyProfileResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[ProfileResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetProfile",
		Method:   "GET",
		PathSpec: "/Destiny2/{membershipType}/Profile/{destinyMembershipId}/", PathParams: map[string]string{
			"destinyMembershipId": fmt.Sprint(req.DestinyMembershipID),
			"membershipType":      fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{
			"components": {joinArray(req.Components)},
		}}, &resp)
	return &resp, err
}

// Destiny2GetLeaderboardsRequest are the request parameters for operation Destiny2.GetLeaderboards
type Destiny2GetLeaderboardsRequest struct {

	// The Destiny membershipId of the user to retrieve.
	// Required.
	DestinyMembershipID Int64

	// Maximum number of top players to return. Use a large number to get entire leaderboard.
	Maxtop int32

	// A valid non-BungieNet membership type.
	// Required.
	MembershipType BungieMembershipType

	// List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType
	// for valid values, and pass in string representation, comma delimited.
	Modes string

	// ID of stat to return rather than returning all Leaderboard stats.
	Statid string
}

// Destiny2GetLeaderboards: Gets leaderboards with the signed in user's friends and the supplied
// destinyMembershipId as the focus. PREVIEW: This endpoint has not yet been implemented. It is being
// returned for a preview of future functionality, and for public comment/suggestion/preparation.
//
// URL: /Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/Leaderboards/
//
// Operation: Destiny2.GetLeaderboards
func (a API) Destiny2GetLeaderboards(ctx context.Context, req Destiny2GetLeaderboardsRequest) (*ServerResponse[map[string]map[string]Leaderboard], error) {
	//	{
	//	  "description": "Gets leaderboards with the signed in user's friends and the supplied destinyMembershipId as the focus. PREVIEW: This endpoint has not yet been implemented. It is being returned for a preview of future functionality, and for public comment/suggestion/preparation.",
	//	  "operationId": "Destiny2.GetLeaderboards",
	//	  "parameters": [
	//	    {
	//	      "description": "The Destiny membershipId of the user to retrieve.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Maximum number of top players to return. Use a large number to get entire leaderboard.",
	//	      "in": "query",
	//	      "name": "maxtop",
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid non-BungieNet membership type.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited.",
	//	      "in": "query",
	//	      "name": "modes",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "ID of stat to return rather than returning all Leaderboard stats.",
	//	      "in": "query",
	//	      "name": "statid",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.HistoricalStats.DestinyLeaderboardResults"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2",
	//	    "Preview"
	//	  ],
	//	  "x-preview": true
	//	}
	var resp ServerResponse[map[string]map[string]Leaderboard]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetLeaderboards",
		Method:   "GET",
		PathSpec: "/Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/Leaderboards/", PathParams: map[string]string{
			"destinyMembershipId": fmt.Sprint(req.DestinyMembershipID),
			"membershipType":      fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{
			"maxtop": {fmt.Sprint(req.Maxtop)},
			"modes":  {fmt.Sprint(req.Modes)},
			"statid": {fmt.Sprint(req.Statid)},
		}}, &resp)
	return &resp, err
}

// Destiny2GetHistoricalStatsForAccountRequest are the request parameters for operation
// Destiny2.GetHistoricalStatsForAccount
type Destiny2GetHistoricalStatsForAccountRequest struct {

	// The Destiny membershipId of the user to retrieve.
	// Required.
	DestinyMembershipID Int64

	// Groups of stats to include, otherwise only general stats are returned. Comma separated list is
	// allowed. Values: General, Weapons, Medals.
	Groups []StatsGroupType

	// A valid non-BungieNet membership type.
	// Required.
	MembershipType BungieMembershipType
}

// Destiny2GetHistoricalStatsForAccount: Gets aggregate historical stats organized around each
// character for a given account.
//
// URL: /Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/
//
// Operation: Destiny2.GetHistoricalStatsForAccount
func (a API) Destiny2GetHistoricalStatsForAccount(ctx context.Context, req Destiny2GetHistoricalStatsForAccountRequest) (*ServerResponse[HistoricalStatsAccountResult], error) {
	//	{
	//	  "description": "Gets aggregate historical stats organized around each character for a given account.",
	//	  "operationId": "Destiny2.GetHistoricalStatsForAccount",
	//	  "parameters": [
	//	    {
	//	      "description": "The Destiny membershipId of the user to retrieve.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals.",
	//	      "in": "query",
	//	      "name": "groups",
	//	      "schema": {
	//	        "items": {
	//	          "description": "If the enum value is \u003e 100, it is a \"special\" group that cannot be queried for directly (special cases apply to when they are returned, and are not relevant in general cases)",
	//	          "format": "int32",
	//	          "type": "integer",
	//	          "x-enum-is-bitmask": false,
	//	          "x-enum-reference": {
	//	            "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.DestinyStatsGroupType"
	//	          }
	//	        },
	//	        "type": "array"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid non-BungieNet membership type.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.HistoricalStats.DestinyHistoricalStatsAccountResult"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[HistoricalStatsAccountResult]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetHistoricalStatsForAccount",
		Method:   "GET",
		PathSpec: "/Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/", PathParams: map[string]string{
			"destinyMembershipId": fmt.Sprint(req.DestinyMembershipID),
			"membershipType":      fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{
			"groups": {joinArray(req.Groups)},
		}}, &resp)
	return &resp, err
}

// Destiny2GetDestinyEntityDefinitionRequest are the request parameters for operation
// Destiny2.GetDestinyEntityDefinition
type Destiny2GetDestinyEntityDefinitionRequest struct {

	// The type of entity for whom you would like results. These correspond to the entity's definition
	// contract name. For instance, if you are looking for items, this property should be
	// 'DestinyInventoryItemDefinition'. PREVIEW: This endpoint is still in beta, and may experience rough
	// edges. The schema is tentatively in final form, but there may be bugs that prevent desirable
	// operation.
	// Required.
	EntityType string

	// The hash identifier for the specific Entity you want returned.
	// Required.
	HashIdentifier uint32
}

// Destiny2GetDestinyEntityDefinition: Returns the static definition of an entity of the given Type and
// hash identifier. Examine the API Documentation for the Type Names of entities that have their own
// definitions. Note that the return type will always *inherit from* DestinyDefinition, but the
// specific type returned will be the requested entity type if it can be found. Please don't use this
// as a chatty alternative to the Manifest database if you require large sets of data, but for simple
// and one-off accesses this should be handy.
//
// URL: /Destiny2/Manifest/{entityType}/{hashIdentifier}/
//
// Operation: Destiny2.GetDestinyEntityDefinition
func (a API) Destiny2GetDestinyEntityDefinition(ctx context.Context, req Destiny2GetDestinyEntityDefinitionRequest) (*ServerResponse[Definition], error) {
	//	{
	//	  "description": "Returns the static definition of an entity of the given Type and hash identifier. Examine the API Documentation for the Type Names of entities that have their own definitions. Note that the return type will always *inherit from* DestinyDefinition, but the specific type returned will be the requested entity type if it can be found. Please don't use this as a chatty alternative to the Manifest database if you require large sets of data, but for simple and one-off accesses this should be handy.",
	//	  "operationId": "Destiny2.GetDestinyEntityDefinition",
	//	  "parameters": [
	//	    {
	//	      "description": "The type of entity for whom you would like results. These correspond to the entity's definition contract name. For instance, if you are looking for items, this property should be 'DestinyInventoryItemDefinition'. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation.",
	//	      "in": "path",
	//	      "name": "entityType",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "The hash identifier for the specific Entity you want returned.",
	//	      "in": "path",
	//	      "name": "hashIdentifier",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "uint32",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Definitions.DestinyDefinition"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[Definition]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetDestinyEntityDefinition",
		Method:   "GET",
		PathSpec: "/Destiny2/Manifest/{entityType}/{hashIdentifier}/", PathParams: map[string]string{
			"entityType":     fmt.Sprint(req.EntityType),
			"hashIdentifier": fmt.Sprint(req.HashIdentifier),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// Destiny2SearchDestinyEntitiesRequest are the request parameters for operation
// Destiny2.SearchDestinyEntities
type Destiny2SearchDestinyEntitiesRequest struct {

	// Page number to return, starting with 0.
	Page int32

	// The string to use when searching for Destiny entities.
	// Required.
	SearchTerm string

	// The type of entity for whom you would like results. These correspond to the entity's definition
	// contract name. For instance, if you are looking for items, this property should be
	// 'DestinyInventoryItemDefinition'.
	// Required.
	Type string
}

// Destiny2SearchDestinyEntities: Gets a page list of Destiny items.
//
// URL: /Destiny2/Armory/Search/{type}/{searchTerm}/
//
// Operation: Destiny2.SearchDestinyEntities
func (a API) Destiny2SearchDestinyEntities(ctx context.Context, req Destiny2SearchDestinyEntitiesRequest) (*ServerResponse[EntitySearchResult], error) {
	//	{
	//	  "description": "Gets a page list of Destiny items.",
	//	  "operationId": "Destiny2.SearchDestinyEntities",
	//	  "parameters": [
	//	    {
	//	      "description": "Page number to return, starting with 0.",
	//	      "in": "query",
	//	      "name": "page",
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The string to use when searching for Destiny entities.",
	//	      "in": "path",
	//	      "name": "searchTerm",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "The type of entity for whom you would like results. These correspond to the entity's definition contract name. For instance, if you are looking for items, this property should be 'DestinyInventoryItemDefinition'.",
	//	      "in": "path",
	//	      "name": "type",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Definitions.DestinyEntitySearchResult"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[EntitySearchResult]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.SearchDestinyEntities",
		Method:   "GET",
		PathSpec: "/Destiny2/Armory/Search/{type}/{searchTerm}/", PathParams: map[string]string{
			"searchTerm": fmt.Sprint(req.SearchTerm),
			"type":       fmt.Sprint(req.Type),
		}, QueryParams: url.Values{
			"page": {fmt.Sprint(req.Page)},
		}}, &resp)
	return &resp, err
}

// ContentSearchHelpArticlesRequest are the request parameters for operation Content.SearchHelpArticles
type ContentSearchHelpArticlesRequest struct {

	// Required.
	Searchtext string

	// Required.
	Size string
}

// ContentSearchHelpArticles: Search for Help Articles.
//
// URL: /Content/SearchHelpArticles/{searchtext}/{size}/
//
// Operation: Content.SearchHelpArticles
func (a API) ContentSearchHelpArticles(ctx context.Context, req ContentSearchHelpArticlesRequest) (*ServerResponse[any], error) {
	//	{
	//	  "description": "Search for Help Articles.",
	//	  "operationId": "Content.SearchHelpArticles",
	//	  "parameters": [
	//	    {
	//	      "in": "path",
	//	      "name": "searchtext",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "size",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/IReadOnlyCollectionOfContentItemPublicContract"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Content"
	//	  ]
	//	}
	var resp ServerResponse[any]
	err := a.client.Do(ctx, ClientRequest{Operation: "Content.SearchHelpArticles",
		Method:   "GET",
		PathSpec: "/Content/SearchHelpArticles/{searchtext}/{size}/", PathParams: map[string]string{
			"searchtext": fmt.Sprint(req.Searchtext),
			"size":       fmt.Sprint(req.Size),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// ContentGetContentByIdRequest are the request parameters for operation Content.GetContentById
type ContentGetContentByIdRequest struct {

	// false
	Head bool

	// Required.
	Id Int64

	// Required.
	Locale string
}

// ContentGetContentById: Returns a content item referenced by id
//
// URL: /Content/GetContentById/{id}/{locale}/
//
// Operation: Content.GetContentById
func (a API) ContentGetContentById(ctx context.Context, req ContentGetContentByIdRequest) (*ServerResponse[ContentItemPublicContract], error) {
	//	{
	//	  "description": "Returns a content item referenced by id",
	//	  "operationId": "Content.GetContentById",
	//	  "parameters": [
	//	    {
	//	      "description": "false",
	//	      "in": "query",
	//	      "name": "head",
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "id",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "locale",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Content.ContentItemPublicContract"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Content"
	//	  ]
	//	}
	var resp ServerResponse[ContentItemPublicContract]
	err := a.client.Do(ctx, ClientRequest{Operation: "Content.GetContentById",
		Method:   "GET",
		PathSpec: "/Content/GetContentById/{id}/{locale}/", PathParams: map[string]string{
			"id":     fmt.Sprint(req.Id),
			"locale": fmt.Sprint(req.Locale),
		}, QueryParams: url.Values{
			"head": {fmt.Sprint(req.Head)},
		}}, &resp)
	return &resp, err
}

// GroupV2UnbanMemberRequest are the request parameters for operation GroupV2.UnbanMember
type GroupV2UnbanMemberRequest struct {

	// Required.
	GroupID Int64

	// Membership ID of the member to unban from the group
	// Required.
	MembershipID Int64

	// Membership type of the provided membership ID.
	// Required.
	MembershipType BungieMembershipType
}

// GroupV2UnbanMember: Unbans the requested member, allowing them to re-apply for membership.
//
// URL: /GroupV2/{groupId}/Members/{membershipType}/{membershipId}/Unban/
//
// Operation: GroupV2.UnbanMember
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2UnbanMember(ctx context.Context, req GroupV2UnbanMemberRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Unbans the requested member, allowing them to re-apply for membership.",
	//	  "operationId": "GroupV2.UnbanMember",
	//	  "parameters": [
	//	    {
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership ID of the member to unban from the group",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership type of the provided membership ID.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.UnbanMember",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/Unban/", PathParams: map[string]string{
			"groupId":        fmt.Sprint(req.GroupID),
			"membershipId":   fmt.Sprint(req.MembershipID),
			"membershipType": fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2KickMemberRequest are the request parameters for operation GroupV2.KickMember
type GroupV2KickMemberRequest struct {

	// Group ID to kick the user from.
	// Required.
	GroupID Int64

	// Membership ID to kick.
	// Required.
	MembershipID Int64

	// Membership type of the provided membership ID.
	// Required.
	MembershipType BungieMembershipType
}

// GroupV2KickMember: Kick a member from the given group, forcing them to reapply if they wish to
// re-join the group. You must have suitable permissions in the group to perform this operation.
//
// URL: /GroupV2/{groupId}/Members/{membershipType}/{membershipId}/Kick/
//
// Operation: GroupV2.KickMember
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2KickMember(ctx context.Context, req GroupV2KickMemberRequest) (*ServerResponse[GroupMemberLeaveResult], error) {
	//	{
	//	  "description": "Kick a member from the given group, forcing them to reapply if they wish to re-join the group. You must have suitable permissions in the group to perform this operation.",
	//	  "operationId": "GroupV2.KickMember",
	//	  "parameters": [
	//	    {
	//	      "description": "Group ID to kick the user from.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership ID to kick.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership type of the provided membership ID.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/GroupsV2.GroupMemberLeaveResult"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[GroupMemberLeaveResult]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.KickMember",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/Kick/", PathParams: map[string]string{
			"groupId":        fmt.Sprint(req.GroupID),
			"membershipId":   fmt.Sprint(req.MembershipID),
			"membershipType": fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2BanMemberRequest are the request parameters for operation GroupV2.BanMember
type GroupV2BanMemberRequest struct {

	// Group ID that has the member to ban.
	// Required.
	GroupID Int64

	// Membership ID of the member to ban from the group.
	// Required.
	MembershipID Int64

	// Membership type of the provided membership ID.
	// Required.
	MembershipType BungieMembershipType

	// Required.
	Body GroupBanRequestBody
}

// GroupV2BanMember: Bans the requested member from the requested group for the specified period of
// time.
//
// URL: /GroupV2/{groupId}/Members/{membershipType}/{membershipId}/Ban/
//
// Operation: GroupV2.BanMember
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2BanMember(ctx context.Context, req GroupV2BanMemberRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Bans the requested member from the requested group for the specified period of time.",
	//	  "operationId": "GroupV2.BanMember",
	//	  "parameters": [
	//	    {
	//	      "description": "Group ID that has the member to ban.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership ID of the member to ban from the group.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership type of the provided membership ID.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupBanRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.BanMember",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/Ban/", PathParams: map[string]string{
			"groupId":        fmt.Sprint(req.GroupID),
			"membershipId":   fmt.Sprint(req.MembershipID),
			"membershipType": fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// GroupV2IndividualGroupInviteCancelRequest are the request parameters for operation
// GroupV2.IndividualGroupInviteCancel
type GroupV2IndividualGroupInviteCancelRequest struct {

	// ID of the group you would like to join.
	// Required.
	GroupID Int64

	// Membership id of the account being cancelled.
	// Required.
	MembershipID Int64

	// MembershipType of the account being cancelled.
	// Required.
	MembershipType BungieMembershipType
}

// GroupV2IndividualGroupInviteCancel: Cancels a pending invitation to join a group.
//
// URL: /GroupV2/{groupId}/Members/IndividualInviteCancel/{membershipType}/{membershipId}/
//
// Operation: GroupV2.IndividualGroupInviteCancel
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2IndividualGroupInviteCancel(ctx context.Context, req GroupV2IndividualGroupInviteCancelRequest) (*ServerResponse[GroupApplicationResponse], error) {
	//	{
	//	  "description": "Cancels a pending invitation to join a group.",
	//	  "operationId": "GroupV2.IndividualGroupInviteCancel",
	//	  "parameters": [
	//	    {
	//	      "description": "ID of the group you would like to join.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership id of the account being cancelled.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "MembershipType of the account being cancelled.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/GroupsV2.GroupApplicationResponse"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[GroupApplicationResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.IndividualGroupInviteCancel",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/Members/IndividualInviteCancel/{membershipType}/{membershipId}/", PathParams: map[string]string{
			"groupId":        fmt.Sprint(req.GroupID),
			"membershipId":   fmt.Sprint(req.MembershipID),
			"membershipType": fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2IndividualGroupInviteRequest are the request parameters for operation
// GroupV2.IndividualGroupInvite
type GroupV2IndividualGroupInviteRequest struct {

	// ID of the group you would like to join.
	// Required.
	GroupID Int64

	// Membership id of the account being invited.
	// Required.
	MembershipID Int64

	// MembershipType of the account being invited.
	// Required.
	MembershipType BungieMembershipType

	// Required.
	Body GroupApplicationRequestBody
}

// GroupV2IndividualGroupInvite: Invite a user to join this group.
//
// URL: /GroupV2/{groupId}/Members/IndividualInvite/{membershipType}/{membershipId}/
//
// Operation: GroupV2.IndividualGroupInvite
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2IndividualGroupInvite(ctx context.Context, req GroupV2IndividualGroupInviteRequest) (*ServerResponse[GroupApplicationResponse], error) {
	//	{
	//	  "description": "Invite a user to join this group.",
	//	  "operationId": "GroupV2.IndividualGroupInvite",
	//	  "parameters": [
	//	    {
	//	      "description": "ID of the group you would like to join.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership id of the account being invited.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "MembershipType of the account being invited.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupApplicationRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/GroupsV2.GroupApplicationResponse"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[GroupApplicationResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.IndividualGroupInvite",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/Members/IndividualInvite/{membershipType}/{membershipId}/", PathParams: map[string]string{
			"groupId":        fmt.Sprint(req.GroupID),
			"membershipId":   fmt.Sprint(req.MembershipID),
			"membershipType": fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// GroupV2ApprovePendingRequest are the request parameters for operation GroupV2.ApprovePending
type GroupV2ApprovePendingRequest struct {

	// ID of the group.
	// Required.
	GroupID Int64

	// The membership id being approved.
	// Required.
	MembershipID Int64

	// Membership type of the supplied membership ID.
	// Required.
	MembershipType BungieMembershipType

	// Required.
	Body GroupApplicationRequestBody
}

// GroupV2ApprovePending: Approve the given membershipId to join the group/clan as long as they have
// applied.
//
// URL: /GroupV2/{groupId}/Members/Approve/{membershipType}/{membershipId}/
//
// Operation: GroupV2.ApprovePending
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2ApprovePending(ctx context.Context, req GroupV2ApprovePendingRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "Approve the given membershipId to join the group/clan as long as they have applied.",
	//	  "operationId": "GroupV2.ApprovePending",
	//	  "parameters": [
	//	    {
	//	      "description": "ID of the group.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The membership id being approved.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership type of the supplied membership ID.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupApplicationRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.ApprovePending",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/Members/Approve/{membershipType}/{membershipId}/", PathParams: map[string]string{
			"groupId":        fmt.Sprint(req.GroupID),
			"membershipId":   fmt.Sprint(req.MembershipID),
			"membershipType": fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// GroupV2AbdicateFoundershipRequest are the request parameters for operation
// GroupV2.AbdicateFoundership
type GroupV2AbdicateFoundershipRequest struct {

	// The new founder for this group. Must already be a group admin.
	// Required.
	FounderIdNew Int64

	// The target group id.
	// Required.
	GroupID Int64

	// Membership type of the provided founderIdNew.
	// Required.
	MembershipType BungieMembershipType
}

// GroupV2AbdicateFoundership: An administrative method to allow the founder of a group or clan to give
// up their position to another admin permanently.
//
// URL: /GroupV2/{groupId}/Admin/AbdicateFoundership/{membershipType}/{founderIdNew}/
//
// Operation: GroupV2.AbdicateFoundership
func (a API) GroupV2AbdicateFoundership(ctx context.Context, req GroupV2AbdicateFoundershipRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "An administrative method to allow the founder of a group or clan to give up their position to another admin permanently.",
	//	  "operationId": "GroupV2.AbdicateFoundership",
	//	  "parameters": [
	//	    {
	//	      "description": "The new founder for this group. Must already be a group admin.",
	//	      "in": "path",
	//	      "name": "founderIdNew",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The target group id.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership type of the provided founderIdNew.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.AbdicateFoundership",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/Admin/AbdicateFoundership/{membershipType}/{founderIdNew}/", PathParams: map[string]string{
			"founderIdNew":   fmt.Sprint(req.FounderIdNew),
			"groupId":        fmt.Sprint(req.GroupID),
			"membershipType": fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2RecoverGroupForFounderRequest are the request parameters for operation
// GroupV2.RecoverGroupForFounder
type GroupV2RecoverGroupForFounderRequest struct {

	// Type of group the supplied member founded.
	// Required.
	GroupType GroupType

	// Membership ID to for which to find founded groups.
	// Required.
	MembershipID Int64

	// Membership type of the supplied membership ID.
	// Required.
	MembershipType BungieMembershipType
}

// GroupV2RecoverGroupForFounder: Allows a founder to manually recover a group they can see in game but
// not on bungie.net
//
// URL: /GroupV2/Recover/{membershipType}/{membershipId}/{groupType}/
//
// Operation: GroupV2.RecoverGroupForFounder
func (a API) GroupV2RecoverGroupForFounder(ctx context.Context, req GroupV2RecoverGroupForFounderRequest) (*ServerResponse[GroupMembershipSearchResponse], error) {
	//	{
	//	  "description": "Allows a founder to manually recover a group they can see in game but not on bungie.net",
	//	  "operationId": "GroupV2.RecoverGroupForFounder",
	//	  "parameters": [
	//	    {
	//	      "description": "Type of group the supplied member founded.",
	//	      "in": "path",
	//	      "name": "groupType",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership ID to for which to find founded groups.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership type of the supplied membership ID.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/GroupsV2.GroupMembershipSearchResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[GroupMembershipSearchResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.RecoverGroupForFounder",
		Method:   "GET",
		PathSpec: "/GroupV2/Recover/{membershipType}/{membershipId}/{groupType}/", PathParams: map[string]string{
			"groupType":      fmt.Sprint(req.GroupType),
			"membershipId":   fmt.Sprint(req.MembershipID),
			"membershipType": fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// FireteamFinderSearchListingsByFiltersRequest are the request parameters for operation
// FireteamFinder.SearchListingsByFilters
type FireteamFinderSearchListingsByFiltersRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// Optional boolean to bypass the offline-only check, so the client can pull fireteam from the game.
	OverrideOfflineFilter bool

	// Required.
	Body FireteamFinderSearchListingsByFiltersRequestBody
}

// FireteamFinderSearchListingsByFilters: Returns search results for available Fireteams provided
// search filters.
//
// URL: /FireteamFinder/Search/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.SearchListingsByFilters
func (a API) FireteamFinderSearchListingsByFilters(ctx context.Context, req FireteamFinderSearchListingsByFiltersRequest) (*ServerResponse[FireteamFinderSearchListingsByFiltersResponse], error) {
	//	{
	//	  "description": "Returns search results for available Fireteams provided search filters.",
	//	  "operationId": "FireteamFinder.SearchListingsByFilters",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Optional boolean to bypass the offline-only check, so the client can pull fireteam from the game.",
	//	      "in": "query",
	//	      "name": "overrideOfflineFilter",
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderSearchListingsByFiltersRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderSearchListingsByFiltersResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderSearchListingsByFiltersResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.SearchListingsByFilters",
		Method:   "POST",
		PathSpec: "/FireteamFinder/Search/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
		}, QueryParams: url.Values{
			"overrideOfflineFilter": {fmt.Sprint(req.OverrideOfflineFilter)},
		}, Body: req.Body}, &resp)
	return &resp, err
}

// FireteamFinderSearchListingsByClanRequest are the request parameters for operation
// FireteamFinder.SearchListingsByClan
type FireteamFinderSearchListingsByClanRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// Required.
	Body FireteamFinderSearchListingsByClanRequestBody
}

// FireteamFinderSearchListingsByClan: Returns search results for available Fireteams provided a clan.
//
// URL: /FireteamFinder/Search/Clan/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.SearchListingsByClan
func (a API) FireteamFinderSearchListingsByClan(ctx context.Context, req FireteamFinderSearchListingsByClanRequest) (*ServerResponse[FireteamFinderSearchListingsByClanResponse], error) {
	//	{
	//	  "description": "Returns search results for available Fireteams provided a clan.",
	//	  "operationId": "FireteamFinder.SearchListingsByClan",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderSearchListingsByClanRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderSearchListingsByClanResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderSearchListingsByClanResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.SearchListingsByClan",
		Method:   "POST",
		PathSpec: "/FireteamFinder/Search/Clan/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// FireteamFinderGetPlayerOffersRequest are the request parameters for operation
// FireteamFinder.GetPlayerOffers
type FireteamFinderGetPlayerOffersRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// An optional token from a previous response to fetch the next page of results.
	NextPageToken string

	// The maximum number of results to be returned with this page.
	PageSize int32
}

// FireteamFinderGetPlayerOffers: Retrieves Fireteam offers that this player has recieved.
//
// URL:
// /FireteamFinder/PlayerOffers/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.GetPlayerOffers
func (a API) FireteamFinderGetPlayerOffers(ctx context.Context, req FireteamFinderGetPlayerOffersRequest) (*ServerResponse[FireteamFinderGetPlayerOffersResponse], error) {
	//	{
	//	  "description": "Retrieves Fireteam offers that this player has recieved.",
	//	  "operationId": "FireteamFinder.GetPlayerOffers",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "An optional token from a previous response to fetch the next page of results.",
	//	      "in": "query",
	//	      "name": "nextPageToken",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "The maximum number of results to be returned with this page.",
	//	      "in": "query",
	//	      "name": "pageSize",
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderGetPlayerOffersResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderGetPlayerOffersResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.GetPlayerOffers",
		Method:   "GET",
		PathSpec: "/FireteamFinder/PlayerOffers/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
		}, QueryParams: url.Values{
			"nextPageToken": {fmt.Sprint(req.NextPageToken)},
			"pageSize":      {fmt.Sprint(req.PageSize)},
		}}, &resp)
	return &resp, err
}

// FireteamFinderGetPlayerLobbiesRequest are the request parameters for operation
// FireteamFinder.GetPlayerLobbies
type FireteamFinderGetPlayerLobbiesRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// An optional token from a previous response to fetch the next page of results.
	NextPageToken string

	// The maximum number of results to be returned with this page.
	PageSize int32
}

// FireteamFinderGetPlayerLobbies: Retrieves the information for a Fireteam lobby.
//
// URL:
// /FireteamFinder/PlayerLobbies/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.GetPlayerLobbies
func (a API) FireteamFinderGetPlayerLobbies(ctx context.Context, req FireteamFinderGetPlayerLobbiesRequest) (*ServerResponse[FireteamFinderGetPlayerLobbiesResponse], error) {
	//	{
	//	  "description": "Retrieves the information for a Fireteam lobby.",
	//	  "operationId": "FireteamFinder.GetPlayerLobbies",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "An optional token from a previous response to fetch the next page of results.",
	//	      "in": "query",
	//	      "name": "nextPageToken",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "The maximum number of results to be returned with this page.",
	//	      "in": "query",
	//	      "name": "pageSize",
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderGetPlayerLobbiesResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderGetPlayerLobbiesResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.GetPlayerLobbies",
		Method:   "GET",
		PathSpec: "/FireteamFinder/PlayerLobbies/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
		}, QueryParams: url.Values{
			"nextPageToken": {fmt.Sprint(req.NextPageToken)},
			"pageSize":      {fmt.Sprint(req.PageSize)},
		}}, &resp)
	return &resp, err
}

// FireteamFinderGetPlayerApplicationsRequest are the request parameters for operation
// FireteamFinder.GetPlayerApplications
type FireteamFinderGetPlayerApplicationsRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// An optional token from a previous response to fetch the next page of results.
	NextPageToken string

	// The maximum number of results to be returned with this page.
	PageSize int32
}

// FireteamFinderGetPlayerApplications: Retrieves Fireteam applications that this player has sent or
// recieved.
//
// URL:
// /FireteamFinder/PlayerApplications/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.GetPlayerApplications
func (a API) FireteamFinderGetPlayerApplications(ctx context.Context, req FireteamFinderGetPlayerApplicationsRequest) (*ServerResponse[FireteamFinderGetPlayerApplicationsResponse], error) {
	//	{
	//	  "description": "Retrieves Fireteam applications that this player has sent or recieved.",
	//	  "operationId": "FireteamFinder.GetPlayerApplications",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "An optional token from a previous response to fetch the next page of results.",
	//	      "in": "query",
	//	      "name": "nextPageToken",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "The maximum number of results to be returned with this page.",
	//	      "in": "query",
	//	      "name": "pageSize",
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderGetPlayerApplicationsResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderGetPlayerApplicationsResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.GetPlayerApplications",
		Method:   "GET",
		PathSpec: "/FireteamFinder/PlayerApplications/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
		}, QueryParams: url.Values{
			"nextPageToken": {fmt.Sprint(req.NextPageToken)},
			"pageSize":      {fmt.Sprint(req.PageSize)},
		}}, &resp)
	return &resp, err
}

// FireteamFinderJoinLobbyRequest are the request parameters for operation FireteamFinder.JoinLobby
type FireteamFinderJoinLobbyRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// Required.
	Body FireteamFinderJoinLobbyRequestBody
}

// FireteamFinderJoinLobby: Sends a request to join an available Fireteam lobby.
//
// URL: /FireteamFinder/Lobby/Join/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.JoinLobby
func (a API) FireteamFinderJoinLobby(ctx context.Context, req FireteamFinderJoinLobbyRequest) (*ServerResponse[FireteamFinderLobbyResponse], error) {
	//	{
	//	  "description": "Sends a request to join an available Fireteam lobby.",
	//	  "operationId": "FireteamFinder.JoinLobby",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderJoinLobbyRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderLobbyResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderLobbyResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.JoinLobby",
		Method:   "POST",
		PathSpec: "/FireteamFinder/Lobby/Join/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// FireteamFinderHostLobbyRequest are the request parameters for operation FireteamFinder.HostLobby
type FireteamFinderHostLobbyRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// Required.
	Body FireteamFinderHostLobbyRequestBody
}

// FireteamFinderHostLobby: Creates a new Fireteam lobby and Fireteam Finder listing.
//
// URL: /FireteamFinder/Lobby/Host/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.HostLobby
func (a API) FireteamFinderHostLobby(ctx context.Context, req FireteamFinderHostLobbyRequest) (*ServerResponse[FireteamFinderHostLobbyResponse], error) {
	//	{
	//	  "description": "Creates a new Fireteam lobby and Fireteam Finder listing.",
	//	  "operationId": "FireteamFinder.HostLobby",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderHostLobbyRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderHostLobbyResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderHostLobbyResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.HostLobby",
		Method:   "POST",
		PathSpec: "/FireteamFinder/Lobby/Host/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// FireteamFinderBulkGetListingStatusRequest are the request parameters for operation
// FireteamFinder.BulkGetListingStatus
type FireteamFinderBulkGetListingStatusRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// Required.
	Body FireteamFinderBulkGetListingStatusRequestBody
}

// FireteamFinderBulkGetListingStatus: Retrieves Fireteam listing statuses in bulk.
//
// URL:
// /FireteamFinder/Listing/BulkStatus/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.BulkGetListingStatus
func (a API) FireteamFinderBulkGetListingStatus(ctx context.Context, req FireteamFinderBulkGetListingStatusRequest) (*ServerResponse[FireteamFinderBulkGetListingStatusResponse], error) {
	//	{
	//	  "description": "Retrieves Fireteam listing statuses in bulk.",
	//	  "operationId": "FireteamFinder.BulkGetListingStatus",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderBulkGetListingStatusRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderBulkGetListingStatusResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderBulkGetListingStatusResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.BulkGetListingStatus",
		Method:   "POST",
		PathSpec: "/FireteamFinder/Listing/BulkStatus/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// FireteamFinderGetCharacterActivityAccessRequest are the request parameters for operation
// FireteamFinder.GetCharacterActivityAccess
type FireteamFinderGetCharacterActivityAccessRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType
}

// FireteamFinderGetCharacterActivityAccess: Retrieves the information for a Fireteam lobby.
//
// URL:
// /FireteamFinder/CharacterActivityAccess/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.GetCharacterActivityAccess
func (a API) FireteamFinderGetCharacterActivityAccess(ctx context.Context, req FireteamFinderGetCharacterActivityAccessRequest) (*ServerResponse[FireteamFinderGetCharacterActivityAccessResponse], error) {
	//	{
	//	  "description": "Retrieves the information for a Fireteam lobby.",
	//	  "operationId": "FireteamFinder.GetCharacterActivityAccess",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderGetCharacterActivityAccessResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderGetCharacterActivityAccessResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.GetCharacterActivityAccess",
		Method:   "GET",
		PathSpec: "/FireteamFinder/CharacterActivityAccess/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// Destiny2GetItemRequest are the request parameters for operation Destiny2.GetItem
type Destiny2GetItemRequest struct {

	// A comma separated list of components to return (as strings or numeric values). See the
	// DestinyComponentType enum for valid components to request. You must request at least one component
	// to receive results.
	Components []ComponentType

	// The membership ID of the destiny profile.
	// Required.
	DestinyMembershipID Int64

	// The Instance ID of the destiny item.
	// Required.
	ItemInstanceID Int64

	// A valid non-BungieNet membership type.
	// Required.
	MembershipType BungieMembershipType
}

// Destiny2GetItem: Retrieve the details of an instanced Destiny Item. An instanced Destiny item is one
// with an ItemInstanceId. Non-instanced items, such as materials, have no useful instance-specific
// details and thus are not queryable here.
//
// URL: /Destiny2/{membershipType}/Profile/{destinyMembershipId}/Item/{itemInstanceId}/
//
// Operation: Destiny2.GetItem
func (a API) Destiny2GetItem(ctx context.Context, req Destiny2GetItemRequest) (*ServerResponse[ItemResponse], error) {
	//	{
	//	  "description": "Retrieve the details of an instanced Destiny Item. An instanced Destiny item is one with an ItemInstanceId. Non-instanced items, such as materials, have no useful instance-specific details and thus are not queryable here.",
	//	  "operationId": "Destiny2.GetItem",
	//	  "parameters": [
	//	    {
	//	      "description": "A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results.",
	//	      "in": "query",
	//	      "name": "components",
	//	      "schema": {
	//	        "items": {
	//	          "description": "Represents the possible components that can be returned from Destiny \"Get\" calls such as GetProfile, GetCharacter, GetVendor etc...\r\nWhen making one of these requests, you will pass one or more of these components as a comma separated list in the \"?components=\" querystring parameter. For instance, if you want baseline Profile data, Character Data, and character progressions, you would pass \"?components=Profiles,Characters,CharacterProgressions\" You may use either the numerical or string values.",
	//	          "format": "int32",
	//	          "type": "integer",
	//	          "x-enum-is-bitmask": false,
	//	          "x-enum-reference": {
	//	            "$ref": "#/components/schemas/Destiny.DestinyComponentType"
	//	          }
	//	        },
	//	        "type": "array"
	//	      }
	//	    },
	//	    {
	//	      "description": "The membership ID of the destiny profile.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The Instance ID of the destiny item.",
	//	      "in": "path",
	//	      "name": "itemInstanceId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid non-BungieNet membership type.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Responses.DestinyItemResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[ItemResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetItem",
		Method:   "GET",
		PathSpec: "/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Item/{itemInstanceId}/", PathParams: map[string]string{
			"destinyMembershipId": fmt.Sprint(req.DestinyMembershipID),
			"itemInstanceId":      fmt.Sprint(req.ItemInstanceID),
			"membershipType":      fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{
			"components": {joinArray(req.Components)},
		}}, &resp)
	return &resp, err
}

// Destiny2GetVendorsRequest are the request parameters for operation Destiny2.GetVendors
type Destiny2GetVendorsRequest struct {

	// The Destiny Character ID of the character for whom we're getting vendor info.
	// Required.
	CharacterID Int64

	// A comma separated list of components to return (as strings or numeric values). See the
	// DestinyComponentType enum for valid components to request. You must request at least one component
	// to receive results.
	Components []ComponentType

	// Destiny membership ID of another user. You may be denied.
	// Required.
	DestinyMembershipID Int64

	// The filter of what vendors and items to return, if any.
	Filter VendorFilter

	// A valid non-BungieNet membership type.
	// Required.
	MembershipType BungieMembershipType
}

// Destiny2GetVendors: Get currently available vendors from the list of vendors that can possibly have
// rotating inventory. Note that this does not include things like preview vendors and
// vendors-as-kiosks, neither of whom have rotating/dynamic inventories. Use their definitions as-is
// for those.
//
// URL: /Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Vendors/
//
// Operation: Destiny2.GetVendors
func (a API) Destiny2GetVendors(ctx context.Context, req Destiny2GetVendorsRequest) (*ServerResponse[VendorsResponse], error) {
	//	{
	//	  "description": "Get currently available vendors from the list of vendors that can possibly have rotating inventory. Note that this does not include things like preview vendors and vendors-as-kiosks, neither of whom have rotating/dynamic inventories. Use their definitions as-is for those.",
	//	  "operationId": "Destiny2.GetVendors",
	//	  "parameters": [
	//	    {
	//	      "description": "The Destiny Character ID of the character for whom we're getting vendor info.",
	//	      "in": "path",
	//	      "name": "characterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results.",
	//	      "in": "query",
	//	      "name": "components",
	//	      "schema": {
	//	        "items": {
	//	          "description": "Represents the possible components that can be returned from Destiny \"Get\" calls such as GetProfile, GetCharacter, GetVendor etc...\r\nWhen making one of these requests, you will pass one or more of these components as a comma separated list in the \"?components=\" querystring parameter. For instance, if you want baseline Profile data, Character Data, and character progressions, you would pass \"?components=Profiles,Characters,CharacterProgressions\" You may use either the numerical or string values.",
	//	          "format": "int32",
	//	          "type": "integer",
	//	          "x-enum-is-bitmask": false,
	//	          "x-enum-reference": {
	//	            "$ref": "#/components/schemas/Destiny.DestinyComponentType"
	//	          }
	//	        },
	//	        "type": "array"
	//	      }
	//	    },
	//	    {
	//	      "description": "Destiny membership ID of another user. You may be denied.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The filter of what vendors and items to return, if any.",
	//	      "in": "query",
	//	      "name": "filter",
	//	      "schema": {
	//	        "description": "Indicates the type of filter to apply to Vendor results.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Destiny.DestinyVendorFilter"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid non-BungieNet membership type.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Responses.DestinyVendorsResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[VendorsResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetVendors",
		Method:   "GET",
		PathSpec: "/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Vendors/", PathParams: map[string]string{
			"characterId":         fmt.Sprint(req.CharacterID),
			"destinyMembershipId": fmt.Sprint(req.DestinyMembershipID),
			"membershipType":      fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{
			"components": {joinArray(req.Components)},
			"filter":     {fmt.Sprint(req.Filter)},
		}}, &resp)
	return &resp, err
}

// Destiny2GetCharacterRequest are the request parameters for operation Destiny2.GetCharacter
type Destiny2GetCharacterRequest struct {

	// ID of the character.
	// Required.
	CharacterID Int64

	// A comma separated list of components to return (as strings or numeric values). See the
	// DestinyComponentType enum for valid components to request. You must request at least one component
	// to receive results.
	Components []ComponentType

	// Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid non-BungieNet membership type.
	// Required.
	MembershipType BungieMembershipType
}

// Destiny2GetCharacter: Returns character information for the supplied character.
//
// URL: /Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/
//
// Operation: Destiny2.GetCharacter
func (a API) Destiny2GetCharacter(ctx context.Context, req Destiny2GetCharacterRequest) (*ServerResponse[CharacterResponse], error) {
	//	{
	//	  "description": "Returns character information for the supplied character.",
	//	  "operationId": "Destiny2.GetCharacter",
	//	  "parameters": [
	//	    {
	//	      "description": "ID of the character.",
	//	      "in": "path",
	//	      "name": "characterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results.",
	//	      "in": "query",
	//	      "name": "components",
	//	      "schema": {
	//	        "items": {
	//	          "description": "Represents the possible components that can be returned from Destiny \"Get\" calls such as GetProfile, GetCharacter, GetVendor etc...\r\nWhen making one of these requests, you will pass one or more of these components as a comma separated list in the \"?components=\" querystring parameter. For instance, if you want baseline Profile data, Character Data, and character progressions, you would pass \"?components=Profiles,Characters,CharacterProgressions\" You may use either the numerical or string values.",
	//	          "format": "int32",
	//	          "type": "integer",
	//	          "x-enum-is-bitmask": false,
	//	          "x-enum-reference": {
	//	            "$ref": "#/components/schemas/Destiny.DestinyComponentType"
	//	          }
	//	        },
	//	        "type": "array"
	//	      }
	//	    },
	//	    {
	//	      "description": "Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid non-BungieNet membership type.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Responses.DestinyCharacterResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[CharacterResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetCharacter",
		Method:   "GET",
		PathSpec: "/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/", PathParams: map[string]string{
			"characterId":         fmt.Sprint(req.CharacterID),
			"destinyMembershipId": fmt.Sprint(req.DestinyMembershipID),
			"membershipType":      fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{
			"components": {joinArray(req.Components)},
		}}, &resp)
	return &resp, err
}

// Destiny2GetUniqueWeaponHistoryRequest are the request parameters for operation
// Destiny2.GetUniqueWeaponHistory
type Destiny2GetUniqueWeaponHistoryRequest struct {

	// The id of the character to retrieve.
	// Required.
	CharacterID Int64

	// The Destiny membershipId of the user to retrieve.
	// Required.
	DestinyMembershipID Int64

	// A valid non-BungieNet membership type.
	// Required.
	MembershipType BungieMembershipType
}

// Destiny2GetUniqueWeaponHistory: Gets details about unique weapon usage, including all exotic
// weapons.
//
// URL:
// /Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/UniqueWeapons/
//
// Operation: Destiny2.GetUniqueWeaponHistory
func (a API) Destiny2GetUniqueWeaponHistory(ctx context.Context, req Destiny2GetUniqueWeaponHistoryRequest) (*ServerResponse[HistoricalWeaponStatsData], error) {
	//	{
	//	  "description": "Gets details about unique weapon usage, including all exotic weapons.",
	//	  "operationId": "Destiny2.GetUniqueWeaponHistory",
	//	  "parameters": [
	//	    {
	//	      "description": "The id of the character to retrieve.",
	//	      "in": "path",
	//	      "name": "characterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The Destiny membershipId of the user to retrieve.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid non-BungieNet membership type.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.HistoricalStats.DestinyHistoricalWeaponStatsData"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[HistoricalWeaponStatsData]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetUniqueWeaponHistory",
		Method:   "GET",
		PathSpec: "/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/UniqueWeapons/", PathParams: map[string]string{
			"characterId":         fmt.Sprint(req.CharacterID),
			"destinyMembershipId": fmt.Sprint(req.DestinyMembershipID),
			"membershipType":      fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// Destiny2GetDestinyAggregateActivityStatsRequest are the request parameters for operation
// Destiny2.GetDestinyAggregateActivityStats
type Destiny2GetDestinyAggregateActivityStatsRequest struct {

	// The specific character whose activities should be returned.
	// Required.
	CharacterID Int64

	// The Destiny membershipId of the user to retrieve.
	// Required.
	DestinyMembershipID Int64

	// A valid non-BungieNet membership type.
	// Required.
	MembershipType BungieMembershipType
}

// Destiny2GetDestinyAggregateActivityStats: Gets all activities the character has participated in
// together with aggregate statistics for those activities.
//
// URL:
// /Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/AggregateActivityStats/
//
// Operation: Destiny2.GetDestinyAggregateActivityStats
func (a API) Destiny2GetDestinyAggregateActivityStats(ctx context.Context, req Destiny2GetDestinyAggregateActivityStatsRequest) (*ServerResponse[AggregateActivityResults], error) {
	//	{
	//	  "description": "Gets all activities the character has participated in together with aggregate statistics for those activities.",
	//	  "operationId": "Destiny2.GetDestinyAggregateActivityStats",
	//	  "parameters": [
	//	    {
	//	      "description": "The specific character whose activities should be returned.",
	//	      "in": "path",
	//	      "name": "characterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The Destiny membershipId of the user to retrieve.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid non-BungieNet membership type.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.HistoricalStats.DestinyAggregateActivityResults"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[AggregateActivityResults]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetDestinyAggregateActivityStats",
		Method:   "GET",
		PathSpec: "/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/AggregateActivityStats/", PathParams: map[string]string{
			"characterId":         fmt.Sprint(req.CharacterID),
			"destinyMembershipId": fmt.Sprint(req.DestinyMembershipID),
			"membershipType":      fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// Destiny2GetActivityHistoryRequest are the request parameters for operation
// Destiny2.GetActivityHistory
type Destiny2GetActivityHistoryRequest struct {

	// The id of the character to retrieve.
	// Required.
	CharacterID Int64

	// Number of rows to return
	Count int32

	// The Destiny membershipId of the user to retrieve.
	// Required.
	DestinyMembershipID Int64

	// A valid non-BungieNet membership type.
	// Required.
	MembershipType BungieMembershipType

	// A filter for the activity mode to be returned. None returns all activities. See the documentation
	// for DestinyActivityModeType for valid values, and pass in string representation.
	Mode ActivityModeType

	// Page number to return, starting with 0.
	Page int32
}

// Destiny2GetActivityHistory: Gets activity history stats for indicated character.
//
// URL:
// /Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/Activities/
//
// Operation: Destiny2.GetActivityHistory
func (a API) Destiny2GetActivityHistory(ctx context.Context, req Destiny2GetActivityHistoryRequest) (*ServerResponse[ActivityHistoryResults], error) {
	//	{
	//	  "description": "Gets activity history stats for indicated character.",
	//	  "operationId": "Destiny2.GetActivityHistory",
	//	  "parameters": [
	//	    {
	//	      "description": "The id of the character to retrieve.",
	//	      "in": "path",
	//	      "name": "characterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Number of rows to return",
	//	      "in": "query",
	//	      "name": "count",
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The Destiny membershipId of the user to retrieve.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid non-BungieNet membership type.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation.",
	//	      "in": "query",
	//	      "name": "mode",
	//	      "schema": {
	//	        "description": "For historical reasons, this list will have both D1 and D2-relevant Activity Modes in it. Please don't take this to mean that some D1-only feature is coming back!",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.DestinyActivityModeType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Page number to return, starting with 0.",
	//	      "in": "query",
	//	      "name": "page",
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.HistoricalStats.DestinyActivityHistoryResults"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[ActivityHistoryResults]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetActivityHistory",
		Method:   "GET",
		PathSpec: "/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/Activities/", PathParams: map[string]string{
			"characterId":         fmt.Sprint(req.CharacterID),
			"destinyMembershipId": fmt.Sprint(req.DestinyMembershipID),
			"membershipType":      fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{
			"count": {fmt.Sprint(req.Count)},
			"mode":  {fmt.Sprint(req.Mode)},
			"page":  {fmt.Sprint(req.Page)},
		}}, &resp)
	return &resp, err
}

// Destiny2GetHistoricalStatsRequest are the request parameters for operation
// Destiny2.GetHistoricalStats
type Destiny2GetHistoricalStatsRequest struct {

	// The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate
	// stats across all characters.
	// Required.
	CharacterID Int64

	// Last day to return when daily stats are requested. Use the format YYYY-MM-DD. Currently, we cannot
	// allow more than 31 days of daily data to be requested in a single request.
	Dayend Timestamp

	// First day to return when daily stats are requested. Use the format YYYY-MM-DD. Currently, we cannot
	// allow more than 31 days of daily data to be requested in a single request.
	Daystart Timestamp

	// The Destiny membershipId of the user to retrieve.
	// Required.
	DestinyMembershipID Int64

	// Group of stats to include, otherwise only general stats are returned. Comma separated list is
	// allowed. Values: General, Weapons, Medals
	Groups []StatsGroupType

	// A valid non-BungieNet membership type.
	// Required.
	MembershipType BungieMembershipType

	// Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass
	// in string representation, comma delimited.
	Modes []ActivityModeType

	// Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity
	PeriodType PeriodType
}

// Destiny2GetHistoricalStats: Gets historical stats for indicated character.
//
// URL: /Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/
//
// Operation: Destiny2.GetHistoricalStats
func (a API) Destiny2GetHistoricalStats(ctx context.Context, req Destiny2GetHistoricalStatsRequest) (*ServerResponse[map[string]HistoricalStatsByPeriod], error) {
	//	{
	//	  "description": "Gets historical stats for indicated character.",
	//	  "operationId": "Destiny2.GetHistoricalStats",
	//	  "parameters": [
	//	    {
	//	      "description": "The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters.",
	//	      "in": "path",
	//	      "name": "characterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Last day to return when daily stats are requested. Use the format YYYY-MM-DD. Currently, we cannot allow more than 31 days of daily data to be requested in a single request.",
	//	      "in": "query",
	//	      "name": "dayend",
	//	      "schema": {
	//	        "format": "date-time",
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "First day to return when daily stats are requested. Use the format YYYY-MM-DD. Currently, we cannot allow more than 31 days of daily data to be requested in a single request.",
	//	      "in": "query",
	//	      "name": "daystart",
	//	      "schema": {
	//	        "format": "date-time",
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "The Destiny membershipId of the user to retrieve.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals",
	//	      "in": "query",
	//	      "name": "groups",
	//	      "schema": {
	//	        "items": {
	//	          "description": "If the enum value is \u003e 100, it is a \"special\" group that cannot be queried for directly (special cases apply to when they are returned, and are not relevant in general cases)",
	//	          "format": "int32",
	//	          "type": "integer",
	//	          "x-enum-is-bitmask": false,
	//	          "x-enum-reference": {
	//	            "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.DestinyStatsGroupType"
	//	          }
	//	        },
	//	        "type": "array"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid non-BungieNet membership type.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited.",
	//	      "in": "query",
	//	      "name": "modes",
	//	      "schema": {
	//	        "items": {
	//	          "description": "For historical reasons, this list will have both D1 and D2-relevant Activity Modes in it. Please don't take this to mean that some D1-only feature is coming back!",
	//	          "format": "int32",
	//	          "type": "integer",
	//	          "x-enum-is-bitmask": false,
	//	          "x-enum-reference": {
	//	            "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.DestinyActivityModeType"
	//	          }
	//	        },
	//	        "type": "array"
	//	      }
	//	    },
	//	    {
	//	      "description": "Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity",
	//	      "in": "query",
	//	      "name": "periodType",
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.PeriodType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.HistoricalStats.DestinyHistoricalStatsResults"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[map[string]HistoricalStatsByPeriod]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetHistoricalStats",
		Method:   "GET",
		PathSpec: "/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/", PathParams: map[string]string{
			"characterId":         fmt.Sprint(req.CharacterID),
			"destinyMembershipId": fmt.Sprint(req.DestinyMembershipID),
			"membershipType":      fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{
			"dayend":     {fmt.Sprint(req.Dayend)},
			"daystart":   {fmt.Sprint(req.Daystart)},
			"groups":     {joinArray(req.Groups)},
			"modes":      {joinArray(req.Modes)},
			"periodType": {fmt.Sprint(req.PeriodType)},
		}}, &resp)
	return &resp, err
}

// Destiny2GetLeaderboardsForCharacterRequest are the request parameters for operation
// Destiny2.GetLeaderboardsForCharacter
type Destiny2GetLeaderboardsForCharacterRequest struct {

	// The specific character to build the leaderboard around for the provided Destiny Membership.
	// Required.
	CharacterID Int64

	// The Destiny membershipId of the user to retrieve.
	// Required.
	DestinyMembershipID Int64

	// Maximum number of top players to return. Use a large number to get entire leaderboard.
	Maxtop int32

	// A valid non-BungieNet membership type.
	// Required.
	MembershipType BungieMembershipType

	// List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType
	// for valid values, and pass in string representation, comma delimited.
	Modes string

	// ID of stat to return rather than returning all Leaderboard stats.
	Statid string
}

// Destiny2GetLeaderboardsForCharacter: Gets leaderboards with the signed in user's friends and the
// supplied destinyMembershipId as the focus. PREVIEW: This endpoint is still in beta, and may
// experience rough edges. The schema is in final form, but there may be bugs that prevent desirable
// operation.
//
// URL: /Destiny2/Stats/Leaderboards/{membershipType}/{destinyMembershipId}/{characterId}/
//
// Operation: Destiny2.GetLeaderboardsForCharacter
func (a API) Destiny2GetLeaderboardsForCharacter(ctx context.Context, req Destiny2GetLeaderboardsForCharacterRequest) (*ServerResponse[map[string]map[string]Leaderboard], error) {
	//	{
	//	  "description": "Gets leaderboards with the signed in user's friends and the supplied destinyMembershipId as the focus. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is in final form, but there may be bugs that prevent desirable operation.",
	//	  "operationId": "Destiny2.GetLeaderboardsForCharacter",
	//	  "parameters": [
	//	    {
	//	      "description": "The specific character to build the leaderboard around for the provided Destiny Membership.",
	//	      "in": "path",
	//	      "name": "characterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The Destiny membershipId of the user to retrieve.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Maximum number of top players to return. Use a large number to get entire leaderboard.",
	//	      "in": "query",
	//	      "name": "maxtop",
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid non-BungieNet membership type.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited.",
	//	      "in": "query",
	//	      "name": "modes",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "ID of stat to return rather than returning all Leaderboard stats.",
	//	      "in": "query",
	//	      "name": "statid",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.HistoricalStats.DestinyLeaderboardResults"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2",
	//	    "Preview"
	//	  ],
	//	  "x-preview": true
	//	}
	var resp ServerResponse[map[string]map[string]Leaderboard]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetLeaderboardsForCharacter",
		Method:   "GET",
		PathSpec: "/Destiny2/Stats/Leaderboards/{membershipType}/{destinyMembershipId}/{characterId}/", PathParams: map[string]string{
			"characterId":         fmt.Sprint(req.CharacterID),
			"destinyMembershipId": fmt.Sprint(req.DestinyMembershipID),
			"membershipType":      fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{
			"maxtop": {fmt.Sprint(req.Maxtop)},
			"modes":  {fmt.Sprint(req.Modes)},
			"statid": {fmt.Sprint(req.Statid)},
		}}, &resp)
	return &resp, err
}

// ContentSearchContentByTagAndTypeRequest are the request parameters for operation
// Content.SearchContentByTagAndType
type ContentSearchContentByTagAndTypeRequest struct {

	// Page number for the search results starting with page 1.
	Currentpage int32

	// Not used.
	Head bool

	// Not used.
	Itemsperpage int32

	// Required.
	Locale string

	// Required.
	Tag string

	// Required.
	Type string
}

// ContentSearchContentByTagAndType: Searches for Content Items that match the given Tag and Content
// Type.
//
// URL: /Content/SearchContentByTagAndType/{tag}/{type}/{locale}/
//
// Operation: Content.SearchContentByTagAndType
func (a API) ContentSearchContentByTagAndType(ctx context.Context, req ContentSearchContentByTagAndTypeRequest) (*ServerResponse[SearchResult[ContentItemPublicContract]], error) {
	//	{
	//	  "description": "Searches for Content Items that match the given Tag and Content Type.",
	//	  "operationId": "Content.SearchContentByTagAndType",
	//	  "parameters": [
	//	    {
	//	      "description": "Page number for the search results starting with page 1.",
	//	      "in": "query",
	//	      "name": "currentpage",
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Not used.",
	//	      "in": "query",
	//	      "name": "head",
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    },
	//	    {
	//	      "description": "Not used.",
	//	      "in": "query",
	//	      "name": "itemsperpage",
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "locale",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "tag",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "type",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/SearchResultOfContentItemPublicContract"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Content"
	//	  ]
	//	}
	var resp ServerResponse[SearchResult[ContentItemPublicContract]]
	err := a.client.Do(ctx, ClientRequest{Operation: "Content.SearchContentByTagAndType",
		Method:   "GET",
		PathSpec: "/Content/SearchContentByTagAndType/{tag}/{type}/{locale}/", PathParams: map[string]string{
			"locale": fmt.Sprint(req.Locale),
			"tag":    fmt.Sprint(req.Tag),
			"type":   fmt.Sprint(req.Type),
		}, QueryParams: url.Values{
			"currentpage":  {fmt.Sprint(req.Currentpage)},
			"head":         {fmt.Sprint(req.Head)},
			"itemsperpage": {fmt.Sprint(req.Itemsperpage)},
		}}, &resp)
	return &resp, err
}

// ContentGetContentByTagAndTypeRequest are the request parameters for operation
// Content.GetContentByTagAndType
type ContentGetContentByTagAndTypeRequest struct {

	// Not used.
	Head bool

	// Required.
	Locale string

	// Required.
	Tag string

	// Required.
	Type string
}

// ContentGetContentByTagAndType: Returns the newest item that matches a given tag and Content Type.
//
// URL: /Content/GetContentByTagAndType/{tag}/{type}/{locale}/
//
// Operation: Content.GetContentByTagAndType
func (a API) ContentGetContentByTagAndType(ctx context.Context, req ContentGetContentByTagAndTypeRequest) (*ServerResponse[ContentItemPublicContract], error) {
	//	{
	//	  "description": "Returns the newest item that matches a given tag and Content Type.",
	//	  "operationId": "Content.GetContentByTagAndType",
	//	  "parameters": [
	//	    {
	//	      "description": "Not used.",
	//	      "in": "query",
	//	      "name": "head",
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "locale",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "tag",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "type",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Content.ContentItemPublicContract"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Content"
	//	  ]
	//	}
	var resp ServerResponse[ContentItemPublicContract]
	err := a.client.Do(ctx, ClientRequest{Operation: "Content.GetContentByTagAndType",
		Method:   "GET",
		PathSpec: "/Content/GetContentByTagAndType/{tag}/{type}/{locale}/", PathParams: map[string]string{
			"locale": fmt.Sprint(req.Locale),
			"tag":    fmt.Sprint(req.Tag),
			"type":   fmt.Sprint(req.Type),
		}, QueryParams: url.Values{
			"head": {fmt.Sprint(req.Head)},
		}}, &resp)
	return &resp, err
}

// CommunityContentGetCommunityContentRequest are the request parameters for operation
// CommunityContent.GetCommunityContent
type CommunityContentGetCommunityContentRequest struct {

	// The type of media to get
	// Required.
	MediaFilter BitmaskSet[ForumTopicsCategoryFilters]

	// Zero based page
	// Required.
	Page int32

	// The sort mode.
	// Required.
	Sort CommunityContentSortMode
}

// CommunityContentGetCommunityContent: Returns community content.
//
// URL: /CommunityContent/Get/{sort}/{mediaFilter}/{page}/
//
// Operation: CommunityContent.GetCommunityContent
func (a API) CommunityContentGetCommunityContent(ctx context.Context, req CommunityContentGetCommunityContentRequest) (*ServerResponse[PostSearchResponse], error) {
	//	{
	//	  "description": "Returns community content.",
	//	  "operationId": "CommunityContent.GetCommunityContent",
	//	  "parameters": [
	//	    {
	//	      "description": "The type of media to get",
	//	      "in": "path",
	//	      "name": "mediaFilter",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": true,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Forum.ForumTopicsCategoryFiltersEnum"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Zero based page",
	//	      "in": "path",
	//	      "name": "page",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The sort mode.",
	//	      "in": "path",
	//	      "name": "sort",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "byte",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Forum.CommunityContentSortMode"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Forum.PostSearchResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "CommunityContent"
	//	  ]
	//	}
	var resp ServerResponse[PostSearchResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "CommunityContent.GetCommunityContent",
		Method:   "GET",
		PathSpec: "/CommunityContent/Get/{sort}/{mediaFilter}/{page}/", PathParams: map[string]string{
			"mediaFilter": fmt.Sprint(req.MediaFilter),
			"page":        fmt.Sprint(req.Page),
			"sort":        fmt.Sprint(req.Sort),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2EditGroupMembershipRequest are the request parameters for operation
// GroupV2.EditGroupMembership
type GroupV2EditGroupMembershipRequest struct {

	// ID of the group to which the member belongs.
	// Required.
	GroupID Int64

	// Membership ID to modify.
	// Required.
	MembershipID Int64

	// Membership type of the provide membership ID.
	// Required.
	MembershipType BungieMembershipType

	// New membertype for the specified member.
	// Required.
	MemberType RuntimeGroupMemberType
}

// GroupV2EditGroupMembership: Edit the membership type of a given member. You must have suitable
// permissions in the group to perform this operation.
//
// URL: /GroupV2/{groupId}/Members/{membershipType}/{membershipId}/SetMembershipType/{memberType}/
//
// Operation: GroupV2.EditGroupMembership
//
// Scope: oauth2 [AdminGroups]
func (a API) GroupV2EditGroupMembership(ctx context.Context, req GroupV2EditGroupMembershipRequest) (*ServerResponse[int32], error) {
	//	{
	//	  "description": "Edit the membership type of a given member. You must have suitable permissions in the group to perform this operation.",
	//	  "operationId": "GroupV2.EditGroupMembership",
	//	  "parameters": [
	//	    {
	//	      "description": "ID of the group to which the member belongs.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership ID to modify.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership type of the provide membership ID.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "New membertype for the specified member.",
	//	      "in": "path",
	//	      "name": "memberType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The member levels used by all V2 Groups API. Individual group types use their own mappings in their native storage (general uses BnetDbGroupMemberType and D2 clans use ClanMemberLevel), but they are all translated to this in the runtime api. These runtime values should NEVER be stored anywhere, so the values can be changed as necessary.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/GroupsV2.RuntimeGroupMemberType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/int32"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "AdminGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[int32]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.EditGroupMembership",
		Method:   "POST",
		PathSpec: "/GroupV2/{groupId}/Members/{membershipType}/{membershipId}/SetMembershipType/{memberType}/", PathParams: map[string]string{
			"groupId":        fmt.Sprint(req.GroupID),
			"membershipId":   fmt.Sprint(req.MembershipID),
			"membershipType": fmt.Sprint(req.MembershipType),
			"memberType":     fmt.Sprint(req.MemberType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2GetGroupsForMemberRequest are the request parameters for operation GroupV2.GetGroupsForMember
type GroupV2GetGroupsForMemberRequest struct {

	// Filter apply to list of joined groups.
	// Required.
	Filter GroupsForMemberFilter

	// Type of group the supplied member founded.
	// Required.
	GroupType GroupType

	// Membership ID to for which to find founded groups.
	// Required.
	MembershipID Int64

	// Membership type of the supplied membership ID.
	// Required.
	MembershipType BungieMembershipType
}

// GroupV2GetGroupsForMember: Get information about the groups that a given member has joined.
//
// URL: /GroupV2/User/{membershipType}/{membershipId}/{filter}/{groupType}/
//
// Operation: GroupV2.GetGroupsForMember
func (a API) GroupV2GetGroupsForMember(ctx context.Context, req GroupV2GetGroupsForMemberRequest) (*ServerResponse[GetGroupsForMemberResponse], error) {
	//	{
	//	  "description": "Get information about the groups that a given member has joined.",
	//	  "operationId": "GroupV2.GetGroupsForMember",
	//	  "parameters": [
	//	    {
	//	      "description": "Filter apply to list of joined groups.",
	//	      "in": "path",
	//	      "name": "filter",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupsForMemberFilter"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Type of group the supplied member founded.",
	//	      "in": "path",
	//	      "name": "groupType",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership ID to for which to find founded groups.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership type of the supplied membership ID.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/GroupsV2.GetGroupsForMemberResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[GetGroupsForMemberResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetGroupsForMember",
		Method:   "GET",
		PathSpec: "/GroupV2/User/{membershipType}/{membershipId}/{filter}/{groupType}/", PathParams: map[string]string{
			"filter":         fmt.Sprint(req.Filter),
			"groupType":      fmt.Sprint(req.GroupType),
			"membershipId":   fmt.Sprint(req.MembershipID),
			"membershipType": fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// GroupV2GetPotentialGroupsForMemberRequest are the request parameters for operation
// GroupV2.GetPotentialGroupsForMember
type GroupV2GetPotentialGroupsForMemberRequest struct {

	// Filter apply to list of potential joined groups.
	// Required.
	Filter GroupPotentialMemberStatus

	// Type of group the supplied member applied.
	// Required.
	GroupType GroupType

	// Membership ID to for which to find applied groups.
	// Required.
	MembershipID Int64

	// Membership type of the supplied membership ID.
	// Required.
	MembershipType BungieMembershipType
}

// GroupV2GetPotentialGroupsForMember: Get information about the groups that a given member has applied
// to or been invited to.
//
// URL: /GroupV2/User/Potential/{membershipType}/{membershipId}/{filter}/{groupType}/
//
// Operation: GroupV2.GetPotentialGroupsForMember
func (a API) GroupV2GetPotentialGroupsForMember(ctx context.Context, req GroupV2GetPotentialGroupsForMemberRequest) (*ServerResponse[GroupPotentialMembershipSearchResponse], error) {
	//	{
	//	  "description": "Get information about the groups that a given member has applied to or been invited to.",
	//	  "operationId": "GroupV2.GetPotentialGroupsForMember",
	//	  "parameters": [
	//	    {
	//	      "description": "Filter apply to list of potential joined groups.",
	//	      "in": "path",
	//	      "name": "filter",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupPotentialMemberStatus"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Type of group the supplied member applied.",
	//	      "in": "path",
	//	      "name": "groupType",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/GroupsV2.GroupType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership ID to for which to find applied groups.",
	//	      "in": "path",
	//	      "name": "membershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Membership type of the supplied membership ID.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/GroupsV2.GroupPotentialMembershipSearchResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "GroupV2"
	//	  ]
	//	}
	var resp ServerResponse[GroupPotentialMembershipSearchResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "GroupV2.GetPotentialGroupsForMember",
		Method:   "GET",
		PathSpec: "/GroupV2/User/Potential/{membershipType}/{membershipId}/{filter}/{groupType}/", PathParams: map[string]string{
			"filter":         fmt.Sprint(req.Filter),
			"groupType":      fmt.Sprint(req.GroupType),
			"membershipId":   fmt.Sprint(req.MembershipID),
			"membershipType": fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// ForumGetCoreTopicsPagedRequest are the request parameters for operation Forum.GetCoreTopicsPaged
type ForumGetCoreTopicsPagedRequest struct {

	// The category filter.
	// Required.
	CategoryFilter BitmaskSet[ForumTopicsCategoryFilters]

	// Comma seperated list of locales posts must match to return in the result list. Default 'en'
	Locales string

	// Zero base page
	// Required.
	Page int32

	// The date filter.
	// Required.
	QuickDate ForumTopicsQuickDate

	// The sort mode.
	// Required.
	Sort ForumTopicsSort
}

// ForumGetCoreTopicsPaged: Gets a listing of all topics marked as part of the core group.
//
// URL: /Forum/GetCoreTopicsPaged/{page}/{sort}/{quickDate}/{categoryFilter}/
//
// Operation: Forum.GetCoreTopicsPaged
func (a API) ForumGetCoreTopicsPaged(ctx context.Context, req ForumGetCoreTopicsPagedRequest) (*ServerResponse[PostSearchResponse], error) {
	//	{
	//	  "description": "Gets a listing of all topics marked as part of the core group.",
	//	  "operationId": "Forum.GetCoreTopicsPaged",
	//	  "parameters": [
	//	    {
	//	      "description": "The category filter.",
	//	      "in": "path",
	//	      "name": "categoryFilter",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": true,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Forum.ForumTopicsCategoryFiltersEnum"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Comma seperated list of locales posts must match to return in the result list. Default 'en'",
	//	      "in": "query",
	//	      "name": "locales",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "Zero base page",
	//	      "in": "path",
	//	      "name": "page",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The date filter.",
	//	      "in": "path",
	//	      "name": "quickDate",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Forum.ForumTopicsQuickDateEnum"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "The sort mode.",
	//	      "in": "path",
	//	      "name": "sort",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "byte",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Forum.ForumTopicsSortEnum"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Forum.PostSearchResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Forum"
	//	  ]
	//	}
	var resp ServerResponse[PostSearchResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Forum.GetCoreTopicsPaged",
		Method:   "GET",
		PathSpec: "/Forum/GetCoreTopicsPaged/{page}/{sort}/{quickDate}/{categoryFilter}/", PathParams: map[string]string{
			"categoryFilter": fmt.Sprint(req.CategoryFilter),
			"page":           fmt.Sprint(req.Page),
			"quickDate":      fmt.Sprint(req.QuickDate),
			"sort":           fmt.Sprint(req.Sort),
		}, QueryParams: url.Values{
			"locales": {fmt.Sprint(req.Locales)},
		}}, &resp)
	return &resp, err
}

// FireteamFinderGetOfferRequest are the request parameters for operation FireteamFinder.GetOffer
type FireteamFinderGetOfferRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// The unique ID of the offer.
	// Required.
	OfferID Int64
}

// FireteamFinderGetOffer: Retrieves an offer to a Fireteam lobby.
//
// URL:
// /FireteamFinder/Offer/{offerId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.GetOffer
func (a API) FireteamFinderGetOffer(ctx context.Context, req FireteamFinderGetOfferRequest) (*ServerResponse[FireteamFinderOffer], error) {
	//	{
	//	  "description": "Retrieves an offer to a Fireteam lobby.",
	//	  "operationId": "FireteamFinder.GetOffer",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "The unique ID of the offer.",
	//	      "in": "path",
	//	      "name": "offerId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderOffer"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderOffer]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.GetOffer",
		Method:   "GET",
		PathSpec: "/FireteamFinder/Offer/{offerId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
			"offerId":               fmt.Sprint(req.OfferID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// FireteamFinderRespondToOfferRequest are the request parameters for operation
// FireteamFinder.RespondToOffer
type FireteamFinderRespondToOfferRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// The unique ID of the offer.
	// Required.
	OfferID Int64

	// Required.
	Body FireteamFinderRespondToOfferRequestBody
}

// FireteamFinderRespondToOffer: Responds to a Fireteam lobby offer.
//
// URL:
// /FireteamFinder/Offer/Respond/{offerId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.RespondToOffer
func (a API) FireteamFinderRespondToOffer(ctx context.Context, req FireteamFinderRespondToOfferRequest) (*ServerResponse[FireteamFinderRespondToOfferResponse], error) {
	//	{
	//	  "description": "Responds to a Fireteam lobby offer.",
	//	  "operationId": "FireteamFinder.RespondToOffer",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "The unique ID of the offer.",
	//	      "in": "path",
	//	      "name": "offerId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderRespondToOfferRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderRespondToOfferResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderRespondToOfferResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.RespondToOffer",
		Method:   "POST",
		PathSpec: "/FireteamFinder/Offer/Respond/{offerId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
			"offerId":               fmt.Sprint(req.OfferID),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// FireteamFinderGetLobbyRequest are the request parameters for operation FireteamFinder.GetLobby
type FireteamFinderGetLobbyRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// The ID of the lobby to retrieve.
	// Required.
	LobbyID Int64
}

// FireteamFinderGetLobby: Retrieves the information for a Fireteam lobby.
//
// URL:
// /FireteamFinder/Lobby/{lobbyId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.GetLobby
func (a API) FireteamFinderGetLobby(ctx context.Context, req FireteamFinderGetLobbyRequest) (*ServerResponse[FireteamFinderLobbyResponse], error) {
	//	{
	//	  "description": "Retrieves the information for a Fireteam lobby.",
	//	  "operationId": "FireteamFinder.GetLobby",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "The ID of the lobby to retrieve.",
	//	      "in": "path",
	//	      "name": "lobbyId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderLobbyResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderLobbyResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.GetLobby",
		Method:   "GET",
		PathSpec: "/FireteamFinder/Lobby/{lobbyId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
			"lobbyId":               fmt.Sprint(req.LobbyID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// FireteamFinderGetLobbyOffersRequest are the request parameters for operation
// FireteamFinder.GetLobbyOffers
type FireteamFinderGetLobbyOffersRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// The unique ID of the lobby.
	// Required.
	LobbyID Int64

	// An optional token from a previous response to fetch the next page of results.
	NextPageToken string

	// The maximum number of results to be returned with this page.
	PageSize int32
}

// FireteamFinderGetLobbyOffers: Retrieves all offers relevant to a Fireteam lobby.
//
// URL:
// /FireteamFinder/Lobby/{lobbyId}/Offers/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.GetLobbyOffers
func (a API) FireteamFinderGetLobbyOffers(ctx context.Context, req FireteamFinderGetLobbyOffersRequest) (*ServerResponse[FireteamFinderGetLobbyOffersResponse], error) {
	//	{
	//	  "description": "Retrieves all offers relevant to a Fireteam lobby.",
	//	  "operationId": "FireteamFinder.GetLobbyOffers",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "The unique ID of the lobby.",
	//	      "in": "path",
	//	      "name": "lobbyId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "An optional token from a previous response to fetch the next page of results.",
	//	      "in": "query",
	//	      "name": "nextPageToken",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "The maximum number of results to be returned with this page.",
	//	      "in": "query",
	//	      "name": "pageSize",
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderGetLobbyOffersResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderGetLobbyOffersResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.GetLobbyOffers",
		Method:   "GET",
		PathSpec: "/FireteamFinder/Lobby/{lobbyId}/Offers/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
			"lobbyId":               fmt.Sprint(req.LobbyID),
		}, QueryParams: url.Values{
			"nextPageToken": {fmt.Sprint(req.NextPageToken)},
			"pageSize":      {fmt.Sprint(req.PageSize)},
		}}, &resp)
	return &resp, err
}

// FireteamFinderUpdateLobbySettingsRequest are the request parameters for operation
// FireteamFinder.UpdateLobbySettings
type FireteamFinderUpdateLobbySettingsRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// The ID of the lobby to update.
	// Required.
	LobbyID Int64

	// Required.
	Body FireteamFinderUpdateLobbySettingsRequestBody
}

// FireteamFinderUpdateLobbySettings: Updates the settings for a Fireteam lobby.
//
// URL:
// /FireteamFinder/Lobby/UpdateSettings/{lobbyId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.UpdateLobbySettings
func (a API) FireteamFinderUpdateLobbySettings(ctx context.Context, req FireteamFinderUpdateLobbySettingsRequest) (*ServerResponse[FireteamFinderUpdateLobbySettingsResponse], error) {
	//	{
	//	  "description": "Updates the settings for a Fireteam lobby.",
	//	  "operationId": "FireteamFinder.UpdateLobbySettings",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "The ID of the lobby to update.",
	//	      "in": "path",
	//	      "name": "lobbyId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderUpdateLobbySettingsRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderUpdateLobbySettingsResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderUpdateLobbySettingsResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.UpdateLobbySettings",
		Method:   "POST",
		PathSpec: "/FireteamFinder/Lobby/UpdateSettings/{lobbyId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
			"lobbyId":               fmt.Sprint(req.LobbyID),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// FireteamFinderLeaveLobbyRequest are the request parameters for operation FireteamFinder.LeaveLobby
type FireteamFinderLeaveLobbyRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// The ID of the lobby to leave.
	// Required.
	LobbyID Int64
}

// FireteamFinderLeaveLobby: Sends a request to leave a Fireteam lobby.
//
// URL:
// /FireteamFinder/Lobby/Leave/{lobbyId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.LeaveLobby
func (a API) FireteamFinderLeaveLobby(ctx context.Context, req FireteamFinderLeaveLobbyRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "Sends a request to leave a Fireteam lobby.",
	//	  "operationId": "FireteamFinder.LeaveLobby",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "The ID of the lobby to leave.",
	//	      "in": "path",
	//	      "name": "lobbyId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.LeaveLobby",
		Method:   "POST",
		PathSpec: "/FireteamFinder/Lobby/Leave/{lobbyId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
			"lobbyId":               fmt.Sprint(req.LobbyID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// FireteamFinderActivateLobbyForNewListingIdRequest are the request parameters for operation
// FireteamFinder.ActivateLobbyForNewListingId
type FireteamFinderActivateLobbyForNewListingIdRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// Optional boolean to forcibly activate the lobby, kicking pending applicants.
	ForceActivation bool

	// The ID of the lobby to activate.
	// Required.
	LobbyID Int64
}

// FireteamFinderActivateLobbyForNewListingId: Activates a lobby and initializes it as an active
// Fireteam, returning the updated Listing ID.
//
// URL:
// /FireteamFinder/Lobby/ActivateForNewListingId/{lobbyId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.ActivateLobbyForNewListingId
func (a API) FireteamFinderActivateLobbyForNewListingId(ctx context.Context, req FireteamFinderActivateLobbyForNewListingIdRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "Activates a lobby and initializes it as an active Fireteam, returning the updated Listing ID.",
	//	  "operationId": "FireteamFinder.ActivateLobbyForNewListingId",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Optional boolean to forcibly activate the lobby, kicking pending applicants.",
	//	      "in": "query",
	//	      "name": "forceActivation",
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    },
	//	    {
	//	      "description": "The ID of the lobby to activate.",
	//	      "in": "path",
	//	      "name": "lobbyId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.ActivateLobbyForNewListingId",
		Method:   "POST",
		PathSpec: "/FireteamFinder/Lobby/ActivateForNewListingId/{lobbyId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
			"lobbyId":               fmt.Sprint(req.LobbyID),
		}, QueryParams: url.Values{
			"forceActivation": {fmt.Sprint(req.ForceActivation)},
		}}, &resp)
	return &resp, err
}

// FireteamFinderActivateLobbyRequest are the request parameters for operation
// FireteamFinder.ActivateLobby
type FireteamFinderActivateLobbyRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// Optional boolean to forcibly activate the lobby, kicking pending applicants.
	ForceActivation bool

	// The ID of the lobby to activate.
	// Required.
	LobbyID Int64
}

// FireteamFinderActivateLobby: Activates a lobby and initializes it as an active Fireteam.
//
// URL:
// /FireteamFinder/Lobby/Activate/{lobbyId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.ActivateLobby
func (a API) FireteamFinderActivateLobby(ctx context.Context, req FireteamFinderActivateLobbyRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "Activates a lobby and initializes it as an active Fireteam.",
	//	  "operationId": "FireteamFinder.ActivateLobby",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Optional boolean to forcibly activate the lobby, kicking pending applicants.",
	//	      "in": "query",
	//	      "name": "forceActivation",
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    },
	//	    {
	//	      "description": "The ID of the lobby to activate.",
	//	      "in": "path",
	//	      "name": "lobbyId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.ActivateLobby",
		Method:   "POST",
		PathSpec: "/FireteamFinder/Lobby/Activate/{lobbyId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
			"lobbyId":               fmt.Sprint(req.LobbyID),
		}, QueryParams: url.Values{
			"forceActivation": {fmt.Sprint(req.ForceActivation)},
		}}, &resp)
	return &resp, err
}

// FireteamFinderGetListingApplicationsRequest are the request parameters for operation
// FireteamFinder.GetListingApplications
type FireteamFinderGetListingApplicationsRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// Optional flag representing a filter on the state of the application.
	Flags Int64

	// The ID of the listing whose applications to retrieve.
	// Required.
	ListingID Int64

	// An optional token from a previous response to fetch the next page of results.
	NextPageToken string

	// The maximum number of results to be returned with this page.
	PageSize int32
}

// FireteamFinderGetListingApplications: Retrieves all applications to a Fireteam Finder listing.
//
// URL:
// /FireteamFinder/Listing/{listingId}/Applications/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.GetListingApplications
func (a API) FireteamFinderGetListingApplications(ctx context.Context, req FireteamFinderGetListingApplicationsRequest) (*ServerResponse[FireteamFinderGetListingApplicationsResponse], error) {
	//	{
	//	  "description": "Retrieves all applications to a Fireteam Finder listing.",
	//	  "operationId": "FireteamFinder.GetListingApplications",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Optional flag representing a filter on the state of the application.",
	//	      "in": "query",
	//	      "name": "flags",
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The ID of the listing whose applications to retrieve.",
	//	      "in": "path",
	//	      "name": "listingId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "An optional token from a previous response to fetch the next page of results.",
	//	      "in": "query",
	//	      "name": "nextPageToken",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "The maximum number of results to be returned with this page.",
	//	      "in": "query",
	//	      "name": "pageSize",
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderGetListingApplicationsResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderGetListingApplicationsResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.GetListingApplications",
		Method:   "GET",
		PathSpec: "/FireteamFinder/Listing/{listingId}/Applications/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
			"listingId":             fmt.Sprint(req.ListingID),
		}, QueryParams: url.Values{
			"flags":         {fmt.Sprint(req.Flags)},
			"nextPageToken": {fmt.Sprint(req.NextPageToken)},
			"pageSize":      {fmt.Sprint(req.PageSize)},
		}}, &resp)
	return &resp, err
}

// FireteamFinderRespondToAuthenticationRequest are the request parameters for operation
// FireteamFinder.RespondToAuthentication
type FireteamFinderRespondToAuthenticationRequest struct {

	// The ID of the application whose authentication to confirm.
	// Required.
	ApplicationID Int64

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// Required.
	Body FireteamFinderRespondToAuthenticationRequestBody
}

// FireteamFinderRespondToAuthentication: Responds to an authentication request for a Fireteam.
//
// URL:
// /FireteamFinder/Authentication/Respond/{applicationId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.RespondToAuthentication
func (a API) FireteamFinderRespondToAuthentication(ctx context.Context, req FireteamFinderRespondToAuthenticationRequest) (*ServerResponse[FireteamFinderRespondToAuthenticationResponse], error) {
	//	{
	//	  "description": "Responds to an authentication request for a Fireteam.",
	//	  "operationId": "FireteamFinder.RespondToAuthentication",
	//	  "parameters": [
	//	    {
	//	      "description": "The ID of the application whose authentication to confirm.",
	//	      "in": "path",
	//	      "name": "applicationId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderRespondToAuthenticationRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderRespondToAuthenticationResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderRespondToAuthenticationResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.RespondToAuthentication",
		Method:   "POST",
		PathSpec: "/FireteamFinder/Authentication/Respond/{applicationId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"applicationId":         fmt.Sprint(req.ApplicationID),
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// FireteamFinderGetApplicationRequest are the request parameters for operation
// FireteamFinder.GetApplication
type FireteamFinderGetApplicationRequest struct {

	// Required.
	ApplicationID Int64

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType
}

// FireteamFinderGetApplication: Retrieves a Fireteam application.
//
// URL:
// /FireteamFinder/Application/{applicationId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.GetApplication
func (a API) FireteamFinderGetApplication(ctx context.Context, req FireteamFinderGetApplicationRequest) (*ServerResponse[FireteamFinderGetApplicationResponse], error) {
	//	{
	//	  "description": "Retrieves a Fireteam application.",
	//	  "operationId": "FireteamFinder.GetApplication",
	//	  "parameters": [
	//	    {
	//	      "in": "path",
	//	      "name": "applicationId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderGetApplicationResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderGetApplicationResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.GetApplication",
		Method:   "GET",
		PathSpec: "/FireteamFinder/Application/{applicationId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"applicationId":         fmt.Sprint(req.ApplicationID),
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// FireteamFinderRespondToApplicationRequest are the request parameters for operation
// FireteamFinder.RespondToApplication
type FireteamFinderRespondToApplicationRequest struct {

	// The application ID to respond to.
	// Required.
	ApplicationID Int64

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// Required.
	Body FireteamFinderRespondToApplicationRequestBody
}

// FireteamFinderRespondToApplication: Responds to an application sent to a Fireteam lobby.
//
// URL:
// /FireteamFinder/Application/Respond/{applicationId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.RespondToApplication
func (a API) FireteamFinderRespondToApplication(ctx context.Context, req FireteamFinderRespondToApplicationRequest) (*ServerResponse[FireteamFinderRespondToApplicationResponse], error) {
	//	{
	//	  "description": "Responds to an application sent to a Fireteam lobby.",
	//	  "operationId": "FireteamFinder.RespondToApplication",
	//	  "parameters": [
	//	    {
	//	      "description": "The application ID to respond to.",
	//	      "in": "path",
	//	      "name": "applicationId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderRespondToApplicationRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderRespondToApplicationResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderRespondToApplicationResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.RespondToApplication",
		Method:   "POST",
		PathSpec: "/FireteamFinder/Application/Respond/{applicationId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"applicationId":         fmt.Sprint(req.ApplicationID),
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// FireteamFinderLeaveApplicationRequest are the request parameters for operation
// FireteamFinder.LeaveApplication
type FireteamFinderLeaveApplicationRequest struct {

	// The ID of the application to leave.
	// Required.
	ApplicationID Int64

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType
}

// FireteamFinderLeaveApplication: Sends a request to leave a Fireteam listing application.
//
// URL:
// /FireteamFinder/Application/Leave/{applicationId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.LeaveApplication
func (a API) FireteamFinderLeaveApplication(ctx context.Context, req FireteamFinderLeaveApplicationRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "Sends a request to leave a Fireteam listing application.",
	//	  "operationId": "FireteamFinder.LeaveApplication",
	//	  "parameters": [
	//	    {
	//	      "description": "The ID of the application to leave.",
	//	      "in": "path",
	//	      "name": "applicationId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.LeaveApplication",
		Method:   "POST",
		PathSpec: "/FireteamFinder/Application/Leave/{applicationId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"applicationId":         fmt.Sprint(req.ApplicationID),
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// FireteamGetMyClanFireteamsRequest are the request parameters for operation
// Fireteam.GetMyClanFireteams
type FireteamGetMyClanFireteamsRequest struct {

	// If true, filter by clan. Otherwise, ignore the clan and show all of the user's fireteams.
	GroupFilter bool

	// The group id of the clan. (This parameter is ignored unless the optional query parameter groupFilter
	// is true).
	// Required.
	GroupID Int64

	// If true, return fireteams that have been closed.
	// Required.
	IncludeClosed bool

	// An optional language filter.
	LangFilter string

	// Deprecated parameter, ignored.
	// Required.
	Page int32

	// The platform filter.
	// Required.
	Platform FireteamPlatform
}

// FireteamGetMyClanFireteams: Gets a listing of all fireteams that caller is an applicant, a member,
// or an alternate of.
//
// URL: /Fireteam/Clan/{groupId}/My/{platform}/{includeClosed}/{page}/
//
// Operation: Fireteam.GetMyClanFireteams
//
// Scope: oauth2 [ReadGroups]
func (a API) FireteamGetMyClanFireteams(ctx context.Context, req FireteamGetMyClanFireteamsRequest) (*ServerResponse[SearchResult[FireteamResponse]], error) {
	//	{
	//	  "description": "Gets a listing of all fireteams that caller is an applicant, a member, or an alternate of.",
	//	  "operationId": "Fireteam.GetMyClanFireteams",
	//	  "parameters": [
	//	    {
	//	      "description": "If true, filter by clan. Otherwise, ignore the clan and show all of the user's fireteams.",
	//	      "in": "query",
	//	      "name": "groupFilter",
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    },
	//	    {
	//	      "description": "The group id of the clan. (This parameter is ignored unless the optional query parameter groupFilter is true).",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "If true, return fireteams that have been closed.",
	//	      "in": "path",
	//	      "name": "includeClosed",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    },
	//	    {
	//	      "description": "An optional language filter.",
	//	      "in": "query",
	//	      "name": "langFilter",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "deprecated": true,
	//	      "description": "Deprecated parameter, ignored.",
	//	      "in": "path",
	//	      "name": "page",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The platform filter.",
	//	      "in": "path",
	//	      "name": "platform",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "byte",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Fireteam.FireteamPlatform"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/SearchResultOfFireteamResponse"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "ReadGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Fireteam"
	//	  ]
	//	}
	var resp ServerResponse[SearchResult[FireteamResponse]]
	err := a.client.Do(ctx, ClientRequest{Operation: "Fireteam.GetMyClanFireteams",
		Method:   "GET",
		PathSpec: "/Fireteam/Clan/{groupId}/My/{platform}/{includeClosed}/{page}/", PathParams: map[string]string{
			"groupId":       fmt.Sprint(req.GroupID),
			"includeClosed": fmt.Sprint(req.IncludeClosed),
			"page":          fmt.Sprint(req.Page),
			"platform":      fmt.Sprint(req.Platform),
		}, QueryParams: url.Values{
			"groupFilter": {fmt.Sprint(req.GroupFilter)},
			"langFilter":  {fmt.Sprint(req.LangFilter)},
		}}, &resp)
	return &resp, err
}

// Destiny2GetVendorRequest are the request parameters for operation Destiny2.GetVendor
type Destiny2GetVendorRequest struct {

	// The Destiny Character ID of the character for whom we're getting vendor info.
	// Required.
	CharacterID Int64

	// A comma separated list of components to return (as strings or numeric values). See the
	// DestinyComponentType enum for valid components to request. You must request at least one component
	// to receive results.
	Components []ComponentType

	// Destiny membership ID of another user. You may be denied.
	// Required.
	DestinyMembershipID Int64

	// A valid non-BungieNet membership type.
	// Required.
	MembershipType BungieMembershipType

	// The Hash identifier of the Vendor to be returned.
	// Required.
	VendorHash uint32
}

// Destiny2GetVendor: Get the details of a specific Vendor.
//
// URL:
// /Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Vendors/{vendorHash}/
//
// Operation: Destiny2.GetVendor
func (a API) Destiny2GetVendor(ctx context.Context, req Destiny2GetVendorRequest) (*ServerResponse[VendorResponse], error) {
	//	{
	//	  "description": "Get the details of a specific Vendor.",
	//	  "operationId": "Destiny2.GetVendor",
	//	  "parameters": [
	//	    {
	//	      "description": "The Destiny Character ID of the character for whom we're getting vendor info.",
	//	      "in": "path",
	//	      "name": "characterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results.",
	//	      "in": "query",
	//	      "name": "components",
	//	      "schema": {
	//	        "items": {
	//	          "description": "Represents the possible components that can be returned from Destiny \"Get\" calls such as GetProfile, GetCharacter, GetVendor etc...\r\nWhen making one of these requests, you will pass one or more of these components as a comma separated list in the \"?components=\" querystring parameter. For instance, if you want baseline Profile data, Character Data, and character progressions, you would pass \"?components=Profiles,Characters,CharacterProgressions\" You may use either the numerical or string values.",
	//	          "format": "int32",
	//	          "type": "integer",
	//	          "x-enum-is-bitmask": false,
	//	          "x-enum-reference": {
	//	            "$ref": "#/components/schemas/Destiny.DestinyComponentType"
	//	          }
	//	        },
	//	        "type": "array"
	//	      }
	//	    },
	//	    {
	//	      "description": "Destiny membership ID of another user. You may be denied.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid non-BungieNet membership type.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "The Hash identifier of the Vendor to be returned.",
	//	      "in": "path",
	//	      "name": "vendorHash",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "uint32",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Responses.DestinyVendorResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[VendorResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetVendor",
		Method:   "GET",
		PathSpec: "/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Vendors/{vendorHash}/", PathParams: map[string]string{
			"characterId":         fmt.Sprint(req.CharacterID),
			"destinyMembershipId": fmt.Sprint(req.DestinyMembershipID),
			"membershipType":      fmt.Sprint(req.MembershipType),
			"vendorHash":          fmt.Sprint(req.VendorHash),
		}, QueryParams: url.Values{
			"components": {joinArray(req.Components)},
		}}, &resp)
	return &resp, err
}

// Destiny2GetCollectibleNodeDetailsRequest are the request parameters for operation
// Destiny2.GetCollectibleNodeDetails
type Destiny2GetCollectibleNodeDetailsRequest struct {

	// The Destiny Character ID of the character for whom we're getting collectible detail info.
	// Required.
	CharacterID Int64

	// The hash identifier of the Presentation Node for whom we should return collectible details. Details
	// will only be returned for collectibles that are direct descendants of this node.
	// Required.
	CollectiblePresentationNodeHash uint32

	// A comma separated list of components to return (as strings or numeric values). See the
	// DestinyComponentType enum for valid components to request. You must request at least one component
	// to receive results.
	Components []ComponentType

	// Destiny membership ID of another user. You may be denied.
	// Required.
	DestinyMembershipID Int64

	// A valid non-BungieNet membership type.
	// Required.
	MembershipType BungieMembershipType
}

// Destiny2GetCollectibleNodeDetails: Given a Presentation Node that has Collectibles as direct
// descendants, this will return item details about those descendants in the context of the requesting
// character.
//
// URL:
// /Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Collectibles/{collectiblePresentationNodeHash}/
//
// Operation: Destiny2.GetCollectibleNodeDetails
func (a API) Destiny2GetCollectibleNodeDetails(ctx context.Context, req Destiny2GetCollectibleNodeDetailsRequest) (*ServerResponse[CollectibleNodeDetailResponse], error) {
	//	{
	//	  "description": "Given a Presentation Node that has Collectibles as direct descendants, this will return item details about those descendants in the context of the requesting character.",
	//	  "operationId": "Destiny2.GetCollectibleNodeDetails",
	//	  "parameters": [
	//	    {
	//	      "description": "The Destiny Character ID of the character for whom we're getting collectible detail info.",
	//	      "in": "path",
	//	      "name": "characterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node.",
	//	      "in": "path",
	//	      "name": "collectiblePresentationNodeHash",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "uint32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results.",
	//	      "in": "query",
	//	      "name": "components",
	//	      "schema": {
	//	        "items": {
	//	          "description": "Represents the possible components that can be returned from Destiny \"Get\" calls such as GetProfile, GetCharacter, GetVendor etc...\r\nWhen making one of these requests, you will pass one or more of these components as a comma separated list in the \"?components=\" querystring parameter. For instance, if you want baseline Profile data, Character Data, and character progressions, you would pass \"?components=Profiles,Characters,CharacterProgressions\" You may use either the numerical or string values.",
	//	          "format": "int32",
	//	          "type": "integer",
	//	          "x-enum-is-bitmask": false,
	//	          "x-enum-reference": {
	//	            "$ref": "#/components/schemas/Destiny.DestinyComponentType"
	//	          }
	//	        },
	//	        "type": "array"
	//	      }
	//	    },
	//	    {
	//	      "description": "Destiny membership ID of another user. You may be denied.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid non-BungieNet membership type.",
	//	      "in": "path",
	//	      "name": "membershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Destiny.Responses.DestinyCollectibleNodeDetailResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Destiny2"
	//	  ]
	//	}
	var resp ServerResponse[CollectibleNodeDetailResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Destiny2.GetCollectibleNodeDetails",
		Method:   "GET",
		PathSpec: "/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Collectibles/{collectiblePresentationNodeHash}/", PathParams: map[string]string{
			"characterId":                     fmt.Sprint(req.CharacterID),
			"collectiblePresentationNodeHash": fmt.Sprint(req.CollectiblePresentationNodeHash),
			"destinyMembershipId":             fmt.Sprint(req.DestinyMembershipID),
			"membershipType":                  fmt.Sprint(req.MembershipType),
		}, QueryParams: url.Values{
			"components": {joinArray(req.Components)},
		}}, &resp)
	return &resp, err
}

// FireteamFinderKickPlayerRequest are the request parameters for operation FireteamFinder.KickPlayer
type FireteamFinderKickPlayerRequest struct {

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// The ID of the lobby to kick the player from.
	// Required.
	LobbyID Int64

	// A valid Destiny membership ID of the player to kick.
	// Required.
	TargetMembershipID Int64

	// Required.
	Body FireteamFinderKickPlayerRequestBody
}

// FireteamFinderKickPlayer: Kicks a player from a Fireteam Finder lobby.
//
// URL:
// /FireteamFinder/Lobby/{lobbyId}/KickPlayer/{targetMembershipId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.KickPlayer
func (a API) FireteamFinderKickPlayer(ctx context.Context, req FireteamFinderKickPlayerRequest) (*ServerResponse[bool], error) {
	//	{
	//	  "description": "Kicks a player from a Fireteam Finder lobby.",
	//	  "operationId": "FireteamFinder.KickPlayer",
	//	  "parameters": [
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "The ID of the lobby to kick the player from.",
	//	      "in": "path",
	//	      "name": "lobbyId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID of the player to kick.",
	//	      "in": "path",
	//	      "name": "targetMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "requestBody": {
	//	    "content": {
	//	      "application/json": {
	//	        "schema": {
	//	          "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderKickPlayerRequest"
	//	        }
	//	      }
	//	    },
	//	    "required": true
	//	  },
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/boolean"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[bool]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.KickPlayer",
		Method:   "POST",
		PathSpec: "/FireteamFinder/Lobby/{lobbyId}/KickPlayer/{targetMembershipId}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
			"lobbyId":               fmt.Sprint(req.LobbyID),
			"targetMembershipId":    fmt.Sprint(req.TargetMembershipID),
		}, QueryParams: url.Values{}, Body: req.Body}, &resp)
	return &resp, err
}

// FireteamFinderApplyToListingRequest are the request parameters for operation
// FireteamFinder.ApplyToListing
type FireteamFinderApplyToListingRequest struct {

	// The type of application to apply
	// Required.
	ApplicationType FireteamFinderApplicationType

	// A valid Destiny character ID.
	// Required.
	DestinyCharacterID Int64

	// A valid Destiny membership ID.
	// Required.
	DestinyMembershipID Int64

	// A valid Destiny membership type.
	// Required.
	DestinyMembershipType BungieMembershipType

	// The id of the listing to apply to
	// Required.
	ListingID Int64
}

// FireteamFinderApplyToListing: Applies to have a character join a fireteam.
//
// URL:
// /FireteamFinder/Listing/{listingId}/Apply/{applicationType}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/
//
// Operation: FireteamFinder.ApplyToListing
func (a API) FireteamFinderApplyToListing(ctx context.Context, req FireteamFinderApplyToListingRequest) (*ServerResponse[FireteamFinderApplyToListingResponse], error) {
	//	{
	//	  "description": "Applies to have a character join a fireteam.",
	//	  "operationId": "FireteamFinder.ApplyToListing",
	//	  "parameters": [
	//	    {
	//	      "description": "The type of application to apply",
	//	      "in": "path",
	//	      "name": "applicationType",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderApplicationType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny character ID.",
	//	      "in": "path",
	//	      "name": "destinyCharacterId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership ID.",
	//	      "in": "path",
	//	      "name": "destinyMembershipId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A valid Destiny membership type.",
	//	      "in": "path",
	//	      "name": "destinyMembershipType",
	//	      "required": true,
	//	      "schema": {
	//	        "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/BungieMembershipType"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "The id of the listing to apply to",
	//	      "in": "path",
	//	      "name": "listingId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/FireteamFinder.DestinyFireteamFinderApplyToListingResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "FireteamFinder"
	//	  ]
	//	}
	var resp ServerResponse[FireteamFinderApplyToListingResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "FireteamFinder.ApplyToListing",
		Method:   "POST",
		PathSpec: "/FireteamFinder/Listing/{listingId}/Apply/{applicationType}/{destinyMembershipType}/{destinyMembershipId}/{destinyCharacterId}/", PathParams: map[string]string{
			"applicationType":       fmt.Sprint(req.ApplicationType),
			"destinyCharacterId":    fmt.Sprint(req.DestinyCharacterID),
			"destinyMembershipId":   fmt.Sprint(req.DestinyMembershipID),
			"destinyMembershipType": fmt.Sprint(req.DestinyMembershipType),
			"listingId":             fmt.Sprint(req.ListingID),
		}, QueryParams: url.Values{}}, &resp)
	return &resp, err
}

// FireteamSearchPublicAvailableClanFireteamsRequest are the request parameters for operation
// Fireteam.SearchPublicAvailableClanFireteams
type FireteamSearchPublicAvailableClanFireteamsRequest struct {

	// The activity type to filter by.
	// Required.
	ActivityType int32

	// The date range to grab available fireteams.
	// Required.
	DateRange FireteamDateRange

	// If you wish the result to exclude immediate fireteams, set this to true. Immediate-only can be
	// forced using the dateRange enum.
	ExcludeImmediate bool

	// An optional language filter.
	LangFilter string

	// Zero based page
	// Required.
	Page int32

	// The platform filter.
	// Required.
	Platform FireteamPlatform

	// Filters based on available slots
	// Required.
	SlotFilter FireteamSlotSearch
}

// FireteamSearchPublicAvailableClanFireteams: Gets a listing of all public fireteams starting now with
// open slots. Caller is not checked for join criteria so caching is maximized.
//
// URL: /Fireteam/Search/Available/{platform}/{activityType}/{dateRange}/{slotFilter}/{page}/
//
// Operation: Fireteam.SearchPublicAvailableClanFireteams
//
// Scope: oauth2 [ReadGroups]
func (a API) FireteamSearchPublicAvailableClanFireteams(ctx context.Context, req FireteamSearchPublicAvailableClanFireteamsRequest) (*ServerResponse[SearchResult[FireteamSummary]], error) {
	//	{
	//	  "description": "Gets a listing of all public fireteams starting now with open slots. Caller is not checked for join criteria so caching is maximized.",
	//	  "operationId": "Fireteam.SearchPublicAvailableClanFireteams",
	//	  "parameters": [
	//	    {
	//	      "description": "The activity type to filter by.",
	//	      "in": "path",
	//	      "name": "activityType",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The date range to grab available fireteams.",
	//	      "in": "path",
	//	      "name": "dateRange",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "byte",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Fireteam.FireteamDateRange"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "If you wish the result to exclude immediate fireteams, set this to true. Immediate-only can be forced using the dateRange enum.",
	//	      "in": "query",
	//	      "name": "excludeImmediate",
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    },
	//	    {
	//	      "description": "An optional language filter.",
	//	      "in": "query",
	//	      "name": "langFilter",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "Zero based page",
	//	      "in": "path",
	//	      "name": "page",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The platform filter.",
	//	      "in": "path",
	//	      "name": "platform",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "byte",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Fireteam.FireteamPlatform"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Filters based on available slots",
	//	      "in": "path",
	//	      "name": "slotFilter",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "byte",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Fireteam.FireteamSlotSearch"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/SearchResultOfFireteamSummary"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "ReadGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Fireteam"
	//	  ]
	//	}
	var resp ServerResponse[SearchResult[FireteamSummary]]
	err := a.client.Do(ctx, ClientRequest{Operation: "Fireteam.SearchPublicAvailableClanFireteams",
		Method:   "GET",
		PathSpec: "/Fireteam/Search/Available/{platform}/{activityType}/{dateRange}/{slotFilter}/{page}/", PathParams: map[string]string{
			"activityType": fmt.Sprint(req.ActivityType),
			"dateRange":    fmt.Sprint(req.DateRange),
			"page":         fmt.Sprint(req.Page),
			"platform":     fmt.Sprint(req.Platform),
			"slotFilter":   fmt.Sprint(req.SlotFilter),
		}, QueryParams: url.Values{
			"excludeImmediate": {fmt.Sprint(req.ExcludeImmediate)},
			"langFilter":       {fmt.Sprint(req.LangFilter)},
		}}, &resp)
	return &resp, err
}

// ForumGetTopicsPagedRequest are the request parameters for operation Forum.GetTopicsPaged
type ForumGetTopicsPagedRequest struct {

	// A category filter
	// Required.
	CategoryFilter BitmaskSet[ForumTopicsCategoryFilters]

	// The group, if any.
	// Required.
	Group Int64

	// Comma seperated list of locales posts must match to return in the result list. Default 'en'
	Locales string

	// Zero paged page number
	// Required.
	Page int32

	// Unused
	// Required.
	PageSize int32

	// A date filter.
	// Required.
	QuickDate ForumTopicsQuickDate

	// The sort mode.
	// Required.
	Sort ForumTopicsSort

	// The tags to search, if any.
	Tagstring string
}

// ForumGetTopicsPaged: Get topics from any forum.
//
// URL: /Forum/GetTopicsPaged/{page}/{pageSize}/{group}/{sort}/{quickDate}/{categoryFilter}/
//
// Operation: Forum.GetTopicsPaged
func (a API) ForumGetTopicsPaged(ctx context.Context, req ForumGetTopicsPagedRequest) (*ServerResponse[PostSearchResponse], error) {
	//	{
	//	  "description": "Get topics from any forum.",
	//	  "operationId": "Forum.GetTopicsPaged",
	//	  "parameters": [
	//	    {
	//	      "description": "A category filter",
	//	      "in": "path",
	//	      "name": "categoryFilter",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": true,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Forum.ForumTopicsCategoryFiltersEnum"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "The group, if any.",
	//	      "in": "path",
	//	      "name": "group",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Comma seperated list of locales posts must match to return in the result list. Default 'en'",
	//	      "in": "query",
	//	      "name": "locales",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "Zero paged page number",
	//	      "in": "path",
	//	      "name": "page",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "Unused",
	//	      "in": "path",
	//	      "name": "pageSize",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "A date filter.",
	//	      "in": "path",
	//	      "name": "quickDate",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Forum.ForumTopicsQuickDateEnum"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "The sort mode.",
	//	      "in": "path",
	//	      "name": "sort",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "byte",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Forum.ForumTopicsSortEnum"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "The tags to search, if any.",
	//	      "in": "query",
	//	      "name": "tagstring",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Forum.PostSearchResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Forum"
	//	  ]
	//	}
	var resp ServerResponse[PostSearchResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Forum.GetTopicsPaged",
		Method:   "GET",
		PathSpec: "/Forum/GetTopicsPaged/{page}/{pageSize}/{group}/{sort}/{quickDate}/{categoryFilter}/", PathParams: map[string]string{
			"categoryFilter": fmt.Sprint(req.CategoryFilter),
			"group":          fmt.Sprint(req.Group),
			"page":           fmt.Sprint(req.Page),
			"pageSize":       fmt.Sprint(req.PageSize),
			"quickDate":      fmt.Sprint(req.QuickDate),
			"sort":           fmt.Sprint(req.Sort),
		}, QueryParams: url.Values{
			"locales":   {fmt.Sprint(req.Locales)},
			"tagstring": {fmt.Sprint(req.Tagstring)},
		}}, &resp)
	return &resp, err
}

// ForumGetPostsThreadedPagedFromChildRequest are the request parameters for operation
// Forum.GetPostsThreadedPagedFromChild
type ForumGetPostsThreadedPagedFromChildRequest struct {

	// Required.
	ChildPostID Int64

	// Required.
	Page int32

	// Required.
	PageSize int32

	// Required.
	ReplySize int32

	// Required.
	RootThreadMode bool

	// If this value is not null or empty, banned posts are requested to be returned
	Showbanned string

	// Required.
	SortMode ForumPostSort
}

// ForumGetPostsThreadedPagedFromChild: Returns a thread of posts starting at the topicId of the input
// childPostId, optionally returning replies to those posts as well as the original parent.
//
// URL:
// /Forum/GetPostsThreadedPagedFromChild/{childPostId}/{page}/{pageSize}/{replySize}/{rootThreadMode}/{sortMode}/
//
// Operation: Forum.GetPostsThreadedPagedFromChild
func (a API) ForumGetPostsThreadedPagedFromChild(ctx context.Context, req ForumGetPostsThreadedPagedFromChildRequest) (*ServerResponse[PostSearchResponse], error) {
	//	{
	//	  "description": "Returns a thread of posts starting at the topicId of the input childPostId, optionally returning replies to those posts as well as the original parent.",
	//	  "operationId": "Forum.GetPostsThreadedPagedFromChild",
	//	  "parameters": [
	//	    {
	//	      "in": "path",
	//	      "name": "childPostId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "page",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "pageSize",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "replySize",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "rootThreadMode",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    },
	//	    {
	//	      "description": "If this value is not null or empty, banned posts are requested to be returned",
	//	      "in": "query",
	//	      "name": "showbanned",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "sortMode",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Forum.ForumPostSortEnum"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Forum.PostSearchResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Forum"
	//	  ]
	//	}
	var resp ServerResponse[PostSearchResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Forum.GetPostsThreadedPagedFromChild",
		Method:   "GET",
		PathSpec: "/Forum/GetPostsThreadedPagedFromChild/{childPostId}/{page}/{pageSize}/{replySize}/{rootThreadMode}/{sortMode}/", PathParams: map[string]string{
			"childPostId":    fmt.Sprint(req.ChildPostID),
			"page":           fmt.Sprint(req.Page),
			"pageSize":       fmt.Sprint(req.PageSize),
			"replySize":      fmt.Sprint(req.ReplySize),
			"rootThreadMode": fmt.Sprint(req.RootThreadMode),
			"sortMode":       fmt.Sprint(req.SortMode),
		}, QueryParams: url.Values{
			"showbanned": {fmt.Sprint(req.Showbanned)},
		}}, &resp)
	return &resp, err
}

// ForumGetPostsThreadedPagedRequest are the request parameters for operation
// Forum.GetPostsThreadedPaged
type ForumGetPostsThreadedPagedRequest struct {

	// Required.
	GetParentPost bool

	// Required.
	Page int32

	// Required.
	PageSize int32

	// Required.
	ParentPostID Int64

	// Required.
	ReplySize int32

	// Required.
	RootThreadMode bool

	// If this value is not null or empty, banned posts are requested to be returned
	Showbanned string

	// Required.
	SortMode ForumPostSort
}

// ForumGetPostsThreadedPaged: Returns a thread of posts at the given parent, optionally returning
// replies to those posts as well as the original parent.
//
// URL:
// /Forum/GetPostsThreadedPaged/{parentPostId}/{page}/{pageSize}/{replySize}/{getParentPost}/{rootThreadMode}/{sortMode}/
//
// Operation: Forum.GetPostsThreadedPaged
func (a API) ForumGetPostsThreadedPaged(ctx context.Context, req ForumGetPostsThreadedPagedRequest) (*ServerResponse[PostSearchResponse], error) {
	//	{
	//	  "description": "Returns a thread of posts at the given parent, optionally returning replies to those posts as well as the original parent.",
	//	  "operationId": "Forum.GetPostsThreadedPaged",
	//	  "parameters": [
	//	    {
	//	      "in": "path",
	//	      "name": "getParentPost",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "page",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "pageSize",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "parentPostId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "replySize",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "rootThreadMode",
	//	      "required": true,
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    },
	//	    {
	//	      "description": "If this value is not null or empty, banned posts are requested to be returned",
	//	      "in": "query",
	//	      "name": "showbanned",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "in": "path",
	//	      "name": "sortMode",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Forum.ForumPostSortEnum"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/Forum.PostSearchResponse"
	//	    }
	//	  },
	//	  "tags": [
	//	    "Forum"
	//	  ]
	//	}
	var resp ServerResponse[PostSearchResponse]
	err := a.client.Do(ctx, ClientRequest{Operation: "Forum.GetPostsThreadedPaged",
		Method:   "GET",
		PathSpec: "/Forum/GetPostsThreadedPaged/{parentPostId}/{page}/{pageSize}/{replySize}/{getParentPost}/{rootThreadMode}/{sortMode}/", PathParams: map[string]string{
			"getParentPost":  fmt.Sprint(req.GetParentPost),
			"page":           fmt.Sprint(req.Page),
			"pageSize":       fmt.Sprint(req.PageSize),
			"parentPostId":   fmt.Sprint(req.ParentPostID),
			"replySize":      fmt.Sprint(req.ReplySize),
			"rootThreadMode": fmt.Sprint(req.RootThreadMode),
			"sortMode":       fmt.Sprint(req.SortMode),
		}, QueryParams: url.Values{
			"showbanned": {fmt.Sprint(req.Showbanned)},
		}}, &resp)
	return &resp, err
}

// FireteamGetAvailableClanFireteamsRequest are the request parameters for operation
// Fireteam.GetAvailableClanFireteams
type FireteamGetAvailableClanFireteamsRequest struct {

	// The activity type to filter by.
	// Required.
	ActivityType int32

	// The date range to grab available fireteams.
	// Required.
	DateRange FireteamDateRange

	// If you wish the result to exclude immediate fireteams, set this to true. Immediate-only can be
	// forced using the dateRange enum.
	ExcludeImmediate bool

	// The group id of the clan.
	// Required.
	GroupID Int64

	// An optional language filter.
	LangFilter string

	// Zero based page
	// Required.
	Page int32

	// The platform filter.
	// Required.
	Platform FireteamPlatform

	// Determines public/private filtering.
	// Required.
	PublicOnly FireteamPublicSearchOption

	// Filters based on available slots
	// Required.
	SlotFilter FireteamSlotSearch
}

// FireteamGetAvailableClanFireteams: Gets a listing of all of this clan's fireteams that are have
// available slots. Caller is not checked for join criteria so caching is maximized.
//
// URL:
// /Fireteam/Clan/{groupId}/Available/{platform}/{activityType}/{dateRange}/{slotFilter}/{publicOnly}/{page}/
//
// Operation: Fireteam.GetAvailableClanFireteams
//
// Scope: oauth2 [ReadGroups]
func (a API) FireteamGetAvailableClanFireteams(ctx context.Context, req FireteamGetAvailableClanFireteamsRequest) (*ServerResponse[SearchResult[FireteamSummary]], error) {
	//	{
	//	  "description": "Gets a listing of all of this clan's fireteams that are have available slots. Caller is not checked for join criteria so caching is maximized.",
	//	  "operationId": "Fireteam.GetAvailableClanFireteams",
	//	  "parameters": [
	//	    {
	//	      "description": "The activity type to filter by.",
	//	      "in": "path",
	//	      "name": "activityType",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The date range to grab available fireteams.",
	//	      "in": "path",
	//	      "name": "dateRange",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "byte",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Fireteam.FireteamDateRange"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "If you wish the result to exclude immediate fireteams, set this to true. Immediate-only can be forced using the dateRange enum.",
	//	      "in": "query",
	//	      "name": "excludeImmediate",
	//	      "schema": {
	//	        "type": "boolean"
	//	      }
	//	    },
	//	    {
	//	      "description": "The group id of the clan.",
	//	      "in": "path",
	//	      "name": "groupId",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int64",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "An optional language filter.",
	//	      "in": "query",
	//	      "name": "langFilter",
	//	      "schema": {
	//	        "type": "string"
	//	      }
	//	    },
	//	    {
	//	      "description": "Zero based page",
	//	      "in": "path",
	//	      "name": "page",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "int32",
	//	        "type": "integer"
	//	      }
	//	    },
	//	    {
	//	      "description": "The platform filter.",
	//	      "in": "path",
	//	      "name": "platform",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "byte",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Fireteam.FireteamPlatform"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Determines public/private filtering.",
	//	      "in": "path",
	//	      "name": "publicOnly",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "byte",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Fireteam.FireteamPublicSearchOption"
	//	        }
	//	      }
	//	    },
	//	    {
	//	      "description": "Filters based on available slots",
	//	      "in": "path",
	//	      "name": "slotFilter",
	//	      "required": true,
	//	      "schema": {
	//	        "format": "byte",
	//	        "type": "integer",
	//	        "x-enum-is-bitmask": false,
	//	        "x-enum-reference": {
	//	          "$ref": "#/components/schemas/Fireteam.FireteamSlotSearch"
	//	        }
	//	      }
	//	    }
	//	  ],
	//	  "responses": {
	//	    "200": {
	//	      "$ref": "#/components/responses/SearchResultOfFireteamSummary"
	//	    }
	//	  },
	//	  "security": [
	//	    {
	//	      "oauth2": [
	//	        "ReadGroups"
	//	      ]
	//	    }
	//	  ],
	//	  "tags": [
	//	    "Fireteam"
	//	  ]
	//	}
	var resp ServerResponse[SearchResult[FireteamSummary]]
	err := a.client.Do(ctx, ClientRequest{Operation: "Fireteam.GetAvailableClanFireteams",
		Method:   "GET",
		PathSpec: "/Fireteam/Clan/{groupId}/Available/{platform}/{activityType}/{dateRange}/{slotFilter}/{publicOnly}/{page}/", PathParams: map[string]string{
			"activityType": fmt.Sprint(req.ActivityType),
			"dateRange":    fmt.Sprint(req.DateRange),
			"groupId":      fmt.Sprint(req.GroupID),
			"page":         fmt.Sprint(req.Page),
			"platform":     fmt.Sprint(req.Platform),
			"publicOnly":   fmt.Sprint(req.PublicOnly),
			"slotFilter":   fmt.Sprint(req.SlotFilter),
		}, QueryParams: url.Values{
			"excludeImmediate": {fmt.Sprint(req.ExcludeImmediate)},
			"langFilter":       {fmt.Sprint(req.LangFilter)},
		}}, &resp)
	return &resp, err
}

// Applications.ApiUsage
type ApiUsage struct {
	// {
	//   "properties": {
	//     "apiCalls": {
	//       "description": "Counts for on API calls made for the time range.",
	//       "items": {
	//         "$ref": "#/components/schemas/Applications.Series"
	//       },
	//       "type": "array"
	//     },
	//     "throttledRequests": {
	//       "description": "Instances of blocked requests or requests that crossed the warn threshold during the time range.",
	//       "items": {
	//         "$ref": "#/components/schemas/Applications.Series"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// Counts for on API calls made for the time range.
	ApiCalls []Series `json:"apiCalls"`

	// Instances of blocked requests or requests that crossed the warn threshold during the time range.
	ThrottledRequests []Series `json:"throttledRequests"`
}

// Applications.Application
type Application struct {
	// {
	//   "properties": {
	//     "applicationId": {
	//       "description": "Unique ID assigned to the application",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "applicationType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Applications.OAuthApplicationType"
	//       }
	//     },
	//     "creationDate": {
	//       "description": "Date the application was first added to our database.",
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "firstPublished": {
	//       "description": "Date the first time the application status entered the 'Public' status.",
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "link": {
	//       "description": "Link to website for the application where a user can learn more about the app.",
	//       "type": "string"
	//     },
	//     "name": {
	//       "description": "Name of the application",
	//       "type": "string"
	//     },
	//     "origin": {
	//       "description": "Value of the Origin header sent in requests generated by this application.",
	//       "type": "string"
	//     },
	//     "overrideAuthorizeViewName": {
	//       "description": "An optional override for the Authorize view name.",
	//       "type": "string"
	//     },
	//     "redirectUrl": {
	//       "description": "URL used to pass the user's authorization code to the application",
	//       "type": "string"
	//     },
	//     "scope": {
	//       "description": "Permissions the application needs to work",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "status": {
	//       "description": "Current status of the application.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Applications.ApplicationStatus"
	//       }
	//     },
	//     "statusChanged": {
	//       "description": "Date the application status last changed.",
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "team": {
	//       "description": "List of team members who manage this application on Bungie.net. Will always consist of at least the application owner.",
	//       "items": {
	//         "$ref": "#/components/schemas/Applications.ApplicationDeveloper"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// Unique ID assigned to the application
	ApplicationID int32 `json:"applicationId"`

	ApplicationType OAuthApplicationType `json:"applicationType"`

	// Date the application was first added to our database.
	CreationDate Timestamp `json:"creationDate"`

	// Date the first time the application status entered the 'Public' status.
	FirstPublished Timestamp `json:"firstPublished"`

	// Link to website for the application where a user can learn more about the app.
	Link string `json:"link"`

	// Name of the application
	Name string `json:"name"`

	// Value of the Origin header sent in requests generated by this application.
	Origin string `json:"origin"`

	// An optional override for the Authorize view name.
	OverrideAuthorizeViewName string `json:"overrideAuthorizeViewName"`

	// URL used to pass the user's authorization code to the application
	RedirectUrl string `json:"redirectUrl"`

	// Permissions the application needs to work
	Scope Int64 `json:"scope"`

	// Current status of the application.
	Status ApplicationStatus `json:"status"`

	// Date the application status last changed.
	StatusChanged Timestamp `json:"statusChanged"`

	// List of team members who manage this application on Bungie.net. Will always consist of at least the
	// application owner.
	Team []ApplicationDeveloper `json:"team"`
}

// Applications.ApplicationDeveloper
type ApplicationDeveloper struct {
	// {
	//   "properties": {
	//     "apiEulaVersion": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "role": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Applications.DeveloperRole"
	//       }
	//     },
	//     "user": {
	//       "$ref": "#/components/schemas/User.UserInfoCard"
	//     }
	//   },
	//   "type": "object"
	// }

	ApiEulaVersion int32 `json:"apiEulaVersion"`

	Role DeveloperRole `json:"role"`

	User UserInfoCard `json:"user"`
}

// Applications.ApplicationScopes
type ApplicationScopes Int64

const (
	ApplicationScopes_ReadBasicUserProfile          = ApplicationScopes(1)
	ApplicationScopes_ReadGroups                    = ApplicationScopes(2)
	ApplicationScopes_WriteGroups                   = ApplicationScopes(4)
	ApplicationScopes_AdminGroups                   = ApplicationScopes(8)
	ApplicationScopes_BnetWrite                     = ApplicationScopes(16)
	ApplicationScopes_MoveEquipDestinyItems         = ApplicationScopes(32)
	ApplicationScopes_ReadDestinyInventoryAndVault  = ApplicationScopes(64)
	ApplicationScopes_ReadUserData                  = ApplicationScopes(128)
	ApplicationScopes_EditUserData                  = ApplicationScopes(256)
	ApplicationScopes_ReadDestinyVendorsAndAdvisors = ApplicationScopes(512)
	ApplicationScopes_ReadAndApplyTokens            = ApplicationScopes(1024)
	ApplicationScopes_AdvancedWriteActions          = ApplicationScopes(2048)
	ApplicationScopes_PartnerOfferGrant             = ApplicationScopes(4096)
	ApplicationScopes_DestinyUnlockValueQuery       = ApplicationScopes(8192)
	ApplicationScopes_UserPiiRead                   = ApplicationScopes(16384)
)

// Applications.ApplicationStatus
type ApplicationStatus int32

const (
	ApplicationStatus_None     = ApplicationStatus(0)
	ApplicationStatus_Private  = ApplicationStatus(1)
	ApplicationStatus_Public   = ApplicationStatus(2)
	ApplicationStatus_Disabled = ApplicationStatus(3)
	ApplicationStatus_Blocked  = ApplicationStatus(4)
)

// Applications.Datapoint
type Datapoint struct {
	// {
	//   "properties": {
	//     "count": {
	//       "description": "Count associated with timestamp",
	//       "format": "double",
	//       "nullable": true,
	//       "type": "number"
	//     },
	//     "time": {
	//       "description": "Timestamp for the related count.",
	//       "format": "date-time",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// Count associated with timestamp
	Count Nullable[float64] `json:"count,omitempty"`

	// Timestamp for the related count.
	Time Timestamp `json:"time"`
}

// Applications.DeveloperRole
type DeveloperRole int32

const (
	DeveloperRole_None       = DeveloperRole(0)
	DeveloperRole_Owner      = DeveloperRole(1)
	DeveloperRole_TeamMember = DeveloperRole(2)
)

// Applications.OAuthApplicationType
type OAuthApplicationType int32

const (
	OAuthApplicationType_None         = OAuthApplicationType(0)
	OAuthApplicationType_Confidential = OAuthApplicationType(1)
	OAuthApplicationType_Public       = OAuthApplicationType(2)
)

// Applications.Series
type Series struct {
	// {
	//   "properties": {
	//     "datapoints": {
	//       "description": "Collection of samples with time and value.",
	//       "items": {
	//         "$ref": "#/components/schemas/Applications.Datapoint"
	//       },
	//       "type": "array"
	//     },
	//     "target": {
	//       "description": "Target to which to datapoints apply.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// Collection of samples with time and value.
	Datapoints []Datapoint `json:"datapoints"`

	// Target to which to datapoints apply.
	Target string `json:"target"`
}

// BungieCredentialType
//
// The types of credentials the Accounts system supports. This is the external facing enum used in
// place of the internal-only Bungie.SharedDefinitions.CredentialType.
type BungieCredentialType int

const (
	BungieCredentialType_None        = BungieCredentialType(0)
	BungieCredentialType_Xuid        = BungieCredentialType(1)
	BungieCredentialType_Psnid       = BungieCredentialType(2)
	BungieCredentialType_Wlid        = BungieCredentialType(3)
	BungieCredentialType_Fake        = BungieCredentialType(4)
	BungieCredentialType_Facebook    = BungieCredentialType(5)
	BungieCredentialType_Google      = BungieCredentialType(8)
	BungieCredentialType_Windows     = BungieCredentialType(9)
	BungieCredentialType_DemonId     = BungieCredentialType(10)
	BungieCredentialType_SteamId     = BungieCredentialType(12)
	BungieCredentialType_BattleNetId = BungieCredentialType(14)
	BungieCredentialType_StadiaId    = BungieCredentialType(16)
	BungieCredentialType_TwitchId    = BungieCredentialType(18)
	BungieCredentialType_EgsId       = BungieCredentialType(20)
)

// BungieMembershipType
//
// The types of membership the Accounts system supports. This is the external facing enum used in place
// of the internal-only Bungie.SharedDefinitions.MembershipType.
type BungieMembershipType int32

const (
	BungieMembershipType_None          = BungieMembershipType(0)
	BungieMembershipType_TigerXbox     = BungieMembershipType(1)
	BungieMembershipType_TigerPsn      = BungieMembershipType(2)
	BungieMembershipType_TigerSteam    = BungieMembershipType(3)
	BungieMembershipType_TigerBlizzard = BungieMembershipType(4)
	BungieMembershipType_TigerStadia   = BungieMembershipType(5)
	BungieMembershipType_TigerEgs      = BungieMembershipType(6)
	BungieMembershipType_TigerDemon    = BungieMembershipType(10)
	BungieMembershipType_BungieNext    = BungieMembershipType(254)
	BungieMembershipType_All           = BungieMembershipType(-1)
)

// BungieMembershipType[]
//
//

// Common.Models.CoreSetting
type CoreSetting struct {
	// {
	//   "properties": {
	//     "childSettings": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "displayName": {
	//       "type": "string"
	//     },
	//     "identifier": {
	//       "type": "string"
	//     },
	//     "imagePath": {
	//       "type": "string"
	//     },
	//     "isDefault": {
	//       "type": "boolean"
	//     },
	//     "summary": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	ChildSettings []CoreSetting `json:"childSettings"`

	DisplayName string `json:"displayName"`

	Identifier string `json:"identifier"`

	ImagePath string `json:"imagePath"`

	IsDefault bool `json:"isDefault"`

	Summary string `json:"summary"`
}

// Common.Models.CoreSettingsConfiguration
type CoreSettingsConfiguration struct {
	// {
	//   "properties": {
	//     "clanBannerDecalColors": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "clanBannerDecals": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "clanBannerGonfalonColors": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "clanBannerGonfalonDetailColors": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "clanBannerGonfalonDetails": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "clanBannerGonfalons": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "clanBannerStandards": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "defaultGroupTheme": {
	//       "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//     },
	//     "destiny2CoreSettings": {
	//       "$ref": "#/components/schemas/Common.Models.Destiny2CoreSettings"
	//     },
	//     "destinyMembershipTypes": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "emailSettings": {
	//       "$ref": "#/components/schemas/User.EmailSettings"
	//     },
	//     "environment": {
	//       "type": "string"
	//     },
	//     "fireteamActivities": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "forumCategories": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "groupAvatars": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "ignoreReasons": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "recruitmentActivities": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "recruitmentMiscTags": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "recruitmentPlatformTags": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "systemContentLocales": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     },
	//     "systems": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSystem"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "userContentLocales": {
	//       "items": {
	//         "$ref": "#/components/schemas/Common.Models.CoreSetting"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	ClanBannerDecalColors []CoreSetting `json:"clanBannerDecalColors"`

	ClanBannerDecals []CoreSetting `json:"clanBannerDecals"`

	ClanBannerGonfalonColors []CoreSetting `json:"clanBannerGonfalonColors"`

	ClanBannerGonfalonDetailColors []CoreSetting `json:"clanBannerGonfalonDetailColors"`

	ClanBannerGonfalonDetails []CoreSetting `json:"clanBannerGonfalonDetails"`

	ClanBannerGonfalons []CoreSetting `json:"clanBannerGonfalons"`

	ClanBannerStandards []CoreSetting `json:"clanBannerStandards"`

	DefaultGroupTheme CoreSetting `json:"defaultGroupTheme"`

	Destiny2CoreSettings CoreSettings `json:"destiny2CoreSettings"`

	DestinyMembershipTypes []CoreSetting `json:"destinyMembershipTypes"`

	EmailSettings EmailSettings `json:"emailSettings"`

	Environment string `json:"environment"`

	FireteamActivities []CoreSetting `json:"fireteamActivities"`

	ForumCategories []CoreSetting `json:"forumCategories"`

	GroupAvatars []CoreSetting `json:"groupAvatars"`

	IgnoreReasons []CoreSetting `json:"ignoreReasons"`

	RecruitmentActivities []CoreSetting `json:"recruitmentActivities"`

	RecruitmentMiscTags []CoreSetting `json:"recruitmentMiscTags"`

	RecruitmentPlatformTags []CoreSetting `json:"recruitmentPlatformTags"`

	SystemContentLocales []CoreSetting `json:"systemContentLocales"`

	Systems map[string]CoreSystem `json:"systems"`

	UserContentLocales []CoreSetting `json:"userContentLocales"`
}

// Common.Models.CoreSystem
type CoreSystem struct {
	// {
	//   "properties": {
	//     "enabled": {
	//       "type": "boolean"
	//     },
	//     "parameters": {
	//       "additionalProperties": {
	//         "type": "string"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	Enabled bool `json:"enabled"`

	Parameters map[string]string `json:"parameters"`
}

// Common.Models.Destiny2CoreSettings
type CoreSettings struct {
	// {
	//   "properties": {
	//     "activeSealsRootNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "activeTriumphsRootNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "ammoTypeHeavyIcon": {
	//       "type": "string"
	//     },
	//     "ammoTypePrimaryIcon": {
	//       "type": "string"
	//     },
	//     "ammoTypeSpecialIcon": {
	//       "type": "string"
	//     },
	//     "badgesRootNode": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "collectionRootNode": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "craftingRootNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "currentRankProgressionHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionDefinition"
	//       }
	//     },
	//     "currentSeasonHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Seasons.DestinySeasonDefinition"
	//       }
	//     },
	//     "currentSeasonalArtifactHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     },
	//     "enabledFireteamFinderActivityGraphHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderActivityGraphDefinition"
	//       }
	//     },
	//     "exoticCatalystsRootNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "fireteamFinderConstantsHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderConstantsDefinition"
	//       }
	//     },
	//     "futureSeasonHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Seasons.DestinySeasonDefinition"
	//       }
	//     },
	//     "guardianRankConstantsHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.GuardianRanks.DestinyGuardianRankConstantsDefinition"
	//       }
	//     },
	//     "guardianRanksRootNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "insertPlugFreeBlockedSocketTypeHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinySocketTypeDefinition"
	//       }
	//     },
	//     "insertPlugFreeProtectedPlugItemHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "legacySealsRootNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "legacyTriumphsRootNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "loadoutConstantsHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Loadouts.DestinyLoadoutConstantsDefinition"
	//       }
	//     },
	//     "loreRootNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "medalsRootNode": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "medalsRootNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "metricsRootNode": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "pastSeasonHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Seasons.DestinySeasonDefinition"
	//       }
	//     },
	//     "recordsRootNode": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "seasonalChallengesPresentationNodeHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "undiscoveredCollectibleImage": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	ActiveSealsRootNodeHash Hash[PresentationNodeDefinition] `json:"activeSealsRootNodeHash"`

	ActiveTriumphsRootNodeHash Hash[PresentationNodeDefinition] `json:"activeTriumphsRootNodeHash"`

	AmmoTypeHeavyIcon string `json:"ammoTypeHeavyIcon"`

	AmmoTypePrimaryIcon string `json:"ammoTypePrimaryIcon"`

	AmmoTypeSpecialIcon string `json:"ammoTypeSpecialIcon"`

	BadgesRootNode Hash[PresentationNodeDefinition] `json:"badgesRootNode"`

	CollectionRootNode Hash[PresentationNodeDefinition] `json:"collectionRootNode"`

	CraftingRootNodeHash Hash[PresentationNodeDefinition] `json:"craftingRootNodeHash"`

	CurrentRankProgressionHashes []uint32 `json:"currentRankProgressionHashes"`

	CurrentSeasonHash Nullable[Hash[SeasonDefinition]] `json:"currentSeasonHash,omitempty"`

	CurrentSeasonalArtifactHash Hash[VendorDefinition] `json:"currentSeasonalArtifactHash"`

	EnabledFireteamFinderActivityGraphHashes []uint32 `json:"enabledFireteamFinderActivityGraphHashes"`

	ExoticCatalystsRootNodeHash Hash[PresentationNodeDefinition] `json:"exoticCatalystsRootNodeHash"`

	FireteamFinderConstantsHash Hash[FireteamFinderConstantsDefinition] `json:"fireteamFinderConstantsHash"`

	FutureSeasonHashes []uint32 `json:"futureSeasonHashes"`

	GuardianRankConstantsHash Hash[GuardianRankConstantsDefinition] `json:"guardianRankConstantsHash"`

	GuardianRanksRootNodeHash Hash[PresentationNodeDefinition] `json:"guardianRanksRootNodeHash"`

	InsertPlugFreeBlockedSocketTypeHashes []uint32 `json:"insertPlugFreeBlockedSocketTypeHashes"`

	InsertPlugFreeProtectedPlugItemHashes []uint32 `json:"insertPlugFreeProtectedPlugItemHashes"`

	LegacySealsRootNodeHash Hash[PresentationNodeDefinition] `json:"legacySealsRootNodeHash"`

	LegacyTriumphsRootNodeHash Hash[PresentationNodeDefinition] `json:"legacyTriumphsRootNodeHash"`

	LoadoutConstantsHash Hash[LoadoutConstantsDefinition] `json:"loadoutConstantsHash"`

	LoreRootNodeHash Hash[PresentationNodeDefinition] `json:"loreRootNodeHash"`

	MedalsRootNode Hash[PresentationNodeDefinition] `json:"medalsRootNode"`

	MedalsRootNodeHash Hash[PresentationNodeDefinition] `json:"medalsRootNodeHash"`

	MetricsRootNode Hash[PresentationNodeDefinition] `json:"metricsRootNode"`

	PastSeasonHashes []uint32 `json:"pastSeasonHashes"`

	RecordsRootNode Hash[PresentationNodeDefinition] `json:"recordsRootNode"`

	SeasonalChallengesPresentationNodeHash Nullable[Hash[PresentationNodeDefinition]] `json:"seasonalChallengesPresentationNodeHash,omitempty"`

	UndiscoveredCollectibleImage string `json:"undiscoveredCollectibleImage"`
}

// Components.ComponentPrivacySetting
//
// A set of flags for reason(s) why the component populated in the way that it did. Inspect the
// individual flags for the reasons.
type ComponentPrivacySetting int32

const (
	ComponentPrivacySetting_None    = ComponentPrivacySetting(0)
	ComponentPrivacySetting_Public  = ComponentPrivacySetting(1)
	ComponentPrivacySetting_Private = ComponentPrivacySetting(2)
)

// Components.ComponentResponse
//
// The base class for any component-returning object that may need to indicate information about the
// state of the component being returned.
type ComponentResponse[T any] struct {
	Data T `json:"data"`
	// {
	//   "description": "The base class for any component-returning object that may need to indicate information about the state of the component being returned.",
	//   "properties": {
	//     "disabled": {
	//       "description": "If true, this component is disabled.",
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "privacy": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Components.ComponentPrivacySetting"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// If true, this component is disabled.
	Disabled Nullable[bool] `json:"disabled,omitempty"`

	Privacy ComponentPrivacySetting `json:"privacy"`
}

// Config.ClanBanner.ClanBannerDecal
type ClanBannerDecal struct {
	// {
	//   "properties": {
	//     "backgroundPath": {
	//       "type": "string"
	//     },
	//     "foregroundPath": {
	//       "type": "string"
	//     },
	//     "identifier": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	BackgroundPath string `json:"backgroundPath"`

	ForegroundPath string `json:"foregroundPath"`

	Identifier string `json:"identifier"`
}

// Config.ClanBanner.ClanBannerSource
type ClanBannerSource map[string]any

//	{
//	  "type": "object"
//	}
//
// Config.GroupTheme
type GroupTheme struct {
	// {
	//   "properties": {
	//     "description": {
	//       "type": "string"
	//     },
	//     "folder": {
	//       "type": "string"
	//     },
	//     "name": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Description string `json:"description"`

	Folder string `json:"folder"`

	Name string `json:"name"`
}

// Config.UserTheme
type UserTheme struct {
	// {
	//   "properties": {
	//     "userThemeDescription": {
	//       "type": "string"
	//     },
	//     "userThemeId": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "userThemeName": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	UserThemeDescription string `json:"userThemeDescription"`

	UserThemeID int32 `json:"userThemeId"`

	UserThemeName string `json:"userThemeName"`
}

// Content.CommentSummary
type CommentSummary struct {
	// {
	//   "properties": {
	//     "commentCount": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "topicId": {
	//       "format": "int64",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	CommentCount int32 `json:"commentCount"`

	TopicID Int64 `json:"topicId"`
}

// Content.ContentItemPublicContract
type ContentItemPublicContract struct {
	// {
	//   "properties": {
	//     "allowComments": {
	//       "type": "boolean"
	//     },
	//     "author": {
	//       "$ref": "#/components/schemas/User.GeneralUser"
	//     },
	//     "autoEnglishPropertyFallback": {
	//       "type": "boolean"
	//     },
	//     "cType": {
	//       "type": "string"
	//     },
	//     "cmsPath": {
	//       "type": "string"
	//     },
	//     "commentSummary": {
	//       "$ref": "#/components/schemas/Content.CommentSummary"
	//     },
	//     "contentId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "creationDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "hasAgeGate": {
	//       "type": "boolean"
	//     },
	//     "minimumAge": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "modifyDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "properties": {
	//       "additionalProperties": {
	//         "type": "object"
	//       },
	//       "description": "Firehose content is really a collection of metadata and \"properties\", which are the potentially-but-not-strictly localizable data that comprises the meat of whatever content is being shown.\r\nAs Cole Porter would have crooned, \"Anything Goes\" with Firehose properties. They are most often strings, but they can theoretically be anything. They are JSON encoded, and could be JSON structures, simple strings, numbers etc... The Content Type of the item (cType) will describe the properties, and thus how they ought to be deserialized.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "ratingImagePath": {
	//       "type": "string"
	//     },
	//     "representations": {
	//       "items": {
	//         "$ref": "#/components/schemas/Content.ContentRepresentation"
	//       },
	//       "type": "array"
	//     },
	//     "tags": {
	//       "description": "NOTE: Tags will always be lower case.",
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	AllowComments bool `json:"allowComments"`

	Author GeneralUser `json:"author"`

	AutoEnglishPropertyFallback bool `json:"autoEnglishPropertyFallback"`

	CType string `json:"cType"`

	CmsPath string `json:"cmsPath"`

	CommentSummary CommentSummary `json:"commentSummary"`

	ContentID Int64 `json:"contentId"`

	CreationDate Timestamp `json:"creationDate"`

	HasAgeGate bool `json:"hasAgeGate"`

	MinimumAge int32 `json:"minimumAge"`

	ModifyDate Timestamp `json:"modifyDate"`

	// Firehose content is really a collection of metadata and "properties", which are the
	// potentially-but-not-strictly localizable data that comprises the meat of whatever content is being
	// shown.
	// As Cole Porter would have crooned, "Anything Goes" with Firehose properties. They are most often
	// strings, but they can theoretically be anything. They are JSON encoded, and could be JSON
	// structures, simple strings, numbers etc... The Content Type of the item (cType) will describe the
	// properties, and thus how they ought to be deserialized.
	Properties map[string]any `json:"properties"`

	RatingImagePath string `json:"ratingImagePath"`

	Representations []ContentRepresentation `json:"representations"`

	// NOTE: Tags will always be lower case.
	Tags []string `json:"tags"`
}

// Content.ContentRepresentation
type ContentRepresentation struct {
	// {
	//   "properties": {
	//     "name": {
	//       "type": "string"
	//     },
	//     "path": {
	//       "type": "string"
	//     },
	//     "validationString": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Name string `json:"name"`

	Path string `json:"path"`

	ValidationString string `json:"validationString"`
}

// Content.Models.ContentPreview
type ContentPreview struct {
	// {
	//   "properties": {
	//     "itemInSet": {
	//       "type": "boolean"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "path": {
	//       "type": "string"
	//     },
	//     "setNesting": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "setTag": {
	//       "type": "string"
	//     },
	//     "useSetId": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	ItemInSet bool `json:"itemInSet"`

	Name string `json:"name"`

	Path string `json:"path"`

	SetNesting int32 `json:"setNesting"`

	SetTag string `json:"setTag"`

	UseSetID int32 `json:"useSetId"`
}

// Content.Models.ContentPropertyDataTypeEnum
type ContentPropertyDataType int32

const (
	ContentPropertyDataType_None               = ContentPropertyDataType(0)
	ContentPropertyDataType_Plaintext          = ContentPropertyDataType(1)
	ContentPropertyDataType_Html               = ContentPropertyDataType(2)
	ContentPropertyDataType_Dropdown           = ContentPropertyDataType(3)
	ContentPropertyDataType_List               = ContentPropertyDataType(4)
	ContentPropertyDataType_Json               = ContentPropertyDataType(5)
	ContentPropertyDataType_Content            = ContentPropertyDataType(6)
	ContentPropertyDataType_Representation     = ContentPropertyDataType(7)
	ContentPropertyDataType_Set                = ContentPropertyDataType(8)
	ContentPropertyDataType_File               = ContentPropertyDataType(9)
	ContentPropertyDataType_FolderSet          = ContentPropertyDataType(10)
	ContentPropertyDataType_Date               = ContentPropertyDataType(11)
	ContentPropertyDataType_MultilinePlaintext = ContentPropertyDataType(12)
	ContentPropertyDataType_DestinyContent     = ContentPropertyDataType(13)
	ContentPropertyDataType_Color              = ContentPropertyDataType(14)
)

// Content.Models.ContentTypeDefaultValue
type ContentTypeDefaultValue struct {
	// {
	//   "properties": {
	//     "defaultValue": {
	//       "type": "string"
	//     },
	//     "whenClause": {
	//       "type": "string"
	//     },
	//     "whenValue": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	DefaultValue string `json:"defaultValue"`

	WhenClause string `json:"whenClause"`

	WhenValue string `json:"whenValue"`
}

// Content.Models.ContentTypeDescription
type ContentTypeDescription struct {
	// {
	//   "properties": {
	//     "allowComments": {
	//       "type": "boolean"
	//     },
	//     "autoEnglishPropertyFallback": {
	//       "type": "boolean"
	//     },
	//     "bindIdentifierToProperty": {
	//       "type": "string"
	//     },
	//     "boundRegex": {
	//       "type": "string"
	//     },
	//     "bulkUploadable": {
	//       "type": "boolean"
	//     },
	//     "cType": {
	//       "type": "string"
	//     },
	//     "contentDescription": {
	//       "type": "string"
	//     },
	//     "forceIdentifierBinding": {
	//       "type": "boolean"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "previewImage": {
	//       "type": "string"
	//     },
	//     "previews": {
	//       "items": {
	//         "$ref": "#/components/schemas/Content.Models.ContentPreview"
	//       },
	//       "type": "array"
	//     },
	//     "priority": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "properties": {
	//       "items": {
	//         "$ref": "#/components/schemas/Content.Models.ContentTypeProperty"
	//       },
	//       "type": "array"
	//     },
	//     "propertySections": {
	//       "items": {
	//         "$ref": "#/components/schemas/Content.Models.ContentTypePropertySection"
	//       },
	//       "type": "array"
	//     },
	//     "reminder": {
	//       "type": "string"
	//     },
	//     "showInContentEditor": {
	//       "type": "boolean"
	//     },
	//     "suppressCmsPath": {
	//       "type": "boolean"
	//     },
	//     "tagMetadata": {
	//       "items": {
	//         "$ref": "#/components/schemas/Content.Models.TagMetadataDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "tagMetadataItems": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Content.Models.TagMetadataItem"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "typeOf": {
	//       "type": "string"
	//     },
	//     "usageExamples": {
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	AllowComments bool `json:"allowComments"`

	AutoEnglishPropertyFallback bool `json:"autoEnglishPropertyFallback"`

	BindIdentifierToProperty string `json:"bindIdentifierToProperty"`

	BoundRegex string `json:"boundRegex"`

	BulkUploadable bool `json:"bulkUploadable"`

	CType string `json:"cType"`

	ContentDescription string `json:"contentDescription"`

	ForceIdentifierBinding bool `json:"forceIdentifierBinding"`

	Name string `json:"name"`

	PreviewImage string `json:"previewImage"`

	Previews []ContentPreview `json:"previews"`

	Priority int32 `json:"priority"`

	Properties []ContentTypeProperty `json:"properties"`

	PropertySections []ContentTypePropertySection `json:"propertySections"`

	Reminder string `json:"reminder"`

	ShowInContentEditor bool `json:"showInContentEditor"`

	SuppressCmsPath bool `json:"suppressCmsPath"`

	TagMetadata []TagMetadataDefinition `json:"tagMetadata"`

	TagMetadataItems map[string]TagMetadataItem `json:"tagMetadataItems"`

	TypeOf string `json:"typeOf"`

	UsageExamples []string `json:"usageExamples"`
}

// Content.Models.ContentTypeProperty
type ContentTypeProperty struct {
	// {
	//   "properties": {
	//     "attributes": {
	//       "additionalProperties": {
	//         "type": "string"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "bindToProperty": {
	//       "type": "string"
	//     },
	//     "boundRegex": {
	//       "type": "string"
	//     },
	//     "childProperties": {
	//       "items": {
	//         "$ref": "#/components/schemas/Content.Models.ContentTypeProperty"
	//       },
	//       "type": "array"
	//     },
	//     "contentTypeAllowed": {
	//       "type": "string"
	//     },
	//     "datatype": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Content.Models.ContentPropertyDataTypeEnum"
	//       }
	//     },
	//     "defaultValues": {
	//       "items": {
	//         "$ref": "#/components/schemas/Content.Models.ContentTypeDefaultValue"
	//       },
	//       "type": "array"
	//     },
	//     "enabled": {
	//       "type": "boolean"
	//     },
	//     "entitytype": {
	//       "type": "string"
	//     },
	//     "fallback": {
	//       "type": "boolean"
	//     },
	//     "isCombo": {
	//       "type": "boolean"
	//     },
	//     "isExternalAllowed": {
	//       "type": "boolean"
	//     },
	//     "isImage": {
	//       "type": "boolean"
	//     },
	//     "isTitle": {
	//       "type": "boolean"
	//     },
	//     "isVideo": {
	//       "type": "boolean"
	//     },
	//     "legalContentTypes": {
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     },
	//     "localizable": {
	//       "type": "boolean"
	//     },
	//     "maxByteLength": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "maxFileSize": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "maxHeight": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "maxLength": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "maxWidth": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "minHeight": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "minWidth": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "order": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "propertyDescription": {
	//       "type": "string"
	//     },
	//     "propertySection": {
	//       "type": "string"
	//     },
	//     "readableName": {
	//       "type": "string"
	//     },
	//     "regexp": {
	//       "type": "string"
	//     },
	//     "representationSelection": {
	//       "additionalProperties": {
	//         "type": "string"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "representationValidationString": {
	//       "type": "string"
	//     },
	//     "required": {
	//       "type": "boolean"
	//     },
	//     "rootPropertyName": {
	//       "type": "string"
	//     },
	//     "rssAttribute": {
	//       "type": "string"
	//     },
	//     "suppressProperty": {
	//       "type": "boolean"
	//     },
	//     "validateAs": {
	//       "type": "string"
	//     },
	//     "value": {
	//       "type": "string"
	//     },
	//     "visible": {
	//       "type": "boolean"
	//     },
	//     "visibleDependency": {
	//       "type": "string"
	//     },
	//     "visibleOn": {
	//       "type": "string"
	//     },
	//     "weight": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	Attributes map[string]string `json:"attributes"`

	BindToProperty string `json:"bindToProperty"`

	BoundRegex string `json:"boundRegex"`

	ChildProperties []ContentTypeProperty `json:"childProperties"`

	ContentTypeAllowed string `json:"contentTypeAllowed"`

	Datatype ContentPropertyDataType `json:"datatype"`

	DefaultValues []ContentTypeDefaultValue `json:"defaultValues"`

	Enabled bool `json:"enabled"`

	Entitytype string `json:"entitytype"`

	Fallback bool `json:"fallback"`

	IsCombo bool `json:"isCombo"`

	IsExternalAllowed bool `json:"isExternalAllowed"`

	IsImage bool `json:"isImage"`

	IsTitle bool `json:"isTitle"`

	IsVideo bool `json:"isVideo"`

	LegalContentTypes []string `json:"legalContentTypes"`

	Localizable bool `json:"localizable"`

	MaxByteLength int32 `json:"maxByteLength"`

	MaxFileSize int32 `json:"maxFileSize"`

	MaxHeight int32 `json:"maxHeight"`

	MaxLength int32 `json:"maxLength"`

	MaxWidth int32 `json:"maxWidth"`

	MinHeight int32 `json:"minHeight"`

	MinWidth int32 `json:"minWidth"`

	Name string `json:"name"`

	Order int32 `json:"order"`

	PropertyDescription string `json:"propertyDescription"`

	PropertySection string `json:"propertySection"`

	ReadableName string `json:"readableName"`

	Regexp string `json:"regexp"`

	RepresentationSelection map[string]string `json:"representationSelection"`

	RepresentationValidationString string `json:"representationValidationString"`

	Required bool `json:"required"`

	RootPropertyName string `json:"rootPropertyName"`

	RssAttribute string `json:"rssAttribute"`

	SuppressProperty bool `json:"suppressProperty"`

	ValidateAs string `json:"validateAs"`

	Value string `json:"value"`

	Visible bool `json:"visible"`

	VisibleDependency string `json:"visibleDependency"`

	VisibleOn string `json:"visibleOn"`

	Weight int32 `json:"weight"`
}

// Content.Models.ContentTypePropertySection
type ContentTypePropertySection struct {
	// {
	//   "properties": {
	//     "collapsed": {
	//       "type": "boolean"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "readableName": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Collapsed bool `json:"collapsed"`

	Name string `json:"name"`

	ReadableName string `json:"readableName"`
}

// Content.Models.TagMetadataDefinition
type TagMetadataDefinition struct {
	// {
	//   "properties": {
	//     "datatype": {
	//       "type": "string"
	//     },
	//     "description": {
	//       "type": "string"
	//     },
	//     "isRequired": {
	//       "type": "boolean"
	//     },
	//     "items": {
	//       "items": {
	//         "$ref": "#/components/schemas/Content.Models.TagMetadataItem"
	//       },
	//       "type": "array"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "order": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	Datatype string `json:"datatype"`

	Description string `json:"description"`

	IsRequired bool `json:"isRequired"`

	Items []TagMetadataItem `json:"items"`

	Name string `json:"name"`

	Order int32 `json:"order"`
}

// Content.Models.TagMetadataItem
type TagMetadataItem struct {
	// {
	//   "properties": {
	//     "description": {
	//       "type": "string"
	//     },
	//     "groups": {
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     },
	//     "isDefault": {
	//       "type": "boolean"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "tagText": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Description string `json:"description"`

	Groups []string `json:"groups"`

	IsDefault bool `json:"isDefault"`

	Name string `json:"name"`

	TagText string `json:"tagText"`
}

// Content.NewsArticleRssItem
type NewsArticleRssItem struct {
	// {
	//   "properties": {
	//     "Description": {
	//       "type": "string"
	//     },
	//     "HtmlContent": {
	//       "type": "string"
	//     },
	//     "ImagePath": {
	//       "type": "string"
	//     },
	//     "Link": {
	//       "type": "string"
	//     },
	//     "OptionalMobileImagePath": {
	//       "type": "string"
	//     },
	//     "PubDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "Title": {
	//       "type": "string"
	//     },
	//     "UniqueIdentifier": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Description string `json:"Description"`

	HtmlContent string `json:"HtmlContent"`

	ImagePath string `json:"ImagePath"`

	Link string `json:"Link"`

	OptionalMobileImagePath string `json:"OptionalMobileImagePath"`

	PubDate Timestamp `json:"PubDate"`

	Title string `json:"Title"`

	UniqueIdentifier string `json:"UniqueIdentifier"`
}

// Content.NewsArticleRssResponse
type NewsArticleRssResponse struct {
	// {
	//   "properties": {
	//     "CategoryFilter": {
	//       "type": "string"
	//     },
	//     "CurrentPaginationToken": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "NewsArticles": {
	//       "items": {
	//         "$ref": "#/components/schemas/Content.NewsArticleRssItem"
	//       },
	//       "type": "array"
	//     },
	//     "NextPaginationToken": {
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "PagerAction": {
	//       "type": "string"
	//     },
	//     "ResultCountThisPage": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	CategoryFilter string `json:"CategoryFilter"`

	CurrentPaginationToken int32 `json:"CurrentPaginationToken"`

	NewsArticles []NewsArticleRssItem `json:"NewsArticles"`

	NextPaginationToken Nullable[int32] `json:"NextPaginationToken,omitempty"`

	PagerAction string `json:"PagerAction"`

	ResultCountThisPage int32 `json:"ResultCountThisPage"`
}

// Dates.DateRange
type DateRange struct {
	// {
	//   "properties": {
	//     "end": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "start": {
	//       "format": "date-time",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	End Timestamp `json:"end"`

	Start Timestamp `json:"start"`
}

// Destiny.Activities.DestinyPublicActivityStatus
//
// Represents the public-facing status of an activity: any data about what is currently active in the
// Activity, regardless of an individual character's progress in it.
type PublicActivityStatus struct {
	// {
	//   "description": "Represents the public-facing status of an activity: any data about what is currently active in the Activity, regardless of an individual character's progress in it.",
	//   "properties": {
	//     "challengeObjectiveHashes": {
	//       "description": "Active Challenges for the activity, if any - represented as hashes for DestinyObjectiveDefinitions.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectiveDefinition"
	//       }
	//     },
	//     "modifierHashes": {
	//       "description": "The active modifiers on this activity, if any - represented as hashes for DestinyActivityModifierDefinitions.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.ActivityModifiers.DestinyActivityModifierDefinition"
	//       }
	//     },
	//     "rewardTooltipItems": {
	//       "description": "If the activity itself provides any specific \"mock\" rewards, this will be the items and their quantity.\r\nWhy \"mock\", you ask? Because these are the rewards as they are represented in the tooltip of the Activity.\r\nThese are often pointers to fake items that look good in a tooltip, but represent an abstract concept of what you will get for a reward rather than the specific items you may obtain.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemQuantity"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// Active Challenges for the activity, if any - represented as hashes for DestinyObjectiveDefinitions.
	ChallengeObjectiveHashes []uint32 `json:"challengeObjectiveHashes"`

	// The active modifiers on this activity, if any - represented as hashes for
	// DestinyActivityModifierDefinitions.
	ModifierHashes []uint32 `json:"modifierHashes"`

	// If the activity itself provides any specific "mock" rewards, this will be the items and their
	// quantity.
	// Why "mock", you ask? Because these are the rewards as they are represented in the tooltip of the
	// Activity.
	// These are often pointers to fake items that look good in a tooltip, but represent an abstract
	// concept of what you will get for a reward rather than the specific items you may obtain.
	RewardTooltipItems []ItemQuantity `json:"rewardTooltipItems"`
}

// Destiny.ActivityGraphNodeHighlightType
//
// The various known UI styles in which an item can be highlighted. It'll be up to you to determine
// what you want to show based on this highlighting, BNet doesn't have any assets that correspond to
// these states. And yeah, RiseOfIron and Comet have their own special highlight states. Don't ask me,
// I can't imagine they're still used.
type ActivityGraphNodeHighlightType int32

const (
	ActivityGraphNodeHighlightType_None       = ActivityGraphNodeHighlightType(0)
	ActivityGraphNodeHighlightType_Normal     = ActivityGraphNodeHighlightType(1)
	ActivityGraphNodeHighlightType_Hyper      = ActivityGraphNodeHighlightType(2)
	ActivityGraphNodeHighlightType_Comet      = ActivityGraphNodeHighlightType(3)
	ActivityGraphNodeHighlightType_RiseOfIron = ActivityGraphNodeHighlightType(4)
)

// Destiny.Advanced.AwaAuthorizationResult
type AwaAuthorizationResult struct {
	// {
	//   "properties": {
	//     "actionToken": {
	//       "description": "Credential used to prove the user authorized an advanced write action.",
	//       "type": "string"
	//     },
	//     "developerNote": {
	//       "description": "Message to the app developer to help understand the response.",
	//       "type": "string"
	//     },
	//     "maximumNumberOfUses": {
	//       "description": "This token may be used to perform the requested action this number of times, at a maximum. If this value is 0, then there is no limit.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "description": "MembershipType from the permission request.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "responseReason": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.Advanced.AwaResponseReason"
	//       }
	//     },
	//     "type": {
	//       "description": "Advanced Write Action Type from the permission request.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.Advanced.AwaType"
	//       }
	//     },
	//     "userSelection": {
	//       "description": "Indication of how the user responded to the request. If the value is \"Approved\" the actionToken will contain the token that can be presented when performing the advanced write action.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.Advanced.AwaUserSelection"
	//       }
	//     },
	//     "validUntil": {
	//       "description": "Time, UTC, when token expires.",
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// Credential used to prove the user authorized an advanced write action.
	ActionToken string `json:"actionToken"`

	// Message to the app developer to help understand the response.
	DeveloperNote string `json:"developerNote"`

	// This token may be used to perform the requested action this number of times, at a maximum. If this
	// value is 0, then there is no limit.
	MaximumNumberOfUses int32 `json:"maximumNumberOfUses"`

	// MembershipType from the permission request.
	MembershipType BungieMembershipType `json:"membershipType"`

	ResponseReason AwaResponseReason `json:"responseReason"`

	// Advanced Write Action Type from the permission request.
	Type AwaType `json:"type"`

	// Indication of how the user responded to the request. If the value is "Approved" the actionToken will
	// contain the token that can be presented when performing the advanced write action.
	UserSelection AwaUserSelection `json:"userSelection"`

	// Time, UTC, when token expires.
	ValidUntil Nullable[Timestamp] `json:"validUntil,omitempty"`
}

// Destiny.Advanced.AwaInitializeResponse
type AwaInitializeResponse struct {
	// {
	//   "properties": {
	//     "correlationId": {
	//       "description": "ID used to get the token. Present this ID to the user as it will identify this specific request on their device.",
	//       "type": "string"
	//     },
	//     "sentToSelf": {
	//       "description": "True if the PUSH message will only be sent to the device that made this request.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	// ID used to get the token. Present this ID to the user as it will identify this specific request on
	// their device.
	CorrelationID string `json:"correlationId"`

	// True if the PUSH message will only be sent to the device that made this request.
	SentToSelf bool `json:"sentToSelf"`
}

// Destiny.Advanced.AwaPermissionRequested
type AwaPermissionRequested struct {
	// {
	//   "properties": {
	//     "affectedItemId": {
	//       "description": "Item instance ID the action shall be applied to. This is optional for all but a new AwaType values. Rule of thumb is to provide the item instance ID if one is available.",
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "characterId": {
	//       "description": "Destiny character ID, if applicable, that will be affected by the action.",
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "description": "Destiny membership type of the account to modify.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "type": {
	//       "description": "Type of advanced write action.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.Advanced.AwaType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// Item instance ID the action shall be applied to. This is optional for all but a new AwaType values.
	// Rule of thumb is to provide the item instance ID if one is available.
	AffectedItemID Nullable[Int64] `json:"affectedItemId,omitempty"`

	// Destiny character ID, if applicable, that will be affected by the action.
	CharacterID Nullable[Int64] `json:"characterId,omitempty"`

	// Destiny membership type of the account to modify.
	MembershipType BungieMembershipType `json:"membershipType"`

	// Type of advanced write action.
	Type AwaType `json:"type"`
}

// Destiny.Advanced.AwaResponseReason
type AwaResponseReason int32

const (
	AwaResponseReason_None     = AwaResponseReason(0)
	AwaResponseReason_Answered = AwaResponseReason(1)
	AwaResponseReason_TimedOut = AwaResponseReason(2)
	AwaResponseReason_Replaced = AwaResponseReason(3)
)

// Destiny.Advanced.AwaType
type AwaType int32

const (
	AwaType_None        = AwaType(0)
	AwaType_InsertPlugs = AwaType(1)
)

// Destiny.Advanced.AwaUserResponse
type AwaUserResponse struct {
	// {
	//   "properties": {
	//     "correlationId": {
	//       "description": "Correlation ID of the request",
	//       "type": "string"
	//     },
	//     "nonce": {
	//       "description": "Secret nonce received via the PUSH notification.",
	//       "items": {
	//         "format": "byte",
	//         "type": "string"
	//       },
	//       "type": "array"
	//     },
	//     "selection": {
	//       "description": "Indication of the selection the user has made (Approving or rejecting the action)",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.Advanced.AwaUserSelection"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// Correlation ID of the request
	CorrelationID string `json:"correlationId"`

	// Secret nonce received via the PUSH notification.
	Nonce []int `json:"nonce"`

	// Indication of the selection the user has made (Approving or rejecting the action)
	Selection AwaUserSelection `json:"selection"`
}

// Destiny.Advanced.AwaUserSelection
type AwaUserSelection int32

const (
	AwaUserSelection_None     = AwaUserSelection(0)
	AwaUserSelection_Rejected = AwaUserSelection(1)
	AwaUserSelection_Approved = AwaUserSelection(2)
)

// Destiny.Artifacts.DestinyArtifactCharacterScoped
type ArtifactCharacterScoped struct {
	// {
	//   "properties": {
	//     "artifactHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Artifacts.DestinyArtifactDefinition"
	//       }
	//     },
	//     "pointsUsed": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "resetCount": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "tiers": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Artifacts.DestinyArtifactTier"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	ArtifactHash Hash[ArtifactDefinition] `json:"artifactHash"`

	PointsUsed int32 `json:"pointsUsed"`

	ResetCount int32 `json:"resetCount"`

	Tiers []ArtifactTier `json:"tiers"`
}

// Destiny.Artifacts.DestinyArtifactProfileScoped
//
// Represents a Seasonal Artifact and all data related to it for the requested Account.
// It can be combined with Character-scoped data for a full picture of what a character has
// available/has chosen, or just these settings can be used for overview information.
type ArtifactProfileScoped struct {
	// {
	//   "description": "Represents a Seasonal Artifact and all data related to it for the requested Account.\r\nIt can be combined with Character-scoped data for a full picture of what a character has available/has chosen, or just these settings can be used for overview information.",
	//   "properties": {
	//     "artifactHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Artifacts.DestinyArtifactDefinition"
	//       }
	//     },
	//     "pointProgression": {
	//       "$ref": "#/components/schemas/Destiny.DestinyProgression"
	//     },
	//     "pointsAcquired": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "powerBonus": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "powerBonusProgression": {
	//       "$ref": "#/components/schemas/Destiny.DestinyProgression"
	//     }
	//   },
	//   "type": "object"
	// }

	ArtifactHash Hash[ArtifactDefinition] `json:"artifactHash"`

	PointProgression Progression `json:"pointProgression"`

	PointsAcquired int32 `json:"pointsAcquired"`

	PowerBonus int32 `json:"powerBonus"`

	PowerBonusProgression Progression `json:"powerBonusProgression"`
}

// Destiny.Artifacts.DestinyArtifactTier
type ArtifactTier struct {
	// {
	//   "properties": {
	//     "isUnlocked": {
	//       "type": "boolean"
	//     },
	//     "items": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Artifacts.DestinyArtifactTierItem"
	//       },
	//       "type": "array"
	//     },
	//     "pointsToUnlock": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "tierHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	IsUnlocked bool `json:"isUnlocked"`

	Items []ArtifactTierItem `json:"items"`

	PointsToUnlock int32 `json:"pointsToUnlock"`

	TierHash uint32 `json:"tierHash"`
}

// Destiny.Artifacts.DestinyArtifactTierItem
type ArtifactTierItem struct {
	// {
	//   "properties": {
	//     "isActive": {
	//       "type": "boolean"
	//     },
	//     "isVisible": {
	//       "type": "boolean"
	//     },
	//     "itemHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	IsActive bool `json:"isActive"`

	IsVisible bool `json:"isVisible"`

	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`
}

// Destiny.BucketCategory
type BucketCategory int32

const (
	BucketCategory_Invisible  = BucketCategory(0)
	BucketCategory_Item       = BucketCategory(1)
	BucketCategory_Currency   = BucketCategory(2)
	BucketCategory_Equippable = BucketCategory(3)
	BucketCategory_Ignored    = BucketCategory(4)
)

// Destiny.BucketScope
type BucketScope int32

const (
	BucketScope_Character = BucketScope(0)
	BucketScope_Account   = BucketScope(1)
)

// Destiny.Challenges.DestinyChallengeStatus
//
// Represents the status and other related information for a challenge that is - or was - available to
// a player.
// A challenge is a bonus objective, generally tacked onto Quests or Activities, that provide
// additional variations on play.
type ChallengeStatus struct {
	// {
	//   "description": "Represents the status and other related information for a challenge that is - or was - available to a player. \r\nA challenge is a bonus objective, generally tacked onto Quests or Activities, that provide additional variations on play.",
	//   "properties": {
	//     "objective": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Quests.DestinyObjectiveProgress"
	//         }
	//       ],
	//       "description": "The progress - including completion status - of the active challenge.",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object"
	// }

	// The progress - including completion status - of the active challenge.
	Objective ObjectiveProgress `json:"objective"`
}

// Destiny.Character.DestinyCharacterCustomization
//
// Raw data about the customization options chosen for a character's face and appearance.
// You can look up the relevant class/race/gender combo in
// DestinyCharacterCustomizationOptionDefinition for the character, and then look up these values
// within the CustomizationOptions found to pull some data about their choices. Warning: not all of
// that data is meaningful. Some data has useful icons. Others have nothing, and are only meant for 3D
// rendering purposes (which we sadly do not expose yet)
type CharacterCustomization struct {
	// {
	//   "description": "Raw data about the customization options chosen for a character's face and appearance.\r\nYou can look up the relevant class/race/gender combo in DestinyCharacterCustomizationOptionDefinition for the character, and then look up these values within the CustomizationOptions found to pull some data about their choices. Warning: not all of that data is meaningful. Some data has useful icons. Others have nothing, and are only meant for 3D rendering purposes (which we sadly do not expose yet)",
	//   "properties": {
	//     "decalColor": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "decalIndex": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "eyeColor": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "face": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "featureColors": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "featureIndex": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "hairColors": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "hairIndex": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "lipColor": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "personality": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "skinColor": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "wearHelmet": {
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	DecalColor uint32 `json:"decalColor"`

	DecalIndex int32 `json:"decalIndex"`

	EyeColor uint32 `json:"eyeColor"`

	Face uint32 `json:"face"`

	FeatureColors []uint32 `json:"featureColors"`

	FeatureIndex int32 `json:"featureIndex"`

	HairColors []uint32 `json:"hairColors"`

	HairIndex int32 `json:"hairIndex"`

	LipColor uint32 `json:"lipColor"`

	Personality uint32 `json:"personality"`

	SkinColor uint32 `json:"skinColor"`

	WearHelmet bool `json:"wearHelmet"`
}

// Destiny.Character.DestinyCharacterPeerView
//
// A minimal view of a character's equipped items, for the purpose of rendering a summary screen or
// showing the character in 3D.
type CharacterPeerView struct {
	// {
	//   "description": "A minimal view of a character's equipped items, for the purpose of rendering a summary screen or showing the character in 3D.",
	//   "properties": {
	//     "equipment": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Character.DestinyItemPeerView"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	Equipment []ItemPeerView `json:"equipment"`
}

// Destiny.Character.DestinyItemPeerView
//
// Bare minimum summary information for an item, for the sake of 3D rendering the item.
type ItemPeerView struct {
	// {
	//   "description": "Bare minimum summary information for an item, for the sake of 3D rendering the item.",
	//   "properties": {
	//     "dyes": {
	//       "description": "The list of dyes that have been applied to this item.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DyeReference"
	//       },
	//       "type": "array"
	//     },
	//     "itemHash": {
	//       "description": "The hash identifier of the item in question. Use it to look up the DestinyInventoryItemDefinition of the item for static rendering data.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The list of dyes that have been applied to this item.
	Dyes []DyeReference `json:"dyes"`

	// The hash identifier of the item in question. Use it to look up the DestinyInventoryItemDefinition of
	// the item for static rendering data.
	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`
}

// Destiny.Components.Collectibles.DestinyCollectibleComponent
type CollectibleComponent struct {
	// {
	//   "properties": {
	//     "state": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyCollectibleState"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	State BitmaskSet[CollectibleState] `json:"state"`
}

// Destiny.Components.Collectibles.DestinyCollectiblesComponent
type CollectiblesComponent struct {
	// {
	//   "properties": {
	//     "collectibles": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Components.Collectibles.DestinyCollectibleComponent"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Collectibles.DestinyCollectibleDefinition"
	//       }
	//     },
	//     "collectionBadgesRootNodeHash": {
	//       "description": "The hash for the root presentation node definition of Collection Badges.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "collectionCategoriesRootNodeHash": {
	//       "description": "The hash for the root presentation node definition of Collection categories.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "Collectibles"
	// }

	Collectibles map[Hash[CollectibleDefinition]]CollectibleComponent `json:"collectibles"`

	// The hash for the root presentation node definition of Collection Badges.
	CollectionBadgesRootNodeHash Hash[PresentationNodeDefinition] `json:"collectionBadgesRootNodeHash"`

	// The hash for the root presentation node definition of Collection categories.
	CollectionCategoriesRootNodeHash Hash[PresentationNodeDefinition] `json:"collectionCategoriesRootNodeHash"`
}

// Destiny.Components.Collectibles.DestinyProfileCollectiblesComponent
type ProfileCollectiblesComponent struct {
	// {
	//   "properties": {
	//     "collectibles": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Components.Collectibles.DestinyCollectibleComponent"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Collectibles.DestinyCollectibleDefinition"
	//       }
	//     },
	//     "collectionBadgesRootNodeHash": {
	//       "description": "The hash for the root presentation node definition of Collection Badges.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "collectionCategoriesRootNodeHash": {
	//       "description": "The hash for the root presentation node definition of Collection categories.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "newnessFlaggedCollectibleHashes": {
	//       "description": "The list of collectibles determined by the game as having been \"recently\" acquired.\r\nThe game client itself actually controls this data, so I personally question whether anyone will get much use out of this: because we can't edit this value through the API. But in case anyone finds it useful, here it is.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Collectibles.DestinyCollectibleDefinition"
	//       }
	//     },
	//     "recentCollectibleHashes": {
	//       "description": "The list of collectibles determined by the game as having been \"recently\" acquired.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Collectibles.DestinyCollectibleDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "Collectibles"
	// }

	Collectibles map[Hash[CollectibleDefinition]]CollectibleComponent `json:"collectibles"`

	// The hash for the root presentation node definition of Collection Badges.
	CollectionBadgesRootNodeHash Hash[PresentationNodeDefinition] `json:"collectionBadgesRootNodeHash"`

	// The hash for the root presentation node definition of Collection categories.
	CollectionCategoriesRootNodeHash Hash[PresentationNodeDefinition] `json:"collectionCategoriesRootNodeHash"`

	// The list of collectibles determined by the game as having been "recently" acquired.
	// The game client itself actually controls this data, so I personally question whether anyone will get
	// much use out of this: because we can't edit this value through the API. But in case anyone finds it
	// useful, here it is.
	NewnessFlaggedCollectibleHashes []uint32 `json:"newnessFlaggedCollectibleHashes"`

	// The list of collectibles determined by the game as having been "recently" acquired.
	RecentCollectibleHashes []uint32 `json:"recentCollectibleHashes"`
}

// Destiny.Components.Craftables.DestinyCraftableComponent
type CraftableComponent struct {
	// {
	//   "properties": {
	//     "failedRequirementIndexes": {
	//       "description": "If the requirements are not met for crafting this item, these will index into the list of failure strings.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "sockets": {
	//       "description": "Plug item state for the crafting sockets.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Components.Craftables.DestinyCraftableSocketComponent"
	//       },
	//       "type": "array"
	//     },
	//     "visible": {
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	// If the requirements are not met for crafting this item, these will index into the list of failure
	// strings.
	FailedRequirementIndexes []int32 `json:"failedRequirementIndexes"`

	// Plug item state for the crafting sockets.
	Sockets []CraftableSocketComponent `json:"sockets"`

	Visible bool `json:"visible"`
}

// Destiny.Components.Craftables.DestinyCraftableSocketComponent
type CraftableSocketComponent struct {
	// {
	//   "properties": {
	//     "plugSetHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinyPlugSetDefinition"
	//       }
	//     },
	//     "plugs": {
	//       "description": "Unlock state for plugs in the socket plug set definition",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Components.Craftables.DestinyCraftableSocketPlugComponent"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	PlugSetHash Hash[PlugSetDefinition] `json:"plugSetHash"`

	// Unlock state for plugs in the socket plug set definition
	Plugs []CraftableSocketPlugComponent `json:"plugs"`
}

// Destiny.Components.Craftables.DestinyCraftableSocketPlugComponent
type CraftableSocketPlugComponent struct {
	// {
	//   "properties": {
	//     "failedRequirementIndexes": {
	//       "description": "Index into the unlock requirements to display failure descriptions",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "plugItemHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// Index into the unlock requirements to display failure descriptions
	FailedRequirementIndexes []int32 `json:"failedRequirementIndexes"`

	PlugItemHash Hash[InventoryItemDefinition] `json:"plugItemHash"`
}

// Destiny.Components.Craftables.DestinyCraftablesComponent
type CraftablesComponent struct {
	// {
	//   "properties": {
	//     "craftables": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Components.Craftables.DestinyCraftableComponent"
	//       },
	//       "description": "A map of craftable item hashes to craftable item state components.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "craftingRootNodeHash": {
	//       "description": "The hash for the root presentation node definition of craftable item categories.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "Craftables"
	// }

	// A map of craftable item hashes to craftable item state components.
	Craftables map[Hash[InventoryItemDefinition]]CraftableComponent `json:"craftables"`

	// The hash for the root presentation node definition of craftable item categories.
	CraftingRootNodeHash Hash[PresentationNodeDefinition] `json:"craftingRootNodeHash"`
}

// Destiny.Components.Inventory.DestinyCurrenciesComponent
//
// This component provides a quick lookup of every item the requested character has and how much of
// that item they have.
// Requesting this component will allow you to circumvent manually putting together the list of which
// currencies you have for the purpose of testing currency requirements on an item being purchased, or
// operations that have costs.
// You *could* figure this out yourself by doing a GetCharacter or GetProfile request and forming your
// own lookup table, but that is inconvenient enough that this feels like a worthwhile (and optional)
// redundancy. Don't bother requesting it if you have already created your own lookup from prior
// GetCharacter/GetProfile calls.
type CurrenciesComponent struct {
	// {
	//   "description": "This component provides a quick lookup of every item the requested character has and how much of that item they have.\r\nRequesting this component will allow you to circumvent manually putting together the list of which currencies you have for the purpose of testing currency requirements on an item being purchased, or operations that have costs.\r\nYou *could* figure this out yourself by doing a GetCharacter or GetProfile request and forming your own lookup table, but that is inconvenient enough that this feels like a worthwhile (and optional) redundancy. Don't bother requesting it if you have already created your own lookup from prior GetCharacter/GetProfile calls.",
	//   "properties": {
	//     "itemQuantities": {
	//       "additionalProperties": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "description": "A dictionary - keyed by the item's hash identifier (DestinyInventoryItemDefinition), and whose value is the amount of that item you have across all available inventory buckets for purchasing.\r\nThis allows you to see whether the requesting character can afford any given purchase/action without having to re-create this list itself.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "materialRequirementSetStates": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Components.Inventory.DestinyMaterialRequirementSetState"
	//       },
	//       "description": "A map of material requirement hashes and their status information.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "CurrencyLookups"
	// }

	// A dictionary - keyed by the item's hash identifier (DestinyInventoryItemDefinition), and whose value
	// is the amount of that item you have across all available inventory buckets for purchasing.
	// This allows you to see whether the requesting character can afford any given purchase/action without
	// having to re-create this list itself.
	ItemQuantities map[Hash[InventoryItemDefinition]]int32 `json:"itemQuantities"`

	// A map of material requirement hashes and their status information.
	MaterialRequirementSetStates map[uint32]MaterialRequirementSetState `json:"materialRequirementSetStates"`
}

// Destiny.Components.Inventory.DestinyMaterialRequirementSetState
type MaterialRequirementSetState struct {
	// {
	//   "properties": {
	//     "materialRequirementSetHash": {
	//       "description": "The hash identifier of the material requirement set. Use it to look up the DestinyMaterialRequirementSetDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyMaterialRequirementSetDefinition"
	//       }
	//     },
	//     "materialRequirementStates": {
	//       "description": "The dynamic state values for individual material requirements.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Components.Inventory.DestinyMaterialRequirementState"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash identifier of the material requirement set. Use it to look up the
	// DestinyMaterialRequirementSetDefinition.
	MaterialRequirementSetHash Hash[MaterialRequirementSetDefinition] `json:"materialRequirementSetHash"`

	// The dynamic state values for individual material requirements.
	MaterialRequirementStates []MaterialRequirementState `json:"materialRequirementStates"`
}

// Destiny.Components.Inventory.DestinyMaterialRequirementState
type MaterialRequirementState struct {
	// {
	//   "properties": {
	//     "count": {
	//       "description": "The amount of the material required.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "itemHash": {
	//       "description": "The hash identifier of the material required. Use it to look up the material's DestinyInventoryItemDefinition.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "stackSize": {
	//       "description": "A value for the amount of a (possibly virtual) material on some scope. For example: Dawning cookie baking material requirements.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// The amount of the material required.
	Count int32 `json:"count"`

	// The hash identifier of the material required. Use it to look up the material's
	// DestinyInventoryItemDefinition.
	ItemHash uint32 `json:"itemHash"`

	// A value for the amount of a (possibly virtual) material on some scope. For example: Dawning cookie
	// baking material requirements.
	StackSize int32 `json:"stackSize"`
}

// Destiny.Components.Inventory.DestinyPlatformSilverComponent
type PlatformSilverComponent struct {
	// {
	//   "properties": {
	//     "platformSilver": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Entities.Items.DestinyItemComponent"
	//       },
	//       "description": "If a Profile is played on multiple platforms, this is the silver they have for each platform, keyed by Membership Type.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/BungieMembershipType"
	//         }
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "PlatformSilver"
	// }

	// If a Profile is played on multiple platforms, this is the silver they have for each platform, keyed
	// by Membership Type.
	PlatformSilver map[string]ItemComponent `json:"platformSilver"`
}

// Destiny.Components.Items.DestinyItemPlugComponent
//
// Plugs are non-instanced items that can provide Stat and Perk benefits when socketed into an
// instanced item. Items have Sockets, and Plugs are inserted into Sockets.
// This component finds all items that are considered "Plugs" in your inventory, and return information
// about the plug aside from any specific Socket into which it could be inserted.
type ItemPlugComponent struct {
	// {
	//   "description": "Plugs are non-instanced items that can provide Stat and Perk benefits when socketed into an instanced item. Items have Sockets, and Plugs are inserted into Sockets.\r\nThis component finds all items that are considered \"Plugs\" in your inventory, and return information about the plug aside from any specific Socket into which it could be inserted.",
	//   "properties": {
	//     "canInsert": {
	//       "description": "If true, this plug has met all of its insertion requirements. Big if true.",
	//       "type": "boolean"
	//     },
	//     "enableFailIndexes": {
	//       "description": "If a plug is not enabled, this will be populated with indexes into the plug item definition's plug.enabledRules property, so that you can show the reasons why it is not enabled.\r\nThis list will be empty if the plug is enabled.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "enabled": {
	//       "description": "If true, this plug will provide its benefits while inserted.",
	//       "type": "boolean"
	//     },
	//     "insertFailIndexes": {
	//       "description": "If the plug cannot be inserted for some reason, this will have the indexes into the plug item definition's plug.insertionRules property, so you can show the reasons why it can't be inserted.\r\nThis list will be empty if the plug can be inserted.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "maxStackSize": {
	//       "description": "If available, this is the maximum stack size to display for the socket plug item.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "plugItemHash": {
	//       "description": "The hash identifier of the DestinyInventoryItemDefinition that represents this plug.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "plugObjectives": {
	//       "description": "Sometimes, Plugs may have objectives: these are often used for flavor and display purposes, but they can be used for any arbitrary purpose (both fortunately and unfortunately). Recently (with Season 2) they were expanded in use to be used as the \"gating\" for whether the plug can be inserted at all. For instance, a Plug might be tracking the number of PVP kills you have made. It will use the parent item's data about that tracking status to determine what to show, and will generally show it using the DestinyObjectiveDefinition's progressDescription property. Refer to the plug's itemHash and objective property for more information if you would like to display even more data.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Quests.DestinyObjectiveProgress"
	//       },
	//       "type": "array"
	//     },
	//     "stackSize": {
	//       "description": "If available, this is the stack size to display for the socket plug item.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "ItemPlugStates"
	// }

	// If true, this plug has met all of its insertion requirements. Big if true.
	CanInsert bool `json:"canInsert"`

	// If a plug is not enabled, this will be populated with indexes into the plug item definition's
	// plug.enabledRules property, so that you can show the reasons why it is not enabled.
	// This list will be empty if the plug is enabled.
	EnableFailIndexes []int32 `json:"enableFailIndexes"`

	// If true, this plug will provide its benefits while inserted.
	Enabled bool `json:"enabled"`

	// If the plug cannot be inserted for some reason, this will have the indexes into the plug item
	// definition's plug.insertionRules property, so you can show the reasons why it can't be inserted.
	// This list will be empty if the plug can be inserted.
	InsertFailIndexes []int32 `json:"insertFailIndexes"`

	// If available, this is the maximum stack size to display for the socket plug item.
	MaxStackSize Nullable[int32] `json:"maxStackSize,omitempty"`

	// The hash identifier of the DestinyInventoryItemDefinition that represents this plug.
	PlugItemHash Hash[InventoryItemDefinition] `json:"plugItemHash"`

	// Sometimes, Plugs may have objectives: these are often used for flavor and display purposes, but they
	// can be used for any arbitrary purpose (both fortunately and unfortunately). Recently (with Season 2)
	// they were expanded in use to be used as the "gating" for whether the plug can be inserted at all.
	// For instance, a Plug might be tracking the number of PVP kills you have made. It will use the parent
	// item's data about that tracking status to determine what to show, and will generally show it using
	// the DestinyObjectiveDefinition's progressDescription property. Refer to the plug's itemHash and
	// objective property for more information if you would like to display even more data.
	PlugObjectives []ObjectiveProgress `json:"plugObjectives"`

	// If available, this is the stack size to display for the socket plug item.
	StackSize Nullable[int32] `json:"stackSize,omitempty"`
}

// Destiny.Components.Items.DestinyItemPlugObjectivesComponent
type ItemPlugObjectivesComponent struct {
	// {
	//   "properties": {
	//     "objectivesPerPlug": {
	//       "additionalProperties": {
	//         "items": {
	//           "$ref": "#/components/schemas/Destiny.Quests.DestinyObjectiveProgress"
	//         },
	//         "type": "array"
	//       },
	//       "description": "This set of data is keyed by the Item Hash (DestinyInventoryItemDefinition) of the plug whose objectives are being returned, with the value being the list of those objectives.\r\n What if two plugs with the same hash are returned for an item, you ask?\r\n Good question! They share the same item-scoped state, and as such would have identical objective state as a result. How's that for convenient.\r\n Sometimes, Plugs may have objectives: generally, these are used for flavor and display purposes. For instance, a Plug might be tracking the number of PVP kills you have made. It will use the parent item's data about that tracking status to determine what to show, and will generally show it using the DestinyObjectiveDefinition's progressDescription property. Refer to the plug's itemHash and objective property for more information if you would like to display even more data.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "ItemPlugObjectives"
	// }

	// This set of data is keyed by the Item Hash (DestinyInventoryItemDefinition) of the plug whose
	// objectives are being returned, with the value being the list of those objectives.
	//
	//	What if two plugs with the same hash are returned for an item, you ask?
	//	Good question! They share the same item-scoped state, and as such would have identical objective
	//
	// state as a result. How's that for convenient.
	//
	//	Sometimes, Plugs may have objectives: generally, these are used for flavor and display purposes.
	//
	// For instance, a Plug might be tracking the number of PVP kills you have made. It will use the parent
	// item's data about that tracking status to determine what to show, and will generally show it using
	// the DestinyObjectiveDefinition's progressDescription property. Refer to the plug's itemHash and
	// objective property for more information if you would like to display even more data.
	ObjectivesPerPlug map[Hash[InventoryItemDefinition]][]ObjectiveProgress `json:"objectivesPerPlug"`
}

// Destiny.Components.Items.DestinyItemReusablePlugsComponent
type ItemReusablePlugsComponent struct {
	// {
	//   "properties": {
	//     "plugs": {
	//       "additionalProperties": {
	//         "items": {
	//           "$ref": "#/components/schemas/Destiny.Sockets.DestinyItemPlugBase"
	//         },
	//         "type": "array"
	//       },
	//       "description": "If the item supports reusable plugs, this is the list of plugs that are allowed to be used for the socket, and any relevant information about whether they are \"enabled\", whether they are allowed to be inserted, and any other information such as objectives.\r\n A Reusable Plug is a plug that you can always insert into this socket as long as its insertion rules are passed, regardless of whether or not you have the plug in your inventory. An example of it failing an insertion rule would be if it has an Objective that needs to be completed before it can be inserted, and that objective hasn't been completed yet.\r\n In practice, a socket will *either* have reusable plugs *or* it will allow for plugs in your inventory to be inserted. See DestinyInventoryItemDefinition.socket for more info.\r\n KEY = The INDEX into the item's list of sockets. VALUE = The set of plugs for that socket.\r\n If a socket doesn't have any reusable plugs defined at the item scope, there will be no entry for that socket.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "int32",
	//         "type": "integer"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "ItemReusablePlugs"
	// }

	// If the item supports reusable plugs, this is the list of plugs that are allowed to be used for the
	// socket, and any relevant information about whether they are "enabled", whether they are allowed to
	// be inserted, and any other information such as objectives.
	//
	//	A Reusable Plug is a plug that you can always insert into this socket as long as its insertion
	//
	// rules are passed, regardless of whether or not you have the plug in your inventory. An example of it
	// failing an insertion rule would be if it has an Objective that needs to be completed before it can
	// be inserted, and that objective hasn't been completed yet.
	//
	//	In practice, a socket will *either* have reusable plugs *or* it will allow for plugs in your
	//
	// inventory to be inserted. See DestinyInventoryItemDefinition.socket for more info.
	//
	//	KEY = The INDEX into the item's list of sockets. VALUE = The set of plugs for that socket.
	//	If a socket doesn't have any reusable plugs defined at the item scope, there will be no entry for
	//
	// that socket.
	Plugs map[int32][]ItemPlugBase `json:"plugs"`
}

// Destiny.Components.Kiosks.DestinyKioskItem
type KioskItem struct {
	// {
	//   "properties": {
	//     "canAcquire": {
	//       "description": "If true, the user can not only see the item, but they can acquire it. It is possible that a user can see a kiosk item and not be able to acquire it.",
	//       "type": "boolean"
	//     },
	//     "failureIndexes": {
	//       "description": "Indexes into failureStrings for the Vendor, indicating the reasons why it failed if any.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "flavorObjective": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Quests.DestinyObjectiveProgress"
	//         }
	//       ],
	//       "description": "I may regret naming it this way - but this represents when an item has an objective that doesn't serve a beneficial purpose, but rather is used for \"flavor\" or additional information. For instance, when Emblems track specific stats, those stats are represented as Objectives on the item.",
	//       "type": "object"
	//     },
	//     "index": {
	//       "description": "The index of the item in the related DestinyVendorDefintion's itemList property, representing the sale.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// If true, the user can not only see the item, but they can acquire it. It is possible that a user can
	// see a kiosk item and not be able to acquire it.
	CanAcquire bool `json:"canAcquire"`

	// Indexes into failureStrings for the Vendor, indicating the reasons why it failed if any.
	FailureIndexes []int32 `json:"failureIndexes"`

	// I may regret naming it this way - but this represents when an item has an objective that doesn't
	// serve a beneficial purpose, but rather is used for "flavor" or additional information. For instance,
	// when Emblems track specific stats, those stats are represented as Objectives on the item.
	FlavorObjective ObjectiveProgress `json:"flavorObjective"`

	// The index of the item in the related DestinyVendorDefintion's itemList property, representing the
	// sale.
	Index int32 `json:"index"`
}

// Destiny.Components.Kiosks.DestinyKiosksComponent
//
// A Kiosk is a Vendor (DestinyVendorDefinition) that sells items based on whether you have already
// acquired that item before.
// This component returns information about what Kiosk items are available to you on a *Profile* level.
// It is theoretically possible for Kiosks to have items gated by specific Character as well. If you
// ever have those, you will find them on the individual character's DestinyCharacterKiosksComponent.
// Note that, because this component returns vendorItemIndexes (that is to say, indexes into the Kiosk
// Vendor's itemList property), these results are necessarily content version dependent. Make sure that
// you have the latest version of the content manifest databases before using this data.
type KiosksComponent struct {
	// {
	//   "description": "A Kiosk is a Vendor (DestinyVendorDefinition) that sells items based on whether you have already acquired that item before.\r\nThis component returns information about what Kiosk items are available to you on a *Profile* level. It is theoretically possible for Kiosks to have items gated by specific Character as well. If you ever have those, you will find them on the individual character's DestinyCharacterKiosksComponent.\r\nNote that, because this component returns vendorItemIndexes (that is to say, indexes into the Kiosk Vendor's itemList property), these results are necessarily content version dependent. Make sure that you have the latest version of the content manifest databases before using this data.",
	//   "properties": {
	//     "kioskItems": {
	//       "additionalProperties": {
	//         "items": {
	//           "$ref": "#/components/schemas/Destiny.Components.Kiosks.DestinyKioskItem"
	//         },
	//         "type": "array"
	//       },
	//       "description": "A dictionary keyed by the Kiosk Vendor's hash identifier (use it to look up the DestinyVendorDefinition for the relevant kiosk vendor), and whose value is a list of all the items that the user can \"see\" in the Kiosk, and any other interesting metadata.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "Kiosks"
	// }

	// A dictionary keyed by the Kiosk Vendor's hash identifier (use it to look up the
	// DestinyVendorDefinition for the relevant kiosk vendor), and whose value is a list of all the items
	// that the user can "see" in the Kiosk, and any other interesting metadata.
	KioskItems map[Hash[VendorDefinition]][]KioskItem `json:"kioskItems"`
}

// Destiny.Components.Loadouts.DestinyLoadoutComponent
type LoadoutComponent struct {
	// {
	//   "properties": {
	//     "colorHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Loadouts.DestinyLoadoutColorDefinition"
	//       }
	//     },
	//     "iconHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Loadouts.DestinyLoadoutIconDefinition"
	//       }
	//     },
	//     "items": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Components.Loadouts.DestinyLoadoutItemComponent"
	//       },
	//       "type": "array"
	//     },
	//     "nameHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Loadouts.DestinyLoadoutNameDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	ColorHash Hash[LoadoutColorDefinition] `json:"colorHash"`

	IconHash Hash[LoadoutIconDefinition] `json:"iconHash"`

	Items []LoadoutItemComponent `json:"items"`

	NameHash Hash[LoadoutNameDefinition] `json:"nameHash"`
}

// Destiny.Components.Loadouts.DestinyLoadoutItemComponent
type LoadoutItemComponent struct {
	// {
	//   "properties": {
	//     "itemInstanceId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "plugItemHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	ItemInstanceID Int64 `json:"itemInstanceId"`

	PlugItemHashes []uint32 `json:"plugItemHashes"`
}

// Destiny.Components.Loadouts.DestinyLoadoutsComponent
type LoadoutsComponent struct {
	// {
	//   "properties": {
	//     "loadouts": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Components.Loadouts.DestinyLoadoutComponent"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "CharacterLoadouts"
	// }

	Loadouts []LoadoutComponent `json:"loadouts"`
}

// Destiny.Components.Metrics.DestinyMetricComponent
type MetricComponent struct {
	// {
	//   "properties": {
	//     "invisible": {
	//       "type": "boolean"
	//     },
	//     "objectiveProgress": {
	//       "$ref": "#/components/schemas/Destiny.Quests.DestinyObjectiveProgress"
	//     }
	//   },
	//   "type": "object"
	// }

	Invisible bool `json:"invisible"`

	ObjectiveProgress ObjectiveProgress `json:"objectiveProgress"`
}

// Destiny.Components.Metrics.DestinyMetricsComponent
type MetricsComponent struct {
	// {
	//   "properties": {
	//     "metrics": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Components.Metrics.DestinyMetricComponent"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "metricsRootNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "Metrics"
	// }

	Metrics map[uint32]MetricComponent `json:"metrics"`

	MetricsRootNodeHash Hash[PresentationNodeDefinition] `json:"metricsRootNodeHash"`
}

// Destiny.Components.PlugSets.DestinyPlugSetsComponent
//
// Sockets may refer to a "Plug Set": a set of reusable plugs that may be shared across multiple
// sockets (or even, in theory, multiple sockets over multiple items).
// This is the set of those plugs that we came across in the users' inventory, along with the values
// for plugs in the set. Any given set in this component may be represented in Character and
// Profile-level, as some plugs may be Profile-level restricted, and some character-level restricted.
// (note that the ones that are even more specific will remain on the actual socket component itself,
// as they cannot be reused)
type PlugSetsComponent struct {
	// {
	//   "description": "Sockets may refer to a \"Plug Set\": a set of reusable plugs that may be shared across multiple sockets (or even, in theory, multiple sockets over multiple items).\r\nThis is the set of those plugs that we came across in the users' inventory, along with the values for plugs in the set. Any given set in this component may be represented in Character and Profile-level, as some plugs may be Profile-level restricted, and some character-level restricted. (note that the ones that are even more specific will remain on the actual socket component itself, as they cannot be reused)",
	//   "properties": {
	//     "plugs": {
	//       "additionalProperties": {
	//         "items": {
	//           "$ref": "#/components/schemas/Destiny.Sockets.DestinyItemPlug"
	//         },
	//         "type": "array"
	//       },
	//       "description": "The shared list of plugs for each relevant PlugSet, keyed by the hash identifier of the PlugSet (DestinyPlugSetDefinition).",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinyPlugSetDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "ItemSockets"
	// }

	// The shared list of plugs for each relevant PlugSet, keyed by the hash identifier of the PlugSet
	// (DestinyPlugSetDefinition).
	Plugs map[Hash[PlugSetDefinition]][]ItemPlug `json:"plugs"`
}

// Destiny.Components.Presentation.DestinyPresentationNodeComponent
type PresentationNodeComponent struct {
	// {
	//   "properties": {
	//     "completionValue": {
	//       "description": "The value at which the presentation node is considered to be completed.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "objective": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Quests.DestinyObjectiveProgress"
	//         }
	//       ],
	//       "description": "An optional property: presentation nodes MAY have objectives, which can be used to infer more human readable data about the progress. However, progressValue and completionValue ought to be considered the canonical values for progress on Progression Nodes.",
	//       "type": "object"
	//     },
	//     "progressValue": {
	//       "description": "How much of the presentation node is considered to be completed so far by the given character/profile.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "recordCategoryScore": {
	//       "description": "If available, this is the current score for the record category that this node represents.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "state": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyPresentationNodeState"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The value at which the presentation node is considered to be completed.
	CompletionValue int32 `json:"completionValue"`

	// An optional property: presentation nodes MAY have objectives, which can be used to infer more human
	// readable data about the progress. However, progressValue and completionValue ought to be considered
	// the canonical values for progress on Progression Nodes.
	Objective ObjectiveProgress `json:"objective"`

	// How much of the presentation node is considered to be completed so far by the given
	// character/profile.
	ProgressValue int32 `json:"progressValue"`

	// If available, this is the current score for the record category that this node represents.
	RecordCategoryScore Nullable[int32] `json:"recordCategoryScore,omitempty"`

	State BitmaskSet[PresentationNodeState] `json:"state"`
}

// Destiny.Components.Presentation.DestinyPresentationNodesComponent
type PresentationNodesComponent struct {
	// {
	//   "properties": {
	//     "nodes": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Components.Presentation.DestinyPresentationNodeComponent"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "PresentationNodes"
	// }

	Nodes map[Hash[PresentationNodeDefinition]]PresentationNodeComponent `json:"nodes"`
}

// Destiny.Components.Profiles.DestinyProfileProgressionComponent
//
// The set of progression-related information that applies at a Profile-wide level for your Destiny
// experience. This differs from the Jimi Hendrix Experience because there's less guitars on fire. Yet.
// #spoileralert?
// This will include information such as Checklist info.
type ProfileProgressionComponent struct {
	// {
	//   "description": "The set of progression-related information that applies at a Profile-wide level for your Destiny experience. This differs from the Jimi Hendrix Experience because there's less guitars on fire. Yet. #spoileralert?\r\nThis will include information such as Checklist info.",
	//   "properties": {
	//     "checklists": {
	//       "additionalProperties": {
	//         "additionalProperties": {
	//           "type": "boolean"
	//         },
	//         "type": "object",
	//         "x-dictionary-key": {
	//           "format": "uint32",
	//           "type": "integer"
	//         }
	//       },
	//       "description": "The set of checklists that can be examined on a profile-wide basis, keyed by the hash identifier of the Checklist (DestinyChecklistDefinition)\r\nFor each checklist returned, its value is itself a Dictionary keyed by the checklist's hash identifier with the value being a boolean indicating if it's been discovered yet.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Checklists.DestinyChecklistDefinition"
	//       }
	//     },
	//     "seasonalArtifact": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Artifacts.DestinyArtifactProfileScoped"
	//         }
	//       ],
	//       "description": "Data related to your progress on the current season's artifact that is the same across characters.",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "ProfileProgression"
	// }

	// The set of checklists that can be examined on a profile-wide basis, keyed by the hash identifier of
	// the Checklist (DestinyChecklistDefinition)
	// For each checklist returned, its value is itself a Dictionary keyed by the checklist's hash
	// identifier with the value being a boolean indicating if it's been discovered yet.
	Checklists map[Hash[ChecklistDefinition]]map[uint32]bool `json:"checklists"`

	// Data related to your progress on the current season's artifact that is the same across characters.
	SeasonalArtifact ArtifactProfileScoped `json:"seasonalArtifact"`
}

// Destiny.Components.Profiles.DestinyProfileTransitoryComponent
//
// This is an experimental set of data that Bungie considers to be "transitory" - information that may
// be useful for API users, but that is coming from a non-authoritative data source about information
// that could potentially change at a more frequent pace than Bungie.net will receive updates about it.
// This information is provided exclusively for convenience should any of it be useful to users: we
// provide no guarantees to the accuracy or timeliness of data that comes from this source. Know that
// this data can potentially be out-of-date or even wrong entirely if the user disconnected from the
// game or suddenly changed their status before we can receive refreshed data.
type ProfileTransitoryComponent struct {
	// {
	//   "description": "This is an experimental set of data that Bungie considers to be \"transitory\" - information that may be useful for API users, but that is coming from a non-authoritative data source about information that could potentially change at a more frequent pace than Bungie.net will receive updates about it.\r\nThis information is provided exclusively for convenience should any of it be useful to users: we provide no guarantees to the accuracy or timeliness of data that comes from this source. Know that this data can potentially be out-of-date or even wrong entirely if the user disconnected from the game or suddenly changed their status before we can receive refreshed data.",
	//   "properties": {
	//     "currentActivity": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Components.Profiles.DestinyProfileTransitoryCurrentActivity"
	//         }
	//       ],
	//       "description": "If you are in an activity, this is some transitory info about the activity currently being played.",
	//       "type": "object"
	//     },
	//     "joinability": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Components.Profiles.DestinyProfileTransitoryJoinability"
	//         }
	//       ],
	//       "description": "Information about whether and what might prevent you from joining this person on a fireteam.",
	//       "type": "object"
	//     },
	//     "lastOrbitedDestinationHash": {
	//       "description": "The hash identifier for the DestinyDestinationDefinition of the last location you were orbiting when in orbit.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyDestinationDefinition"
	//       }
	//     },
	//     "partyMembers": {
	//       "description": "If you have any members currently in your party, this is some (very) bare-bones information about those members.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Components.Profiles.DestinyProfileTransitoryPartyMember"
	//       },
	//       "type": "array"
	//     },
	//     "tracking": {
	//       "description": "Information about tracked entities.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Components.Profiles.DestinyProfileTransitoryTrackingEntry"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "Transitory"
	// }

	// If you are in an activity, this is some transitory info about the activity currently being played.
	CurrentActivity ProfileTransitoryCurrentActivity `json:"currentActivity"`

	// Information about whether and what might prevent you from joining this person on a fireteam.
	Joinability ProfileTransitoryJoinability `json:"joinability"`

	// The hash identifier for the DestinyDestinationDefinition of the last location you were orbiting when
	// in orbit.
	LastOrbitedDestinationHash Nullable[Hash[DestinationDefinition]] `json:"lastOrbitedDestinationHash,omitempty"`

	// If you have any members currently in your party, this is some (very) bare-bones information about
	// those members.
	PartyMembers []ProfileTransitoryPartyMember `json:"partyMembers"`

	// Information about tracked entities.
	Tracking []ProfileTransitoryTrackingEntry `json:"tracking"`
}

// Destiny.Components.Profiles.DestinyProfileTransitoryCurrentActivity
//
// If you are playing in an activity, this is some information about it.
// Note that we cannot guarantee any of this resembles what ends up in the PGCR in any way. They are
// sourced by two entirely separate systems with their own logic, and the one we source this data from
// should be considered non-authoritative in comparison.
type ProfileTransitoryCurrentActivity struct {
	// {
	//   "description": "If you are playing in an activity, this is some information about it.\r\nNote that we cannot guarantee any of this resembles what ends up in the PGCR in any way. They are sourced by two entirely separate systems with their own logic, and the one we source this data from should be considered non-authoritative in comparison.",
	//   "properties": {
	//     "endTime": {
	//       "description": "If you're still in it but it \"ended\" (like when folks are dancing around the loot after they beat a boss), this is when the activity ended.",
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "highestOpposingFactionScore": {
	//       "description": "If you have human opponents, this is the highest opposing team's score.",
	//       "format": "float",
	//       "type": "number"
	//     },
	//     "numberOfOpponents": {
	//       "description": "This is how many human or poorly crafted aimbot opponents you have.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "numberOfPlayers": {
	//       "description": "This is how many human or poorly crafted aimbots are on your team.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "score": {
	//       "description": "This is what our non-authoritative source thought the score was.",
	//       "format": "float",
	//       "type": "number"
	//     },
	//     "startTime": {
	//       "description": "When the activity started.",
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// If you're still in it but it "ended" (like when folks are dancing around the loot after they beat a
	// boss), this is when the activity ended.
	EndTime Nullable[Timestamp] `json:"endTime,omitempty"`

	// If you have human opponents, this is the highest opposing team's score.
	HighestOpposingFactionScore float64 `json:"highestOpposingFactionScore"`

	// This is how many human or poorly crafted aimbot opponents you have.
	NumberOfOpponents int32 `json:"numberOfOpponents"`

	// This is how many human or poorly crafted aimbots are on your team.
	NumberOfPlayers int32 `json:"numberOfPlayers"`

	// This is what our non-authoritative source thought the score was.
	Score float64 `json:"score"`

	// When the activity started.
	StartTime Nullable[Timestamp] `json:"startTime,omitempty"`
}

// Destiny.Components.Profiles.DestinyProfileTransitoryJoinability
//
// Some basic information about whether you can be joined, how many slots are left etc. Note that this
// can change quickly, so it may not actually be useful. But perhaps it will be in some use cases?
type ProfileTransitoryJoinability struct {
	// {
	//   "description": "Some basic information about whether you can be joined, how many slots are left etc. Note that this can change quickly, so it may not actually be useful. But perhaps it will be in some use cases?",
	//   "properties": {
	//     "closedReasons": {
	//       "description": "Reasons why a person can't join this person's fireteam.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyJoinClosedReasons"
	//       }
	//     },
	//     "openSlots": {
	//       "description": "The number of slots still available on this person's fireteam.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "privacySetting": {
	//       "description": "Who the person is currently allowing invites from.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyGamePrivacySetting"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// Reasons why a person can't join this person's fireteam.
	ClosedReasons BitmaskSet[JoinClosedReasons] `json:"closedReasons"`

	// The number of slots still available on this person's fireteam.
	OpenSlots int32 `json:"openSlots"`

	// Who the person is currently allowing invites from.
	PrivacySetting GamePrivacySetting `json:"privacySetting"`
}

// Destiny.Components.Profiles.DestinyProfileTransitoryPartyMember
//
// This is some bare minimum information about a party member in a Fireteam. Unfortunately, without
// great computational expense on our side we can only get at the data contained here. I'd like to give
// you a character ID for example, but we don't have it. But we do have these three pieces of
// information. May they help you on your quest to show meaningful data about current Fireteams.
// Notably, we don't and can't feasibly return info on characters. If you can, try to use just the data
// below for your UI and purposes. Only hit us with further queries if you absolutely must know the
// character ID of the currently playing character. Pretty please with sugar on top.
type ProfileTransitoryPartyMember struct {
	// {
	//   "description": "This is some bare minimum information about a party member in a Fireteam. Unfortunately, without great computational expense on our side we can only get at the data contained here. I'd like to give you a character ID for example, but we don't have it. But we do have these three pieces of information. May they help you on your quest to show meaningful data about current Fireteams.\r\nNotably, we don't and can't feasibly return info on characters. If you can, try to use just the data below for your UI and purposes. Only hit us with further queries if you absolutely must know the character ID of the currently playing character. Pretty please with sugar on top.",
	//   "properties": {
	//     "displayName": {
	//       "description": "The player's last known display name.",
	//       "type": "string"
	//     },
	//     "emblemHash": {
	//       "description": "The identifier for the DestinyInventoryItemDefinition of the player's emblem.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "membershipId": {
	//       "description": "The Membership ID that matches the party member.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "status": {
	//       "description": "A Flags Enumeration value indicating the states that the player is in relevant to being on a fireteam.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyPartyMemberStates"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The player's last known display name.
	DisplayName string `json:"displayName"`

	// The identifier for the DestinyInventoryItemDefinition of the player's emblem.
	EmblemHash Hash[InventoryItemDefinition] `json:"emblemHash"`

	// The Membership ID that matches the party member.
	MembershipID Int64 `json:"membershipId"`

	// A Flags Enumeration value indicating the states that the player is in relevant to being on a
	// fireteam.
	Status BitmaskSet[PartyMemberStates] `json:"status"`
}

// Destiny.Components.Profiles.DestinyProfileTransitoryTrackingEntry
//
// This represents a single "thing" being tracked by the player.
// This can point to many types of entities, but only a subset of them will actually have a valid hash
// identifier for whatever it is being pointed to.
// It's up to you to interpret what it means when various combinations of these entries have values
// being tracked.
type ProfileTransitoryTrackingEntry struct {
	// {
	//   "description": "This represents a single \"thing\" being tracked by the player.\r\nThis can point to many types of entities, but only a subset of them will actually have a valid hash identifier for whatever it is being pointed to.\r\nIt's up to you to interpret what it means when various combinations of these entries have values being tracked.",
	//   "properties": {
	//     "activityHash": {
	//       "description": "OPTIONAL - If this is tracking the status of a DestinyActivityDefinition, this is the identifier for that activity.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "itemHash": {
	//       "description": "OPTIONAL - If this is tracking the status of a DestinyInventoryItemDefinition, this is the identifier for that item.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "locationHash": {
	//       "description": "OPTIONAL - If this is tracking a DestinyLocationDefinition, this is the identifier for that location.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyLocationDefinition"
	//       }
	//     },
	//     "objectiveHash": {
	//       "description": "OPTIONAL - If this is tracking the status of a DestinyObjectiveDefinition, this is the identifier for that objective.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectiveDefinition"
	//       }
	//     },
	//     "questlineItemHash": {
	//       "description": "OPTIONAL - If this is tracking the status of a quest, this is the identifier for the DestinyInventoryItemDefinition that containst that questline data.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "trackedDate": {
	//       "description": "OPTIONAL - I've got to level with you, I don't really know what this is. Is it when you started tracking it? Is it only populated for tracked items that have time limits?\r\nI don't know, but we can get at it - when I get time to actually test what it is, I'll update this. In the meantime, bask in the mysterious data.",
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// OPTIONAL - If this is tracking the status of a DestinyActivityDefinition, this is the identifier for
	// that activity.
	ActivityHash Nullable[Hash[ActivityDefinition]] `json:"activityHash,omitempty"`

	// OPTIONAL - If this is tracking the status of a DestinyInventoryItemDefinition, this is the
	// identifier for that item.
	ItemHash Nullable[Hash[InventoryItemDefinition]] `json:"itemHash,omitempty"`

	// OPTIONAL - If this is tracking a DestinyLocationDefinition, this is the identifier for that
	// location.
	LocationHash Nullable[Hash[LocationDefinition]] `json:"locationHash,omitempty"`

	// OPTIONAL - If this is tracking the status of a DestinyObjectiveDefinition, this is the identifier
	// for that objective.
	ObjectiveHash Nullable[Hash[ObjectiveDefinition]] `json:"objectiveHash,omitempty"`

	// OPTIONAL - If this is tracking the status of a quest, this is the identifier for the
	// DestinyInventoryItemDefinition that containst that questline data.
	QuestlineItemHash Nullable[Hash[InventoryItemDefinition]] `json:"questlineItemHash,omitempty"`

	// OPTIONAL - I've got to level with you, I don't really know what this is. Is it when you started
	// tracking it? Is it only populated for tracked items that have time limits?
	// I don't know, but we can get at it - when I get time to actually test what it is, I'll update this.
	// In the meantime, bask in the mysterious data.
	TrackedDate Nullable[Timestamp] `json:"trackedDate,omitempty"`
}

// Destiny.Components.Records.DestinyCharacterRecordsComponent
type CharacterRecordsComponent struct {
	// {
	//   "properties": {
	//     "featuredRecordHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Records.DestinyRecordDefinition"
	//       }
	//     },
	//     "recordCategoriesRootNodeHash": {
	//       "description": "The hash for the root presentation node definition of Triumph categories.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "recordSealsRootNodeHash": {
	//       "description": "The hash for the root presentation node definition of Triumph Seals.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "records": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Components.Records.DestinyRecordComponent"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "Records"
	// }

	FeaturedRecordHashes []uint32 `json:"featuredRecordHashes"`

	// The hash for the root presentation node definition of Triumph categories.
	RecordCategoriesRootNodeHash Hash[PresentationNodeDefinition] `json:"recordCategoriesRootNodeHash"`

	// The hash for the root presentation node definition of Triumph Seals.
	RecordSealsRootNodeHash Hash[PresentationNodeDefinition] `json:"recordSealsRootNodeHash"`

	Records map[uint32]RecordComponent `json:"records"`
}

// Destiny.Components.Records.DestinyProfileRecordsComponent
type ProfileRecordsComponent struct {
	// {
	//   "properties": {
	//     "activeScore": {
	//       "description": "Your 'active' Triumphs score.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "legacyScore": {
	//       "description": "Your 'legacy' Triumphs score.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "lifetimeScore": {
	//       "description": "Your 'lifetime' Triumphs score.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "recordCategoriesRootNodeHash": {
	//       "description": "The hash for the root presentation node definition of Triumph categories.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "recordSealsRootNodeHash": {
	//       "description": "The hash for the root presentation node definition of Triumph Seals.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "records": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Components.Records.DestinyRecordComponent"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "score": {
	//       "description": "Your 'active' Triumphs score, maintained for backwards compatibility.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "trackedRecordHash": {
	//       "description": "If this profile is tracking a record, this is the hash identifier of the record it is tracking.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Records.DestinyRecordDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "Records"
	// }

	// Your 'active' Triumphs score.
	ActiveScore int32 `json:"activeScore"`

	// Your 'legacy' Triumphs score.
	LegacyScore int32 `json:"legacyScore"`

	// Your 'lifetime' Triumphs score.
	LifetimeScore int32 `json:"lifetimeScore"`

	// The hash for the root presentation node definition of Triumph categories.
	RecordCategoriesRootNodeHash Hash[PresentationNodeDefinition] `json:"recordCategoriesRootNodeHash"`

	// The hash for the root presentation node definition of Triumph Seals.
	RecordSealsRootNodeHash Hash[PresentationNodeDefinition] `json:"recordSealsRootNodeHash"`

	Records map[uint32]RecordComponent `json:"records"`

	// Your 'active' Triumphs score, maintained for backwards compatibility.
	Score int32 `json:"score"`

	// If this profile is tracking a record, this is the hash identifier of the record it is tracking.
	TrackedRecordHash Nullable[Hash[RecordDefinition]] `json:"trackedRecordHash,omitempty"`
}

// Destiny.Components.Records.DestinyRecordComponent
type RecordComponent struct {
	// {
	//   "properties": {
	//     "completedCount": {
	//       "description": "If available, this is the number of times this record has been completed. For example, the number of times a seal title has been gilded.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "intervalObjectives": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Quests.DestinyObjectiveProgress"
	//       },
	//       "type": "array"
	//     },
	//     "intervalsRedeemedCount": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "objectives": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Quests.DestinyObjectiveProgress"
	//       },
	//       "type": "array"
	//     },
	//     "rewardVisibilty": {
	//       "description": "If available, a list that describes which reward rewards should be shown (true) or hidden (false). This property is for regular record rewards, and not for interval objective rewards.",
	//       "items": {
	//         "type": "boolean"
	//       },
	//       "type": "array"
	//     },
	//     "state": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyRecordState"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// If available, this is the number of times this record has been completed. For example, the number of
	// times a seal title has been gilded.
	CompletedCount Nullable[int32] `json:"completedCount,omitempty"`

	IntervalObjectives []ObjectiveProgress `json:"intervalObjectives"`

	IntervalsRedeemedCount int32 `json:"intervalsRedeemedCount"`

	Objectives []ObjectiveProgress `json:"objectives"`

	// If available, a list that describes which reward rewards should be shown (true) or hidden (false).
	// This property is for regular record rewards, and not for interval objective rewards.
	RewardVisibilty []bool `json:"rewardVisibilty"`

	State BitmaskSet[RecordState] `json:"state"`
}

// Destiny.Components.Records.DestinyRecordsComponent
type RecordsComponent struct {
	// {
	//   "properties": {
	//     "recordCategoriesRootNodeHash": {
	//       "description": "The hash for the root presentation node definition of Triumph categories.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "recordSealsRootNodeHash": {
	//       "description": "The hash for the root presentation node definition of Triumph Seals.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "records": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Components.Records.DestinyRecordComponent"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "Records"
	// }

	// The hash for the root presentation node definition of Triumph categories.
	RecordCategoriesRootNodeHash Hash[PresentationNodeDefinition] `json:"recordCategoriesRootNodeHash"`

	// The hash for the root presentation node definition of Triumph Seals.
	RecordSealsRootNodeHash Hash[PresentationNodeDefinition] `json:"recordSealsRootNodeHash"`

	Records map[uint32]RecordComponent `json:"records"`
}

// Destiny.Components.Social.DestinySocialCommendationsComponent
type SocialCommendationsComponent struct {
	// {
	//   "properties": {
	//     "commendationNodePercentagesByHash": {
	//       "additionalProperties": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "description": "The percentage for each commendation type out of total received",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "commendationNodeScoresByHash": {
	//       "additionalProperties": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Social.DestinySocialCommendationNodeDefinition"
	//       }
	//     },
	//     "commendationScoresByHash": {
	//       "additionalProperties": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Social.DestinySocialCommendationDefinition"
	//       }
	//     },
	//     "scoreDetailValues": {
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "totalScore": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "SocialCommendations"
	// }

	// The percentage for each commendation type out of total received
	CommendationNodePercentagesByHash map[uint32]uint32 `json:"commendationNodePercentagesByHash"`

	CommendationNodeScoresByHash map[Hash[SocialCommendationNodeDefinition]]int32 `json:"commendationNodeScoresByHash"`

	CommendationScoresByHash map[Hash[SocialCommendationDefinition]]int32 `json:"commendationScoresByHash"`

	ScoreDetailValues []int32 `json:"scoreDetailValues"`

	TotalScore int32 `json:"totalScore"`
}

// Destiny.Components.StringVariables.DestinyStringVariablesComponent
type StringVariablesComponent struct {
	// {
	//   "properties": {
	//     "integerValuesByHash": {
	//       "additionalProperties": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "StringVariables"
	// }

	IntegerValuesByHash map[uint32]int32 `json:"integerValuesByHash"`
}

// Destiny.Components.Vendors.DestinyPublicVendorComponent
//
// This component contains essential/summary information about the vendor from the perspective of a
// character-agnostic view.
type PublicVendorComponent struct {
	// {
	//   "description": "This component contains essential/summary information about the vendor from the perspective of a character-agnostic view.",
	//   "properties": {
	//     "enabled": {
	//       "description": "If True, the Vendor is currently accessible. \r\nIf False, they may not actually be visible in the world at the moment.",
	//       "type": "boolean"
	//     },
	//     "nextRefreshDate": {
	//       "description": "The date when this vendor's inventory will next rotate/refresh.\r\nNote that this is distinct from the date ranges that the vendor is visible/available in-game: this field indicates the specific time when the vendor's available items refresh and rotate, regardless of whether the vendor is actually available at that time. Unfortunately, these two values may be (and are, for the case of important vendors like Xur) different.\r\nIssue https://github.com/Bungie-net/api/issues/353 is tracking a fix to start providing visibility date ranges where possible in addition to this refresh date, so that all important dates for vendors are available for use.",
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "vendorHash": {
	//       "description": "The unique identifier for the vendor. Use it to look up their DestinyVendorDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "Vendors"
	// }

	// If True, the Vendor is currently accessible.
	// If False, they may not actually be visible in the world at the moment.
	Enabled bool `json:"enabled"`

	// The date when this vendor's inventory will next rotate/refresh.
	// Note that this is distinct from the date ranges that the vendor is visible/available in-game: this
	// field indicates the specific time when the vendor's available items refresh and rotate, regardless
	// of whether the vendor is actually available at that time. Unfortunately, these two values may be
	// (and are, for the case of important vendors like Xur) different.
	// Issue https://github.com/Bungie-net/api/issues/353 is tracking a fix to start providing visibility
	// date ranges where possible in addition to this refresh date, so that all important dates for vendors
	// are available for use.
	NextRefreshDate Timestamp `json:"nextRefreshDate"`

	// The unique identifier for the vendor. Use it to look up their DestinyVendorDefinition.
	VendorHash Hash[VendorDefinition] `json:"vendorHash"`
}

// Destiny.Components.Vendors.DestinyPublicVendorSaleItemComponent
//
// Has character-agnostic information about an item being sold by a vendor.
// Note that if you want instance, stats, etc... data for the item, you'll have to request additional
// components such as ItemInstances, ItemPerks etc... and acquire them from the DestinyVendorResponse's
// "items" property. For most of these, however, you'll have to ask for it in context of a specific
// character.
type PublicVendorSaleItemComponent struct {
	// {
	//   "description": "Has character-agnostic information about an item being sold by a vendor.\r\nNote that if you want instance, stats, etc... data for the item, you'll have to request additional components such as ItemInstances, ItemPerks etc... and acquire them from the DestinyVendorResponse's \"items\" property. For most of these, however, you'll have to ask for it in context of a specific character.",
	//   "properties": {
	//     "apiPurchasable": {
	//       "description": "If true, this item can be purchased through the Bungie.net API.",
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "costs": {
	//       "description": "A summary of the current costs of the item.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemQuantity"
	//       },
	//       "type": "array"
	//     },
	//     "itemHash": {
	//       "description": "The hash of the item being sold, as a quick shortcut for looking up the DestinyInventoryItemDefinition of the sale item.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "overrideNextRefreshDate": {
	//       "description": "If this item has its own custom date where it may be removed from the Vendor's rotation, this is that date.\r\nNote that there's not actually any guarantee that it will go away: it could be chosen again and end up still being in the Vendor's sale items! But this is the next date where that test will occur, and is also the date that the game shows for availability on things like Bounties being sold. So it's the best we can give.",
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "overrideStyleItemHash": {
	//       "description": "If populated, this is the hash of the item whose icon (and other secondary styles, but *not* the human readable strings) should override whatever icons/styles are on the item being sold.\r\nIf you don't do this, certain items whose styles are being overridden by socketed items - such as the \"Recycle Shader\" item - would show whatever their default icon/style is, and it wouldn't be pretty or look accurate.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "quantity": {
	//       "description": "How much of the item you'll be getting.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "vendorItemIndex": {
	//       "description": "The index into the DestinyVendorDefinition.itemList property. Note that this means Vendor data *is* Content Version dependent: make sure you have the latest content before you use Vendor data, or these indexes may mismatch. \r\nMost systems avoid this problem, but Vendors is one area where we are unable to reasonably avoid content dependency at the moment.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "VendorSales"
	// }

	// If true, this item can be purchased through the Bungie.net API.
	ApiPurchasable Nullable[bool] `json:"apiPurchasable,omitempty"`

	// A summary of the current costs of the item.
	Costs []ItemQuantity `json:"costs"`

	// The hash of the item being sold, as a quick shortcut for looking up the
	// DestinyInventoryItemDefinition of the sale item.
	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`

	// If this item has its own custom date where it may be removed from the Vendor's rotation, this is
	// that date.
	// Note that there's not actually any guarantee that it will go away: it could be chosen again and end
	// up still being in the Vendor's sale items! But this is the next date where that test will occur, and
	// is also the date that the game shows for availability on things like Bounties being sold. So it's
	// the best we can give.
	OverrideNextRefreshDate Nullable[Timestamp] `json:"overrideNextRefreshDate,omitempty"`

	// If populated, this is the hash of the item whose icon (and other secondary styles, but *not* the
	// human readable strings) should override whatever icons/styles are on the item being sold.
	// If you don't do this, certain items whose styles are being overridden by socketed items - such as
	// the "Recycle Shader" item - would show whatever their default icon/style is, and it wouldn't be
	// pretty or look accurate.
	OverrideStyleItemHash Nullable[Hash[InventoryItemDefinition]] `json:"overrideStyleItemHash,omitempty"`

	// How much of the item you'll be getting.
	Quantity int32 `json:"quantity"`

	// The index into the DestinyVendorDefinition.itemList property. Note that this means Vendor data *is*
	// Content Version dependent: make sure you have the latest content before you use Vendor data, or
	// these indexes may mismatch.
	// Most systems avoid this problem, but Vendors is one area where we are unable to reasonably avoid
	// content dependency at the moment.
	VendorItemIndex int32 `json:"vendorItemIndex"`
}

// Destiny.Components.Vendors.DestinyVendorBaseComponent
//
// This component contains essential/summary information about the vendor.
type VendorBaseComponent struct {
	// {
	//   "description": "This component contains essential/summary information about the vendor.",
	//   "properties": {
	//     "enabled": {
	//       "description": "If True, the Vendor is currently accessible. \r\nIf False, they may not actually be visible in the world at the moment.",
	//       "type": "boolean"
	//     },
	//     "nextRefreshDate": {
	//       "description": "The date when this vendor's inventory will next rotate/refresh.\r\nNote that this is distinct from the date ranges that the vendor is visible/available in-game: this field indicates the specific time when the vendor's available items refresh and rotate, regardless of whether the vendor is actually available at that time. Unfortunately, these two values may be (and are, for the case of important vendors like Xur) different.\r\nIssue https://github.com/Bungie-net/api/issues/353 is tracking a fix to start providing visibility date ranges where possible in addition to this refresh date, so that all important dates for vendors are available for use.",
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "vendorHash": {
	//       "description": "The unique identifier for the vendor. Use it to look up their DestinyVendorDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "Vendors"
	// }

	// If True, the Vendor is currently accessible.
	// If False, they may not actually be visible in the world at the moment.
	Enabled bool `json:"enabled"`

	// The date when this vendor's inventory will next rotate/refresh.
	// Note that this is distinct from the date ranges that the vendor is visible/available in-game: this
	// field indicates the specific time when the vendor's available items refresh and rotate, regardless
	// of whether the vendor is actually available at that time. Unfortunately, these two values may be
	// (and are, for the case of important vendors like Xur) different.
	// Issue https://github.com/Bungie-net/api/issues/353 is tracking a fix to start providing visibility
	// date ranges where possible in addition to this refresh date, so that all important dates for vendors
	// are available for use.
	NextRefreshDate Timestamp `json:"nextRefreshDate"`

	// The unique identifier for the vendor. Use it to look up their DestinyVendorDefinition.
	VendorHash Hash[VendorDefinition] `json:"vendorHash"`
}

// Destiny.Components.Vendors.DestinyVendorGroup
//
// Represents a specific group of vendors that can be rendered in the recommended order.
// How do we figure out this order? It's a long story, and will likely get more complicated over time.
type VendorGroup struct {
	// {
	//   "description": "Represents a specific group of vendors that can be rendered in the recommended order.\r\nHow do we figure out this order? It's a long story, and will likely get more complicated over time.",
	//   "properties": {
	//     "vendorGroupHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorGroupDefinition"
	//       }
	//     },
	//     "vendorHashes": {
	//       "description": "The ordered list of vendors within a particular group.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	VendorGroupHash Hash[VendorGroupDefinition] `json:"vendorGroupHash"`

	// The ordered list of vendors within a particular group.
	VendorHashes []uint32 `json:"vendorHashes"`
}

// Destiny.Components.Vendors.DestinyVendorGroupComponent
//
// This component returns references to all of the Vendors in the response, grouped by categorizations
// that Bungie has deemed to be interesting, in the order in which both the groups and the vendors
// within that group should be rendered.
type VendorGroupComponent struct {
	// {
	//   "description": "This component returns references to all of the Vendors in the response, grouped by categorizations that Bungie has deemed to be interesting, in the order in which both the groups and the vendors within that group should be rendered.",
	//   "properties": {
	//     "groups": {
	//       "description": "The ordered list of groups being returned.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Components.Vendors.DestinyVendorGroup"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "Vendors"
	// }

	// The ordered list of groups being returned.
	Groups []VendorGroup `json:"groups"`
}

// Destiny.Components.Vendors.DestinyVendorSaleItemBaseComponent
//
// The base class for Vendor Sale Item data. Has a bunch of character-agnostic state about the item
// being sold.
// Note that if you want instance, stats, etc... data for the item, you'll have to request additional
// components such as ItemInstances, ItemPerks etc... and acquire them from the DestinyVendorResponse's
// "items" property.
type VendorSaleItemBaseComponent struct {
	// {
	//   "description": "The base class for Vendor Sale Item data. Has a bunch of character-agnostic state about the item being sold.\r\nNote that if you want instance, stats, etc... data for the item, you'll have to request additional components such as ItemInstances, ItemPerks etc... and acquire them from the DestinyVendorResponse's \"items\" property.",
	//   "properties": {
	//     "apiPurchasable": {
	//       "description": "If true, this item can be purchased through the Bungie.net API.",
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "costs": {
	//       "description": "A summary of the current costs of the item.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemQuantity"
	//       },
	//       "type": "array"
	//     },
	//     "itemHash": {
	//       "description": "The hash of the item being sold, as a quick shortcut for looking up the DestinyInventoryItemDefinition of the sale item.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "overrideNextRefreshDate": {
	//       "description": "If this item has its own custom date where it may be removed from the Vendor's rotation, this is that date.\r\nNote that there's not actually any guarantee that it will go away: it could be chosen again and end up still being in the Vendor's sale items! But this is the next date where that test will occur, and is also the date that the game shows for availability on things like Bounties being sold. So it's the best we can give.",
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "overrideStyleItemHash": {
	//       "description": "If populated, this is the hash of the item whose icon (and other secondary styles, but *not* the human readable strings) should override whatever icons/styles are on the item being sold.\r\nIf you don't do this, certain items whose styles are being overridden by socketed items - such as the \"Recycle Shader\" item - would show whatever their default icon/style is, and it wouldn't be pretty or look accurate.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "quantity": {
	//       "description": "How much of the item you'll be getting.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "vendorItemIndex": {
	//       "description": "The index into the DestinyVendorDefinition.itemList property. Note that this means Vendor data *is* Content Version dependent: make sure you have the latest content before you use Vendor data, or these indexes may mismatch. \r\nMost systems avoid this problem, but Vendors is one area where we are unable to reasonably avoid content dependency at the moment.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "VendorSales"
	// }

	// If true, this item can be purchased through the Bungie.net API.
	ApiPurchasable Nullable[bool] `json:"apiPurchasable,omitempty"`

	// A summary of the current costs of the item.
	Costs []ItemQuantity `json:"costs"`

	// The hash of the item being sold, as a quick shortcut for looking up the
	// DestinyInventoryItemDefinition of the sale item.
	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`

	// If this item has its own custom date where it may be removed from the Vendor's rotation, this is
	// that date.
	// Note that there's not actually any guarantee that it will go away: it could be chosen again and end
	// up still being in the Vendor's sale items! But this is the next date where that test will occur, and
	// is also the date that the game shows for availability on things like Bounties being sold. So it's
	// the best we can give.
	OverrideNextRefreshDate Nullable[Timestamp] `json:"overrideNextRefreshDate,omitempty"`

	// If populated, this is the hash of the item whose icon (and other secondary styles, but *not* the
	// human readable strings) should override whatever icons/styles are on the item being sold.
	// If you don't do this, certain items whose styles are being overridden by socketed items - such as
	// the "Recycle Shader" item - would show whatever their default icon/style is, and it wouldn't be
	// pretty or look accurate.
	OverrideStyleItemHash Nullable[Hash[InventoryItemDefinition]] `json:"overrideStyleItemHash,omitempty"`

	// How much of the item you'll be getting.
	Quantity int32 `json:"quantity"`

	// The index into the DestinyVendorDefinition.itemList property. Note that this means Vendor data *is*
	// Content Version dependent: make sure you have the latest content before you use Vendor data, or
	// these indexes may mismatch.
	// Most systems avoid this problem, but Vendors is one area where we are unable to reasonably avoid
	// content dependency at the moment.
	VendorItemIndex int32 `json:"vendorItemIndex"`
}

// Destiny.Config.DestinyManifest
//
// DestinyManifest is the external-facing contract for just the properties needed by those calling the
// Destiny Platform.
type Manifest struct {
	// {
	//   "description": "DestinyManifest is the external-facing contract for just the properties needed by those calling the Destiny Platform.",
	//   "properties": {
	//     "iconImagePyramidInfo": {
	//       "description": "Information about the \"Image Pyramid\" for Destiny icons. Where possible, we create smaller versions of Destiny icons. These are found as subfolders under the location of the \"original/full size\" Destiny images, with the same file name and extension as the original image itself. (this lets us avoid sending largely redundant path info with every entity, at the expense of the smaller versions of the image being less discoverable)",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Config.ImagePyramidEntry"
	//       },
	//       "type": "array"
	//     },
	//     "jsonWorldComponentContentPaths": {
	//       "additionalProperties": {
	//         "additionalProperties": {
	//           "type": "string"
	//         },
	//         "type": "object",
	//         "x-dictionary-key": {
	//           "type": "string"
	//         }
	//       },
	//       "description": "This points to the generated JSON that contains all the Definitions. Each key is a locale. The value is a dictionary, where the key is a definition type by name, and the value is the path to the file for that definition. WARNING: This is unsafe and subject to change - do not depend on data in these files staying around long-term.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "jsonWorldContentPaths": {
	//       "additionalProperties": {
	//         "type": "string"
	//       },
	//       "description": "This points to the generated JSON that contains all the Definitions. Each key is a locale. The value is a path to the aggregated world definitions (warning: large file!)",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "mobileAssetContentPath": {
	//       "type": "string"
	//     },
	//     "mobileClanBannerDatabasePath": {
	//       "type": "string"
	//     },
	//     "mobileGearAssetDataBases": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Config.GearAssetDataBaseDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "mobileGearCDN": {
	//       "additionalProperties": {
	//         "type": "string"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "mobileWorldContentPaths": {
	//       "additionalProperties": {
	//         "type": "string"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "version": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// Information about the "Image Pyramid" for Destiny icons. Where possible, we create smaller versions
	// of Destiny icons. These are found as subfolders under the location of the "original/full size"
	// Destiny images, with the same file name and extension as the original image itself. (this lets us
	// avoid sending largely redundant path info with every entity, at the expense of the smaller versions
	// of the image being less discoverable)
	IconImagePyramidInfo []ImagePyramidEntry `json:"iconImagePyramidInfo"`

	// This points to the generated JSON that contains all the Definitions. Each key is a locale. The value
	// is a dictionary, where the key is a definition type by name, and the value is the path to the file
	// for that definition. WARNING: This is unsafe and subject to change - do not depend on data in these
	// files staying around long-term.
	JsonWorldComponentContentPaths map[string]map[string]string `json:"jsonWorldComponentContentPaths"`

	// This points to the generated JSON that contains all the Definitions. Each key is a locale. The value
	// is a path to the aggregated world definitions (warning: large file!)
	JsonWorldContentPaths map[string]string `json:"jsonWorldContentPaths"`

	MobileAssetContentPath string `json:"mobileAssetContentPath"`

	MobileClanBannerDatabasePath string `json:"mobileClanBannerDatabasePath"`

	MobileGearAssetDataBases []GearAssetDataBaseDefinition `json:"mobileGearAssetDataBases"`

	MobileGearCDN map[string]string `json:"mobileGearCDN"`

	MobileWorldContentPaths map[string]string `json:"mobileWorldContentPaths"`

	Version string `json:"version"`
}

// Destiny.Config.GearAssetDataBaseDefinition
type GearAssetDataBaseDefinition struct {
	// {
	//   "properties": {
	//     "path": {
	//       "type": "string"
	//     },
	//     "version": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	Path string `json:"path"`

	Version int32 `json:"version"`
}

// Destiny.Config.ImagePyramidEntry
type ImagePyramidEntry struct {
	// {
	//   "properties": {
	//     "factor": {
	//       "description": "The factor by which the original image size has been reduced.",
	//       "format": "float",
	//       "type": "number"
	//     },
	//     "name": {
	//       "description": "The name of the subfolder where these images are located.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// The factor by which the original image size has been reduced.
	Factor float64 `json:"factor"`

	// The name of the subfolder where these images are located.
	Name string `json:"name"`
}

// Destiny.Constants.DestinyEnvironmentLocationMapping
type EnvironmentLocationMapping struct {
	// {
	//   "properties": {
	//     "activationSource": {
	//       "description": "A hint that the UI uses to figure out how this location is activated by the player.",
	//       "type": "string"
	//     },
	//     "activityHash": {
	//       "description": "If this is populated, this is the activity you have to be playing in order to see this location appear because of this mapping. (theoretically, a location can have multiple mappings, and some might require you to be in a specific activity when others don't)",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "itemHash": {
	//       "description": "If this is populated, it is the item that you must possess for this location to be active because of this mapping. (theoretically, a location can have multiple mappings, and some might require an item while others don't)",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "locationHash": {
	//       "description": "The location that is revealed on the director by this mapping.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyLocationDefinition"
	//       }
	//     },
	//     "objectiveHash": {
	//       "description": "If this is populated, this is an objective related to the location.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectiveDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// A hint that the UI uses to figure out how this location is activated by the player.
	ActivationSource string `json:"activationSource"`

	// If this is populated, this is the activity you have to be playing in order to see this location
	// appear because of this mapping. (theoretically, a location can have multiple mappings, and some
	// might require you to be in a specific activity when others don't)
	ActivityHash Nullable[Hash[ActivityDefinition]] `json:"activityHash,omitempty"`

	// If this is populated, it is the item that you must possess for this location to be active because of
	// this mapping. (theoretically, a location can have multiple mappings, and some might require an item
	// while others don't)
	ItemHash Nullable[Hash[InventoryItemDefinition]] `json:"itemHash,omitempty"`

	// The location that is revealed on the director by this mapping.
	LocationHash Hash[LocationDefinition] `json:"locationHash"`

	// If this is populated, this is an objective related to the location.
	ObjectiveHash Nullable[Hash[ObjectiveDefinition]] `json:"objectiveHash,omitempty"`
}

// Destiny.DamageType
type DamageType int32

const (
	DamageType_None    = DamageType(0)
	DamageType_Kinetic = DamageType(1)
	DamageType_Arc     = DamageType(2)
	DamageType_Thermal = DamageType(3)
	DamageType_Void    = DamageType(4)
	DamageType_Raid    = DamageType(5)
	DamageType_Stasis  = DamageType(6)
	DamageType_Strand  = DamageType(7)
)

// Destiny.Definitions.Activities.DestinyActivityInteractableDefinition
//
// There are times in every Activity's life when interacting with an object in the world will result in
// another Activity activating. Well, not every Activity. Just certain ones.
// Anyways, this defines a set of interactable components, the activities that they spawn when you
// interact with them, and the conditions under which they can be interacted with.
// Sadly, we don't get any *really* good data for them, like positional data... yet. I have hopes for
// future data that we could put on this.
type ActivityInteractableDefinition struct {
	// {
	//   "description": "There are times in every Activity's life when interacting with an object in the world will result in another Activity activating. Well, not every Activity. Just certain ones.\r\nAnyways, this defines a set of interactable components, the activities that they spawn when you interact with them, and the conditions under which they can be interacted with.\r\nSadly, we don't get any *really* good data for them, like positional data... yet. I have hopes for future data that we could put on this.",
	//   "properties": {
	//     "entries": {
	//       "description": "The possible interactables in this activity interactable definition.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Activities.DestinyActivityInteractableEntryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "ActivityInteractables"
	// }

	// The possible interactables in this activity interactable definition.
	Entries []ActivityInteractableEntryDefinition `json:"entries"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.Activities.DestinyActivityInteractableEntryDefinition
//
// Defines a specific interactable and the action that can occur when triggered.
type ActivityInteractableEntryDefinition struct {
	// {
	//   "description": "Defines a specific interactable and the action that can occur when triggered.",
	//   "properties": {
	//     "activityHash": {
	//       "description": "The activity that will trigger when you interact with this interactable.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The activity that will trigger when you interact with this interactable.
	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`
}

// Destiny.Definitions.ActivityModifiers.DestinyActivityModifierDefinition
//
// Modifiers - in Destiny 1, these were referred to as "Skulls" - are changes that can be applied to an
// Activity.
type ActivityModifierDefinition struct {
	// {
	//   "description": "Modifiers - in Destiny 1, these were referred to as \"Skulls\" - are changes that can be applied to an Activity.",
	//   "properties": {
	//     "displayInActivitySelection": {
	//       "type": "boolean"
	//     },
	//     "displayInNavMode": {
	//       "type": "boolean"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "ActivityModifiers"
	// }

	DisplayInActivitySelection bool `json:"displayInActivitySelection"`

	DisplayInNavMode bool `json:"displayInNavMode"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.Animations.DestinyAnimationReference
type AnimationReference struct {
	// {
	//   "properties": {
	//     "animIdentifier": {
	//       "type": "string"
	//     },
	//     "animName": {
	//       "type": "string"
	//     },
	//     "path": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	AnimIdentifier string `json:"animIdentifier"`

	AnimName string `json:"animName"`

	Path string `json:"path"`
}

// Destiny.Definitions.Artifacts.DestinyArtifactDefinition
//
// Represents known info about a Destiny Artifact.
// We cannot guarantee that artifact definitions will be immutable between seasons - in fact, we've
// been told that they will be replaced between seasons. But this definition is built both to minimize
// the amount of lookups for related data that have to occur, and is built in hope that, if this plan
// changes, we will be able to accommodate it more easily.
type ArtifactDefinition struct {
	// {
	//   "description": "Represents known info about a Destiny Artifact.\r\nWe cannot guarantee that artifact definitions will be immutable between seasons - in fact, we've been told that they will be replaced between seasons. But this definition is built both to minimize the amount of lookups for related data that have to occur, and is built in hope that, if this plan changes, we will be able to accommodate it more easily.",
	//   "properties": {
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "Any basic display info we know about the Artifact. Currently sourced from a related inventory item, but the source of this data is subject to change.",
	//       "type": "object"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "tiers": {
	//       "description": "Any Tier/Rank data related to this artifact, listed in display order.  Currently sourced from a Vendor, but this source is subject to change.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Artifacts.DestinyArtifactTierDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "translationBlock": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemTranslationBlockDefinition"
	//         }
	//       ],
	//       "description": "Any Geometry/3D info we know about the Artifact. Currently sourced from a related inventory item's gearset information, but the source of this data is subject to change.",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Artifacts"
	// }

	// Any basic display info we know about the Artifact. Currently sourced from a related inventory item,
	// but the source of this data is subject to change.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// Any Tier/Rank data related to this artifact, listed in display order.  Currently sourced from a
	// Vendor, but this source is subject to change.
	Tiers []ArtifactTierDefinition `json:"tiers"`

	// Any Geometry/3D info we know about the Artifact. Currently sourced from a related inventory item's
	// gearset information, but the source of this data is subject to change.
	TranslationBlock ItemTranslationBlockDefinition `json:"translationBlock"`
}

// Destiny.Definitions.Artifacts.DestinyArtifactTierDefinition
type ArtifactTierDefinition struct {
	// {
	//   "properties": {
	//     "displayTitle": {
	//       "description": "The human readable title of this tier, if any.",
	//       "type": "string"
	//     },
	//     "items": {
	//       "description": "The items that can be earned within this tier.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Artifacts.DestinyArtifactTierItemDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "minimumUnlockPointsUsedRequirement": {
	//       "description": "The minimum number of \"unlock points\" that you must have used before you can unlock items from this tier.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "progressRequirementMessage": {
	//       "description": "A string representing the localized minimum requirement text for this Tier, if any.",
	//       "type": "string"
	//     },
	//     "tierHash": {
	//       "description": "An identifier, unique within the Artifact, for this specific tier.",
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// The human readable title of this tier, if any.
	DisplayTitle string `json:"displayTitle"`

	// The items that can be earned within this tier.
	Items []ArtifactTierItemDefinition `json:"items"`

	// The minimum number of "unlock points" that you must have used before you can unlock items from this
	// tier.
	MinimumUnlockPointsUsedRequirement int32 `json:"minimumUnlockPointsUsedRequirement"`

	// A string representing the localized minimum requirement text for this Tier, if any.
	ProgressRequirementMessage string `json:"progressRequirementMessage"`

	// An identifier, unique within the Artifact, for this specific tier.
	TierHash uint32 `json:"tierHash"`
}

// Destiny.Definitions.Artifacts.DestinyArtifactTierItemDefinition
type ArtifactTierItemDefinition struct {
	// {
	//   "properties": {
	//     "itemHash": {
	//       "description": "The identifier of the Plug Item unlocked by activating this item in the Artifact.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The identifier of the Plug Item unlocked by activating this item in the Artifact.
	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`
}

// Destiny.Definitions.BreakerTypes.DestinyBreakerTypeDefinition
type BreakerTypeDefinition struct {
	// {
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "enumValue": {
	//       "description": "We have an enumeration for Breaker types for quick reference. This is the current definition's breaker type enum value.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyBreakerType"
	//       }
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "BreakerTypes"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// We have an enumeration for Breaker types for quick reference. This is the current definition's
	// breaker type enum value.
	EnumValue BreakerType `json:"enumValue"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.Checklists.DestinyChecklistDefinition
//
// By public demand, Checklists are loose sets of "things to do/things you have done" in Destiny that
// we were actually able to track. They include easter eggs you find in the world, unique chests you
// unlock, and other such data where the first time you do it is significant enough to be tracked, and
// you have the potential to "get them all".
// These may be account-wide, or may be per character. The status of these will be returned in related
// "Checklist" data coming down from API requests such as GetProfile or GetCharacter.
// Generally speaking, the items in a checklist can be completed in any order: we return an ordered
// list which only implies the way we are showing them in our own UI, and you can feel free to alter it
// as you wish.
// Note that, in the future, there will be something resembling the old D1 Record Books in at least
// some vague form. When that is created, it may be that it will supercede much or all of this
// Checklist data. It remains to be seen if that will be the case, so for now assume that the
// Checklists will still exist even after the release of D2: Forsaken.
type ChecklistDefinition struct {
	// {
	//   "description": "By public demand, Checklists are loose sets of \"things to do/things you have done\" in Destiny that we were actually able to track. They include easter eggs you find in the world, unique chests you unlock, and other such data where the first time you do it is significant enough to be tracked, and you have the potential to \"get them all\".\r\nThese may be account-wide, or may be per character. The status of these will be returned in related \"Checklist\" data coming down from API requests such as GetProfile or GetCharacter.\r\nGenerally speaking, the items in a checklist can be completed in any order: we return an ordered list which only implies the way we are showing them in our own UI, and you can feel free to alter it as you wish.\r\nNote that, in the future, there will be something resembling the old D1 Record Books in at least some vague form. When that is created, it may be that it will supercede much or all of this Checklist data. It remains to be seen if that will be the case, so for now assume that the Checklists will still exist even after the release of D2: Forsaken.",
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "entries": {
	//       "description": "The individual checklist items. Gotta catch 'em all.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Checklists.DestinyChecklistEntryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "scope": {
	//       "description": "Indicates whether you will find this checklist on the Profile or Character components.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyScope"
	//       }
	//     },
	//     "viewActionString": {
	//       "description": "A localized string prompting you to view the checklist.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Checklists"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The individual checklist items. Gotta catch 'em all.
	Entries []ChecklistEntryDefinition `json:"entries"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// Indicates whether you will find this checklist on the Profile or Character components.
	Scope Scope `json:"scope"`

	// A localized string prompting you to view the checklist.
	ViewActionString string `json:"viewActionString"`
}

// Destiny.Definitions.Checklists.DestinyChecklistEntryDefinition
//
// The properties of an individual checklist item. Note that almost everything is optional: it is
// *highly* variable what kind of data we'll actually be able to return: at times we may have no other
// relationships to entities at all.
// Whatever UI you build, do it with the knowledge that any given entry might not actually be able to
// be associated with some other Destiny entity.
type ChecklistEntryDefinition struct {
	// {
	//   "description": "The properties of an individual checklist item. Note that almost everything is optional: it is *highly* variable what kind of data we'll actually be able to return: at times we may have no other relationships to entities at all.\r\nWhatever UI you build, do it with the knowledge that any given entry might not actually be able to be associated with some other Destiny entity.",
	//   "properties": {
	//     "activityHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "bubbleHash": {
	//       "description": "Note that a Bubble's hash doesn't uniquely identify a \"top level\" entity in Destiny. Only the combination of location and bubble can uniquely identify a place in the world of Destiny: so if bubbleHash is populated, locationHash must too be populated for it to have any meaning.\r\nYou can use this property if it is populated to look up the DestinyLocationDefinition's associated .locationReleases[].activityBubbleName property.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "destinationHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyDestinationDefinition"
	//       }
	//     },
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "Even if no other associations exist, we will give you *something* for display properties. In cases where we have no associated entities, it may be as simple as a numerical identifier.",
	//       "type": "object"
	//     },
	//     "hash": {
	//       "description": "The identifier for this Checklist entry. Guaranteed unique only within this Checklist Definition, and not globally/for all checklists.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "itemHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "locationHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyLocationDefinition"
	//       }
	//     },
	//     "scope": {
	//       "description": "The scope at which this specific entry can be computed.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyScope"
	//       }
	//     },
	//     "vendorHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     },
	//     "vendorInteractionIndex": {
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	ActivityHash Nullable[Hash[ActivityDefinition]] `json:"activityHash,omitempty"`

	// Note that a Bubble's hash doesn't uniquely identify a "top level" entity in Destiny. Only the
	// combination of location and bubble can uniquely identify a place in the world of Destiny: so if
	// bubbleHash is populated, locationHash must too be populated for it to have any meaning.
	// You can use this property if it is populated to look up the DestinyLocationDefinition's associated
	// .locationReleases[].activityBubbleName property.
	BubbleHash Nullable[uint32] `json:"bubbleHash,omitempty"`

	DestinationHash Nullable[Hash[DestinationDefinition]] `json:"destinationHash,omitempty"`

	// Even if no other associations exist, we will give you *something* for display properties. In cases
	// where we have no associated entities, it may be as simple as a numerical identifier.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The identifier for this Checklist entry. Guaranteed unique only within this Checklist Definition,
	// and not globally/for all checklists.
	Hash uint32 `json:"hash"`

	ItemHash Nullable[Hash[InventoryItemDefinition]] `json:"itemHash,omitempty"`

	LocationHash Nullable[Hash[LocationDefinition]] `json:"locationHash,omitempty"`

	// The scope at which this specific entry can be computed.
	Scope Scope `json:"scope"`

	VendorHash Nullable[Hash[VendorDefinition]] `json:"vendorHash,omitempty"`

	VendorInteractionIndex Nullable[int32] `json:"vendorInteractionIndex,omitempty"`
}

// Destiny.Definitions.Collectibles.DestinyCollectibleAcquisitionBlock
type CollectibleAcquisitionBlock struct {
	// {
	//   "properties": {
	//     "acquireMaterialRequirementHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyMaterialRequirementSetDefinition"
	//       }
	//     },
	//     "acquireTimestampUnlockValueHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyUnlockValueDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	AcquireMaterialRequirementHash Nullable[Hash[MaterialRequirementSetDefinition]] `json:"acquireMaterialRequirementHash,omitempty"`

	AcquireTimestampUnlockValueHash Nullable[Hash[UnlockValueDefinition]] `json:"acquireTimestampUnlockValueHash,omitempty"`
}

// Destiny.Definitions.Collectibles.DestinyCollectibleDefinition
//
// Defines a
type CollectibleDefinition struct {
	// {
	//   "description": "Defines a",
	//   "properties": {
	//     "acquisitionInfo": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Collectibles.DestinyCollectibleAcquisitionBlock"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "itemHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "parentNodeHashes": {
	//       "description": "A quick reference to presentation nodes that have this node as a child. Presentation nodes can be parented under multiple parents.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "presentationInfo": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationChildBlock"
	//     },
	//     "presentationNodeType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyPresentationNodeType"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "scope": {
	//       "description": "Indicates whether the state of this Collectible is determined on a per-character or on an account-wide basis.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyScope"
	//       }
	//     },
	//     "sourceHash": {
	//       "description": "This is a hash identifier we are building on the BNet side in an attempt to let people group collectibles by similar sources.\r\nI can't promise that it's going to be 100% accurate, but if the designers were consistent in assigning the same source strings to items with the same sources, it *ought to* be. No promises though.\r\nThis hash also doesn't relate to an actual definition, just to note: we've got nothing useful other than the source string for this data.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "sourceString": {
	//       "description": "A human readable string for a hint about how to acquire the item.",
	//       "type": "string"
	//     },
	//     "stateInfo": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Collectibles.DestinyCollectibleStateBlock"
	//     },
	//     "traitHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Traits.DestinyTraitDefinition"
	//       }
	//     },
	//     "traitIds": {
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Collectibles"
	// }

	AcquisitionInfo CollectibleAcquisitionBlock `json:"acquisitionInfo"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`

	// A quick reference to presentation nodes that have this node as a child. Presentation nodes can be
	// parented under multiple parents.
	ParentNodeHashes []uint32 `json:"parentNodeHashes"`

	PresentationInfo PresentationChildBlock `json:"presentationInfo"`

	PresentationNodeType PresentationNodeType `json:"presentationNodeType"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// Indicates whether the state of this Collectible is determined on a per-character or on an
	// account-wide basis.
	Scope Scope `json:"scope"`

	// This is a hash identifier we are building on the BNet side in an attempt to let people group
	// collectibles by similar sources.
	// I can't promise that it's going to be 100% accurate, but if the designers were consistent in
	// assigning the same source strings to items with the same sources, it *ought to* be. No promises
	// though.
	// This hash also doesn't relate to an actual definition, just to note: we've got nothing useful other
	// than the source string for this data.
	SourceHash Nullable[uint32] `json:"sourceHash,omitempty"`

	// A human readable string for a hint about how to acquire the item.
	SourceString string `json:"sourceString"`

	StateInfo CollectibleStateBlock `json:"stateInfo"`

	TraitHashes []uint32 `json:"traitHashes"`

	TraitIds []string `json:"traitIds"`
}

// Destiny.Definitions.Collectibles.DestinyCollectibleStateBlock
type CollectibleStateBlock struct {
	// {
	//   "properties": {
	//     "obscuredOverrideItemHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "requirements": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeRequirementsBlock"
	//     }
	//   },
	//   "type": "object"
	// }

	ObscuredOverrideItemHash Nullable[Hash[InventoryItemDefinition]] `json:"obscuredOverrideItemHash,omitempty"`

	Requirements PresentationNodeRequirementsBlock `json:"requirements"`
}

// Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition
//
// Many Destiny*Definition contracts - the "first order" entities of Destiny that have their own tables
// in the Manifest Database - also have displayable information. This is the base class for that
// display information.
type DisplayPropertiesDefinition struct {
	// {
	//   "description": "Many Destiny*Definition contracts - the \"first order\" entities of Destiny that have their own tables in the Manifest Database - also have displayable information. This is the base class for that display information.",
	//   "properties": {
	//     "description": {
	//       "type": "string"
	//     },
	//     "hasIcon": {
	//       "type": "boolean"
	//     },
	//     "highResIcon": {
	//       "description": "If this item has a high-res icon (at least for now, many things won't), then the path to that icon will be here.",
	//       "type": "string"
	//     },
	//     "icon": {
	//       "description": "Note that \"icon\" is sometimes misleading, and should be interpreted in the context of the entity. For instance, in Destiny 1 the DestinyRecordBookDefinition's icon was a big picture of a book.\r\nBut usually, it will be a small square image that you can use as... well, an icon.\r\nThey are currently represented as 96px x 96px images.",
	//       "type": "string"
	//     },
	//     "iconSequences": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyIconSequenceDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "name": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Description string `json:"description"`

	HasIcon bool `json:"hasIcon"`

	// If this item has a high-res icon (at least for now, many things won't), then the path to that icon
	// will be here.
	HighResIcon string `json:"highResIcon"`

	// Note that "icon" is sometimes misleading, and should be interpreted in the context of the entity.
	// For instance, in Destiny 1 the DestinyRecordBookDefinition's icon was a big picture of a book.
	// But usually, it will be a small square image that you can use as... well, an icon.
	// They are currently represented as 96px x 96px images.
	Icon string `json:"icon"`

	IconSequences []IconSequenceDefinition `json:"iconSequences"`

	Name string `json:"name"`
}

// Destiny.Definitions.Common.DestinyIconSequenceDefinition
type IconSequenceDefinition struct {
	// {
	//   "properties": {
	//     "frames": {
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	Frames []string `json:"frames"`
}

// Destiny.Definitions.Common.DestinyPositionDefinition
type PositionDefinition struct {
	// {
	//   "properties": {
	//     "x": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "y": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "z": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	X int32 `json:"x"`

	Y int32 `json:"y"`

	Z int32 `json:"z"`
}

// Destiny.Definitions.DestinyActivityChallengeDefinition
//
// Represents a reference to a Challenge, which for now is just an Objective.
type ActivityChallengeDefinition struct {
	// {
	//   "description": "Represents a reference to a Challenge, which for now is just an Objective.",
	//   "properties": {
	//     "dummyRewards": {
	//       "description": "The rewards as they're represented in the UI. Note that they generally link to \"dummy\" items that give a summary of rewards rather than direct, real items themselves.\r\nIf the quantity is 0, don't show the quantity.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemQuantity"
	//       },
	//       "type": "array"
	//     },
	//     "objectiveHash": {
	//       "description": "The hash for the Objective that matches this challenge. Use it to look up the DestinyObjectiveDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectiveDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The rewards as they're represented in the UI. Note that they generally link to "dummy" items that
	// give a summary of rewards rather than direct, real items themselves.
	// If the quantity is 0, don't show the quantity.
	DummyRewards []ItemQuantity `json:"dummyRewards"`

	// The hash for the Objective that matches this challenge. Use it to look up the
	// DestinyObjectiveDefinition.
	ObjectiveHash Hash[ObjectiveDefinition] `json:"objectiveHash"`
}

// Destiny.Definitions.DestinyActivityDefinition
//
// The static data about Activities in Destiny 2.
// Note that an Activity must be combined with an ActivityMode to know - from a Gameplay perspective -
// what the user is "Playing".
// In most PvE activities, this is fairly straightforward. A Story Activity can only be played in the
// Story Activity Mode.
// However, in PvP activities, the Activity alone only tells you the map being played, or the Playlist
// that the user chose to enter. You'll need to know the Activity Mode they're playing to know that
// they're playing Mode X on Map Y.
// Activity Definitions tell a great deal of information about what *could* be relevant to a user: what
// rewards they can earn, what challenges could be performed, what modifiers could be applied. To
// figure out which of these properties is actually live, you'll need to combine the definition with
// "Live" data from one of the Destiny endpoints.
// Activities also have Activity Types, but unfortunately in Destiny 2 these are even less reliable of
// a source of information than they were in Destiny 1. I will be looking into ways to provide more
// reliable sources for type information as time goes on, but for now we're going to have to deal with
// the limitations. See DestinyActivityTypeDefinition for more information.
type ActivityDefinition struct {
	// {
	//   "description": "The static data about Activities in Destiny 2.\r\nNote that an Activity must be combined with an ActivityMode to know - from a Gameplay perspective - what the user is \"Playing\".\r\nIn most PvE activities, this is fairly straightforward. A Story Activity can only be played in the Story Activity Mode.\r\nHowever, in PvP activities, the Activity alone only tells you the map being played, or the Playlist that the user chose to enter. You'll need to know the Activity Mode they're playing to know that they're playing Mode X on Map Y.\r\nActivity Definitions tell a great deal of information about what *could* be relevant to a user: what rewards they can earn, what challenges could be performed, what modifiers could be applied. To figure out which of these properties is actually live, you'll need to combine the definition with \"Live\" data from one of the Destiny endpoints.\r\nActivities also have Activity Types, but unfortunately in Destiny 2 these are even less reliable of a source of information than they were in Destiny 1. I will be looking into ways to provide more reliable sources for type information as time goes on, but for now we're going to have to deal with the limitations. See DestinyActivityTypeDefinition for more information.",
	//   "properties": {
	//     "activityGraphList": {
	//       "description": "Unfortunately, in practice this is almost never populated. In theory, this is supposed to tell which Activity Graph to show if you bring up the director while in this activity.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityGraphListEntryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "activityLightLevel": {
	//       "description": "The recommended light level for this activity.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "activityLocationMappings": {
	//       "description": "A list of location mappings that are affected by this activity. Pulled out of DestinyLocationDefinitions for our/your lookup convenience.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Constants.DestinyEnvironmentLocationMapping"
	//       },
	//       "type": "array"
	//     },
	//     "activityModeHashes": {
	//       "description": "The hash identifiers for Activity Modes relevant to this activity.  Note that if this is a playlist, the specific playlist entry chosen will determine the actual activity modes that end up being relevant.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityModeDefinition"
	//       }
	//     },
	//     "activityModeTypes": {
	//       "description": "The activity modes - if any - in enum form. Because we can't seem to escape the enums.",
	//       "items": {
	//         "description": "For historical reasons, this list will have both D1 and D2-relevant Activity Modes in it. Please don't take this to mean that some D1-only feature is coming back!",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.DestinyActivityModeType"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "activityTypeHash": {
	//       "description": "The hash identifier for the Activity Type of this Activity. You may use it to look up the DestinyActivityTypeDefinition for human readable info, but be forewarned: Playlists and many PVP Map Activities will map to generic Activity Types. You'll have to use your knowledge of the Activity Mode being played to get more specific information about what the user is playing.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityTypeDefinition"
	//       }
	//     },
	//     "challenges": {
	//       "description": "An activity can have many Challenges, of which any subset of them may be active for play at any given period of time. This gives the information about the challenges and data that we use to understand when they're active and what rewards they provide. Sadly, at the moment there's no central definition for challenges: much like \"Skulls\" were in Destiny 1, these are defined on individual activities and there can be many duplicates/near duplicates across the Destiny 2 ecosystem. I have it in mind to centralize these in a future revision of the API, but we are out of time.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityChallengeDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "destinationHash": {
	//       "description": "The hash identifier for the Destination on which this Activity is played. Use it to look up the DestinyDestinationDefinition for human readable info about the destination. A Destination can be thought of as a more specific location than a \"Place\". For instance, if the \"Place\" is Earth, the \"Destination\" would be a specific city or region on Earth.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyDestinationDefinition"
	//       }
	//     },
	//     "directActivityModeHash": {
	//       "description": "If this activity had an activity mode directly defined on it, this will be the hash of that mode.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityModeDefinition"
	//       }
	//     },
	//     "directActivityModeType": {
	//       "description": "If the activity had an activity mode directly defined on it, this will be the enum value of that mode.",
	//       "enum": [
	//         "0",
	//         "2",
	//         "3",
	//         "4",
	//         "5",
	//         "6",
	//         "7",
	//         "9",
	//         "10",
	//         "11",
	//         "12",
	//         "13",
	//         "15",
	//         "16",
	//         "17",
	//         "18",
	//         "19",
	//         "20",
	//         "21",
	//         "22",
	//         "24",
	//         "25",
	//         "26",
	//         "27",
	//         "28",
	//         "29",
	//         "30",
	//         "31",
	//         "32",
	//         "37",
	//         "38",
	//         "39",
	//         "40",
	//         "41",
	//         "42",
	//         "43",
	//         "44",
	//         "45",
	//         "46",
	//         "47",
	//         "48",
	//         "49",
	//         "50",
	//         "51",
	//         "52",
	//         "53",
	//         "54",
	//         "55",
	//         "56",
	//         "57",
	//         "58",
	//         "59",
	//         "60",
	//         "61",
	//         "62",
	//         "63",
	//         "64",
	//         "65",
	//         "66",
	//         "67",
	//         "68",
	//         "69",
	//         "70",
	//         "71",
	//         "72",
	//         "73",
	//         "74",
	//         "75",
	//         "76",
	//         "77",
	//         "78",
	//         "79",
	//         "80",
	//         "81",
	//         "82",
	//         "83",
	//         "84",
	//         "85",
	//         "86",
	//         "87",
	//         "88",
	//         "89",
	//         "90",
	//         "91",
	//         "92"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "None",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Story",
	//           "numericValue": "2"
	//         },
	//         {
	//           "identifier": "Strike",
	//           "numericValue": "3"
	//         },
	//         {
	//           "identifier": "Raid",
	//           "numericValue": "4"
	//         },
	//         {
	//           "identifier": "AllPvP",
	//           "numericValue": "5"
	//         },
	//         {
	//           "identifier": "Patrol",
	//           "numericValue": "6"
	//         },
	//         {
	//           "identifier": "AllPvE",
	//           "numericValue": "7"
	//         },
	//         {
	//           "identifier": "Reserved9",
	//           "numericValue": "9"
	//         },
	//         {
	//           "identifier": "Control",
	//           "numericValue": "10"
	//         },
	//         {
	//           "identifier": "Reserved11",
	//           "numericValue": "11"
	//         },
	//         {
	//           "description": "Clash -\u003e Destiny's name for Team Deathmatch. 4v4 combat, the team with the highest kills at the end of time wins.",
	//           "identifier": "Clash",
	//           "numericValue": "12"
	//         },
	//         {
	//           "identifier": "Reserved13",
	//           "numericValue": "13"
	//         },
	//         {
	//           "identifier": "CrimsonDoubles",
	//           "numericValue": "15"
	//         },
	//         {
	//           "identifier": "Nightfall",
	//           "numericValue": "16"
	//         },
	//         {
	//           "identifier": "HeroicNightfall",
	//           "numericValue": "17"
	//         },
	//         {
	//           "identifier": "AllStrikes",
	//           "numericValue": "18"
	//         },
	//         {
	//           "identifier": "IronBanner",
	//           "numericValue": "19"
	//         },
	//         {
	//           "identifier": "Reserved20",
	//           "numericValue": "20"
	//         },
	//         {
	//           "identifier": "Reserved21",
	//           "numericValue": "21"
	//         },
	//         {
	//           "identifier": "Reserved22",
	//           "numericValue": "22"
	//         },
	//         {
	//           "identifier": "Reserved24",
	//           "numericValue": "24"
	//         },
	//         {
	//           "identifier": "AllMayhem",
	//           "numericValue": "25"
	//         },
	//         {
	//           "identifier": "Reserved26",
	//           "numericValue": "26"
	//         },
	//         {
	//           "identifier": "Reserved27",
	//           "numericValue": "27"
	//         },
	//         {
	//           "identifier": "Reserved28",
	//           "numericValue": "28"
	//         },
	//         {
	//           "identifier": "Reserved29",
	//           "numericValue": "29"
	//         },
	//         {
	//           "identifier": "Reserved30",
	//           "numericValue": "30"
	//         },
	//         {
	//           "identifier": "Supremacy",
	//           "numericValue": "31"
	//         },
	//         {
	//           "identifier": "PrivateMatchesAll",
	//           "numericValue": "32"
	//         },
	//         {
	//           "identifier": "Survival",
	//           "numericValue": "37"
	//         },
	//         {
	//           "identifier": "Countdown",
	//           "numericValue": "38"
	//         },
	//         {
	//           "identifier": "TrialsOfTheNine",
	//           "numericValue": "39"
	//         },
	//         {
	//           "identifier": "Social",
	//           "numericValue": "40"
	//         },
	//         {
	//           "identifier": "TrialsCountdown",
	//           "numericValue": "41"
	//         },
	//         {
	//           "identifier": "TrialsSurvival",
	//           "numericValue": "42"
	//         },
	//         {
	//           "identifier": "IronBannerControl",
	//           "numericValue": "43"
	//         },
	//         {
	//           "identifier": "IronBannerClash",
	//           "numericValue": "44"
	//         },
	//         {
	//           "identifier": "IronBannerSupremacy",
	//           "numericValue": "45"
	//         },
	//         {
	//           "identifier": "ScoredNightfall",
	//           "numericValue": "46"
	//         },
	//         {
	//           "identifier": "ScoredHeroicNightfall",
	//           "numericValue": "47"
	//         },
	//         {
	//           "identifier": "Rumble",
	//           "numericValue": "48"
	//         },
	//         {
	//           "identifier": "AllDoubles",
	//           "numericValue": "49"
	//         },
	//         {
	//           "identifier": "Doubles",
	//           "numericValue": "50"
	//         },
	//         {
	//           "identifier": "PrivateMatchesClash",
	//           "numericValue": "51"
	//         },
	//         {
	//           "identifier": "PrivateMatchesControl",
	//           "numericValue": "52"
	//         },
	//         {
	//           "identifier": "PrivateMatchesSupremacy",
	//           "numericValue": "53"
	//         },
	//         {
	//           "identifier": "PrivateMatchesCountdown",
	//           "numericValue": "54"
	//         },
	//         {
	//           "identifier": "PrivateMatchesSurvival",
	//           "numericValue": "55"
	//         },
	//         {
	//           "identifier": "PrivateMatchesMayhem",
	//           "numericValue": "56"
	//         },
	//         {
	//           "identifier": "PrivateMatchesRumble",
	//           "numericValue": "57"
	//         },
	//         {
	//           "identifier": "HeroicAdventure",
	//           "numericValue": "58"
	//         },
	//         {
	//           "identifier": "Showdown",
	//           "numericValue": "59"
	//         },
	//         {
	//           "identifier": "Lockdown",
	//           "numericValue": "60"
	//         },
	//         {
	//           "identifier": "Scorched",
	//           "numericValue": "61"
	//         },
	//         {
	//           "identifier": "ScorchedTeam",
	//           "numericValue": "62"
	//         },
	//         {
	//           "identifier": "Gambit",
	//           "numericValue": "63"
	//         },
	//         {
	//           "identifier": "AllPvECompetitive",
	//           "numericValue": "64"
	//         },
	//         {
	//           "identifier": "Breakthrough",
	//           "numericValue": "65"
	//         },
	//         {
	//           "identifier": "BlackArmoryRun",
	//           "numericValue": "66"
	//         },
	//         {
	//           "identifier": "Salvage",
	//           "numericValue": "67"
	//         },
	//         {
	//           "identifier": "IronBannerSalvage",
	//           "numericValue": "68"
	//         },
	//         {
	//           "identifier": "PvPCompetitive",
	//           "numericValue": "69"
	//         },
	//         {
	//           "identifier": "PvPQuickplay",
	//           "numericValue": "70"
	//         },
	//         {
	//           "identifier": "ClashQuickplay",
	//           "numericValue": "71"
	//         },
	//         {
	//           "identifier": "ClashCompetitive",
	//           "numericValue": "72"
	//         },
	//         {
	//           "identifier": "ControlQuickplay",
	//           "numericValue": "73"
	//         },
	//         {
	//           "identifier": "ControlCompetitive",
	//           "numericValue": "74"
	//         },
	//         {
	//           "identifier": "GambitPrime",
	//           "numericValue": "75"
	//         },
	//         {
	//           "identifier": "Reckoning",
	//           "numericValue": "76"
	//         },
	//         {
	//           "identifier": "Menagerie",
	//           "numericValue": "77"
	//         },
	//         {
	//           "identifier": "VexOffensive",
	//           "numericValue": "78"
	//         },
	//         {
	//           "identifier": "NightmareHunt",
	//           "numericValue": "79"
	//         },
	//         {
	//           "identifier": "Elimination",
	//           "numericValue": "80"
	//         },
	//         {
	//           "identifier": "Momentum",
	//           "numericValue": "81"
	//         },
	//         {
	//           "identifier": "Dungeon",
	//           "numericValue": "82"
	//         },
	//         {
	//           "identifier": "Sundial",
	//           "numericValue": "83"
	//         },
	//         {
	//           "identifier": "TrialsOfOsiris",
	//           "numericValue": "84"
	//         },
	//         {
	//           "identifier": "Dares",
	//           "numericValue": "85"
	//         },
	//         {
	//           "identifier": "Offensive",
	//           "numericValue": "86"
	//         },
	//         {
	//           "identifier": "LostSector",
	//           "numericValue": "87"
	//         },
	//         {
	//           "identifier": "Rift",
	//           "numericValue": "88"
	//         },
	//         {
	//           "identifier": "ZoneControl",
	//           "numericValue": "89"
	//         },
	//         {
	//           "identifier": "IronBannerRift",
	//           "numericValue": "90"
	//         },
	//         {
	//           "identifier": "IronBannerZoneControl",
	//           "numericValue": "91"
	//         },
	//         {
	//           "identifier": "Relic",
	//           "numericValue": "92"
	//         }
	//       ]
	//     },
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "The title, subtitle, and icon for the activity. We do a little post-processing on this to try and account for Activities where the designers have left this data too minimal to determine what activity is actually being played.",
	//       "type": "object"
	//     },
	//     "guidedGame": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityGuidedBlockDefinition"
	//         }
	//       ],
	//       "description": "This block of data, if it exists, provides information about the guided game experience and restrictions for this activity. If it doesn't exist, the game is not able to be played as a guided game.",
	//       "type": "object"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "insertionPoints": {
	//       "description": "The list of phases or points of entry into an activity, along with information we can use to determine their gating and availability.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityInsertionPointDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "isPlaylist": {
	//       "description": "If True, this Activity is actually a Playlist that refers to multiple possible specific Activities and Activity Modes. For instance, a Crucible Playlist may have references to multiple Activities (Maps) with multiple Activity Modes (specific PvP gameplay modes). If this is true, refer to the playlistItems property for the specific entries in the playlist.",
	//       "type": "boolean"
	//     },
	//     "isPvP": {
	//       "description": "If true, this activity is a PVP activity or playlist.",
	//       "type": "boolean"
	//     },
	//     "loadouts": {
	//       "description": "The set of all possible loadout requirements that could be active for this activity. Only one will be active at any given time, and you can discover which one through activity-associated data such as Milestones that have activity info on them.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityLoadoutRequirementSet"
	//       },
	//       "type": "array"
	//     },
	//     "matchmaking": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityMatchmakingBlockDefinition"
	//         }
	//       ],
	//       "description": "This block of data provides information about the Activity's matchmaking attributes: how many people can join and such.",
	//       "type": "object"
	//     },
	//     "modifiers": {
	//       "description": "Activities can have Modifiers, as defined in DestinyActivityModifierDefinition. These are references to the modifiers that *can* be applied to that activity, along with data that we use to determine if that modifier is actually active at any given point in time.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityModifierReferenceDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "optionalUnlockStrings": {
	//       "description": "If there are status strings related to the activity and based on internal state of the game, account, or character, then this will be the definition of those strings and the states needed in order for the strings to be shown.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityUnlockStringDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "originalDisplayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "The unadulterated form of the display properties, as they ought to be shown in the Director (if the activity appears in the director).",
	//       "type": "object"
	//     },
	//     "pgcrImage": {
	//       "description": "When Activities are completed, we generate a \"Post-Game Carnage Report\", or PGCR, with details about what happened in that activity (how many kills someone got, which team won, etc...) We use this image as the background when displaying PGCR information, and often use it when we refer to the Activity in general.",
	//       "type": "string"
	//     },
	//     "placeHash": {
	//       "description": "The hash identifier for the \"Place\" on which this Activity is played. Use it to look up the DestinyPlaceDefinition for human readable info about the Place. A Place is the largest-scoped concept for location information. For instance, if the \"Place\" is Earth, the \"Destination\" would be a specific city or region on Earth.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyPlaceDefinition"
	//       }
	//     },
	//     "playlistItems": {
	//       "description": "Represents all of the possible activities that could be played in the Playlist, along with information that we can use to determine if they are active at the present time.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityPlaylistItemDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "releaseIcon": {
	//       "description": "If the activity has an icon associated with a specific release (such as a DLC), this is the path to that release's icon.",
	//       "type": "string"
	//     },
	//     "releaseTime": {
	//       "description": "If the activity will not be visible until a specific and known time, this will be the seconds since the Epoch when it will become visible.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "requirements": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityRequirementsBlock"
	//     },
	//     "rewards": {
	//       "description": "The expected possible rewards for the activity. These rewards may or may not be accessible for an individual player based on their character state, the account state, and even the game's state overall. But it is a useful reference for possible rewards you can earn in the activity. These match up to rewards displayed when you hover over the Activity in the in-game Director, and often refer to Placeholder or \"Dummy\" items: items that tell you what you can earn in vague terms rather than what you'll specifically be earning (partly because the game doesn't even know what you'll earn specifically until you roll for it at the end)",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityRewardDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "selectionScreenDisplayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "The title, subtitle, and icon for the activity as determined by Selection Screen data, if there is any for this activity. There won't be data in this field if the activity is never shown in a selection/options screen.",
	//       "type": "object"
	//     },
	//     "tier": {
	//       "description": "The difficulty tier of the activity.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Activities"
	// }

	// Unfortunately, in practice this is almost never populated. In theory, this is supposed to tell which
	// Activity Graph to show if you bring up the director while in this activity.
	ActivityGraphList []ActivityGraphListEntryDefinition `json:"activityGraphList"`

	// The recommended light level for this activity.
	ActivityLightLevel int32 `json:"activityLightLevel"`

	// A list of location mappings that are affected by this activity. Pulled out of
	// DestinyLocationDefinitions for our/your lookup convenience.
	ActivityLocationMappings []EnvironmentLocationMapping `json:"activityLocationMappings"`

	// The hash identifiers for Activity Modes relevant to this activity.  Note that if this is a playlist,
	// the specific playlist entry chosen will determine the actual activity modes that end up being
	// relevant.
	ActivityModeHashes []uint32 `json:"activityModeHashes"`

	// The activity modes - if any - in enum form. Because we can't seem to escape the enums.
	ActivityModeTypes []ActivityModeType `json:"activityModeTypes"`

	// The hash identifier for the Activity Type of this Activity. You may use it to look up the
	// DestinyActivityTypeDefinition for human readable info, but be forewarned: Playlists and many PVP Map
	// Activities will map to generic Activity Types. You'll have to use your knowledge of the Activity
	// Mode being played to get more specific information about what the user is playing.
	ActivityTypeHash Hash[ActivityTypeDefinition] `json:"activityTypeHash"`

	// An activity can have many Challenges, of which any subset of them may be active for play at any
	// given period of time. This gives the information about the challenges and data that we use to
	// understand when they're active and what rewards they provide. Sadly, at the moment there's no
	// central definition for challenges: much like "Skulls" were in Destiny 1, these are defined on
	// individual activities and there can be many duplicates/near duplicates across the Destiny 2
	// ecosystem. I have it in mind to centralize these in a future revision of the API, but we are out of
	// time.
	Challenges []ActivityChallengeDefinition `json:"challenges"`

	// The hash identifier for the Destination on which this Activity is played. Use it to look up the
	// DestinyDestinationDefinition for human readable info about the destination. A Destination can be
	// thought of as a more specific location than a "Place". For instance, if the "Place" is Earth, the
	// "Destination" would be a specific city or region on Earth.
	DestinationHash Hash[DestinationDefinition] `json:"destinationHash"`

	// If this activity had an activity mode directly defined on it, this will be the hash of that mode.
	DirectActivityModeHash Nullable[Hash[ActivityModeDefinition]] `json:"directActivityModeHash,omitempty"`

	// If the activity had an activity mode directly defined on it, this will be the enum value of that
	// mode.
	DirectActivityModeType Nullable[int32] `json:"directActivityModeType,omitempty"`

	// The title, subtitle, and icon for the activity. We do a little post-processing on this to try and
	// account for Activities where the designers have left this data too minimal to determine what
	// activity is actually being played.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// This block of data, if it exists, provides information about the guided game experience and
	// restrictions for this activity. If it doesn't exist, the game is not able to be played as a guided
	// game.
	GuidedGame ActivityGuidedBlockDefinition `json:"guidedGame"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// The list of phases or points of entry into an activity, along with information we can use to
	// determine their gating and availability.
	InsertionPoints []ActivityInsertionPointDefinition `json:"insertionPoints"`

	// If True, this Activity is actually a Playlist that refers to multiple possible specific Activities
	// and Activity Modes. For instance, a Crucible Playlist may have references to multiple Activities
	// (Maps) with multiple Activity Modes (specific PvP gameplay modes). If this is true, refer to the
	// playlistItems property for the specific entries in the playlist.
	IsPlaylist bool `json:"isPlaylist"`

	// If true, this activity is a PVP activity or playlist.
	IsPvP bool `json:"isPvP"`

	// The set of all possible loadout requirements that could be active for this activity. Only one will
	// be active at any given time, and you can discover which one through activity-associated data such as
	// Milestones that have activity info on them.
	Loadouts []ActivityLoadoutRequirementSet `json:"loadouts"`

	// This block of data provides information about the Activity's matchmaking attributes: how many people
	// can join and such.
	Matchmaking ActivityMatchmakingBlockDefinition `json:"matchmaking"`

	// Activities can have Modifiers, as defined in DestinyActivityModifierDefinition. These are references
	// to the modifiers that *can* be applied to that activity, along with data that we use to determine if
	// that modifier is actually active at any given point in time.
	Modifiers []ActivityModifierReferenceDefinition `json:"modifiers"`

	// If there are status strings related to the activity and based on internal state of the game,
	// account, or character, then this will be the definition of those strings and the states needed in
	// order for the strings to be shown.
	OptionalUnlockStrings []ActivityUnlockStringDefinition `json:"optionalUnlockStrings"`

	// The unadulterated form of the display properties, as they ought to be shown in the Director (if the
	// activity appears in the director).
	OriginalDisplayProperties DisplayPropertiesDefinition `json:"originalDisplayProperties"`

	// When Activities are completed, we generate a "Post-Game Carnage Report", or PGCR, with details about
	// what happened in that activity (how many kills someone got, which team won, etc...) We use this
	// image as the background when displaying PGCR information, and often use it when we refer to the
	// Activity in general.
	PgcrImage string `json:"pgcrImage"`

	// The hash identifier for the "Place" on which this Activity is played. Use it to look up the
	// DestinyPlaceDefinition for human readable info about the Place. A Place is the largest-scoped
	// concept for location information. For instance, if the "Place" is Earth, the "Destination" would be
	// a specific city or region on Earth.
	PlaceHash Hash[PlaceDefinition] `json:"placeHash"`

	// Represents all of the possible activities that could be played in the Playlist, along with
	// information that we can use to determine if they are active at the present time.
	PlaylistItems []ActivityPlaylistItemDefinition `json:"playlistItems"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// If the activity has an icon associated with a specific release (such as a DLC), this is the path to
	// that release's icon.
	ReleaseIcon string `json:"releaseIcon"`

	// If the activity will not be visible until a specific and known time, this will be the seconds since
	// the Epoch when it will become visible.
	ReleaseTime int32 `json:"releaseTime"`

	Requirements ActivityRequirementsBlock `json:"requirements"`

	// The expected possible rewards for the activity. These rewards may or may not be accessible for an
	// individual player based on their character state, the account state, and even the game's state
	// overall. But it is a useful reference for possible rewards you can earn in the activity. These match
	// up to rewards displayed when you hover over the Activity in the in-game Director, and often refer to
	// Placeholder or "Dummy" items: items that tell you what you can earn in vague terms rather than what
	// you'll specifically be earning (partly because the game doesn't even know what you'll earn
	// specifically until you roll for it at the end)
	Rewards []ActivityRewardDefinition `json:"rewards"`

	// The title, subtitle, and icon for the activity as determined by Selection Screen data, if there is
	// any for this activity. There won't be data in this field if the activity is never shown in a
	// selection/options screen.
	SelectionScreenDisplayProperties DisplayPropertiesDefinition `json:"selectionScreenDisplayProperties"`

	// The difficulty tier of the activity.
	Tier int32 `json:"tier"`
}

// Destiny.Definitions.DestinyActivityGraphListEntryDefinition
//
// Destinations and Activities may have default Activity Graphs that should be shown when you bring up
// the Director and are playing in either.
// This contract defines the graph referred to and the gating for when it is relevant.
type ActivityGraphListEntryDefinition struct {
	// {
	//   "description": "Destinations and Activities may have default Activity Graphs that should be shown when you bring up the Director and are playing in either.\r\nThis contract defines the graph referred to and the gating for when it is relevant.",
	//   "properties": {
	//     "activityGraphHash": {
	//       "description": "The hash identifier of the DestinyActivityGraphDefinition that should be shown when opening the director.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Director.DestinyActivityGraphDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash identifier of the DestinyActivityGraphDefinition that should be shown when opening the
	// director.
	ActivityGraphHash Hash[ActivityGraphDefinition] `json:"activityGraphHash"`
}

// Destiny.Definitions.DestinyActivityGuidedBlockDefinition
//
// Guided Game information for this activity.
type ActivityGuidedBlockDefinition struct {
	// {
	//   "description": "Guided Game information for this activity.",
	//   "properties": {
	//     "guidedDisbandCount": {
	//       "description": "If -1, the guided group cannot be disbanded. Otherwise, take the total # of players in the activity and subtract this number: that is the total # of votes needed for the guided group to disband.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "guidedMaxLobbySize": {
	//       "description": "The maximum amount of people that can be in the waiting lobby.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "guidedMinLobbySize": {
	//       "description": "The minimum amount of people that can be in the waiting lobby.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// If -1, the guided group cannot be disbanded. Otherwise, take the total # of players in the activity
	// and subtract this number: that is the total # of votes needed for the guided group to disband.
	GuidedDisbandCount int32 `json:"guidedDisbandCount"`

	// The maximum amount of people that can be in the waiting lobby.
	GuidedMaxLobbySize int32 `json:"guidedMaxLobbySize"`

	// The minimum amount of people that can be in the waiting lobby.
	GuidedMinLobbySize int32 `json:"guidedMinLobbySize"`
}

// Destiny.Definitions.DestinyActivityInsertionPointDefinition
//
// A point of entry into an activity, gated by an unlock flag and with some more-or-less useless (for
// our purposes) phase information. I'm including it in case we end up being able to bolt more useful
// information onto it in the future.
// UPDATE: Turns out this information isn't actually useless, and is in fact actually useful for
// people. Who would have thought? We still don't have localized info for it, but at least this will
// help people when they're looking at phase indexes in stats data, or when they want to know what
// phases have been completed on a weekly achievement.
type ActivityInsertionPointDefinition struct {
	// {
	//   "description": "A point of entry into an activity, gated by an unlock flag and with some more-or-less useless (for our purposes) phase information. I'm including it in case we end up being able to bolt more useful information onto it in the future.\r\nUPDATE: Turns out this information isn't actually useless, and is in fact actually useful for people. Who would have thought? We still don't have localized info for it, but at least this will help people when they're looking at phase indexes in stats data, or when they want to know what phases have been completed on a weekly achievement.",
	//   "properties": {
	//     "phaseHash": {
	//       "description": "A unique hash value representing the phase. This can be useful for, for example, comparing how different instances of Raids have phases in different orders!",
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// A unique hash value representing the phase. This can be useful for, for example, comparing how
	// different instances of Raids have phases in different orders!
	PhaseHash uint32 `json:"phaseHash"`
}

// Destiny.Definitions.DestinyActivityLoadoutRequirement
type ActivityLoadoutRequirement struct {
	// {
	//   "properties": {
	//     "allowedEquippedItemHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "allowedWeaponSubTypes": {
	//       "items": {
	//         "description": "This Enumeration further classifies items by more specific categorizations than DestinyItemType. The \"Sub-Type\" is where we classify and categorize items one step further in specificity: \"Auto Rifle\" instead of just \"Weapon\" for example, or \"Vanguard Bounty\" instead of merely \"Bounty\".\r\nThese sub-types are provided for historical compatibility with Destiny 1, but an ideal alternative is to use DestinyItemCategoryDefinitions and the DestinyItemDefinition.itemCategories property instead. Item Categories allow for arbitrary hierarchies of specificity, and for items to belong to multiple categories across multiple hierarchies simultaneously. For this enum, we pick a single type as a \"best guess\" fit.\r\nNOTE: This is not all of the item types available, and some of these are holdovers from Destiny 1 that may or may not still exist.",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/Destiny.DestinyItemSubType"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "equipmentSlotHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyEquipmentSlotDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	AllowedEquippedItemHashes []uint32 `json:"allowedEquippedItemHashes"`

	AllowedWeaponSubTypes []ItemSubType `json:"allowedWeaponSubTypes"`

	EquipmentSlotHash Hash[EquipmentSlotDefinition] `json:"equipmentSlotHash"`
}

// Destiny.Definitions.DestinyActivityLoadoutRequirementSet
type ActivityLoadoutRequirementSet struct {
	// {
	//   "properties": {
	//     "requirements": {
	//       "description": "The set of requirements that will be applied on the activity if this requirement set is active.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityLoadoutRequirement"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The set of requirements that will be applied on the activity if this requirement set is active.
	Requirements []ActivityLoadoutRequirement `json:"requirements"`
}

// Destiny.Definitions.DestinyActivityMatchmakingBlockDefinition
//
// Information about matchmaking and party size for the activity.
type ActivityMatchmakingBlockDefinition struct {
	// {
	//   "description": "Information about matchmaking and party size for the activity.",
	//   "properties": {
	//     "isMatchmade": {
	//       "description": "If TRUE, the activity is matchmade. Otherwise, it requires explicit forming of a party.",
	//       "type": "boolean"
	//     },
	//     "maxParty": {
	//       "description": "The maximum # of people allowed in a Fireteam.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "maxPlayers": {
	//       "description": "The maximum # of people allowed across all teams in the activity.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "minParty": {
	//       "description": "The minimum # of people in the fireteam for the activity to launch.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "requiresGuardianOath": {
	//       "description": "If true, you have to Solemnly Swear to be up to Nothing But Good(tm) to play.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	// If TRUE, the activity is matchmade. Otherwise, it requires explicit forming of a party.
	IsMatchmade bool `json:"isMatchmade"`

	// The maximum # of people allowed in a Fireteam.
	MaxParty int32 `json:"maxParty"`

	// The maximum # of people allowed across all teams in the activity.
	MaxPlayers int32 `json:"maxPlayers"`

	// The minimum # of people in the fireteam for the activity to launch.
	MinParty int32 `json:"minParty"`

	// If true, you have to Solemnly Swear to be up to Nothing But Good(tm) to play.
	RequiresGuardianOath bool `json:"requiresGuardianOath"`
}

// Destiny.Definitions.DestinyActivityModeDefinition
//
// This definition represents an "Activity Mode" as it exists in the Historical Stats endpoints. An
// individual Activity Mode represents a collection of activities that are played in a certain way. For
// example, Nightfall Strikes are part of a "Nightfall" activity mode, and any activities played as the
// PVP mode "Clash" are part of the "Clash activity mode.
// Activity modes are nested under each other in a hierarchy, so that if you ask for - for example -
// "AllPvP", you will get any PVP activities that the user has played, regardless of what specific PVP
// mode was being played.
type ActivityModeDefinition struct {
	// {
	//   "description": "This definition represents an \"Activity Mode\" as it exists in the Historical Stats endpoints. An individual Activity Mode represents a collection of activities that are played in a certain way. For example, Nightfall Strikes are part of a \"Nightfall\" activity mode, and any activities played as the PVP mode \"Clash\" are part of the \"Clash activity mode.\r\nActivity modes are nested under each other in a hierarchy, so that if you ask for - for example - \"AllPvP\", you will get any PVP activities that the user has played, regardless of what specific PVP mode was being played.",
	//   "properties": {
	//     "activityModeCategory": {
	//       "description": "The type of play being performed in broad terms (PVP, PVE)",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyActivityModeCategory"
	//       }
	//     },
	//     "activityModeMappings": {
	//       "additionalProperties": {
	//         "description": "For historical reasons, this list will have both D1 and D2-relevant Activity Modes in it. Please don't take this to mean that some D1-only feature is coming back!",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.DestinyActivityModeType"
	//         }
	//       },
	//       "description": "If this exists, the mode has specific Activities (referred to by the Key) that should instead map to other Activity Modes when they are played. This was useful in D1 for Private Matches, where we wanted to have Private Matches as an activity mode while still referring to the specific mode being played.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "display": {
	//       "description": "If FALSE, we want to ignore this type when we're showing activity modes in BNet UI. It will still be returned in case 3rd parties want to use it for any purpose.",
	//       "type": "boolean"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "friendlyName": {
	//       "description": "A Friendly identifier you can use for referring to this Activity Mode. We really only used this in our URLs, so... you know, take that for whatever it's worth.",
	//       "type": "string"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "isAggregateMode": {
	//       "description": "If true, this mode is an aggregation of other, more specific modes rather than being a mode in itself. This includes modes that group Features/Events rather than Gameplay, such as Trials of The Nine: Trials of the Nine being an Event that is interesting to see aggregate data for, but when you play the activities within Trials of the Nine they are more specific activity modes such as Clash.",
	//       "type": "boolean"
	//     },
	//     "isTeamBased": {
	//       "description": "If True, this mode has oppositional teams fighting against each other rather than \"Free-For-All\" or Co-operative modes of play.\r\nNote that Aggregate modes are never marked as team based, even if they happen to be team based at the moment. At any time, an aggregate whose subordinates are only team based could be changed so that one or more aren't team based, and then this boolean won't make much sense (the aggregation would become \"sometimes team based\"). Let's not deal with that right now.",
	//       "type": "boolean"
	//     },
	//     "modeType": {
	//       "description": "The Enumeration value for this Activity Mode. Pass this identifier into Stats endpoints to get aggregate stats for this mode.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.DestinyActivityModeType"
	//       }
	//     },
	//     "order": {
	//       "description": "The relative ordering of activity modes.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "parentHashes": {
	//       "description": "The hash identifiers of the DestinyActivityModeDefinitions that represent all of the \"parent\" modes for this mode. For instance, the Nightfall Mode is also a member of AllStrikes and AllPvE.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "pgcrImage": {
	//       "description": "If this activity mode has a related PGCR image, this will be the path to said image.",
	//       "type": "string"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "ActivityModes"
	// }

	// The type of play being performed in broad terms (PVP, PVE)
	ActivityModeCategory ActivityModeCategory `json:"activityModeCategory"`

	// If this exists, the mode has specific Activities (referred to by the Key) that should instead map to
	// other Activity Modes when they are played. This was useful in D1 for Private Matches, where we
	// wanted to have Private Matches as an activity mode while still referring to the specific mode being
	// played.
	ActivityModeMappings map[uint32]ActivityModeType `json:"activityModeMappings"`

	// If FALSE, we want to ignore this type when we're showing activity modes in BNet UI. It will still be
	// returned in case 3rd parties want to use it for any purpose.
	Display bool `json:"display"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// A Friendly identifier you can use for referring to this Activity Mode. We really only used this in
	// our URLs, so... you know, take that for whatever it's worth.
	FriendlyName string `json:"friendlyName"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If true, this mode is an aggregation of other, more specific modes rather than being a mode in
	// itself. This includes modes that group Features/Events rather than Gameplay, such as Trials of The
	// Nine: Trials of the Nine being an Event that is interesting to see aggregate data for, but when you
	// play the activities within Trials of the Nine they are more specific activity modes such as Clash.
	IsAggregateMode bool `json:"isAggregateMode"`

	// If True, this mode has oppositional teams fighting against each other rather than "Free-For-All" or
	// Co-operative modes of play.
	// Note that Aggregate modes are never marked as team based, even if they happen to be team based at
	// the moment. At any time, an aggregate whose subordinates are only team based could be changed so
	// that one or more aren't team based, and then this boolean won't make much sense (the aggregation
	// would become "sometimes team based"). Let's not deal with that right now.
	IsTeamBased bool `json:"isTeamBased"`

	// The Enumeration value for this Activity Mode. Pass this identifier into Stats endpoints to get
	// aggregate stats for this mode.
	ModeType ActivityModeType `json:"modeType"`

	// The relative ordering of activity modes.
	Order int32 `json:"order"`

	// The hash identifiers of the DestinyActivityModeDefinitions that represent all of the "parent" modes
	// for this mode. For instance, the Nightfall Mode is also a member of AllStrikes and AllPvE.
	ParentHashes []uint32 `json:"parentHashes"`

	// If this activity mode has a related PGCR image, this will be the path to said image.
	PgcrImage string `json:"pgcrImage"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyActivityModifierReferenceDefinition
//
// A reference to an Activity Modifier from another entity, such as an Activity (for now, just
// Activities).
// This defines some
type ActivityModifierReferenceDefinition struct {
	// {
	//   "description": "A reference to an Activity Modifier from another entity, such as an Activity (for now, just Activities).\r\nThis defines some",
	//   "properties": {
	//     "activityModifierHash": {
	//       "description": "The hash identifier for the DestinyActivityModifierDefinition referenced by this activity.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.ActivityModifiers.DestinyActivityModifierDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash identifier for the DestinyActivityModifierDefinition referenced by this activity.
	ActivityModifierHash Hash[ActivityModifierDefinition] `json:"activityModifierHash"`
}

// Destiny.Definitions.DestinyActivityPlaylistItemDefinition
//
// If the activity is a playlist, this is the definition for a specific entry in the playlist: a single
// possible combination of Activity and Activity Mode that can be chosen.
type ActivityPlaylistItemDefinition struct {
	// {
	//   "description": "If the activity is a playlist, this is the definition for a specific entry in the playlist: a single possible combination of Activity and Activity Mode that can be chosen.",
	//   "properties": {
	//     "activityHash": {
	//       "description": "The hash identifier of the Activity that can be played. Use it to look up the DestinyActivityDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "activityModeHashes": {
	//       "description": "The hash identifiers for Activity Modes relevant to this entry.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityModeDefinition"
	//       }
	//     },
	//     "activityModeTypes": {
	//       "description": "The activity modes - if any - in enum form. Because we can't seem to escape the enums.",
	//       "items": {
	//         "description": "For historical reasons, this list will have both D1 and D2-relevant Activity Modes in it. Please don't take this to mean that some D1-only feature is coming back!",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.DestinyActivityModeType"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "directActivityModeHash": {
	//       "description": "If this playlist entry had an activity mode directly defined on it, this will be the hash of that mode.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityModeDefinition"
	//       }
	//     },
	//     "directActivityModeType": {
	//       "description": "If the playlist entry had an activity mode directly defined on it, this will be the enum value of that mode.",
	//       "enum": [
	//         "0",
	//         "2",
	//         "3",
	//         "4",
	//         "5",
	//         "6",
	//         "7",
	//         "9",
	//         "10",
	//         "11",
	//         "12",
	//         "13",
	//         "15",
	//         "16",
	//         "17",
	//         "18",
	//         "19",
	//         "20",
	//         "21",
	//         "22",
	//         "24",
	//         "25",
	//         "26",
	//         "27",
	//         "28",
	//         "29",
	//         "30",
	//         "31",
	//         "32",
	//         "37",
	//         "38",
	//         "39",
	//         "40",
	//         "41",
	//         "42",
	//         "43",
	//         "44",
	//         "45",
	//         "46",
	//         "47",
	//         "48",
	//         "49",
	//         "50",
	//         "51",
	//         "52",
	//         "53",
	//         "54",
	//         "55",
	//         "56",
	//         "57",
	//         "58",
	//         "59",
	//         "60",
	//         "61",
	//         "62",
	//         "63",
	//         "64",
	//         "65",
	//         "66",
	//         "67",
	//         "68",
	//         "69",
	//         "70",
	//         "71",
	//         "72",
	//         "73",
	//         "74",
	//         "75",
	//         "76",
	//         "77",
	//         "78",
	//         "79",
	//         "80",
	//         "81",
	//         "82",
	//         "83",
	//         "84",
	//         "85",
	//         "86",
	//         "87",
	//         "88",
	//         "89",
	//         "90",
	//         "91",
	//         "92"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "None",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Story",
	//           "numericValue": "2"
	//         },
	//         {
	//           "identifier": "Strike",
	//           "numericValue": "3"
	//         },
	//         {
	//           "identifier": "Raid",
	//           "numericValue": "4"
	//         },
	//         {
	//           "identifier": "AllPvP",
	//           "numericValue": "5"
	//         },
	//         {
	//           "identifier": "Patrol",
	//           "numericValue": "6"
	//         },
	//         {
	//           "identifier": "AllPvE",
	//           "numericValue": "7"
	//         },
	//         {
	//           "identifier": "Reserved9",
	//           "numericValue": "9"
	//         },
	//         {
	//           "identifier": "Control",
	//           "numericValue": "10"
	//         },
	//         {
	//           "identifier": "Reserved11",
	//           "numericValue": "11"
	//         },
	//         {
	//           "description": "Clash -\u003e Destiny's name for Team Deathmatch. 4v4 combat, the team with the highest kills at the end of time wins.",
	//           "identifier": "Clash",
	//           "numericValue": "12"
	//         },
	//         {
	//           "identifier": "Reserved13",
	//           "numericValue": "13"
	//         },
	//         {
	//           "identifier": "CrimsonDoubles",
	//           "numericValue": "15"
	//         },
	//         {
	//           "identifier": "Nightfall",
	//           "numericValue": "16"
	//         },
	//         {
	//           "identifier": "HeroicNightfall",
	//           "numericValue": "17"
	//         },
	//         {
	//           "identifier": "AllStrikes",
	//           "numericValue": "18"
	//         },
	//         {
	//           "identifier": "IronBanner",
	//           "numericValue": "19"
	//         },
	//         {
	//           "identifier": "Reserved20",
	//           "numericValue": "20"
	//         },
	//         {
	//           "identifier": "Reserved21",
	//           "numericValue": "21"
	//         },
	//         {
	//           "identifier": "Reserved22",
	//           "numericValue": "22"
	//         },
	//         {
	//           "identifier": "Reserved24",
	//           "numericValue": "24"
	//         },
	//         {
	//           "identifier": "AllMayhem",
	//           "numericValue": "25"
	//         },
	//         {
	//           "identifier": "Reserved26",
	//           "numericValue": "26"
	//         },
	//         {
	//           "identifier": "Reserved27",
	//           "numericValue": "27"
	//         },
	//         {
	//           "identifier": "Reserved28",
	//           "numericValue": "28"
	//         },
	//         {
	//           "identifier": "Reserved29",
	//           "numericValue": "29"
	//         },
	//         {
	//           "identifier": "Reserved30",
	//           "numericValue": "30"
	//         },
	//         {
	//           "identifier": "Supremacy",
	//           "numericValue": "31"
	//         },
	//         {
	//           "identifier": "PrivateMatchesAll",
	//           "numericValue": "32"
	//         },
	//         {
	//           "identifier": "Survival",
	//           "numericValue": "37"
	//         },
	//         {
	//           "identifier": "Countdown",
	//           "numericValue": "38"
	//         },
	//         {
	//           "identifier": "TrialsOfTheNine",
	//           "numericValue": "39"
	//         },
	//         {
	//           "identifier": "Social",
	//           "numericValue": "40"
	//         },
	//         {
	//           "identifier": "TrialsCountdown",
	//           "numericValue": "41"
	//         },
	//         {
	//           "identifier": "TrialsSurvival",
	//           "numericValue": "42"
	//         },
	//         {
	//           "identifier": "IronBannerControl",
	//           "numericValue": "43"
	//         },
	//         {
	//           "identifier": "IronBannerClash",
	//           "numericValue": "44"
	//         },
	//         {
	//           "identifier": "IronBannerSupremacy",
	//           "numericValue": "45"
	//         },
	//         {
	//           "identifier": "ScoredNightfall",
	//           "numericValue": "46"
	//         },
	//         {
	//           "identifier": "ScoredHeroicNightfall",
	//           "numericValue": "47"
	//         },
	//         {
	//           "identifier": "Rumble",
	//           "numericValue": "48"
	//         },
	//         {
	//           "identifier": "AllDoubles",
	//           "numericValue": "49"
	//         },
	//         {
	//           "identifier": "Doubles",
	//           "numericValue": "50"
	//         },
	//         {
	//           "identifier": "PrivateMatchesClash",
	//           "numericValue": "51"
	//         },
	//         {
	//           "identifier": "PrivateMatchesControl",
	//           "numericValue": "52"
	//         },
	//         {
	//           "identifier": "PrivateMatchesSupremacy",
	//           "numericValue": "53"
	//         },
	//         {
	//           "identifier": "PrivateMatchesCountdown",
	//           "numericValue": "54"
	//         },
	//         {
	//           "identifier": "PrivateMatchesSurvival",
	//           "numericValue": "55"
	//         },
	//         {
	//           "identifier": "PrivateMatchesMayhem",
	//           "numericValue": "56"
	//         },
	//         {
	//           "identifier": "PrivateMatchesRumble",
	//           "numericValue": "57"
	//         },
	//         {
	//           "identifier": "HeroicAdventure",
	//           "numericValue": "58"
	//         },
	//         {
	//           "identifier": "Showdown",
	//           "numericValue": "59"
	//         },
	//         {
	//           "identifier": "Lockdown",
	//           "numericValue": "60"
	//         },
	//         {
	//           "identifier": "Scorched",
	//           "numericValue": "61"
	//         },
	//         {
	//           "identifier": "ScorchedTeam",
	//           "numericValue": "62"
	//         },
	//         {
	//           "identifier": "Gambit",
	//           "numericValue": "63"
	//         },
	//         {
	//           "identifier": "AllPvECompetitive",
	//           "numericValue": "64"
	//         },
	//         {
	//           "identifier": "Breakthrough",
	//           "numericValue": "65"
	//         },
	//         {
	//           "identifier": "BlackArmoryRun",
	//           "numericValue": "66"
	//         },
	//         {
	//           "identifier": "Salvage",
	//           "numericValue": "67"
	//         },
	//         {
	//           "identifier": "IronBannerSalvage",
	//           "numericValue": "68"
	//         },
	//         {
	//           "identifier": "PvPCompetitive",
	//           "numericValue": "69"
	//         },
	//         {
	//           "identifier": "PvPQuickplay",
	//           "numericValue": "70"
	//         },
	//         {
	//           "identifier": "ClashQuickplay",
	//           "numericValue": "71"
	//         },
	//         {
	//           "identifier": "ClashCompetitive",
	//           "numericValue": "72"
	//         },
	//         {
	//           "identifier": "ControlQuickplay",
	//           "numericValue": "73"
	//         },
	//         {
	//           "identifier": "ControlCompetitive",
	//           "numericValue": "74"
	//         },
	//         {
	//           "identifier": "GambitPrime",
	//           "numericValue": "75"
	//         },
	//         {
	//           "identifier": "Reckoning",
	//           "numericValue": "76"
	//         },
	//         {
	//           "identifier": "Menagerie",
	//           "numericValue": "77"
	//         },
	//         {
	//           "identifier": "VexOffensive",
	//           "numericValue": "78"
	//         },
	//         {
	//           "identifier": "NightmareHunt",
	//           "numericValue": "79"
	//         },
	//         {
	//           "identifier": "Elimination",
	//           "numericValue": "80"
	//         },
	//         {
	//           "identifier": "Momentum",
	//           "numericValue": "81"
	//         },
	//         {
	//           "identifier": "Dungeon",
	//           "numericValue": "82"
	//         },
	//         {
	//           "identifier": "Sundial",
	//           "numericValue": "83"
	//         },
	//         {
	//           "identifier": "TrialsOfOsiris",
	//           "numericValue": "84"
	//         },
	//         {
	//           "identifier": "Dares",
	//           "numericValue": "85"
	//         },
	//         {
	//           "identifier": "Offensive",
	//           "numericValue": "86"
	//         },
	//         {
	//           "identifier": "LostSector",
	//           "numericValue": "87"
	//         },
	//         {
	//           "identifier": "Rift",
	//           "numericValue": "88"
	//         },
	//         {
	//           "identifier": "ZoneControl",
	//           "numericValue": "89"
	//         },
	//         {
	//           "identifier": "IronBannerRift",
	//           "numericValue": "90"
	//         },
	//         {
	//           "identifier": "IronBannerZoneControl",
	//           "numericValue": "91"
	//         },
	//         {
	//           "identifier": "Relic",
	//           "numericValue": "92"
	//         }
	//       ]
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash identifier of the Activity that can be played. Use it to look up the
	// DestinyActivityDefinition.
	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`

	// The hash identifiers for Activity Modes relevant to this entry.
	ActivityModeHashes []uint32 `json:"activityModeHashes"`

	// The activity modes - if any - in enum form. Because we can't seem to escape the enums.
	ActivityModeTypes []ActivityModeType `json:"activityModeTypes"`

	// If this playlist entry had an activity mode directly defined on it, this will be the hash of that
	// mode.
	DirectActivityModeHash Nullable[Hash[ActivityModeDefinition]] `json:"directActivityModeHash,omitempty"`

	// If the playlist entry had an activity mode directly defined on it, this will be the enum value of
	// that mode.
	DirectActivityModeType Nullable[int32] `json:"directActivityModeType,omitempty"`
}

// Destiny.Definitions.DestinyActivityRequirementLabel
type ActivityRequirementLabel struct {
	// {
	//   "properties": {
	//     "displayString": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	DisplayString string `json:"displayString"`
}

// Destiny.Definitions.DestinyActivityRequirementsBlock
type ActivityRequirementsBlock struct {
	// {
	//   "properties": {
	//     "fireteamRequirementLabels": {
	//       "description": "If being a fireteam member in this activity is gated, this is the gate being checked.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityRequirementLabel"
	//       },
	//       "type": "array"
	//     },
	//     "leaderRequirementLabels": {
	//       "description": "If being a fireteam Leader in this activity is gated, this is the gate being checked.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityRequirementLabel"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// If being a fireteam member in this activity is gated, this is the gate being checked.
	FireteamRequirementLabels []ActivityRequirementLabel `json:"fireteamRequirementLabels"`

	// If being a fireteam Leader in this activity is gated, this is the gate being checked.
	LeaderRequirementLabels []ActivityRequirementLabel `json:"leaderRequirementLabels"`
}

// Destiny.Definitions.DestinyActivityRewardDefinition
//
// Activities can refer to one or more sets of tooltip-friendly reward data. These are the definitions
// for those tooltip friendly rewards.
type ActivityRewardDefinition struct {
	// {
	//   "description": "Activities can refer to one or more sets of tooltip-friendly reward data. These are the definitions for those tooltip friendly rewards.",
	//   "properties": {
	//     "rewardItems": {
	//       "description": "The \"Items provided\" in the reward. This is almost always a pointer to a DestinyInventoryItemDefintion for an item that you can't actually earn in-game, but that has name/description/icon information for the vague concept of the rewards you will receive. This is because the actual reward generation is non-deterministic and extremely complicated, so the best the game can do is tell you what you'll get in vague terms. And so too shall we.\r\nInteresting trivia: you actually *do* earn these items when you complete the activity. They go into a single-slot bucket on your profile, which is how you see the pop-ups of these rewards when you complete an activity that match these \"dummy\" items. You can even see them if you look at the last one you earned in your profile-level inventory through the BNet API! Who said reading documentation is a waste of time?",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemQuantity"
	//       },
	//       "type": "array"
	//     },
	//     "rewardText": {
	//       "description": "The header for the reward set, if any.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// The "Items provided" in the reward. This is almost always a pointer to a
	// DestinyInventoryItemDefintion for an item that you can't actually earn in-game, but that has
	// name/description/icon information for the vague concept of the rewards you will receive. This is
	// because the actual reward generation is non-deterministic and extremely complicated, so the best the
	// game can do is tell you what you'll get in vague terms. And so too shall we.
	// Interesting trivia: you actually *do* earn these items when you complete the activity. They go into
	// a single-slot bucket on your profile, which is how you see the pop-ups of these rewards when you
	// complete an activity that match these "dummy" items. You can even see them if you look at the last
	// one you earned in your profile-level inventory through the BNet API! Who said reading documentation
	// is a waste of time?
	RewardItems []ItemQuantity `json:"rewardItems"`

	// The header for the reward set, if any.
	RewardText string `json:"rewardText"`
}

// Destiny.Definitions.DestinyActivityTypeDefinition
//
// The definition for an Activity Type.
// In Destiny 2, an Activity Type represents a conceptual categorization of Activities.
// These are most commonly used in the game for the subtitle under Activities, but BNet uses them
// extensively to identify and group activities by their common properties.
// Unfortunately, there has been a movement away from providing the richer data in Destiny 2 that we
// used to get in Destiny 1 for Activity Types. For instance, Nightfalls are grouped under the same
// Activity Type as regular Strikes.
// For this reason, BNet will eventually migrate toward Activity Modes as a better indicator of
// activity category. But for the time being, it is still referred to in many places across our
// codebase.
type ActivityTypeDefinition struct {
	// {
	//   "description": "The definition for an Activity Type.\r\nIn Destiny 2, an Activity Type represents a conceptual categorization of Activities.\r\nThese are most commonly used in the game for the subtitle under Activities, but BNet uses them extensively to identify and group activities by their common properties.\r\nUnfortunately, there has been a movement away from providing the richer data in Destiny 2 that we used to get in Destiny 1 for Activity Types. For instance, Nightfalls are grouped under the same Activity Type as regular Strikes. \r\nFor this reason, BNet will eventually migrate toward Activity Modes as a better indicator of activity category. But for the time being, it is still referred to in many places across our codebase.",
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "ActivityTypes"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyActivityUnlockStringDefinition
//
// Represents a status string that could be conditionally displayed about an activity. Note that
// externally, you can only see the strings themselves. Internally we combine this information with
// server state to determine which strings should be shown.
type ActivityUnlockStringDefinition struct {
	// {
	//   "description": "Represents a status string that could be conditionally displayed about an activity. Note that externally, you can only see the strings themselves. Internally we combine this information with server state to determine which strings should be shown.",
	//   "properties": {
	//     "displayString": {
	//       "description": "The string to be displayed if the conditions are met.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// The string to be displayed if the conditions are met.
	DisplayString string `json:"displayString"`
}

// Destiny.Definitions.DestinyArrangementRegionFilterDefinition
type ArrangementRegionFilterDefinition struct {
	// {
	//   "properties": {
	//     "arrangementIndexByStatValue": {
	//       "additionalProperties": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "int32",
	//         "type": "integer"
	//       }
	//     },
	//     "artArrangementRegionHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "artArrangementRegionIndex": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "statHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	ArrangementIndexByStatValue map[int32]int32 `json:"arrangementIndexByStatValue"`

	ArtArrangementRegionHash uint32 `json:"artArrangementRegionHash"`

	ArtArrangementRegionIndex int32 `json:"artArrangementRegionIndex"`

	StatHash uint32 `json:"statHash"`
}

// Destiny.Definitions.DestinyArtDyeReference
type ArtDyeReference struct {
	// {
	//   "properties": {
	//     "artDyeChannelHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	ArtDyeChannelHash uint32 `json:"artDyeChannelHash"`
}

// Destiny.Definitions.DestinyBubbleDefinition
//
// Basic identifying data about the bubble. Combine with DestinyDestinationBubbleSettingDefinition -
// see DestinyDestinationDefinition.bubbleSettings for more information.
type BubbleDefinition struct {
	// {
	//   "description": "Basic identifying data about the bubble. Combine with DestinyDestinationBubbleSettingDefinition - see DestinyDestinationDefinition.bubbleSettings for more information.",
	//   "properties": {
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "The display properties of this bubble, so you don't have to look them up in a separate list anymore.",
	//       "type": "object"
	//     },
	//     "hash": {
	//       "description": "The identifier for the bubble: only guaranteed to be unique within the Destination.",
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// The display properties of this bubble, so you don't have to look them up in a separate list anymore.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The identifier for the bubble: only guaranteed to be unique within the Destination.
	Hash uint32 `json:"hash"`
}

// Destiny.Definitions.DestinyClassDefinition
//
// Defines a Character Class in Destiny 2. These are types of characters you can play, like Titan,
// Warlock, and Hunter.
type ClassDefinition struct {
	// {
	//   "description": "Defines a Character Class in Destiny 2. These are types of characters you can play, like Titan, Warlock, and Hunter.",
	//   "properties": {
	//     "classType": {
	//       "description": "In Destiny 1, we added a convenience Enumeration for referring to classes. We've kept it, though mostly for posterity. This is the enum value for this definition's class.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyClass"
	//       }
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "genderedClassNames": {
	//       "additionalProperties": {
	//         "type": "string"
	//       },
	//       "description": "A localized string referring to the singular form of the Class's name when referred to in gendered form. Keyed by the DestinyGender.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/Destiny.DestinyGender"
	//         }
	//       }
	//     },
	//     "genderedClassNamesByGenderHash": {
	//       "additionalProperties": {
	//         "type": "string"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyGenderDefinition"
	//       }
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "mentorVendorHash": {
	//       "description": "Mentors don't really mean anything anymore. Don't expect this to be populated.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Classes"
	// }

	// In Destiny 1, we added a convenience Enumeration for referring to classes. We've kept it, though
	// mostly for posterity. This is the enum value for this definition's class.
	ClassType Class `json:"classType"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// A localized string referring to the singular form of the Class's name when referred to in gendered
	// form. Keyed by the DestinyGender.
	GenderedClassNames map[string]string `json:"genderedClassNames"`

	GenderedClassNamesByGenderHash map[Hash[GenderDefinition]]string `json:"genderedClassNamesByGenderHash"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// Mentors don't really mean anything anymore. Don't expect this to be populated.
	MentorVendorHash Nullable[Hash[VendorDefinition]] `json:"mentorVendorHash,omitempty"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyDamageTypeDefinition
//
// All damage types that are possible in the game are defined here, along with localized info and icons
// as needed.
type DamageTypeDefinition struct {
	// {
	//   "description": "All damage types that are possible in the game are defined here, along with localized info and icons as needed.",
	//   "properties": {
	//     "color": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Misc.DestinyColor"
	//         }
	//       ],
	//       "description": "A color associated with the damage type. The displayProperties icon is tinted with a color close to this.",
	//       "type": "object"
	//     },
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "The description of the damage type, icon etc...",
	//       "type": "object"
	//     },
	//     "enumValue": {
	//       "description": "We have an enumeration for damage types for quick reference. This is the current definition's damage type enum value.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DamageType"
	//       }
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "showIcon": {
	//       "description": "If TRUE, the game shows this damage type's icon. Otherwise, it doesn't. Whether you show it or not is up to you.",
	//       "type": "boolean"
	//     },
	//     "transparentIconPath": {
	//       "description": "A variant of the icon that is transparent and colorless.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "DamageTypes"
	// }

	// A color associated with the damage type. The displayProperties icon is tinted with a color close to
	// this.
	Color Color `json:"color"`

	// The description of the damage type, icon etc...
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// We have an enumeration for damage types for quick reference. This is the current definition's damage
	// type enum value.
	EnumValue DamageType `json:"enumValue"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// If TRUE, the game shows this damage type's icon. Otherwise, it doesn't. Whether you show it or not
	// is up to you.
	ShowIcon bool `json:"showIcon"`

	// A variant of the icon that is transparent and colorless.
	TransparentIconPath string `json:"transparentIconPath"`
}

// Destiny.Definitions.DestinyDefinition
//
// Provides common properties for destiny definitions.
type Definition struct {
	// {
	//   "description": "Provides common properties for destiny definitions.",
	//   "properties": {
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyDestinationBubbleSettingDefinition
//
// Human readable data about the bubble. Combine with DestinyBubbleDefinition - see
// DestinyDestinationDefinition.bubbleSettings for more information.
// DEPRECATED - Just use bubbles.
type DestinationBubbleSettingDefinition struct {
	// {
	//   "description": "Human readable data about the bubble. Combine with DestinyBubbleDefinition - see DestinyDestinationDefinition.bubbleSettings for more information.\r\nDEPRECATED - Just use bubbles.",
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     }
	//   },
	//   "type": "object"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`
}

// Destiny.Definitions.DestinyDestinationDefinition
//
// On to one of the more confusing subjects of the API. What is a Destination, and what is the
// relationship between it, Activities, Locations, and Places?
// A "Destination" is a specific region/city/area of a larger "Place". For instance, a Place might be
// Earth where a Destination might be Bellevue, Washington. (Please, pick a more interesting
// destination if you come to visit Earth).
type DestinationDefinition struct {
	// {
	//   "description": "On to one of the more confusing subjects of the API. What is a Destination, and what is the relationship between it, Activities, Locations, and Places?\r\nA \"Destination\" is a specific region/city/area of a larger \"Place\". For instance, a Place might be Earth where a Destination might be Bellevue, Washington. (Please, pick a more interesting destination if you come to visit Earth).",
	//   "properties": {
	//     "activityGraphEntries": {
	//       "description": "If the Destination has default Activity Graphs (i.e. \"Map\") that should be shown in the director, this is the list of those Graphs. At most, only one should be active at any given time for a Destination: these would represent, for example, different variants on a Map if the Destination is changing on a macro level based on game state.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityGraphListEntryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "bubbleSettings": {
	//       "description": "A Destination may have many \"Bubbles\" zones with human readable properties.\r\nWe don't get as much info as I'd like about them - I'd love to return info like where on the map they are located - but at least this gives you the name of those bubbles. bubbleSettings and bubbles both have the identical number of entries, and you should match up their indexes to provide matching bubble and bubbleSettings data.\r\nDEPRECATED - Just use bubbles, it now has this data.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyDestinationBubbleSettingDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "bubbles": {
	//       "description": "This provides the unique identifiers for every bubble in the destination (only guaranteed unique within the destination), and any intrinsic properties of the bubble.\r\nbubbleSettings and bubbles both have the identical number of entries, and you should match up their indexes to provide matching bubble and bubbleSettings data.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyBubbleDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "defaultFreeroamActivityHash": {
	//       "description": "If this Destination has a default Free-Roam activity, this is the hash for that Activity. Use it to look up the DestinyActivityDefintion.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "placeHash": {
	//       "description": "The place that \"owns\" this Destination. Use this hash to look up the DestinyPlaceDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyPlaceDefinition"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Destinations"
	// }

	// If the Destination has default Activity Graphs (i.e. "Map") that should be shown in the director,
	// this is the list of those Graphs. At most, only one should be active at any given time for a
	// Destination: these would represent, for example, different variants on a Map if the Destination is
	// changing on a macro level based on game state.
	ActivityGraphEntries []ActivityGraphListEntryDefinition `json:"activityGraphEntries"`

	// A Destination may have many "Bubbles" zones with human readable properties.
	// We don't get as much info as I'd like about them - I'd love to return info like where on the map
	// they are located - but at least this gives you the name of those bubbles. bubbleSettings and bubbles
	// both have the identical number of entries, and you should match up their indexes to provide matching
	// bubble and bubbleSettings data.
	// DEPRECATED - Just use bubbles, it now has this data.
	BubbleSettings []DestinationBubbleSettingDefinition `json:"bubbleSettings"`

	// This provides the unique identifiers for every bubble in the destination (only guaranteed unique
	// within the destination), and any intrinsic properties of the bubble.
	// bubbleSettings and bubbles both have the identical number of entries, and you should match up their
	// indexes to provide matching bubble and bubbleSettings data.
	Bubbles []BubbleDefinition `json:"bubbles"`

	// If this Destination has a default Free-Roam activity, this is the hash for that Activity. Use it to
	// look up the DestinyActivityDefintion.
	DefaultFreeroamActivityHash Hash[ActivityDefinition] `json:"defaultFreeroamActivityHash"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// The place that "owns" this Destination. Use this hash to look up the DestinyPlaceDefinition.
	PlaceHash Hash[PlaceDefinition] `json:"placeHash"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyDisplayCategoryDefinition
//
// Display Categories are different from "categories" in that these are specifically for visual
// grouping and display of categories in Vendor UI. The "categories" structure is for validation of the
// contained items, and can be categorized entirely separately from "Display Categories", there need be
// and often will be no meaningful relationship between the two.
type DisplayCategoryDefinition struct {
	// {
	//   "description": "Display Categories are different from \"categories\" in that these are specifically for visual grouping and display of categories in Vendor UI. The \"categories\" structure is for validation of the contained items, and can be categorized entirely separately from \"Display Categories\", there need be and often will be no meaningful relationship between the two.",
	//   "properties": {
	//     "displayCategoryHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "displayInBanner": {
	//       "description": "If true, this category should be displayed in the \"Banner\" section of the vendor's UI.",
	//       "type": "boolean"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "displayStyleHash": {
	//       "description": "An indicator of how the category will be displayed in the UI. It's up to you to do something cool or interesting in response to this, or just to treat it as a normal category.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "displayStyleIdentifier": {
	//       "description": "An indicator of how the category will be displayed in the UI. It's up to you to do something cool or interesting in response to this, or just to treat it as a normal category.",
	//       "type": "string"
	//     },
	//     "identifier": {
	//       "description": "A string identifier for the display category.",
	//       "type": "string"
	//     },
	//     "index": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "progressionHash": {
	//       "description": "If it exists, this is the hash identifier of a DestinyProgressionDefinition that represents the progression to show on this display category.\r\nSpecific categories can now have thier own distinct progression, apparently. So that's cool.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionDefinition"
	//       }
	//     },
	//     "sortOrder": {
	//       "description": "If this category sorts items in a nonstandard way, this will be the way we sort.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.VendorDisplayCategorySortOrder"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	DisplayCategoryHash uint32 `json:"displayCategoryHash"`

	// If true, this category should be displayed in the "Banner" section of the vendor's UI.
	DisplayInBanner bool `json:"displayInBanner"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// An indicator of how the category will be displayed in the UI. It's up to you to do something cool or
	// interesting in response to this, or just to treat it as a normal category.
	DisplayStyleHash Nullable[uint32] `json:"displayStyleHash,omitempty"`

	// An indicator of how the category will be displayed in the UI. It's up to you to do something cool or
	// interesting in response to this, or just to treat it as a normal category.
	DisplayStyleIdentifier string `json:"displayStyleIdentifier"`

	// A string identifier for the display category.
	Identifier string `json:"identifier"`

	Index int32 `json:"index"`

	// If it exists, this is the hash identifier of a DestinyProgressionDefinition that represents the
	// progression to show on this display category.
	// Specific categories can now have thier own distinct progression, apparently. So that's cool.
	ProgressionHash Nullable[Hash[ProgressionDefinition]] `json:"progressionHash,omitempty"`

	// If this category sorts items in a nonstandard way, this will be the way we sort.
	SortOrder VendorDisplayCategorySortOrder `json:"sortOrder"`
}

// Destiny.Definitions.DestinyEntitySearchResult
//
// The results of a search for Destiny content. This will be improved on over time, I've been doing
// some experimenting to see what might be useful.
type EntitySearchResult struct {
	// {
	//   "description": "The results of a search for Destiny content. This will be improved on over time, I've been doing some experimenting to see what might be useful.",
	//   "properties": {
	//     "results": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SearchResultOfDestinyEntitySearchResultItem"
	//         }
	//       ],
	//       "description": "The items found that are matches/near matches for the searched-for term, sorted by something vaguely resembling \"relevance\". Hopefully this will get better in the future.",
	//       "type": "object"
	//     },
	//     "suggestedWords": {
	//       "description": "A list of suggested words that might make for better search results, based on the text searched for.",
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The items found that are matches/near matches for the searched-for term, sorted by something vaguely
	// resembling "relevance". Hopefully this will get better in the future.
	Results SearchResult[EntitySearchResultItem] `json:"results"`

	// A list of suggested words that might make for better search results, based on the text searched for.
	SuggestedWords []string `json:"suggestedWords"`
}

// Destiny.Definitions.DestinyEntitySearchResultItem
//
// An individual Destiny Entity returned from the entity search.
type EntitySearchResultItem struct {
	// {
	//   "description": "An individual Destiny Entity returned from the entity search.",
	//   "properties": {
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "Basic display properties on the entity, so you don't have to look up the definition to show basic results for the item.",
	//       "type": "object"
	//     },
	//     "entityType": {
	//       "description": "The type of entity, returned as a string matching the DestinyDefinition's contract class name. You'll have to have your own mapping from class names to actually looking up those definitions in the manifest databases.",
	//       "type": "string"
	//     },
	//     "hash": {
	//       "description": "The hash identifier of the entity. You will use this to look up the DestinyDefinition relevant for the entity found.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "weight": {
	//       "description": "The ranking value for sorting that we calculated using our relevance formula. This will hopefully get better with time and iteration.",
	//       "format": "double",
	//       "type": "number"
	//     }
	//   },
	//   "type": "object"
	// }

	// Basic display properties on the entity, so you don't have to look up the definition to show basic
	// results for the item.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The type of entity, returned as a string matching the DestinyDefinition's contract class name.
	// You'll have to have your own mapping from class names to actually looking up those definitions in
	// the manifest databases.
	EntityType string `json:"entityType"`

	// The hash identifier of the entity. You will use this to look up the DestinyDefinition relevant for
	// the entity found.
	Hash uint32 `json:"hash"`

	// The ranking value for sorting that we calculated using our relevance formula. This will hopefully
	// get better with time and iteration.
	Weight float64 `json:"weight"`
}

// Destiny.Definitions.DestinyEquipmentSlotDefinition
//
// Characters can not only have Inventory buckets (containers of items that are generally matched by
// their type or functionality), they can also have Equipment Slots.
// The Equipment Slot is an indicator that the related bucket can have instanced items equipped on the
// character. For instance, the Primary Weapon bucket has an Equipment Slot that determines whether you
// can equip primary weapons, and holds the association between its slot and the inventory bucket from
// which it can have items equipped.
// An Equipment Slot must have a related Inventory Bucket, but not all inventory buckets must have
// Equipment Slots.
type EquipmentSlotDefinition struct {
	// {
	//   "description": "Characters can not only have Inventory buckets (containers of items that are generally matched by their type or functionality), they can also have Equipment Slots.\r\nThe Equipment Slot is an indicator that the related bucket can have instanced items equipped on the character. For instance, the Primary Weapon bucket has an Equipment Slot that determines whether you can equip primary weapons, and holds the association between its slot and the inventory bucket from which it can have items equipped.\r\nAn Equipment Slot must have a related Inventory Bucket, but not all inventory buckets must have Equipment Slots.",
	//   "properties": {
	//     "applyCustomArtDyes": {
	//       "description": "If True, equipped items should have their custom art dyes applied when rendering the item. Otherwise, custom art dyes on an item should be ignored if the item is equipped in this slot.",
	//       "type": "boolean"
	//     },
	//     "artDyeChannels": {
	//       "description": "The Art Dye Channels that apply to this equipment slot.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyArtDyeReference"
	//       },
	//       "type": "array"
	//     },
	//     "bucketTypeHash": {
	//       "description": "The inventory bucket that owns this equipment slot.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryBucketDefinition"
	//       }
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "equipmentCategoryHash": {
	//       "description": "These technically point to \"Equipment Category Definitions\". But don't get excited. There's nothing of significant value in those definitions, so I didn't bother to expose them. You can use the hash here to group equipment slots by common functionality, which serves the same purpose as if we had the Equipment Category definitions exposed.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "EquipmentSlots"
	// }

	// If True, equipped items should have their custom art dyes applied when rendering the item.
	// Otherwise, custom art dyes on an item should be ignored if the item is equipped in this slot.
	ApplyCustomArtDyes bool `json:"applyCustomArtDyes"`

	// The Art Dye Channels that apply to this equipment slot.
	ArtDyeChannels []ArtDyeReference `json:"artDyeChannels"`

	// The inventory bucket that owns this equipment slot.
	BucketTypeHash Hash[InventoryBucketDefinition] `json:"bucketTypeHash"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// These technically point to "Equipment Category Definitions". But don't get excited. There's nothing
	// of significant value in those definitions, so I didn't bother to expose them. You can use the hash
	// here to group equipment slots by common functionality, which serves the same purpose as if we had
	// the Equipment Category definitions exposed.
	EquipmentCategoryHash uint32 `json:"equipmentCategoryHash"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyEquippingBlockDefinition
//
// Items that can be equipped define this block. It contains information we need to understand how and
// when the item can be equipped.
type EquippingBlockDefinition struct {
	// {
	//   "description": "Items that can be equipped define this block. It contains information we need to understand how and when the item can be equipped.",
	//   "properties": {
	//     "ammoType": {
	//       "description": "Ammo type used by a weapon is no longer determined by the bucket in which it is contained. If the item has an ammo type - i.e. if it is a weapon - this will be the type of ammunition expected.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyAmmunitionType"
	//       }
	//     },
	//     "attributes": {
	//       "description": "These are custom attributes on the equippability of the item.\r\nFor now, this can only be \"equip on acquire\", which would mean that the item will be automatically equipped as soon as you pick it up.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.EquippingItemBlockAttributes"
	//       }
	//     },
	//     "displayStrings": {
	//       "description": "These are strings that represent the possible Game/Account/Character state failure conditions that can occur when trying to equip the item. They match up one-to-one with requiredUnlockExpressions.",
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     },
	//     "equipmentSlotTypeHash": {
	//       "description": "An equipped item *must* be equipped in an Equipment Slot. This is the hash identifier of the DestinyEquipmentSlotDefinition into which it must be equipped.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyEquipmentSlotDefinition"
	//       }
	//     },
	//     "gearsetItemHash": {
	//       "description": "If the item is part of a gearset, this is a reference to that gearset item.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "uniqueLabel": {
	//       "description": "If defined, this is the label used to check if the item has other items of matching types already equipped. \r\nFor instance, when you aren't allowed to equip more than one Exotic Weapon, that's because all exotic weapons have identical uniqueLabels and the game checks the to-be-equipped item's uniqueLabel vs. all other already equipped items (other than the item in the slot that's about to be occupied).",
	//       "type": "string"
	//     },
	//     "uniqueLabelHash": {
	//       "description": "The hash of that unique label. Does not point to a specific definition.",
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// Ammo type used by a weapon is no longer determined by the bucket in which it is contained. If the
	// item has an ammo type - i.e. if it is a weapon - this will be the type of ammunition expected.
	AmmoType AmmunitionType `json:"ammoType"`

	// These are custom attributes on the equippability of the item.
	// For now, this can only be "equip on acquire", which would mean that the item will be automatically
	// equipped as soon as you pick it up.
	Attributes BitmaskSet[EquippingItemBlockAttributes] `json:"attributes"`

	// These are strings that represent the possible Game/Account/Character state failure conditions that
	// can occur when trying to equip the item. They match up one-to-one with requiredUnlockExpressions.
	DisplayStrings []string `json:"displayStrings"`

	// An equipped item *must* be equipped in an Equipment Slot. This is the hash identifier of the
	// DestinyEquipmentSlotDefinition into which it must be equipped.
	EquipmentSlotTypeHash Hash[EquipmentSlotDefinition] `json:"equipmentSlotTypeHash"`

	// If the item is part of a gearset, this is a reference to that gearset item.
	GearsetItemHash Nullable[Hash[InventoryItemDefinition]] `json:"gearsetItemHash,omitempty"`

	// If defined, this is the label used to check if the item has other items of matching types already
	// equipped.
	// For instance, when you aren't allowed to equip more than one Exotic Weapon, that's because all
	// exotic weapons have identical uniqueLabels and the game checks the to-be-equipped item's uniqueLabel
	// vs. all other already equipped items (other than the item in the slot that's about to be occupied).
	UniqueLabel string `json:"uniqueLabel"`

	// The hash of that unique label. Does not point to a specific definition.
	UniqueLabelHash uint32 `json:"uniqueLabelHash"`
}

// Destiny.Definitions.DestinyFactionDefinition
//
// These definitions represent Factions in the game. Factions have ended up unilaterally being related
// to Vendors that represent them, but that need not necessarily be the case.
// A Faction is really just an entity that has a related progression for which a character can gain
// experience. In Destiny 1, Dead Orbit was an example of a Faction: there happens to be a Vendor that
// represents Dead Orbit (and indeed, DestinyVendorDefinition.factionHash defines to this
// relationship), but Dead Orbit could theoretically exist without the Vendor that provides rewards.
type FactionDefinition struct {
	// {
	//   "description": "These definitions represent Factions in the game. Factions have ended up unilaterally being related to Vendors that represent them, but that need not necessarily be the case.\r\nA Faction is really just an entity that has a related progression for which a character can gain experience. In Destiny 1, Dead Orbit was an example of a Faction: there happens to be a Vendor that represents Dead Orbit (and indeed, DestinyVendorDefinition.factionHash defines to this relationship), but Dead Orbit could theoretically exist without the Vendor that provides rewards.",
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "progressionHash": {
	//       "description": "The hash identifier for the DestinyProgressionDefinition that indicates the character's relationship with this faction in terms of experience and levels.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionDefinition"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "rewardItemHash": {
	//       "description": "The faction reward item hash, usually an engram.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "rewardVendorHash": {
	//       "description": "The faction reward vendor hash, used for faction engram previews.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     },
	//     "tokenValues": {
	//       "additionalProperties": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "description": "The faction token item hashes, and their respective progression values.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "vendors": {
	//       "description": "List of vendors that are associated with this faction. The last vendor that passes the unlock flag checks is the one that should be shown.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyFactionVendorDefinition"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Factions"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// The hash identifier for the DestinyProgressionDefinition that indicates the character's relationship
	// with this faction in terms of experience and levels.
	ProgressionHash Hash[ProgressionDefinition] `json:"progressionHash"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// The faction reward item hash, usually an engram.
	RewardItemHash Hash[InventoryItemDefinition] `json:"rewardItemHash"`

	// The faction reward vendor hash, used for faction engram previews.
	RewardVendorHash Hash[VendorDefinition] `json:"rewardVendorHash"`

	// The faction token item hashes, and their respective progression values.
	TokenValues map[uint32]uint32 `json:"tokenValues"`

	// List of vendors that are associated with this faction. The last vendor that passes the unlock flag
	// checks is the one that should be shown.
	Vendors []FactionVendorDefinition `json:"vendors"`
}

// Destiny.Definitions.DestinyFactionVendorDefinition
//
// These definitions represent faction vendors at different points in the game.
// A single faction may contain multiple vendors, or the same vendor available at two different
// locations.
type FactionVendorDefinition struct {
	// {
	//   "description": "These definitions represent faction vendors at different points in the game.\r\nA single faction may contain multiple vendors, or the same vendor available at two different locations.",
	//   "properties": {
	//     "backgroundImagePath": {
	//       "description": "The relative path to the background image representing this Vendor at this location, for use in a banner.",
	//       "type": "string"
	//     },
	//     "destinationHash": {
	//       "description": "The hash identifier for a Destination at which this vendor may be located. Each destination where a Vendor may exist will only ever have a single entry.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyDestinationDefinition"
	//       }
	//     },
	//     "vendorHash": {
	//       "description": "The faction vendor hash.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The relative path to the background image representing this Vendor at this location, for use in a
	// banner.
	BackgroundImagePath string `json:"backgroundImagePath"`

	// The hash identifier for a Destination at which this vendor may be located. Each destination where a
	// Vendor may exist will only ever have a single entry.
	DestinationHash Hash[DestinationDefinition] `json:"destinationHash"`

	// The faction vendor hash.
	VendorHash Hash[VendorDefinition] `json:"vendorHash"`
}

// Destiny.Definitions.DestinyGearArtArrangementReference
type GearArtArrangementReference struct {
	// {
	//   "properties": {
	//     "artArrangementHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "classHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyClassDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	ArtArrangementHash uint32 `json:"artArrangementHash"`

	ClassHash Hash[ClassDefinition] `json:"classHash"`
}

// Destiny.Definitions.DestinyGenderDefinition
//
// Gender is a social construct, and as such we have definitions for Genders. Right now there happens
// to only be two, but we'll see what the future holds.
type GenderDefinition struct {
	// {
	//   "description": "Gender is a social construct, and as such we have definitions for Genders. Right now there happens to only be two, but we'll see what the future holds.",
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "genderType": {
	//       "description": "This is a quick reference enumeration for all of the currently defined Genders. We use the enumeration for quicker lookups in related data, like DestinyClassDefinition.genderedClassNames.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyGender"
	//       }
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Genders"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// This is a quick reference enumeration for all of the currently defined Genders. We use the
	// enumeration for quicker lookups in related data, like DestinyClassDefinition.genderedClassNames.
	GenderType Gender `json:"genderType"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyInventoryBucketDefinition
//
// An Inventory (be it Character or Profile level) is comprised of many Buckets. An example of a bucket
// is "Primary Weapons", where all of the primary weapons on a character are gathered together into a
// single visual element in the UI: a subset of the inventory that has a limited number of slots, and
// in this case also has an associated Equipment Slot for equipping an item in the bucket.
// Item definitions declare what their "default" bucket is
// (DestinyInventoryItemDefinition.inventory.bucketTypeHash), and Item instances will tell you which
// bucket they are currently residing in (DestinyItemComponent.bucketHash). You can use this
// information along with the DestinyInventoryBucketDefinition to show these items grouped by bucket.
// You cannot transfer an item to a bucket that is not its Default without going through a Vendor's
// "accepted items" (DestinyVendorDefinition.acceptedItems). This is how transfer functionality like
// the Vault is implemented, as a feature of a Vendor. See the vendor's acceptedItems property for more
// details.
type InventoryBucketDefinition struct {
	// {
	//   "description": "An Inventory (be it Character or Profile level) is comprised of many Buckets. An example of a bucket is \"Primary Weapons\", where all of the primary weapons on a character are gathered together into a single visual element in the UI: a subset of the inventory that has a limited number of slots, and in this case also has an associated Equipment Slot for equipping an item in the bucket.\r\nItem definitions declare what their \"default\" bucket is (DestinyInventoryItemDefinition.inventory.bucketTypeHash), and Item instances will tell you which bucket they are currently residing in (DestinyItemComponent.bucketHash). You can use this information along with the DestinyInventoryBucketDefinition to show these items grouped by bucket.\r\nYou cannot transfer an item to a bucket that is not its Default without going through a Vendor's \"accepted items\" (DestinyVendorDefinition.acceptedItems). This is how transfer functionality like the Vault is implemented, as a feature of a Vendor. See the vendor's acceptedItems property for more details.",
	//   "properties": {
	//     "bucketOrder": {
	//       "description": "Use this property to provide a quick-and-dirty recommended ordering for buckets in the UI. Most UIs will likely want to forsake this for something more custom and manual.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "category": {
	//       "description": "An enum value for what items can be found in the bucket. See the BucketCategory enum for more details.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.BucketCategory"
	//       }
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "enabled": {
	//       "description": "If True, this bucket is enabled. Disabled buckets may include buckets that were included for test purposes, or that were going to be used but then were abandoned but never removed from content *cough*.",
	//       "type": "boolean"
	//     },
	//     "fifo": {
	//       "description": "if a FIFO bucket fills up, it will delete the oldest item from said bucket when a new item tries to be added to it. If this is FALSE, the bucket will not allow new items to be placed in it until room is made by the user manually deleting items from it. You can see an example of this with the Postmaster's bucket.",
	//       "type": "boolean"
	//     },
	//     "hasTransferDestination": {
	//       "description": "If TRUE, there is at least one Vendor that can transfer items to/from this bucket. See the DestinyVendorDefinition's acceptedItems property for more information on how transferring works.",
	//       "type": "boolean"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "itemCount": {
	//       "description": "The maximum # of item \"slots\" in a bucket. A slot is a given combination of item + quantity.\r\nFor instance, a Weapon will always take up a single slot, and always have a quantity of 1. But a material could take up only a single slot with hundreds of quantity.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "location": {
	//       "description": "Sometimes, inventory buckets represent conceptual \"locations\" in the game that might not be expected. This value indicates the conceptual location of the bucket, regardless of where it is actually contained on the character/account. \r\nSee ItemLocation for details. \r\nNote that location includes the Vault and the Postmaster (both of whom being just inventory buckets with additional actions that can be performed on them through a Vendor)",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.ItemLocation"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "scope": {
	//       "description": "Where the bucket is found. 0 = Character, 1 = Account",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.BucketScope"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "InventoryBuckets"
	// }

	// Use this property to provide a quick-and-dirty recommended ordering for buckets in the UI. Most UIs
	// will likely want to forsake this for something more custom and manual.
	BucketOrder int32 `json:"bucketOrder"`

	// An enum value for what items can be found in the bucket. See the BucketCategory enum for more
	// details.
	Category BucketCategory `json:"category"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// If True, this bucket is enabled. Disabled buckets may include buckets that were included for test
	// purposes, or that were going to be used but then were abandoned but never removed from content
	// *cough*.
	Enabled bool `json:"enabled"`

	// if a FIFO bucket fills up, it will delete the oldest item from said bucket when a new item tries to
	// be added to it. If this is FALSE, the bucket will not allow new items to be placed in it until room
	// is made by the user manually deleting items from it. You can see an example of this with the
	// Postmaster's bucket.
	Fifo bool `json:"fifo"`

	// If TRUE, there is at least one Vendor that can transfer items to/from this bucket. See the
	// DestinyVendorDefinition's acceptedItems property for more information on how transferring works.
	HasTransferDestination bool `json:"hasTransferDestination"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// The maximum # of item "slots" in a bucket. A slot is a given combination of item + quantity.
	// For instance, a Weapon will always take up a single slot, and always have a quantity of 1. But a
	// material could take up only a single slot with hundreds of quantity.
	ItemCount int32 `json:"itemCount"`

	// Sometimes, inventory buckets represent conceptual "locations" in the game that might not be
	// expected. This value indicates the conceptual location of the bucket, regardless of where it is
	// actually contained on the character/account.
	// See ItemLocation for details.
	// Note that location includes the Vault and the Postmaster (both of whom being just inventory buckets
	// with additional actions that can be performed on them through a Vendor)
	Location ItemLocation `json:"location"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// Where the bucket is found. 0 = Character, 1 = Account
	Scope BucketScope `json:"scope"`
}

// Destiny.Definitions.DestinyInventoryItemDefinition
//
// So much of what you see in Destiny is actually an Item used in a new and creative way. This is the
// definition for Items in Destiny, which started off as just entities that could exist in your
// Inventory but ended up being the backing data for so much more: quests, reward previews, slots, and
// subclasses.
// In practice, you will want to associate this data with "live" item data from a Bungie.Net Platform
// call: these definitions describe the item in generic, non-instanced terms: but an actual instance of
// an item can vary widely from these generic definitions.
type InventoryItemDefinition struct {
	// {
	//   "description": "So much of what you see in Destiny is actually an Item used in a new and creative way. This is the definition for Items in Destiny, which started off as just entities that could exist in your Inventory but ended up being the backing data for so much more: quests, reward previews, slots, and subclasses.\r\nIn practice, you will want to associate this data with \"live\" item data from a Bungie.Net Platform call: these definitions describe the item in generic, non-instanced terms: but an actual instance of an item can vary widely from these generic definitions.",
	//   "properties": {
	//     "action": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemActionBlockDefinition"
	//         }
	//       ],
	//       "description": "If the item can be \"used\", this block will be non-null, and will have data related to the action performed when using the item. (Guess what? 99% of the time, this action is \"dismantle\". Shocker)",
	//       "type": "object"
	//     },
	//     "allowActions": {
	//       "description": "BNet may forbid the execution of actions on this item via the API. If that is occurring, allowActions will be set to false.",
	//       "type": "boolean"
	//     },
	//     "animations": {
	//       "description": "If any animations were extracted from game content for this item, these will be the definitions of those animations.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Animations.DestinyAnimationReference"
	//       },
	//       "type": "array"
	//     },
	//     "backgroundColor": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Misc.DestinyColor"
	//         }
	//       ],
	//       "description": "Sometimes, an item will have a background color. Most notably this occurs with Emblems, who use the Background Color for small character nameplates such as the \"friends\" view you see in-game. There are almost certainly other items that have background color as well, though I have not bothered to investigate what items have it nor what purposes they serve: use it as you will.",
	//       "type": "object"
	//     },
	//     "breakerType": {
	//       "description": "Some weapons and plugs can have a \"Breaker Type\": a special ability that works sort of like damage type vulnerabilities. This is (almost?) always set on items by plugs.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyBreakerType"
	//       }
	//     },
	//     "breakerTypeHash": {
	//       "description": "Since we also have a breaker type definition, this is the hash for that breaker type for your convenience. Whether you use the enum or hash and look up the definition depends on what's cleanest for your code.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.BreakerTypes.DestinyBreakerTypeDefinition"
	//       }
	//     },
	//     "classType": {
	//       "description": "We run a similarly weak-sauce algorithm to try and determine whether an item is restricted to a specific class. If we find it to be restricted in such a way, we set this classType property to match the class' enumeration value so that users can easily identify class restricted items.\r\nIf you see a mis-classed item, please inform the developers in the Bungie API forum.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyClass"
	//       }
	//     },
	//     "collectibleHash": {
	//       "description": "If this item has a collectible related to it, this is the hash identifier of that collectible entry.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Collectibles.DestinyCollectibleDefinition"
	//       }
	//     },
	//     "crafting": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemCraftingBlockDefinition"
	//         }
	//       ],
	//       "description": "Recipe items will have relevant crafting information available here.",
	//       "type": "object"
	//     },
	//     "damageTypeHashes": {
	//       "description": "Theoretically, an item can have many possible damage types. In *practice*, this is not true, but just in case weapons start being made that have multiple (for instance, an item where a socket has reusable plugs for every possible damage type that you can choose from freely), this field will return all of the possible damage types that are available to the weapon by default.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyDamageTypeDefinition"
	//       }
	//     },
	//     "damageTypes": {
	//       "description": "This is the list of all damage types that we know ahead of time the item can take on. Unfortunately, this does not preclude the possibility of something funky happening to give the item a damage type that cannot be predicted beforehand: for example, if some designer decides to create arbitrary non-reusable plugs that cause damage type to change.\r\nThis damage type prediction will only use the following to determine potential damage types:\r\n- Intrinsic perks\r\n- Talent Node perks\r\n- Known, reusable plugs for sockets",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/Destiny.DamageType"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "defaultDamageType": {
	//       "description": "If the item has a damage type that could be considered to be default, it will be populated here.\r\nFor various upsetting reasons, it's surprisingly cumbersome to figure this out. I hope you're happy.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DamageType"
	//       }
	//     },
	//     "defaultDamageTypeHash": {
	//       "description": "Similar to defaultDamageType, but represented as the hash identifier for a DestinyDamageTypeDefinition.\r\nI will likely regret leaving in the enumeration versions of these properties, but for now they're very convenient.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyDamageTypeDefinition"
	//       }
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "displaySource": {
	//       "description": "In theory, it is a localized string telling you about how you can find the item. I really wish this was more consistent. Many times, it has nothing. Sometimes, it's instead a more narrative-forward description of the item. Which is cool, and I wish all properties had that data, but it should really be its own property.",
	//       "type": "string"
	//     },
	//     "doesPostmasterPullHaveSideEffects": {
	//       "description": "The boolean will indicate to us (and you!) whether something *could* happen when you transfer this item from the Postmaster that might be considered a \"destructive\" action.\r\nIt is not feasible currently to tell you (or ourelves!) in a consistent way whether this *will* actually cause a destructive action, so we are playing it safe: if it has the potential to do so, we will not allow it to be transferred from the Postmaster by default. You will need to check for this flag before transferring an item from the Postmaster, or else you'll end up receiving an error.",
	//       "type": "boolean"
	//     },
	//     "emblemObjectiveHash": {
	//       "description": "If the item is an emblem that has a special Objective attached to it - for instance, if the emblem tracks PVP Kills, or what-have-you. This is a bit different from, for example, the Vanguard Kill Tracker mod, which pipes data into the \"art channel\". When I get some time, I would like to standardize these so you can get at the values they expose without having to care about what they're being used for and how they are wired up, but for now here's the raw data.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "equippable": {
	//       "description": "If true, then you will be allowed to equip the item if you pass its other requirements.\r\nThis being false means that you cannot equip the item under any circumstances.",
	//       "type": "boolean"
	//     },
	//     "equippingBlock": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyEquippingBlockDefinition"
	//         }
	//       ],
	//       "description": "If this item can be equipped, this block will be non-null and will be populated with the conditions under which it can be equipped.",
	//       "type": "object"
	//     },
	//     "flavorText": {
	//       "type": "string"
	//     },
	//     "gearset": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemGearsetBlockDefinition"
	//         }
	//       ],
	//       "description": "If this item has related items in a \"Gear Set\", this will be non-null and the relationships defined herein.",
	//       "type": "object"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "iconWatermark": {
	//       "description": "If available, this is the original 'active' release watermark overlay for the icon. If the item has different versions, this can be overridden by the 'display version watermark icon' from the 'quality' block. Alternatively, if there is no watermark for the version, and the item version has a power cap below the current season power cap, this can be overridden by the iconWatermarkShelved property.",
	//       "type": "string"
	//     },
	//     "iconWatermarkShelved": {
	//       "description": "If available, this is the 'shelved' release watermark overlay for the icon. If the item version has a power cap below the current season power cap, it can be treated as 'shelved', and should be shown with this 'shelved' watermark overlay.",
	//       "type": "string"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "inventory": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemInventoryBlockDefinition"
	//         }
	//       ],
	//       "description": "If this item can exist in an inventory, this block will be non-null. In practice, every item that currently exists has one of these blocks. But note that it is not necessarily guaranteed.",
	//       "type": "object"
	//     },
	//     "investmentStats": {
	//       "description": "If the item has stats, this block will be defined. It has the \"raw\" investment stats for the item. These investment stats don't take into account the ways that the items can spawn, nor do they take into account any Stat Group transformations. I have retained them for debugging purposes, but I do not know how useful people will find them.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemInvestmentStatDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "isWrapper": {
	//       "description": "If true, this is a dummy vendor-wrapped item template. Items purchased from Eververse will be \"wrapped\" by one of these items so that we can safely provide refund capabilities before the item is \"unwrapped\".",
	//       "type": "boolean"
	//     },
	//     "itemCategoryHashes": {
	//       "description": "BNet attempts to make a more formal definition of item \"Categories\", as defined by DestinyItemCategoryDefinition. This is a list of all Categories that we were able to algorithmically determine that this item is a member of. (for instance, that it's a \"Weapon\", that it's an \"Auto Rifle\", etc...)\r\nThe algorithm for these is, unfortunately, volatile. If you believe you see a miscategorized item, please let us know on the Bungie API forums.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemCategoryDefinition"
	//       }
	//     },
	//     "itemSubType": {
	//       "description": "A value indicating the \"sub-type\" of the item. For instance, where an item might have an itemType value \"Weapon\", this will be something more specific like \"Auto Rifle\".\r\nitemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemSubType"
	//       }
	//     },
	//     "itemType": {
	//       "description": "A value indicating the \"base\" the of the item. This enum is a useful but dramatic oversimplification of what it means for an item to have a \"Type\". Still, it's handy in many situations.\r\nitemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemType"
	//       }
	//     },
	//     "itemTypeAndTierDisplayName": {
	//       "description": "It became a common enough pattern in our UI to show Item Type and Tier combined into a single localized string that I'm just going to go ahead and start pre-creating these for items.",
	//       "type": "string"
	//     },
	//     "itemTypeDisplayName": {
	//       "description": "The localized title/name of the item's type. This can be whatever the designers want, and has no guarantee of consistency between items.",
	//       "type": "string"
	//     },
	//     "links": {
	//       "description": "If we added any help or informational URLs about this item, these will be those links.",
	//       "items": {
	//         "$ref": "#/components/schemas/Links.HyperlinkReference"
	//       },
	//       "type": "array"
	//     },
	//     "loreHash": {
	//       "description": "If the item has any related Lore (DestinyLoreDefinition), this will be the hash identifier you can use to look up the lore definition.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Lore.DestinyLoreDefinition"
	//       }
	//     },
	//     "metrics": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemMetricBlockDefinition"
	//         }
	//       ],
	//       "description": "If this item has available metrics to be shown, this block will be non-null have the appropriate hashes defined.",
	//       "type": "object"
	//     },
	//     "nonTransferrable": {
	//       "description": "The intrinsic transferability of an item.\r\nI hate that this boolean is negative - but there's a reason.\r\nJust because an item is intrinsically transferrable doesn't mean that it can be transferred, and we don't want to imply that this is the only source of that transferability.",
	//       "type": "boolean"
	//     },
	//     "objectives": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemObjectiveBlockDefinition"
	//         }
	//       ],
	//       "description": "If this item has Objectives (extra tasks that can be accomplished related to the item... most frequently when the item is a Quest Step and the Objectives need to be completed to move on to the next Quest Step), this block will be non-null and the objectives defined herein.",
	//       "type": "object"
	//     },
	//     "perks": {
	//       "description": "If the item has any *intrinsic* Perks (Perks that it will provide regardless of Sockets, Talent Grid, and other transitory state), they will be defined here.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemPerkEntryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "plug": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Items.DestinyItemPlugDefinition"
	//         }
	//       ],
	//       "description": "If this item *is* a Plug, this will be non-null and the info defined herein. See DestinyItemPlugDefinition for more information.",
	//       "type": "object"
	//     },
	//     "preview": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemPreviewBlockDefinition"
	//         }
	//       ],
	//       "description": "If this item can be Used or Acquired to gain other items (for instance, how Eververse Boxes can be consumed to get items from the box), this block will be non-null and will give summary information for the items that can be acquired.",
	//       "type": "object"
	//     },
	//     "quality": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemQualityBlockDefinition"
	//         }
	//       ],
	//       "description": "If this item can have a level or stats, this block will be non-null and will be populated with default quality (item level, \"quality\", and infusion) data. See the block for more details, there's often less upfront information in D2 so you'll want to be aware of how you use quality and item level on the definition level now.",
	//       "type": "object"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "sack": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemSackBlockDefinition"
	//         }
	//       ],
	//       "description": "If this item is a \"reward sack\" that can be opened to provide other items, this will be non-null and the properties of the sack contained herein.",
	//       "type": "object"
	//     },
	//     "screenshot": {
	//       "description": "If we were able to acquire an in-game screenshot for the item, the path to that screenshot will be returned here. Note that not all items have screenshots: particularly not any non-equippable items.",
	//       "type": "string"
	//     },
	//     "seasonHash": {
	//       "description": "If this item is related directly to a Season of Destiny, this is the hash identifier for that season.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Seasons.DestinySeasonDefinition"
	//       }
	//     },
	//     "secondaryIcon": {
	//       "description": "A secondary icon associated with the item. Currently this is used in very context specific applications, such as Emblem Nameplates.",
	//       "type": "string"
	//     },
	//     "secondaryOverlay": {
	//       "description": "Pulled from the secondary icon, this is the \"secondary background\" of the secondary icon. Confusing? Sure, that's why I call it \"overlay\" here: because as far as it's been used thus far, it has been for an optional overlay image. We'll see if that holds up, but at least for now it explains what this image is a bit better.",
	//       "type": "string"
	//     },
	//     "secondarySpecial": {
	//       "description": "Pulled from the Secondary Icon, this is the \"special\" background for the item. For Emblems, this is the background image used on the Details view: but it need not be limited to that for other types of items.",
	//       "type": "string"
	//     },
	//     "setData": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemSetBlockDefinition"
	//         }
	//       ],
	//       "description": "If this item is a quest, this block will be non-null. In practice, I wish I had called this the Quest block, but at the time it wasn't clear to me whether it would end up being used for purposes other than quests. It will contain data about the steps in the quest, and mechanics we can use for displaying and tracking the quest.",
	//       "type": "object"
	//     },
	//     "sockets": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemSocketBlockDefinition"
	//         }
	//       ],
	//       "description": "If this item has any Sockets, this will be non-null and the individual sockets on the item will be defined herein.",
	//       "type": "object"
	//     },
	//     "sourceData": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemSourceBlockDefinition"
	//         }
	//       ],
	//       "description": "If this item has a known source, this block will be non-null and populated with source information. Unfortunately, at this time we are not generating sources: that is some aggressively manual work which we didn't have time for, and I'm hoping to get back to at some point in the future.",
	//       "type": "object"
	//     },
	//     "specialItemType": {
	//       "description": "In Destiny 1, we identified some items as having particular categories that we'd like to know about for various internal logic purposes. These are defined in SpecialItemType, and while these days the itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.SpecialItemType"
	//       }
	//     },
	//     "stats": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemStatBlockDefinition"
	//         }
	//       ],
	//       "description": "If this item can have stats (such as a weapon, armor, or vehicle), this block will be non-null and populated with the stats found on the item.",
	//       "type": "object"
	//     },
	//     "summary": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemSummaryBlockDefinition"
	//         }
	//       ],
	//       "description": "Summary data about the item.",
	//       "type": "object"
	//     },
	//     "summaryItemHash": {
	//       "description": "There are times when the game will show you a \"summary/vague\" version of an item - such as a description of its type represented as a DestinyInventoryItemDefinition - rather than display the item itself.\r\nThis happens sometimes when summarizing possible rewards in a tooltip. This is the item displayed instead, if it exists.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "talentGrid": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemTalentGridBlockDefinition"
	//         }
	//       ],
	//       "description": "If the item has a Talent Grid, this will be non-null and the properties of the grid defined herein. Note that, while many items still have talent grids, the only ones with meaningful Nodes still on them will be Subclass/\"Build\" items.",
	//       "type": "object"
	//     },
	//     "tooltipNotifications": {
	//       "description": "Tooltips that only come up conditionally for the item. Check the live data DestinyItemComponent.tooltipNotificationIndexes property for which of these should be shown at runtime.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemTooltipNotification"
	//       },
	//       "type": "array"
	//     },
	//     "tooltipStyle": {
	//       "description": "An identifier that the game UI uses to determine what type of tooltip to show for the item. These have no corresponding definitions that BNet can link to: so it'll be up to you to interpret and display your UI differently according to these styles (or ignore it).",
	//       "type": "string"
	//     },
	//     "traitHashes": {
	//       "description": "These are the corresponding trait definition hashes for the entries in traitIds.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "traitIds": {
	//       "description": "Traits are metadata tags applied to this item. For example: armor slot, weapon type, foundry, faction, etc. These IDs come from the game and don't map to any content, but should still be useful.",
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     },
	//     "translationBlock": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemTranslationBlockDefinition"
	//         }
	//       ],
	//       "description": "If this item can be rendered, this block will be non-null and will be populated with rendering information.",
	//       "type": "object"
	//     },
	//     "uiItemDisplayStyle": {
	//       "description": "A string identifier that the game's UI uses to determine how the item should be rendered in inventory screens and the like. This could really be anything - at the moment, we don't have the time to really breakdown and maintain all the possible strings this could be, partly because new ones could be added ad hoc. But if you want to use it to dictate your own UI, or look for items with a certain display style, go for it!",
	//       "type": "string"
	//     },
	//     "value": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemValueBlockDefinition"
	//         }
	//       ],
	//       "description": "The conceptual \"Value\" of an item, if any was defined. See the DestinyItemValueBlockDefinition for more details.",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Items"
	// }

	// If the item can be "used", this block will be non-null, and will have data related to the action
	// performed when using the item. (Guess what? 99% of the time, this action is "dismantle". Shocker)
	Action ItemActionBlockDefinition `json:"action"`

	// BNet may forbid the execution of actions on this item via the API. If that is occurring,
	// allowActions will be set to false.
	AllowActions bool `json:"allowActions"`

	// If any animations were extracted from game content for this item, these will be the definitions of
	// those animations.
	Animations []AnimationReference `json:"animations"`

	// Sometimes, an item will have a background color. Most notably this occurs with Emblems, who use the
	// Background Color for small character nameplates such as the "friends" view you see in-game. There
	// are almost certainly other items that have background color as well, though I have not bothered to
	// investigate what items have it nor what purposes they serve: use it as you will.
	BackgroundColor Color `json:"backgroundColor"`

	// Some weapons and plugs can have a "Breaker Type": a special ability that works sort of like damage
	// type vulnerabilities. This is (almost?) always set on items by plugs.
	BreakerType BreakerType `json:"breakerType"`

	// Since we also have a breaker type definition, this is the hash for that breaker type for your
	// convenience. Whether you use the enum or hash and look up the definition depends on what's cleanest
	// for your code.
	BreakerTypeHash Nullable[Hash[BreakerTypeDefinition]] `json:"breakerTypeHash,omitempty"`

	// We run a similarly weak-sauce algorithm to try and determine whether an item is restricted to a
	// specific class. If we find it to be restricted in such a way, we set this classType property to
	// match the class' enumeration value so that users can easily identify class restricted items.
	// If you see a mis-classed item, please inform the developers in the Bungie API forum.
	ClassType Class `json:"classType"`

	// If this item has a collectible related to it, this is the hash identifier of that collectible entry.
	CollectibleHash Nullable[Hash[CollectibleDefinition]] `json:"collectibleHash,omitempty"`

	// Recipe items will have relevant crafting information available here.
	Crafting ItemCraftingBlockDefinition `json:"crafting"`

	// Theoretically, an item can have many possible damage types. In *practice*, this is not true, but
	// just in case weapons start being made that have multiple (for instance, an item where a socket has
	// reusable plugs for every possible damage type that you can choose from freely), this field will
	// return all of the possible damage types that are available to the weapon by default.
	DamageTypeHashes []uint32 `json:"damageTypeHashes"`

	// This is the list of all damage types that we know ahead of time the item can take on. Unfortunately,
	// this does not preclude the possibility of something funky happening to give the item a damage type
	// that cannot be predicted beforehand: for example, if some designer decides to create arbitrary
	// non-reusable plugs that cause damage type to change.
	// This damage type prediction will only use the following to determine potential damage types:
	// - Intrinsic perks
	// - Talent Node perks
	// - Known, reusable plugs for sockets
	DamageTypes []DamageType `json:"damageTypes"`

	// If the item has a damage type that could be considered to be default, it will be populated here.
	// For various upsetting reasons, it's surprisingly cumbersome to figure this out. I hope you're happy.
	DefaultDamageType DamageType `json:"defaultDamageType"`

	// Similar to defaultDamageType, but represented as the hash identifier for a
	// DestinyDamageTypeDefinition.
	// I will likely regret leaving in the enumeration versions of these properties, but for now they're
	// very convenient.
	DefaultDamageTypeHash Nullable[Hash[DamageTypeDefinition]] `json:"defaultDamageTypeHash,omitempty"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// In theory, it is a localized string telling you about how you can find the item. I really wish this
	// was more consistent. Many times, it has nothing. Sometimes, it's instead a more narrative-forward
	// description of the item. Which is cool, and I wish all properties had that data, but it should
	// really be its own property.
	DisplaySource string `json:"displaySource"`

	// The boolean will indicate to us (and you!) whether something *could* happen when you transfer this
	// item from the Postmaster that might be considered a "destructive" action.
	// It is not feasible currently to tell you (or ourelves!) in a consistent way whether this *will*
	// actually cause a destructive action, so we are playing it safe: if it has the potential to do so, we
	// will not allow it to be transferred from the Postmaster by default. You will need to check for this
	// flag before transferring an item from the Postmaster, or else you'll end up receiving an error.
	DoesPostmasterPullHaveSideEffects bool `json:"doesPostmasterPullHaveSideEffects"`

	// If the item is an emblem that has a special Objective attached to it - for instance, if the emblem
	// tracks PVP Kills, or what-have-you. This is a bit different from, for example, the Vanguard Kill
	// Tracker mod, which pipes data into the "art channel". When I get some time, I would like to
	// standardize these so you can get at the values they expose without having to care about what they're
	// being used for and how they are wired up, but for now here's the raw data.
	EmblemObjectiveHash Nullable[uint32] `json:"emblemObjectiveHash,omitempty"`

	// If true, then you will be allowed to equip the item if you pass its other requirements.
	// This being false means that you cannot equip the item under any circumstances.
	Equippable bool `json:"equippable"`

	// If this item can be equipped, this block will be non-null and will be populated with the conditions
	// under which it can be equipped.
	EquippingBlock EquippingBlockDefinition `json:"equippingBlock"`

	FlavorText string `json:"flavorText"`

	// If this item has related items in a "Gear Set", this will be non-null and the relationships defined
	// herein.
	Gearset ItemGearsetBlockDefinition `json:"gearset"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// If available, this is the original 'active' release watermark overlay for the icon. If the item has
	// different versions, this can be overridden by the 'display version watermark icon' from the
	// 'quality' block. Alternatively, if there is no watermark for the version, and the item version has a
	// power cap below the current season power cap, this can be overridden by the iconWatermarkShelved
	// property.
	IconWatermark string `json:"iconWatermark"`

	// If available, this is the 'shelved' release watermark overlay for the icon. If the item version has
	// a power cap below the current season power cap, it can be treated as 'shelved', and should be shown
	// with this 'shelved' watermark overlay.
	IconWatermarkShelved string `json:"iconWatermarkShelved"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this item can exist in an inventory, this block will be non-null. In practice, every item that
	// currently exists has one of these blocks. But note that it is not necessarily guaranteed.
	Inventory ItemInventoryBlockDefinition `json:"inventory"`

	// If the item has stats, this block will be defined. It has the "raw" investment stats for the item.
	// These investment stats don't take into account the ways that the items can spawn, nor do they take
	// into account any Stat Group transformations. I have retained them for debugging purposes, but I do
	// not know how useful people will find them.
	InvestmentStats []ItemInvestmentStatDefinition `json:"investmentStats"`

	// If true, this is a dummy vendor-wrapped item template. Items purchased from Eververse will be
	// "wrapped" by one of these items so that we can safely provide refund capabilities before the item is
	// "unwrapped".
	IsWrapper bool `json:"isWrapper"`

	// BNet attempts to make a more formal definition of item "Categories", as defined by
	// DestinyItemCategoryDefinition. This is a list of all Categories that we were able to algorithmically
	// determine that this item is a member of. (for instance, that it's a "Weapon", that it's an "Auto
	// Rifle", etc...)
	// The algorithm for these is, unfortunately, volatile. If you believe you see a miscategorized item,
	// please let us know on the Bungie API forums.
	ItemCategoryHashes []uint32 `json:"itemCategoryHashes"`

	// A value indicating the "sub-type" of the item. For instance, where an item might have an itemType
	// value "Weapon", this will be something more specific like "Auto Rifle".
	// itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its
	// convenience.
	ItemSubType ItemSubType `json:"itemSubType"`

	// A value indicating the "base" the of the item. This enum is a useful but dramatic oversimplification
	// of what it means for an item to have a "Type". Still, it's handy in many situations.
	// itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its
	// convenience.
	ItemType ItemType `json:"itemType"`

	// It became a common enough pattern in our UI to show Item Type and Tier combined into a single
	// localized string that I'm just going to go ahead and start pre-creating these for items.
	ItemTypeAndTierDisplayName string `json:"itemTypeAndTierDisplayName"`

	// The localized title/name of the item's type. This can be whatever the designers want, and has no
	// guarantee of consistency between items.
	ItemTypeDisplayName string `json:"itemTypeDisplayName"`

	// If we added any help or informational URLs about this item, these will be those links.
	Links []HyperlinkReference `json:"links"`

	// If the item has any related Lore (DestinyLoreDefinition), this will be the hash identifier you can
	// use to look up the lore definition.
	LoreHash Nullable[Hash[LoreDefinition]] `json:"loreHash,omitempty"`

	// If this item has available metrics to be shown, this block will be non-null have the appropriate
	// hashes defined.
	Metrics ItemMetricBlockDefinition `json:"metrics"`

	// The intrinsic transferability of an item.
	// I hate that this boolean is negative - but there's a reason.
	// Just because an item is intrinsically transferrable doesn't mean that it can be transferred, and we
	// don't want to imply that this is the only source of that transferability.
	NonTransferrable bool `json:"nonTransferrable"`

	// If this item has Objectives (extra tasks that can be accomplished related to the item... most
	// frequently when the item is a Quest Step and the Objectives need to be completed to move on to the
	// next Quest Step), this block will be non-null and the objectives defined herein.
	Objectives ItemObjectiveBlockDefinition `json:"objectives"`

	// If the item has any *intrinsic* Perks (Perks that it will provide regardless of Sockets, Talent
	// Grid, and other transitory state), they will be defined here.
	Perks []ItemPerkEntryDefinition `json:"perks"`

	// If this item *is* a Plug, this will be non-null and the info defined herein. See
	// DestinyItemPlugDefinition for more information.
	Plug ItemPlugDefinition `json:"plug"`

	// If this item can be Used or Acquired to gain other items (for instance, how Eververse Boxes can be
	// consumed to get items from the box), this block will be non-null and will give summary information
	// for the items that can be acquired.
	Preview ItemPreviewBlockDefinition `json:"preview"`

	// If this item can have a level or stats, this block will be non-null and will be populated with
	// default quality (item level, "quality", and infusion) data. See the block for more details, there's
	// often less upfront information in D2 so you'll want to be aware of how you use quality and item
	// level on the definition level now.
	Quality ItemQualityBlockDefinition `json:"quality"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// If this item is a "reward sack" that can be opened to provide other items, this will be non-null and
	// the properties of the sack contained herein.
	Sack ItemSackBlockDefinition `json:"sack"`

	// If we were able to acquire an in-game screenshot for the item, the path to that screenshot will be
	// returned here. Note that not all items have screenshots: particularly not any non-equippable items.
	Screenshot string `json:"screenshot"`

	// If this item is related directly to a Season of Destiny, this is the hash identifier for that
	// season.
	SeasonHash Nullable[Hash[SeasonDefinition]] `json:"seasonHash,omitempty"`

	// A secondary icon associated with the item. Currently this is used in very context specific
	// applications, such as Emblem Nameplates.
	SecondaryIcon string `json:"secondaryIcon"`

	// Pulled from the secondary icon, this is the "secondary background" of the secondary icon. Confusing?
	// Sure, that's why I call it "overlay" here: because as far as it's been used thus far, it has been
	// for an optional overlay image. We'll see if that holds up, but at least for now it explains what
	// this image is a bit better.
	SecondaryOverlay string `json:"secondaryOverlay"`

	// Pulled from the Secondary Icon, this is the "special" background for the item. For Emblems, this is
	// the background image used on the Details view: but it need not be limited to that for other types of
	// items.
	SecondarySpecial string `json:"secondarySpecial"`

	// If this item is a quest, this block will be non-null. In practice, I wish I had called this the
	// Quest block, but at the time it wasn't clear to me whether it would end up being used for purposes
	// other than quests. It will contain data about the steps in the quest, and mechanics we can use for
	// displaying and tracking the quest.
	SetData ItemSetBlockDefinition `json:"setData"`

	// If this item has any Sockets, this will be non-null and the individual sockets on the item will be
	// defined herein.
	Sockets ItemSocketBlockDefinition `json:"sockets"`

	// If this item has a known source, this block will be non-null and populated with source information.
	// Unfortunately, at this time we are not generating sources: that is some aggressively manual work
	// which we didn't have time for, and I'm hoping to get back to at some point in the future.
	SourceData ItemSourceBlockDefinition `json:"sourceData"`

	// In Destiny 1, we identified some items as having particular categories that we'd like to know about
	// for various internal logic purposes. These are defined in SpecialItemType, and while these days the
	// itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its
	// convenience.
	SpecialItemType SpecialItemType `json:"specialItemType"`

	// If this item can have stats (such as a weapon, armor, or vehicle), this block will be non-null and
	// populated with the stats found on the item.
	Stats ItemStatBlockDefinition `json:"stats"`

	// Summary data about the item.
	Summary ItemSummaryBlockDefinition `json:"summary"`

	// There are times when the game will show you a "summary/vague" version of an item - such as a
	// description of its type represented as a DestinyInventoryItemDefinition - rather than display the
	// item itself.
	// This happens sometimes when summarizing possible rewards in a tooltip. This is the item displayed
	// instead, if it exists.
	SummaryItemHash Nullable[Hash[InventoryItemDefinition]] `json:"summaryItemHash,omitempty"`

	// If the item has a Talent Grid, this will be non-null and the properties of the grid defined herein.
	// Note that, while many items still have talent grids, the only ones with meaningful Nodes still on
	// them will be Subclass/"Build" items.
	TalentGrid ItemTalentGridBlockDefinition `json:"talentGrid"`

	// Tooltips that only come up conditionally for the item. Check the live data
	// DestinyItemComponent.tooltipNotificationIndexes property for which of these should be shown at
	// runtime.
	TooltipNotifications []ItemTooltipNotification `json:"tooltipNotifications"`

	// An identifier that the game UI uses to determine what type of tooltip to show for the item. These
	// have no corresponding definitions that BNet can link to: so it'll be up to you to interpret and
	// display your UI differently according to these styles (or ignore it).
	TooltipStyle string `json:"tooltipStyle"`

	// These are the corresponding trait definition hashes for the entries in traitIds.
	TraitHashes []uint32 `json:"traitHashes"`

	// Traits are metadata tags applied to this item. For example: armor slot, weapon type, foundry,
	// faction, etc. These IDs come from the game and don't map to any content, but should still be useful.
	TraitIds []string `json:"traitIds"`

	// If this item can be rendered, this block will be non-null and will be populated with rendering
	// information.
	TranslationBlock ItemTranslationBlockDefinition `json:"translationBlock"`

	// A string identifier that the game's UI uses to determine how the item should be rendered in
	// inventory screens and the like. This could really be anything - at the moment, we don't have the
	// time to really breakdown and maintain all the possible strings this could be, partly because new
	// ones could be added ad hoc. But if you want to use it to dictate your own UI, or look for items with
	// a certain display style, go for it!
	UiItemDisplayStyle string `json:"uiItemDisplayStyle"`

	// The conceptual "Value" of an item, if any was defined. See the DestinyItemValueBlockDefinition for
	// more details.
	Value ItemValueBlockDefinition `json:"value"`
}

// Destiny.Definitions.DestinyInventoryItemStatDefinition
//
// Defines a specific stat value on an item, and the minimum/maximum range that we could compute for
// the item based on our heuristics for how the item might be generated.
// Not guaranteed to match real-world instances of the item, but should hopefully at least be close. If
// it's not close, let us know on the Bungie API forums.
type InventoryItemStatDefinition struct {
	// {
	//   "description": "Defines a specific stat value on an item, and the minimum/maximum range that we could compute for the item based on our heuristics for how the item might be generated.\r\nNot guaranteed to match real-world instances of the item, but should hopefully at least be close. If it's not close, let us know on the Bungie API forums.",
	//   "properties": {
	//     "displayMaximum": {
	//       "description": "The maximum possible value for the stat as shown in the UI, if it is being shown somewhere that reveals maximum in the UI (such as a bar chart-style view).\r\nThis is pulled directly from the item's DestinyStatGroupDefinition, and placed here for convenience.\r\nIf not returned, there is no maximum to use (and thus the stat should not be shown in a way that assumes there is a limit to the stat)",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "maximum": {
	//       "description": "The maximum possible value for this stat that we think the item can roll.\r\nWARNING: In Destiny 1, this field was calculated using the potential stat rolls on the item's talent grid. In Destiny 2, items no longer have meaningful talent grids and instead have sockets: but the calculation of this field was never altered to adapt to this change. As such, this field should be considered deprecated until we can address this oversight.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "minimum": {
	//       "description": "The minimum possible value for this stat that we think the item can roll.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "statHash": {
	//       "description": "The hash for the DestinyStatDefinition representing this stat.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyStatDefinition"
	//       }
	//     },
	//     "value": {
	//       "description": "This value represents the stat value assuming the minimum possible roll but accounting for any mandatory bonuses that should be applied to the stat on item creation.\r\nIn Destiny 1, this was different from the \"minimum\" value because there were certain conditions where an item could be theoretically lower level/value than the initial roll. \r\nIn Destiny 2, this is not possible unless Talent Grids begin to be used again for these purposes or some other system change occurs... thus in practice, value and minimum should be the same in Destiny 2. Good riddance.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// The maximum possible value for the stat as shown in the UI, if it is being shown somewhere that
	// reveals maximum in the UI (such as a bar chart-style view).
	// This is pulled directly from the item's DestinyStatGroupDefinition, and placed here for convenience.
	// If not returned, there is no maximum to use (and thus the stat should not be shown in a way that
	// assumes there is a limit to the stat)
	DisplayMaximum Nullable[int32] `json:"displayMaximum,omitempty"`

	// The maximum possible value for this stat that we think the item can roll.
	// WARNING: In Destiny 1, this field was calculated using the potential stat rolls on the item's talent
	// grid. In Destiny 2, items no longer have meaningful talent grids and instead have sockets: but the
	// calculation of this field was never altered to adapt to this change. As such, this field should be
	// considered deprecated until we can address this oversight.
	Maximum int32 `json:"maximum"`

	// The minimum possible value for this stat that we think the item can roll.
	Minimum int32 `json:"minimum"`

	// The hash for the DestinyStatDefinition representing this stat.
	StatHash Hash[StatDefinition] `json:"statHash"`

	// This value represents the stat value assuming the minimum possible roll but accounting for any
	// mandatory bonuses that should be applied to the stat on item creation.
	// In Destiny 1, this was different from the "minimum" value because there were certain conditions
	// where an item could be theoretically lower level/value than the initial roll.
	// In Destiny 2, this is not possible unless Talent Grids begin to be used again for these purposes or
	// some other system change occurs... thus in practice, value and minimum should be the same in Destiny
	// 2. Good riddance.
	Value int32 `json:"value"`
}

// Destiny.Definitions.DestinyItemActionBlockDefinition
//
// If an item can have an action performed on it (like "Dismantle"), it will be defined here if you
// care.
type ItemActionBlockDefinition struct {
	// {
	//   "description": "If an item can have an action performed on it (like \"Dismantle\"), it will be defined here if you care.",
	//   "properties": {
	//     "actionTypeLabel": {
	//       "description": "The internal identifier for the action.",
	//       "type": "string"
	//     },
	//     "consumeEntireStack": {
	//       "description": "If true, the entire stack is deleted when the action completes.",
	//       "type": "boolean"
	//     },
	//     "deleteOnAction": {
	//       "description": "If true, the item is deleted when the action completes.",
	//       "type": "boolean"
	//     },
	//     "isPositive": {
	//       "description": "The content has this property, however it's not entirely clear how it is used.",
	//       "type": "boolean"
	//     },
	//     "overlayIcon": {
	//       "description": "The icon associated with the overlay screen for the action, if any.",
	//       "type": "string"
	//     },
	//     "overlayScreenName": {
	//       "description": "If the action has an overlay screen associated with it, this is the name of that screen. Unfortunately, we cannot return the screen's data itself.",
	//       "type": "string"
	//     },
	//     "progressionRewards": {
	//       "description": "If performing this action earns you Progression, this is the list of progressions and values granted for those progressions by performing this action.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionRewardDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "requiredCooldownHash": {
	//       "description": "The identifier hash for the Cooldown associated with this action. We have not pulled this data yet for you to have more data to use for cooldowns.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "requiredCooldownSeconds": {
	//       "description": "The number of seconds to delay before allowing this action to be performed again.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "requiredItems": {
	//       "description": "If the action requires other items to exist or be destroyed, this is the list of those items and requirements.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemActionRequiredItemDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "requiredLocation": {
	//       "description": "Theoretically, an item could have a localized string for a hint about the location in which the action should be performed. In practice, no items yet have this property.",
	//       "type": "string"
	//     },
	//     "useOnAcquire": {
	//       "description": "If true, this action will be performed as soon as you earn this item. Some rewards work this way, providing you a single item to pick up from a reward-granting vendor in-game and then immediately consuming itself to provide you multiple items.",
	//       "type": "boolean"
	//     },
	//     "verbDescription": {
	//       "description": "Localized text describing the action being performed.",
	//       "type": "string"
	//     },
	//     "verbName": {
	//       "description": "Localized text for the verb of the action being performed.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// The internal identifier for the action.
	ActionTypeLabel string `json:"actionTypeLabel"`

	// If true, the entire stack is deleted when the action completes.
	ConsumeEntireStack bool `json:"consumeEntireStack"`

	// If true, the item is deleted when the action completes.
	DeleteOnAction bool `json:"deleteOnAction"`

	// The content has this property, however it's not entirely clear how it is used.
	IsPositive bool `json:"isPositive"`

	// The icon associated with the overlay screen for the action, if any.
	OverlayIcon string `json:"overlayIcon"`

	// If the action has an overlay screen associated with it, this is the name of that screen.
	// Unfortunately, we cannot return the screen's data itself.
	OverlayScreenName string `json:"overlayScreenName"`

	// If performing this action earns you Progression, this is the list of progressions and values granted
	// for those progressions by performing this action.
	ProgressionRewards []ProgressionRewardDefinition `json:"progressionRewards"`

	// The identifier hash for the Cooldown associated with this action. We have not pulled this data yet
	// for you to have more data to use for cooldowns.
	RequiredCooldownHash uint32 `json:"requiredCooldownHash"`

	// The number of seconds to delay before allowing this action to be performed again.
	RequiredCooldownSeconds int32 `json:"requiredCooldownSeconds"`

	// If the action requires other items to exist or be destroyed, this is the list of those items and
	// requirements.
	RequiredItems []ItemActionRequiredItemDefinition `json:"requiredItems"`

	// Theoretically, an item could have a localized string for a hint about the location in which the
	// action should be performed. In practice, no items yet have this property.
	RequiredLocation string `json:"requiredLocation"`

	// If true, this action will be performed as soon as you earn this item. Some rewards work this way,
	// providing you a single item to pick up from a reward-granting vendor in-game and then immediately
	// consuming itself to provide you multiple items.
	UseOnAcquire bool `json:"useOnAcquire"`

	// Localized text describing the action being performed.
	VerbDescription string `json:"verbDescription"`

	// Localized text for the verb of the action being performed.
	VerbName string `json:"verbName"`
}

// Destiny.Definitions.DestinyItemActionRequiredItemDefinition
//
// The definition of an item and quantity required in a character's inventory in order to perform an
// action.
type ItemActionRequiredItemDefinition struct {
	// {
	//   "description": "The definition of an item and quantity required in a character's inventory in order to perform an action.",
	//   "properties": {
	//     "count": {
	//       "description": "The minimum quantity of the item you have to have.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "deleteOnAction": {
	//       "description": "If true, the item/quantity will be deleted from your inventory when the action is performed. Otherwise, you'll retain these required items after the action is complete.",
	//       "type": "boolean"
	//     },
	//     "itemHash": {
	//       "description": "The hash identifier of the item you need to have. Use it to look up the DestinyInventoryItemDefinition for more info.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The minimum quantity of the item you have to have.
	Count int32 `json:"count"`

	// If true, the item/quantity will be deleted from your inventory when the action is performed.
	// Otherwise, you'll retain these required items after the action is complete.
	DeleteOnAction bool `json:"deleteOnAction"`

	// The hash identifier of the item you need to have. Use it to look up the
	// DestinyInventoryItemDefinition for more info.
	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`
}

// Destiny.Definitions.DestinyItemCategoryDefinition
//
// In an attempt to categorize items by type, usage, and other interesting properties, we created
// DestinyItemCategoryDefinition: information about types that is assembled using a set of heuristics
// that examine the properties of an item such as what inventory bucket it's in, its item type name,
// and whether it has or is missing certain blocks of data.
// This heuristic is imperfect, however. If you find an item miscategorized, let us know on the Bungie
// API forums!
// We then populate all of the categories that we think an item belongs to in its
// DestinyInventoryItemDefinition.itemCategoryHashes property. You can use that to provide your own
// custom item filtering, sorting, aggregating... go nuts on it! And let us know if you see more
// categories that you wish would be added!
type ItemCategoryDefinition struct {
	// {
	//   "description": "In an attempt to categorize items by type, usage, and other interesting properties, we created DestinyItemCategoryDefinition: information about types that is assembled using a set of heuristics that examine the properties of an item such as what inventory bucket it's in, its item type name, and whether it has or is missing certain blocks of data.\r\nThis heuristic is imperfect, however. If you find an item miscategorized, let us know on the Bungie API forums!\r\nWe then populate all of the categories that we think an item belongs to in its DestinyInventoryItemDefinition.itemCategoryHashes property. You can use that to provide your own custom item filtering, sorting, aggregating... go nuts on it! And let us know if you see more categories that you wish would be added!",
	//   "properties": {
	//     "deprecated": {
	//       "description": "If True, this category has been deprecated: it may have no items left, or there may be only legacy items that remain in it which are no longer relevant to the game.",
	//       "type": "boolean"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "grantDestinyBreakerType": {
	//       "description": "If the item in question has this category, it also should have this breaker type.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyBreakerType"
	//       }
	//     },
	//     "grantDestinyClass": {
	//       "description": "If an item belongs to this category, it will also get this class restriction enum value.\r\nSee the other \"grant\"-prefixed properties on this definition for my color commentary.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyClass"
	//       }
	//     },
	//     "grantDestinyItemType": {
	//       "description": "If an item belongs to this category, it will also receive this item type. This is now how DestinyItemType is populated for items: it used to be an even jankier process, but that's a story that requires more alcohol.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemType"
	//       }
	//     },
	//     "grantDestinySubType": {
	//       "description": "If an item belongs to this category, it will also receive this subtype enum value.\r\nI know what you're thinking - what if it belongs to multiple categories that provide sub-types?\r\nThe last one processed wins, as is the case with all of these \"grant\" enums. Now you can see one reason why we moved away from these enums... but they're so convenient when they work, aren't they?",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemSubType"
	//       }
	//     },
	//     "groupCategoryOnly": {
	//       "description": "If true, this category is only used for grouping, and should not be evaluated with its own checks. Rather, the item only has this category if it has one of its child categories.",
	//       "type": "boolean"
	//     },
	//     "groupedCategoryHashes": {
	//       "description": "If this category is a \"parent\" category of other categories, those children will have their hashes listed in rendering order here, and can be looked up using these hashes against DestinyItemCategoryDefinition.\r\nIn this way, you can build up a visual hierarchy of item categories. That's what we did, and you can do it too. I believe in you. Yes, you, Carl.\r\n(I hope someone named Carl reads this someday)",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemCategoryDefinition"
	//       }
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "itemTypeRegex": {
	//       "description": "The janky regular expression we used against the item type to try and discern whether the item belongs to this category.",
	//       "type": "string"
	//     },
	//     "itemTypeRegexNot": {
	//       "description": "If the item type matches this janky regex, it does *not* belong to this category.",
	//       "type": "string"
	//     },
	//     "originBucketIdentifier": {
	//       "description": "If the item belongs to this bucket, it does belong to this category.",
	//       "type": "string"
	//     },
	//     "parentCategoryHashes": {
	//       "description": "All item category hashes of \"parent\" categories: categories that contain this as a child through the hierarchy of groupedCategoryHashes. It's a bit redundant, but having this child-centric list speeds up some calculations.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "plugCategoryIdentifier": {
	//       "description": "If the item is a plug, this is the identifier we expect to find associated with it if it is in this category.",
	//       "type": "string"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "shortTitle": {
	//       "description": "A shortened version of the title. The reason why we have this is because the Armory in German had titles that were too long to display in our UI, so these were localized abbreviated versions of those categories. The property still exists today, even though the Armory doesn't exist for D2... yet.",
	//       "type": "string"
	//     },
	//     "traitId": {
	//       "description": "The traitId that can be found on items that belong to this category.",
	//       "type": "string"
	//     },
	//     "visible": {
	//       "description": "If True, this category should be visible in UI. Sometimes we make categories that we don't think are interesting externally. It's up to you if you want to skip on showing them.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "ItemCategories"
	// }

	// If True, this category has been deprecated: it may have no items left, or there may be only legacy
	// items that remain in it which are no longer relevant to the game.
	Deprecated bool `json:"deprecated"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// If the item in question has this category, it also should have this breaker type.
	GrantDestinyBreakerType BreakerType `json:"grantDestinyBreakerType"`

	// If an item belongs to this category, it will also get this class restriction enum value.
	// See the other "grant"-prefixed properties on this definition for my color commentary.
	GrantDestinyClass Class `json:"grantDestinyClass"`

	// If an item belongs to this category, it will also receive this item type. This is now how
	// DestinyItemType is populated for items: it used to be an even jankier process, but that's a story
	// that requires more alcohol.
	GrantDestinyItemType ItemType `json:"grantDestinyItemType"`

	// If an item belongs to this category, it will also receive this subtype enum value.
	// I know what you're thinking - what if it belongs to multiple categories that provide sub-types?
	// The last one processed wins, as is the case with all of these "grant" enums. Now you can see one
	// reason why we moved away from these enums... but they're so convenient when they work, aren't they?
	GrantDestinySubType ItemSubType `json:"grantDestinySubType"`

	// If true, this category is only used for grouping, and should not be evaluated with its own checks.
	// Rather, the item only has this category if it has one of its child categories.
	GroupCategoryOnly bool `json:"groupCategoryOnly"`

	// If this category is a "parent" category of other categories, those children will have their hashes
	// listed in rendering order here, and can be looked up using these hashes against
	// DestinyItemCategoryDefinition.
	// In this way, you can build up a visual hierarchy of item categories. That's what we did, and you can
	// do it too. I believe in you. Yes, you, Carl.
	// (I hope someone named Carl reads this someday)
	GroupedCategoryHashes []uint32 `json:"groupedCategoryHashes"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// The janky regular expression we used against the item type to try and discern whether the item
	// belongs to this category.
	ItemTypeRegex string `json:"itemTypeRegex"`

	// If the item type matches this janky regex, it does *not* belong to this category.
	ItemTypeRegexNot string `json:"itemTypeRegexNot"`

	// If the item belongs to this bucket, it does belong to this category.
	OriginBucketIdentifier string `json:"originBucketIdentifier"`

	// All item category hashes of "parent" categories: categories that contain this as a child through the
	// hierarchy of groupedCategoryHashes. It's a bit redundant, but having this child-centric list speeds
	// up some calculations.
	ParentCategoryHashes []uint32 `json:"parentCategoryHashes"`

	// If the item is a plug, this is the identifier we expect to find associated with it if it is in this
	// category.
	PlugCategoryIdentifier string `json:"plugCategoryIdentifier"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// A shortened version of the title. The reason why we have this is because the Armory in German had
	// titles that were too long to display in our UI, so these were localized abbreviated versions of
	// those categories. The property still exists today, even though the Armory doesn't exist for D2...
	// yet.
	ShortTitle string `json:"shortTitle"`

	// The traitId that can be found on items that belong to this category.
	TraitID string `json:"traitId"`

	// If True, this category should be visible in UI. Sometimes we make categories that we don't think are
	// interesting externally. It's up to you if you want to skip on showing them.
	Visible bool `json:"visible"`
}

// Destiny.Definitions.DestinyItemCraftingBlockBonusPlugDefinition
type ItemCraftingBlockBonusPlugDefinition struct {
	// {
	//   "properties": {
	//     "plugItemHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "socketTypeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinySocketTypeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	PlugItemHash Hash[InventoryItemDefinition] `json:"plugItemHash"`

	SocketTypeHash Hash[SocketTypeDefinition] `json:"socketTypeHash"`
}

// Destiny.Definitions.DestinyItemCraftingBlockDefinition
//
// If an item can have an action performed on it (like "Dismantle"), it will be defined here if you
// care.
type ItemCraftingBlockDefinition struct {
	// {
	//   "description": "If an item can have an action performed on it (like \"Dismantle\"), it will be defined here if you care.",
	//   "properties": {
	//     "baseMaterialRequirements": {
	//       "description": "A reference to the base material requirements for crafting with this recipe.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyMaterialRequirementSetDefinition"
	//       }
	//     },
	//     "bonusPlugs": {
	//       "description": "A list of 'bonus' socket plugs that may be available if certain requirements are met.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemCraftingBlockBonusPlugDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "failedRequirementStrings": {
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     },
	//     "outputItemHash": {
	//       "description": "A reference to the item definition that is created when crafting with this 'recipe' item.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "requiredSocketTypeHashes": {
	//       "description": "A list of socket type hashes that describes which sockets are required for crafting with this recipe.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinySocketTypeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// A reference to the base material requirements for crafting with this recipe.
	BaseMaterialRequirements Nullable[Hash[MaterialRequirementSetDefinition]] `json:"baseMaterialRequirements,omitempty"`

	// A list of 'bonus' socket plugs that may be available if certain requirements are met.
	BonusPlugs []ItemCraftingBlockBonusPlugDefinition `json:"bonusPlugs"`

	FailedRequirementStrings []string `json:"failedRequirementStrings"`

	// A reference to the item definition that is created when crafting with this 'recipe' item.
	OutputItemHash Hash[InventoryItemDefinition] `json:"outputItemHash"`

	// A list of socket type hashes that describes which sockets are required for crafting with this
	// recipe.
	RequiredSocketTypeHashes []uint32 `json:"requiredSocketTypeHashes"`
}

// Destiny.Definitions.DestinyItemCreationEntryLevelDefinition
//
// An overly complicated wrapper for the item level at which the item should spawn.
type ItemCreationEntryLevelDefinition struct {
	// {
	//   "description": "An overly complicated wrapper for the item level at which the item should spawn.",
	//   "properties": {
	//     "level": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	Level int32 `json:"level"`
}

// Destiny.Definitions.DestinyItemGearsetBlockDefinition
//
// If an item has a related gearset, this is the list of items in that set, and an unlock expression
// that evaluates to a number representing the progress toward gearset completion (a very rare use for
// unlock expressions!)
type ItemGearsetBlockDefinition struct {
	// {
	//   "description": "If an item has a related gearset, this is the list of items in that set, and an unlock expression that evaluates to a number representing the progress toward gearset completion (a very rare use for unlock expressions!)",
	//   "properties": {
	//     "itemList": {
	//       "description": "The list of hashes for items in the gearset. Use them to look up DestinyInventoryItemDefinition entries for the items in the set.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "trackingValueMax": {
	//       "description": "The maximum possible number of items that can be collected.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// The list of hashes for items in the gearset. Use them to look up DestinyInventoryItemDefinition
	// entries for the items in the set.
	ItemList []uint32 `json:"itemList"`

	// The maximum possible number of items that can be collected.
	TrackingValueMax int32 `json:"trackingValueMax"`
}

// Destiny.Definitions.DestinyItemIntrinsicSocketEntryDefinition
//
// Represents a socket that has a plug associated with it intrinsically. This is useful for situations
// where the weapon needs to have a visual plug/Mod on it, but that plug/Mod should never change.
type ItemIntrinsicSocketEntryDefinition struct {
	// {
	//   "description": "Represents a socket that has a plug associated with it intrinsically. This is useful for situations where the weapon needs to have a visual plug/Mod on it, but that plug/Mod should never change.",
	//   "properties": {
	//     "defaultVisible": {
	//       "description": "If true, then this socket is visible in the item's \"default\" state. If you have an instance, you should always check the runtime state, as that can override this visibility setting: but if you're looking at the item on a conceptual level, this property can be useful for hiding data such as legacy sockets - which remain defined on items for infrastructure purposes, but can be confusing for users to see.",
	//       "type": "boolean"
	//     },
	//     "plugItemHash": {
	//       "description": "Indicates the plug that is intrinsically inserted into this socket.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "socketTypeHash": {
	//       "description": "Indicates the type of this intrinsic socket.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinySocketTypeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// If true, then this socket is visible in the item's "default" state. If you have an instance, you
	// should always check the runtime state, as that can override this visibility setting: but if you're
	// looking at the item on a conceptual level, this property can be useful for hiding data such as
	// legacy sockets - which remain defined on items for infrastructure purposes, but can be confusing for
	// users to see.
	DefaultVisible bool `json:"defaultVisible"`

	// Indicates the plug that is intrinsically inserted into this socket.
	PlugItemHash Hash[InventoryItemDefinition] `json:"plugItemHash"`

	// Indicates the type of this intrinsic socket.
	SocketTypeHash Hash[SocketTypeDefinition] `json:"socketTypeHash"`
}

// Destiny.Definitions.DestinyItemInventoryBlockDefinition
//
// If the item can exist in an inventory - the overwhelming majority of them can and do - then this is
// the basic properties regarding the item's relationship with the inventory.
type ItemInventoryBlockDefinition struct {
	// {
	//   "description": "If the item can exist in an inventory - the overwhelming majority of them can and do - then this is the basic properties regarding the item's relationship with the inventory.",
	//   "properties": {
	//     "bucketTypeHash": {
	//       "description": "The hash identifier for the DestinyInventoryBucketDefinition to which this item belongs. I should have named this \"bucketHash\", but too many things refer to it now. Sigh.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryBucketDefinition"
	//       }
	//     },
	//     "expirationTooltip": {
	//       "description": "The tooltip message to show, if any, when the item expires.",
	//       "type": "string"
	//     },
	//     "expiredInActivityMessage": {
	//       "description": "If the item expires while playing in an activity, we show a different message.",
	//       "type": "string"
	//     },
	//     "expiredInOrbitMessage": {
	//       "description": "If the item expires in orbit, we show a... more different message. (\"Consummate V's, consummate!\")",
	//       "type": "string"
	//     },
	//     "isInstanceItem": {
	//       "description": "If TRUE, this item is instanced. Otherwise, it is a generic item that merely has a quantity in a stack (like Glimmer).",
	//       "type": "boolean"
	//     },
	//     "maxStackSize": {
	//       "description": "The maximum quantity of this item that can exist in a stack.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "recipeItemHash": {
	//       "description": "A reference to the associated crafting 'recipe' item definition, if this item can be crafted.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "recoveryBucketTypeHash": {
	//       "description": "If the item is picked up by the lost loot queue, this is the hash identifier for the DestinyInventoryBucketDefinition into which it will be placed. Again, I should have named this recoveryBucketHash instead.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryBucketDefinition"
	//       }
	//     },
	//     "stackUniqueLabel": {
	//       "description": "If this string is populated, you can't have more than one stack with this label in a given inventory. Note that this is different from the equipping block's unique label, which is used for equipping uniqueness.",
	//       "type": "string"
	//     },
	//     "suppressExpirationWhenObjectivesComplete": {
	//       "type": "boolean"
	//     },
	//     "tierType": {
	//       "description": "The enumeration matching the tier type of the item to known values, again for convenience sake.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.TierType"
	//       }
	//     },
	//     "tierTypeHash": {
	//       "description": "The hash identifier for the Tier Type of the item, use to look up its DestinyItemTierTypeDefinition if you need to show localized data for the item's tier.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Items.DestinyItemTierTypeDefinition"
	//       }
	//     },
	//     "tierTypeName": {
	//       "description": "The localized name of the tier type, which is a useful shortcut so you don't have to look up the definition every time. However, it's mostly a holdover from days before we had a DestinyItemTierTypeDefinition to refer to.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash identifier for the DestinyInventoryBucketDefinition to which this item belongs. I should
	// have named this "bucketHash", but too many things refer to it now. Sigh.
	BucketTypeHash Hash[InventoryBucketDefinition] `json:"bucketTypeHash"`

	// The tooltip message to show, if any, when the item expires.
	ExpirationTooltip string `json:"expirationTooltip"`

	// If the item expires while playing in an activity, we show a different message.
	ExpiredInActivityMessage string `json:"expiredInActivityMessage"`

	// If the item expires in orbit, we show a... more different message. ("Consummate V's, consummate!")
	ExpiredInOrbitMessage string `json:"expiredInOrbitMessage"`

	// If TRUE, this item is instanced. Otherwise, it is a generic item that merely has a quantity in a
	// stack (like Glimmer).
	IsInstanceItem bool `json:"isInstanceItem"`

	// The maximum quantity of this item that can exist in a stack.
	MaxStackSize int32 `json:"maxStackSize"`

	// A reference to the associated crafting 'recipe' item definition, if this item can be crafted.
	RecipeItemHash Nullable[Hash[InventoryItemDefinition]] `json:"recipeItemHash,omitempty"`

	// If the item is picked up by the lost loot queue, this is the hash identifier for the
	// DestinyInventoryBucketDefinition into which it will be placed. Again, I should have named this
	// recoveryBucketHash instead.
	RecoveryBucketTypeHash Hash[InventoryBucketDefinition] `json:"recoveryBucketTypeHash"`

	// If this string is populated, you can't have more than one stack with this label in a given
	// inventory. Note that this is different from the equipping block's unique label, which is used for
	// equipping uniqueness.
	StackUniqueLabel string `json:"stackUniqueLabel"`

	SuppressExpirationWhenObjectivesComplete bool `json:"suppressExpirationWhenObjectivesComplete"`

	// The enumeration matching the tier type of the item to known values, again for convenience sake.
	TierType TierType `json:"tierType"`

	// The hash identifier for the Tier Type of the item, use to look up its DestinyItemTierTypeDefinition
	// if you need to show localized data for the item's tier.
	TierTypeHash Hash[ItemTierTypeDefinition] `json:"tierTypeHash"`

	// The localized name of the tier type, which is a useful shortcut so you don't have to look up the
	// definition every time. However, it's mostly a holdover from days before we had a
	// DestinyItemTierTypeDefinition to refer to.
	TierTypeName string `json:"tierTypeName"`
}

// Destiny.Definitions.DestinyItemInvestmentStatDefinition
//
// Represents a "raw" investment stat, before calculated stats are calculated and before any
// DestinyStatGroupDefinition is applied to transform the stat into something closer to what you see
// in-game.
// Because these won't match what you see in-game, consider carefully whether you really want to use
// these stats. I have left them in case someone can do something useful or interesting with the
// pre-processed statistics.
type ItemInvestmentStatDefinition struct {
	// {
	//   "description": "Represents a \"raw\" investment stat, before calculated stats are calculated and before any DestinyStatGroupDefinition is applied to transform the stat into something closer to what you see in-game.\r\nBecause these won't match what you see in-game, consider carefully whether you really want to use these stats. I have left them in case someone can do something useful or interesting with the pre-processed statistics.",
	//   "properties": {
	//     "isConditionallyActive": {
	//       "description": "If this is true, the stat will only be applied on the item in certain game state conditions, and we can't know statically whether or not this stat will be applied. Check the \"live\" API data instead for whether this value is being applied on a specific instance of the item in question, and you can use this to decide whether you want to show the stat on the generic view of the item, or whether you want to show some kind of caveat or warning about the stat value being conditional on game state.",
	//       "type": "boolean"
	//     },
	//     "statTypeHash": {
	//       "description": "The hash identifier for the DestinyStatDefinition defining this stat.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyStatDefinition"
	//       }
	//     },
	//     "value": {
	//       "description": "The raw \"Investment\" value for the stat, before transformations are performed to turn this raw stat into stats that are displayed in the game UI.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// If this is true, the stat will only be applied on the item in certain game state conditions, and we
	// can't know statically whether or not this stat will be applied. Check the "live" API data instead
	// for whether this value is being applied on a specific instance of the item in question, and you can
	// use this to decide whether you want to show the stat on the generic view of the item, or whether you
	// want to show some kind of caveat or warning about the stat value being conditional on game state.
	IsConditionallyActive bool `json:"isConditionallyActive"`

	// The hash identifier for the DestinyStatDefinition defining this stat.
	StatTypeHash Hash[StatDefinition] `json:"statTypeHash"`

	// The raw "Investment" value for the stat, before transformations are performed to turn this raw stat
	// into stats that are displayed in the game UI.
	Value int32 `json:"value"`
}

// Destiny.Definitions.DestinyItemMetricBlockDefinition
//
// The metrics available for display and selection on an item.
type ItemMetricBlockDefinition struct {
	// {
	//   "description": "The metrics available for display and selection on an item.",
	//   "properties": {
	//     "availableMetricCategoryNodeHashes": {
	//       "description": "Hash identifiers for any DestinyPresentationNodeDefinition entry that can be used to list available metrics. Any metric listed directly below these nodes, or in any of these nodes' children will be made available for selection.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// Hash identifiers for any DestinyPresentationNodeDefinition entry that can be used to list available
	// metrics. Any metric listed directly below these nodes, or in any of these nodes' children will be
	// made available for selection.
	AvailableMetricCategoryNodeHashes []uint32 `json:"availableMetricCategoryNodeHashes"`
}

// Destiny.Definitions.DestinyItemObjectiveBlockDefinition
//
// An item can have objectives on it. In practice, these are the exclusive purview of "Quest Step"
// items: DestinyInventoryItemDefinitions that represent a specific step in a Quest.
// Quest steps have 1:M objectives that we end up processing and returning in live data as
// DestinyQuestStatus data, and other useful information.
type ItemObjectiveBlockDefinition struct {
	// {
	//   "description": "An item can have objectives on it. In practice, these are the exclusive purview of \"Quest Step\" items: DestinyInventoryItemDefinitions that represent a specific step in a Quest.\r\nQuest steps have 1:M objectives that we end up processing and returning in live data as DestinyQuestStatus data, and other useful information.",
	//   "properties": {
	//     "displayActivityHashes": {
	//       "description": "For every entry in objectiveHashes, there is a corresponding entry in this array at the same index. If the objective is meant to be associated with a specific DestinyActivityDefinition, there will be a valid hash at that index. Otherwise, it will be invalid (0).\r\nRendered somewhat obsolete by perObjectiveDisplayProperties, which currently has much the same information but may end up with more info in the future.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "displayAsStatTracker": {
	//       "type": "boolean"
	//     },
	//     "narrative": {
	//       "description": "The localized string for narrative text related to this quest step, if any.",
	//       "type": "string"
	//     },
	//     "objectiveHashes": {
	//       "description": "The hashes to Objectives (DestinyObjectiveDefinition) that are part of this Quest Step, in the order that they should be rendered.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectiveDefinition"
	//       }
	//     },
	//     "objectiveVerbName": {
	//       "description": "The localized string describing an action to be performed associated with the objectives, if any.",
	//       "type": "string"
	//     },
	//     "perObjectiveDisplayProperties": {
	//       "description": "One entry per Objective on the item, it will have related display information.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectiveDisplayProperties"
	//       },
	//       "type": "array"
	//     },
	//     "questTypeHash": {
	//       "description": "A hashed value for the questTypeIdentifier, because apparently I like to be redundant.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "questTypeIdentifier": {
	//       "description": "The identifier for the type of quest being performed, if any. Not associated with any fixed definition, yet.",
	//       "type": "string"
	//     },
	//     "questlineItemHash": {
	//       "description": "The hash for the DestinyInventoryItemDefinition representing the Quest to which this Quest Step belongs.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "requireFullObjectiveCompletion": {
	//       "description": "If True, all objectives must be completed for the step to be completed. If False, any one objective can be completed for the step to be completed.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	// For every entry in objectiveHashes, there is a corresponding entry in this array at the same index.
	// If the objective is meant to be associated with a specific DestinyActivityDefinition, there will be
	// a valid hash at that index. Otherwise, it will be invalid (0).
	// Rendered somewhat obsolete by perObjectiveDisplayProperties, which currently has much the same
	// information but may end up with more info in the future.
	DisplayActivityHashes []uint32 `json:"displayActivityHashes"`

	DisplayAsStatTracker bool `json:"displayAsStatTracker"`

	// The localized string for narrative text related to this quest step, if any.
	Narrative string `json:"narrative"`

	// The hashes to Objectives (DestinyObjectiveDefinition) that are part of this Quest Step, in the order
	// that they should be rendered.
	ObjectiveHashes []uint32 `json:"objectiveHashes"`

	// The localized string describing an action to be performed associated with the objectives, if any.
	ObjectiveVerbName string `json:"objectiveVerbName"`

	// One entry per Objective on the item, it will have related display information.
	PerObjectiveDisplayProperties []ObjectiveDisplayProperties `json:"perObjectiveDisplayProperties"`

	// A hashed value for the questTypeIdentifier, because apparently I like to be redundant.
	QuestTypeHash uint32 `json:"questTypeHash"`

	// The identifier for the type of quest being performed, if any. Not associated with any fixed
	// definition, yet.
	QuestTypeIdentifier string `json:"questTypeIdentifier"`

	// The hash for the DestinyInventoryItemDefinition representing the Quest to which this Quest Step
	// belongs.
	QuestlineItemHash Hash[InventoryItemDefinition] `json:"questlineItemHash"`

	// If True, all objectives must be completed for the step to be completed. If False, any one objective
	// can be completed for the step to be completed.
	RequireFullObjectiveCompletion bool `json:"requireFullObjectiveCompletion"`
}

// Destiny.Definitions.DestinyItemPerkEntryDefinition
//
// An intrinsic perk on an item, and the requirements for it to be activated.
type ItemPerkEntryDefinition struct {
	// {
	//   "description": "An intrinsic perk on an item, and the requirements for it to be activated.",
	//   "properties": {
	//     "perkHash": {
	//       "description": "A hash identifier for the DestinySandboxPerkDefinition being provided on the item.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinySandboxPerkDefinition"
	//       }
	//     },
	//     "perkVisibility": {
	//       "description": "Indicates whether this perk should be shown, or if it should be shown disabled.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.ItemPerkVisibility"
	//       }
	//     },
	//     "requirementDisplayString": {
	//       "description": "If this perk is not active, this is the string to show for why it's not providing its benefits.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// A hash identifier for the DestinySandboxPerkDefinition being provided on the item.
	PerkHash Hash[SandboxPerkDefinition] `json:"perkHash"`

	// Indicates whether this perk should be shown, or if it should be shown disabled.
	PerkVisibility ItemPerkVisibility `json:"perkVisibility"`

	// If this perk is not active, this is the string to show for why it's not providing its benefits.
	RequirementDisplayString string `json:"requirementDisplayString"`
}

// Destiny.Definitions.DestinyItemPreviewBlockDefinition
//
// Items like Sacks or Boxes can have items that it shows in-game when you view details that represent
// the items you can obtain if you use or acquire the item.
// This defines those categories, and gives some insights into that data's source.
type ItemPreviewBlockDefinition struct {
	// {
	//   "description": "Items like Sacks or Boxes can have items that it shows in-game when you view details that represent the items you can obtain if you use or acquire the item.\r\nThis defines those categories, and gives some insights into that data's source.",
	//   "properties": {
	//     "artifactHash": {
	//       "description": "If this item should show you Artifact information when you preview it, this is the hash identifier of the DestinyArtifactDefinition for the artifact whose data should be shown.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Artifacts.DestinyArtifactDefinition"
	//       }
	//     },
	//     "derivedItemCategories": {
	//       "description": "This is a list of the items being previewed, categorized in the same way as they are in the preview UI.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Items.DestinyDerivedItemCategoryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "previewActionString": {
	//       "description": "If the preview has an associated action (like \"Open\"), this will be the localized string for that action.",
	//       "type": "string"
	//     },
	//     "previewVendorHash": {
	//       "description": "If the preview data is derived from a fake \"Preview\" Vendor, this will be the hash identifier for the DestinyVendorDefinition of that fake vendor.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     },
	//     "screenStyle": {
	//       "description": "A string that the game UI uses as a hint for which detail screen to show for the item. You, too, can leverage this for your own custom screen detail views. Note, however, that these are arbitrarily defined by designers: there's no guarantees of a fixed, known number of these - so fall back to something reasonable if you don't recognize it.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// If this item should show you Artifact information when you preview it, this is the hash identifier
	// of the DestinyArtifactDefinition for the artifact whose data should be shown.
	ArtifactHash Nullable[Hash[ArtifactDefinition]] `json:"artifactHash,omitempty"`

	// This is a list of the items being previewed, categorized in the same way as they are in the preview
	// UI.
	DerivedItemCategories []DerivedItemCategoryDefinition `json:"derivedItemCategories"`

	// If the preview has an associated action (like "Open"), this will be the localized string for that
	// action.
	PreviewActionString string `json:"previewActionString"`

	// If the preview data is derived from a fake "Preview" Vendor, this will be the hash identifier for
	// the DestinyVendorDefinition of that fake vendor.
	PreviewVendorHash Hash[VendorDefinition] `json:"previewVendorHash"`

	// A string that the game UI uses as a hint for which detail screen to show for the item. You, too, can
	// leverage this for your own custom screen detail views. Note, however, that these are arbitrarily
	// defined by designers: there's no guarantees of a fixed, known number of these - so fall back to
	// something reasonable if you don't recognize it.
	ScreenStyle string `json:"screenStyle"`
}

// Destiny.Definitions.DestinyItemQualityBlockDefinition
//
// An item's "Quality" determines its calculated stats. The Level at which the item spawns is combined
// with its "qualityLevel" along with some additional calculations to determine the value of those
// stats.
// In Destiny 2, most items don't have default item levels and quality, making this property less
// useful: these apparently are almost always determined by the complex mechanisms of the Reward system
// rather than statically. They are still provided here in case they are still useful for people. This
// also contains some information about Infusion.
type ItemQualityBlockDefinition struct {
	// {
	//   "description": "An item's \"Quality\" determines its calculated stats. The Level at which the item spawns is combined with its \"qualityLevel\" along with some additional calculations to determine the value of those stats.\r\nIn Destiny 2, most items don't have default item levels and quality, making this property less useful: these apparently are almost always determined by the complex mechanisms of the Reward system rather than statically. They are still provided here in case they are still useful for people. This also contains some information about Infusion.",
	//   "properties": {
	//     "currentVersion": {
	//       "description": "The latest version available for this item.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "displayVersionWatermarkIcons": {
	//       "description": "Icon overlays to denote the item version and power cap status.",
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     },
	//     "infusionCategoryHash": {
	//       "description": "The hash identifier for the infusion. It does not map to a Definition entity.\r\nDEPRECATED: Items can now have multiple infusion categories. Please use infusionCategoryHashes instead.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "infusionCategoryHashes": {
	//       "description": "If any one of these hashes matches any value in another item's infusionCategoryHashes, the two can infuse with each other.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "infusionCategoryName": {
	//       "description": "The string identifier for this item's \"infusability\", if any. \r\nItems that match the same infusionCategoryName are allowed to infuse with each other.\r\nDEPRECATED: Items can now have multiple infusion categories. Please use infusionCategoryHashes instead.",
	//       "type": "string"
	//     },
	//     "itemLevels": {
	//       "description": "The \"base\" defined level of an item. This is a list because, in theory, each Expansion could define its own base level for an item.\r\nIn practice, not only was that never done in Destiny 1, but now this isn't even populated at all. When it's not populated, the level at which it spawns has to be inferred by Reward information, of which BNet receives an imperfect view and will only be reliable on instanced data as a result.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "progressionLevelRequirementHash": {
	//       "description": "An item can refer to pre-set level requirements. They are defined in DestinyProgressionLevelRequirementDefinition, and you can use this hash to find the appropriate definition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Progression.DestinyProgressionLevelRequirementDefinition"
	//       }
	//     },
	//     "qualityLevel": {
	//       "description": "qualityLevel is used in combination with the item's level to calculate stats like Attack and Defense. It plays a role in that calculation, but not nearly as large as itemLevel does.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "versions": {
	//       "description": "The list of versions available for this item.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemVersionDefinition"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The latest version available for this item.
	CurrentVersion uint32 `json:"currentVersion"`

	// Icon overlays to denote the item version and power cap status.
	DisplayVersionWatermarkIcons []string `json:"displayVersionWatermarkIcons"`

	// The hash identifier for the infusion. It does not map to a Definition entity.
	// DEPRECATED: Items can now have multiple infusion categories. Please use infusionCategoryHashes
	// instead.
	InfusionCategoryHash uint32 `json:"infusionCategoryHash"`

	// If any one of these hashes matches any value in another item's infusionCategoryHashes, the two can
	// infuse with each other.
	InfusionCategoryHashes []uint32 `json:"infusionCategoryHashes"`

	// The string identifier for this item's "infusability", if any.
	// Items that match the same infusionCategoryName are allowed to infuse with each other.
	// DEPRECATED: Items can now have multiple infusion categories. Please use infusionCategoryHashes
	// instead.
	InfusionCategoryName string `json:"infusionCategoryName"`

	// The "base" defined level of an item. This is a list because, in theory, each Expansion could define
	// its own base level for an item.
	// In practice, not only was that never done in Destiny 1, but now this isn't even populated at all.
	// When it's not populated, the level at which it spawns has to be inferred by Reward information, of
	// which BNet receives an imperfect view and will only be reliable on instanced data as a result.
	ItemLevels []int32 `json:"itemLevels"`

	// An item can refer to pre-set level requirements. They are defined in
	// DestinyProgressionLevelRequirementDefinition, and you can use this hash to find the appropriate
	// definition.
	ProgressionLevelRequirementHash Hash[ProgressionLevelRequirementDefinition] `json:"progressionLevelRequirementHash"`

	// qualityLevel is used in combination with the item's level to calculate stats like Attack and
	// Defense. It plays a role in that calculation, but not nearly as large as itemLevel does.
	QualityLevel int32 `json:"qualityLevel"`

	// The list of versions available for this item.
	Versions []ItemVersionDefinition `json:"versions"`
}

// Destiny.Definitions.DestinyItemSackBlockDefinition
//
// Some items are "sacks" - they can be "opened" to produce other items. This is information related to
// its sack status, mostly UI strings. Engrams are an example of items that are considered to be
// "Sacks".
type ItemSackBlockDefinition struct {
	// {
	//   "description": "Some items are \"sacks\" - they can be \"opened\" to produce other items. This is information related to its sack status, mostly UI strings. Engrams are an example of items that are considered to be \"Sacks\".",
	//   "properties": {
	//     "detailAction": {
	//       "description": "A description of what will happen when you open the sack. As far as I can tell, this is blank currently. Unknown whether it will eventually be populated with useful info.",
	//       "type": "string"
	//     },
	//     "openAction": {
	//       "description": "The localized name of the action being performed when you open the sack.",
	//       "type": "string"
	//     },
	//     "openOnAcquire": {
	//       "type": "boolean"
	//     },
	//     "selectItemCount": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "vendorSackType": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// A description of what will happen when you open the sack. As far as I can tell, this is blank
	// currently. Unknown whether it will eventually be populated with useful info.
	DetailAction string `json:"detailAction"`

	// The localized name of the action being performed when you open the sack.
	OpenAction string `json:"openAction"`

	OpenOnAcquire bool `json:"openOnAcquire"`

	SelectItemCount int32 `json:"selectItemCount"`

	VendorSackType string `json:"vendorSackType"`
}

// Destiny.Definitions.DestinyItemSetBlockDefinition
//
// Primarily for Quests, this is the definition of properties related to the item if it is a quest and
// its various quest steps.
type ItemSetBlockDefinition struct {
	// {
	//   "description": "Primarily for Quests, this is the definition of properties related to the item if it is a quest and its various quest steps.",
	//   "properties": {
	//     "itemList": {
	//       "description": "A collection of hashes of set items, for items such as Quest Metadata items that possess this data.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemSetBlockEntryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "questLineDescription": {
	//       "description": "The description of the quest line that this quest step is a part of.",
	//       "type": "string"
	//     },
	//     "questLineName": {
	//       "description": "The name of the quest line that this quest step is a part of.",
	//       "type": "string"
	//     },
	//     "questStepSummary": {
	//       "description": "An additional summary of this step in the quest line.",
	//       "type": "string"
	//     },
	//     "requireOrderedSetItemAdd": {
	//       "description": "If true, items in the set can only be added in increasing order, and adding an item will remove any previous item. For Quests, this is by necessity true. Only one quest step is present at a time, and previous steps are removed as you advance in the quest.",
	//       "type": "boolean"
	//     },
	//     "setIsFeatured": {
	//       "description": "If true, the UI should treat this quest as \"featured\"",
	//       "type": "boolean"
	//     },
	//     "setType": {
	//       "description": "A string identifier we can use to attempt to identify the category of the Quest.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// A collection of hashes of set items, for items such as Quest Metadata items that possess this data.
	ItemList []ItemSetBlockEntryDefinition `json:"itemList"`

	// The description of the quest line that this quest step is a part of.
	QuestLineDescription string `json:"questLineDescription"`

	// The name of the quest line that this quest step is a part of.
	QuestLineName string `json:"questLineName"`

	// An additional summary of this step in the quest line.
	QuestStepSummary string `json:"questStepSummary"`

	// If true, items in the set can only be added in increasing order, and adding an item will remove any
	// previous item. For Quests, this is by necessity true. Only one quest step is present at a time, and
	// previous steps are removed as you advance in the quest.
	RequireOrderedSetItemAdd bool `json:"requireOrderedSetItemAdd"`

	// If true, the UI should treat this quest as "featured"
	SetIsFeatured bool `json:"setIsFeatured"`

	// A string identifier we can use to attempt to identify the category of the Quest.
	SetType string `json:"setType"`
}

// Destiny.Definitions.DestinyItemSetBlockEntryDefinition
//
// Defines a particular entry in an ItemSet (AKA a particular Quest Step in a Quest)
type ItemSetBlockEntryDefinition struct {
	// {
	//   "description": "Defines a particular entry in an ItemSet (AKA a particular Quest Step in a Quest)",
	//   "properties": {
	//     "itemHash": {
	//       "description": "This is the hash identifier for a DestinyInventoryItemDefinition representing this quest step.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "trackingValue": {
	//       "description": "Used for tracking which step a user reached. These values will be populated in the user's internal state, which we expose externally as a more usable DestinyQuestStatus object. If this item has been obtained, this value will be set in trackingUnlockValueHash.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// This is the hash identifier for a DestinyInventoryItemDefinition representing this quest step.
	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`

	// Used for tracking which step a user reached. These values will be populated in the user's internal
	// state, which we expose externally as a more usable DestinyQuestStatus object. If this item has been
	// obtained, this value will be set in trackingUnlockValueHash.
	TrackingValue int32 `json:"trackingValue"`
}

// Destiny.Definitions.DestinyItemSocketBlockDefinition
//
// If defined, the item has at least one socket.
type ItemSocketBlockDefinition struct {
	// {
	//   "description": "If defined, the item has at least one socket.",
	//   "properties": {
	//     "detail": {
	//       "description": "This was supposed to be a string that would give per-item details about sockets. In practice, it turns out that all this ever has is the localized word \"details\". ... that's lame, but perhaps it will become something cool in the future.",
	//       "type": "string"
	//     },
	//     "intrinsicSockets": {
	//       "description": "Each intrinsic (or immutable/permanent) socket on an item is defined here, along with the plug that is permanently affixed to the socket.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemIntrinsicSocketEntryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "socketCategories": {
	//       "description": "A convenience property, that refers to the sockets in the \"sockets\" property, pre-grouped by category and ordered in the manner that they should be grouped in the UI. You could form this yourself with the existing data, but why would you want to? Enjoy life man.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemSocketCategoryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "socketEntries": {
	//       "description": "Each non-intrinsic (or mutable) socket on an item is defined here. Check inside for more info.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemSocketEntryDefinition"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// This was supposed to be a string that would give per-item details about sockets. In practice, it
	// turns out that all this ever has is the localized word "details". ... that's lame, but perhaps it
	// will become something cool in the future.
	Detail string `json:"detail"`

	// Each intrinsic (or immutable/permanent) socket on an item is defined here, along with the plug that
	// is permanently affixed to the socket.
	IntrinsicSockets []ItemIntrinsicSocketEntryDefinition `json:"intrinsicSockets"`

	// A convenience property, that refers to the sockets in the "sockets" property, pre-grouped by
	// category and ordered in the manner that they should be grouped in the UI. You could form this
	// yourself with the existing data, but why would you want to? Enjoy life man.
	SocketCategories []ItemSocketCategoryDefinition `json:"socketCategories"`

	// Each non-intrinsic (or mutable) socket on an item is defined here. Check inside for more info.
	SocketEntries []ItemSocketEntryDefinition `json:"socketEntries"`
}

// Destiny.Definitions.DestinyItemSocketCategoryDefinition
//
// Sockets are grouped into categories in the UI. These define which category and which sockets are
// under that category.
type ItemSocketCategoryDefinition struct {
	// {
	//   "description": "Sockets are grouped into categories in the UI. These define which category and which sockets are under that category.",
	//   "properties": {
	//     "socketCategoryHash": {
	//       "description": "The hash for the Socket Category: a quick way to go get the header display information for the category. Use it to look up DestinySocketCategoryDefinition info.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinySocketCategoryDefinition"
	//       }
	//     },
	//     "socketIndexes": {
	//       "description": "Use these indexes to look up the sockets in the \"sockets.socketEntries\" property on the item definition. These are the indexes under the category, in game-rendered order.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash for the Socket Category: a quick way to go get the header display information for the
	// category. Use it to look up DestinySocketCategoryDefinition info.
	SocketCategoryHash Hash[SocketCategoryDefinition] `json:"socketCategoryHash"`

	// Use these indexes to look up the sockets in the "sockets.socketEntries" property on the item
	// definition. These are the indexes under the category, in game-rendered order.
	SocketIndexes []int32 `json:"socketIndexes"`
}

// Destiny.Definitions.DestinyItemSocketEntryDefinition
//
// The definition information for a specific socket on an item. This will determine how the socket
// behaves in-game.
type ItemSocketEntryDefinition struct {
	// {
	//   "description": "The definition information for a specific socket on an item. This will determine how the socket behaves in-game.",
	//   "properties": {
	//     "defaultVisible": {
	//       "description": "If true, then this socket is visible in the item's \"default\" state. If you have an instance, you should always check the runtime state, as that can override this visibility setting: but if you're looking at the item on a conceptual level, this property can be useful for hiding data such as legacy sockets - which remain defined on items for infrastructure purposes, but can be confusing for users to see.",
	//       "type": "boolean"
	//     },
	//     "hidePerksInItemTooltip": {
	//       "description": "If this is true, the perks provided by this socket shouldn't be shown in the item's tooltip. This might be useful if it's providing a hidden bonus, or if the bonus is less important than other benefits on the item.",
	//       "type": "boolean"
	//     },
	//     "plugSources": {
	//       "description": "Indicates where you should go to get plugs for this socket. This will affect how you populate your UI, as well as what plugs are valid for this socket. It's an alternative to having to check for the existence of certain properties (reusablePlugItems for example) to infer where plugs should come from.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.SocketPlugSources"
	//       }
	//     },
	//     "preventInitializationOnVendorPurchase": {
	//       "description": "If this is true, then the socket will not be initialized with a plug if the item is purchased from a Vendor.\r\nRemember that Vendors are much more than conceptual vendors: they include \"Collection Kiosks\" and other entities. See DestinyVendorDefinition for more information.",
	//       "type": "boolean"
	//     },
	//     "randomizedPlugSetHash": {
	//       "description": "This field replaces \"randomizedPlugItems\" as of Shadowkeep launch. If a socket has randomized plugs, this is a pointer to the set of plugs that could be used, as defined in DestinyPlugSetDefinition.\r\n If null, the item has no randomized plugs.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinyPlugSetDefinition"
	//       }
	//     },
	//     "reusablePlugItems": {
	//       "description": "This is a list of pre-determined plugs that can *always* be plugged into this socket, without the character having the plug in their inventory.\r\nIf this list is populated, you will not be allowed to plug an arbitrary item in the socket: you will only be able to choose from one of these reusable plugs.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemSocketEntryPlugItemDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "reusablePlugSetHash": {
	//       "description": "If this socket's plugs come from a reusable DestinyPlugSetDefinition, this is the identifier for that set. We added this concept to reduce some major duplication that's going to come from sockets as replacements for what was once implemented as large sets of items and kiosks (like Emotes).\r\n As of Shadowkeep, these will come up much more frequently and be driven by game content rather than custom curation.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinyPlugSetDefinition"
	//       }
	//     },
	//     "singleInitialItemHash": {
	//       "description": "If a valid hash, this is the hash identifier for the DestinyInventoryItemDefinition representing the Plug that will be initially inserted into the item on item creation. Otherwise, this Socket will either start without a plug inserted, or will have one randomly inserted.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "socketTypeHash": {
	//       "description": "All sockets have a type, and this is the hash identifier for this particular type. Use it to look up the DestinySocketTypeDefinition: read there for more information on how socket types affect the behavior of the socket.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinySocketTypeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// If true, then this socket is visible in the item's "default" state. If you have an instance, you
	// should always check the runtime state, as that can override this visibility setting: but if you're
	// looking at the item on a conceptual level, this property can be useful for hiding data such as
	// legacy sockets - which remain defined on items for infrastructure purposes, but can be confusing for
	// users to see.
	DefaultVisible bool `json:"defaultVisible"`

	// If this is true, the perks provided by this socket shouldn't be shown in the item's tooltip. This
	// might be useful if it's providing a hidden bonus, or if the bonus is less important than other
	// benefits on the item.
	HidePerksInItemTooltip bool `json:"hidePerksInItemTooltip"`

	// Indicates where you should go to get plugs for this socket. This will affect how you populate your
	// UI, as well as what plugs are valid for this socket. It's an alternative to having to check for the
	// existence of certain properties (reusablePlugItems for example) to infer where plugs should come
	// from.
	PlugSources BitmaskSet[SocketPlugSources] `json:"plugSources"`

	// If this is true, then the socket will not be initialized with a plug if the item is purchased from a
	// Vendor.
	// Remember that Vendors are much more than conceptual vendors: they include "Collection Kiosks" and
	// other entities. See DestinyVendorDefinition for more information.
	PreventInitializationOnVendorPurchase bool `json:"preventInitializationOnVendorPurchase"`

	// This field replaces "randomizedPlugItems" as of Shadowkeep launch. If a socket has randomized plugs,
	// this is a pointer to the set of plugs that could be used, as defined in DestinyPlugSetDefinition.
	//
	//	If null, the item has no randomized plugs.
	RandomizedPlugSetHash Nullable[Hash[PlugSetDefinition]] `json:"randomizedPlugSetHash,omitempty"`

	// This is a list of pre-determined plugs that can *always* be plugged into this socket, without the
	// character having the plug in their inventory.
	// If this list is populated, you will not be allowed to plug an arbitrary item in the socket: you will
	// only be able to choose from one of these reusable plugs.
	ReusablePlugItems []ItemSocketEntryPlugItemDefinition `json:"reusablePlugItems"`

	// If this socket's plugs come from a reusable DestinyPlugSetDefinition, this is the identifier for
	// that set. We added this concept to reduce some major duplication that's going to come from sockets
	// as replacements for what was once implemented as large sets of items and kiosks (like Emotes).
	//
	//	As of Shadowkeep, these will come up much more frequently and be driven by game content rather than
	//
	// custom curation.
	ReusablePlugSetHash Nullable[Hash[PlugSetDefinition]] `json:"reusablePlugSetHash,omitempty"`

	// If a valid hash, this is the hash identifier for the DestinyInventoryItemDefinition representing the
	// Plug that will be initially inserted into the item on item creation. Otherwise, this Socket will
	// either start without a plug inserted, or will have one randomly inserted.
	SingleInitialItemHash Hash[InventoryItemDefinition] `json:"singleInitialItemHash"`

	// All sockets have a type, and this is the hash identifier for this particular type. Use it to look up
	// the DestinySocketTypeDefinition: read there for more information on how socket types affect the
	// behavior of the socket.
	SocketTypeHash Hash[SocketTypeDefinition] `json:"socketTypeHash"`
}

// Destiny.Definitions.DestinyItemSocketEntryPlugItemDefinition
//
// The definition of a known, reusable plug that can be applied to a socket.
type ItemSocketEntryPlugItemDefinition struct {
	// {
	//   "description": "The definition of a known, reusable plug that can be applied to a socket.",
	//   "properties": {
	//     "plugItemHash": {
	//       "description": "The hash identifier of a DestinyInventoryItemDefinition representing the plug that can be inserted.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash identifier of a DestinyInventoryItemDefinition representing the plug that can be inserted.
	PlugItemHash Hash[InventoryItemDefinition] `json:"plugItemHash"`
}

// Destiny.Definitions.DestinyItemSocketEntryPlugItemRandomizedDefinition
type ItemSocketEntryPlugItemRandomizedDefinition struct {
	// {
	//   "properties": {
	//     "craftingRequirements": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.DestinyPlugItemCraftingRequirements"
	//     },
	//     "currentlyCanRoll": {
	//       "description": "Indicates if the plug can be rolled on the current version of the item. For example, older versions of weapons may have plug rolls that are no longer possible on the current versions.",
	//       "type": "boolean"
	//     },
	//     "plugItemHash": {
	//       "description": "The hash identifier of a DestinyInventoryItemDefinition representing the plug that can be inserted.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	CraftingRequirements PlugItemCraftingRequirements `json:"craftingRequirements"`

	// Indicates if the plug can be rolled on the current version of the item. For example, older versions
	// of weapons may have plug rolls that are no longer possible on the current versions.
	CurrentlyCanRoll bool `json:"currentlyCanRoll"`

	// The hash identifier of a DestinyInventoryItemDefinition representing the plug that can be inserted.
	PlugItemHash Hash[InventoryItemDefinition] `json:"plugItemHash"`
}

// Destiny.Definitions.DestinyItemSourceBlockDefinition
//
// Data about an item's "sources": ways that the item can be obtained.
type ItemSourceBlockDefinition struct {
	// {
	//   "description": "Data about an item's \"sources\": ways that the item can be obtained.",
	//   "properties": {
	//     "exclusive": {
	//       "description": "If we found that this item is exclusive to a specific platform, this will be set to the BungieMembershipType enumeration that matches that platform.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "sourceHashes": {
	//       "description": "The list of hash identifiers for Reward Sources that hint where the item can be found (DestinyRewardSourceDefinition).",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyRewardSourceDefinition"
	//       }
	//     },
	//     "sources": {
	//       "description": "A collection of details about the stats that were computed for the ways we found that the item could be spawned.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sources.DestinyItemSourceDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "vendorSources": {
	//       "description": "A denormalized reference back to vendors that potentially sell this item.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemVendorSourceReference"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// If we found that this item is exclusive to a specific platform, this will be set to the
	// BungieMembershipType enumeration that matches that platform.
	Exclusive BungieMembershipType `json:"exclusive"`

	// The list of hash identifiers for Reward Sources that hint where the item can be found
	// (DestinyRewardSourceDefinition).
	SourceHashes []uint32 `json:"sourceHashes"`

	// A collection of details about the stats that were computed for the ways we found that the item could
	// be spawned.
	Sources []ItemSourceDefinition `json:"sources"`

	// A denormalized reference back to vendors that potentially sell this item.
	VendorSources []ItemVendorSourceReference `json:"vendorSources"`
}

// Destiny.Definitions.DestinyItemStatBlockDefinition
//
// Information about the item's calculated stats, with as much data as we can find for the stats
// without having an actual instance of the item.
// Note that this means the entire concept of providing these stats is fundamentally insufficient: we
// cannot predict with 100% accuracy the conditions under which an item can spawn, so we use various
// heuristics to attempt to simulate the conditions as accurately as possible. Actual stats for items
// in-game can and will vary, but these should at least be useful base points for comparison and
// display.
// It is also worth noting that some stats, like Magazine size, have further calculations performed on
// them by scripts in-game and on the game servers that BNet does not have access to. We cannot know
// how those stats are further transformed, and thus some stats will be inaccurate even on instances of
// items in BNet vs. how they appear in-game. This is a known limitation of our item statistics,
// without any planned fix.
type ItemStatBlockDefinition struct {
	// {
	//   "description": "Information about the item's calculated stats, with as much data as we can find for the stats without having an actual instance of the item.\r\nNote that this means the entire concept of providing these stats is fundamentally insufficient: we cannot predict with 100% accuracy the conditions under which an item can spawn, so we use various heuristics to attempt to simulate the conditions as accurately as possible. Actual stats for items in-game can and will vary, but these should at least be useful base points for comparison and display.\r\nIt is also worth noting that some stats, like Magazine size, have further calculations performed on them by scripts in-game and on the game servers that BNet does not have access to. We cannot know how those stats are further transformed, and thus some stats will be inaccurate even on instances of items in BNet vs. how they appear in-game. This is a known limitation of our item statistics, without any planned fix.",
	//   "properties": {
	//     "disablePrimaryStatDisplay": {
	//       "description": "If true, the game won't show the \"primary\" stat on this item when you inspect it.\r\nNOTE: This is being manually mapped, because I happen to want it in a block that isn't going to directly create this derivative block.",
	//       "type": "boolean"
	//     },
	//     "hasDisplayableStats": {
	//       "description": "A quick and lazy way to determine whether any stat other than the \"primary\" stat is actually visible on the item. Items often have stats that we return in case people find them useful, but they're not part of the \"Stat Group\" and thus we wouldn't display them in our UI. If this is False, then we're not going to display any of these stats other than the primary one.",
	//       "type": "boolean"
	//     },
	//     "primaryBaseStatHash": {
	//       "description": "This stat is determined to be the \"primary\" stat, and can be looked up in the stats or any other stat collection related to the item.\r\nUse this hash to look up the stat's value using DestinyInventoryItemDefinition.stats.stats, and the renderable data for the primary stat in the related DestinyStatDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyStatDefinition"
	//       }
	//     },
	//     "statGroupHash": {
	//       "description": "If the item's stats are meant to be modified by a DestinyStatGroupDefinition, this will be the identifier for that definition.\r\nIf you are using live data or precomputed stats data on the DestinyInventoryItemDefinition.stats.stats property, you don't have to worry about statGroupHash and how it alters stats: the already altered stats are provided to you. But if you want to see how the sausage gets made, or perform computations yourself, this is valuable information.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyStatGroupDefinition"
	//       }
	//     },
	//     "stats": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemStatDefinition"
	//       },
	//       "description": "If you are looking for precomputed values for the stats on a weapon, this is where they are stored. Technically these are the \"Display\" stat values. Please see DestinyStatsDefinition for what Display Stat Values means, it's a very long story... but essentially these are the closest values BNet can get to the item stats that you see in-game.\r\nThese stats are keyed by the DestinyStatDefinition's hash identifier for the stat that's found on the item.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyStatDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// If true, the game won't show the "primary" stat on this item when you inspect it.
	// NOTE: This is being manually mapped, because I happen to want it in a block that isn't going to
	// directly create this derivative block.
	DisablePrimaryStatDisplay bool `json:"disablePrimaryStatDisplay"`

	// A quick and lazy way to determine whether any stat other than the "primary" stat is actually visible
	// on the item. Items often have stats that we return in case people find them useful, but they're not
	// part of the "Stat Group" and thus we wouldn't display them in our UI. If this is False, then we're
	// not going to display any of these stats other than the primary one.
	HasDisplayableStats bool `json:"hasDisplayableStats"`

	// This stat is determined to be the "primary" stat, and can be looked up in the stats or any other
	// stat collection related to the item.
	// Use this hash to look up the stat's value using DestinyInventoryItemDefinition.stats.stats, and the
	// renderable data for the primary stat in the related DestinyStatDefinition.
	PrimaryBaseStatHash Hash[StatDefinition] `json:"primaryBaseStatHash"`

	// If the item's stats are meant to be modified by a DestinyStatGroupDefinition, this will be the
	// identifier for that definition.
	// If you are using live data or precomputed stats data on the
	// DestinyInventoryItemDefinition.stats.stats property, you don't have to worry about statGroupHash and
	// how it alters stats: the already altered stats are provided to you. But if you want to see how the
	// sausage gets made, or perform computations yourself, this is valuable information.
	StatGroupHash Nullable[Hash[StatGroupDefinition]] `json:"statGroupHash,omitempty"`

	// If you are looking for precomputed values for the stats on a weapon, this is where they are stored.
	// Technically these are the "Display" stat values. Please see DestinyStatsDefinition for what Display
	// Stat Values means, it's a very long story... but essentially these are the closest values BNet can
	// get to the item stats that you see in-game.
	// These stats are keyed by the DestinyStatDefinition's hash identifier for the stat that's found on
	// the item.
	Stats map[Hash[StatDefinition]]InventoryItemStatDefinition `json:"stats"`
}

// Destiny.Definitions.DestinyItemSummaryBlockDefinition
//
// This appears to be information used when rendering rewards. We don't currently use it on BNet.
type ItemSummaryBlockDefinition struct {
	// {
	//   "description": "This appears to be information used when rendering rewards. We don't currently use it on BNet.",
	//   "properties": {
	//     "sortPriority": {
	//       "description": "Apparently when rendering an item in a reward, this should be used as a sort priority. We're not doing it presently.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// Apparently when rendering an item in a reward, this should be used as a sort priority. We're not
	// doing it presently.
	SortPriority int32 `json:"sortPriority"`
}

// Destiny.Definitions.DestinyItemTalentGridBlockDefinition
//
// This defines information that can only come from a talent grid on an item. Items mostly have
// negligible talent grid data these days, but instanced items still retain grids as a source for some
// of this common information.
// Builds/Subclasses are the only items left that still have talent grids with meaningful Nodes.
type ItemTalentGridBlockDefinition struct {
	// {
	//   "description": "This defines information that can only come from a talent grid on an item. Items mostly have negligible talent grid data these days, but instanced items still retain grids as a source for some of this common information.\r\nBuilds/Subclasses are the only items left that still have talent grids with meaningful Nodes.",
	//   "properties": {
	//     "buildName": {
	//       "description": "A shortcut string identifier for the \"build\" in question, if this talent grid has an associated build. Doesn't map to anything we can expose at the moment.",
	//       "type": "string"
	//     },
	//     "hudDamageType": {
	//       "description": "If the talent grid implies a damage type, this is the enum value for that damage type.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DamageType"
	//       }
	//     },
	//     "hudIcon": {
	//       "description": "If the talent grid has a special icon that's shown in the game UI (like builds, funny that), this is the identifier for that icon. Sadly, we don't actually get that icon right now. I'll be looking to replace this with a path to the actual icon itself.",
	//       "type": "string"
	//     },
	//     "itemDetailString": {
	//       "description": "This is meant to be a subtitle for looking at the talent grid. In practice, somewhat frustratingly, this always merely says the localized word for \"Details\". Great. Maybe it'll have more if talent grids ever get used for more than builds and subclasses again.",
	//       "type": "string"
	//     },
	//     "talentGridHash": {
	//       "description": "The hash identifier of the DestinyTalentGridDefinition attached to this item.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyTalentGridDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// A shortcut string identifier for the "build" in question, if this talent grid has an associated
	// build. Doesn't map to anything we can expose at the moment.
	BuildName string `json:"buildName"`

	// If the talent grid implies a damage type, this is the enum value for that damage type.
	HudDamageType DamageType `json:"hudDamageType"`

	// If the talent grid has a special icon that's shown in the game UI (like builds, funny that), this is
	// the identifier for that icon. Sadly, we don't actually get that icon right now. I'll be looking to
	// replace this with a path to the actual icon itself.
	HudIcon string `json:"hudIcon"`

	// This is meant to be a subtitle for looking at the talent grid. In practice, somewhat frustratingly,
	// this always merely says the localized word for "Details". Great. Maybe it'll have more if talent
	// grids ever get used for more than builds and subclasses again.
	ItemDetailString string `json:"itemDetailString"`

	// The hash identifier of the DestinyTalentGridDefinition attached to this item.
	TalentGridHash Hash[TalentGridDefinition] `json:"talentGridHash"`
}

// Destiny.Definitions.DestinyItemTooltipNotification
type ItemTooltipNotification struct {
	// {
	//   "properties": {
	//     "displayString": {
	//       "type": "string"
	//     },
	//     "displayStyle": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	DisplayString string `json:"displayString"`

	DisplayStyle string `json:"displayStyle"`
}

// Destiny.Definitions.DestinyItemTranslationBlockDefinition
//
// This Block defines the rendering data associated with the item, if any.
type ItemTranslationBlockDefinition struct {
	// {
	//   "description": "This Block defines the rendering data associated with the item, if any.",
	//   "properties": {
	//     "arrangements": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyGearArtArrangementReference"
	//       },
	//       "type": "array"
	//     },
	//     "customDyes": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DyeReference"
	//       },
	//       "type": "array"
	//     },
	//     "defaultDyes": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DyeReference"
	//       },
	//       "type": "array"
	//     },
	//     "hasGeometry": {
	//       "type": "boolean"
	//     },
	//     "lockedDyes": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DyeReference"
	//       },
	//       "type": "array"
	//     },
	//     "weaponPatternHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinySandboxPatternDefinition"
	//       }
	//     },
	//     "weaponPatternIdentifier": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Arrangements []GearArtArrangementReference `json:"arrangements"`

	CustomDyes []DyeReference `json:"customDyes"`

	DefaultDyes []DyeReference `json:"defaultDyes"`

	HasGeometry bool `json:"hasGeometry"`

	LockedDyes []DyeReference `json:"lockedDyes"`

	WeaponPatternHash Hash[SandboxPatternDefinition] `json:"weaponPatternHash"`

	WeaponPatternIdentifier string `json:"weaponPatternIdentifier"`
}

// Destiny.Definitions.DestinyItemValueBlockDefinition
//
// This defines an item's "Value". Unfortunately, this appears to be used in different ways depending
// on the way that the item itself is used.
// For items being sold at a Vendor, this is the default "sale price" of the item. These days, the
// vendor itself almost always sets the price, but it still possible for the price to fall back to this
// value. For quests, it is a preview of rewards you can gain by completing the quest. For dummy items,
// if the itemValue refers to an Emblem, it is the emblem that should be shown as the reward. (jeez
// louise)
// It will likely be used in a number of other ways in the future, it appears to be a bucket where they
// put arbitrary items and quantities into the item.
type ItemValueBlockDefinition struct {
	// {
	//   "description": "This defines an item's \"Value\". Unfortunately, this appears to be used in different ways depending on the way that the item itself is used.\r\nFor items being sold at a Vendor, this is the default \"sale price\" of the item. These days, the vendor itself almost always sets the price, but it still possible for the price to fall back to this value. For quests, it is a preview of rewards you can gain by completing the quest. For dummy items, if the itemValue refers to an Emblem, it is the emblem that should be shown as the reward. (jeez louise)\r\nIt will likely be used in a number of other ways in the future, it appears to be a bucket where they put arbitrary items and quantities into the item.",
	//   "properties": {
	//     "itemValue": {
	//       "description": "References to the items that make up this item's \"value\", and the quantity.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemQuantity"
	//       },
	//       "type": "array"
	//     },
	//     "valueDescription": {
	//       "description": "If there's a localized text description of the value provided, this will be said description.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// References to the items that make up this item's "value", and the quantity.
	ItemValue []ItemQuantity `json:"itemValue"`

	// If there's a localized text description of the value provided, this will be said description.
	ValueDescription string `json:"valueDescription"`
}

// Destiny.Definitions.DestinyItemVendorSourceReference
//
// Represents that a vendor could sell this item, and provides a quick link to that vendor and sale
// item.
//
//	Note that we do not and cannot make a guarantee that the vendor will ever *actually* sell this
//
// item, only that the Vendor has a definition that indicates it *could* be sold.
//
//	Note also that a vendor may sell the same item in multiple "ways", which means there may be
//
// multiple vendorItemIndexes for a single Vendor hash.
type ItemVendorSourceReference struct {
	// {
	//   "description": "Represents that a vendor could sell this item, and provides a quick link to that vendor and sale item.\r\n Note that we do not and cannot make a guarantee that the vendor will ever *actually* sell this item, only that the Vendor has a definition that indicates it *could* be sold.\r\n Note also that a vendor may sell the same item in multiple \"ways\", which means there may be multiple vendorItemIndexes for a single Vendor hash.",
	//   "properties": {
	//     "vendorHash": {
	//       "description": "The identifier for the vendor that may sell this item.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     },
	//     "vendorItemIndexes": {
	//       "description": "The Vendor sale item indexes that represent the sale information for this item. The same vendor may sell an item in multiple \"ways\", hence why this is a list. (for instance, a weapon may be \"sold\" as a reward in a quest, for Glimmer, and for Masterwork Cores: each of those ways would be represented by a different vendor sale item with a different index)",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The identifier for the vendor that may sell this item.
	VendorHash Hash[VendorDefinition] `json:"vendorHash"`

	// The Vendor sale item indexes that represent the sale information for this item. The same vendor may
	// sell an item in multiple "ways", hence why this is a list. (for instance, a weapon may be "sold" as
	// a reward in a quest, for Glimmer, and for Masterwork Cores: each of those ways would be represented
	// by a different vendor sale item with a different index)
	VendorItemIndexes []int32 `json:"vendorItemIndexes"`
}

// Destiny.Definitions.DestinyItemVersionDefinition
//
// The version definition currently just holds a reference to the power cap.
type ItemVersionDefinition struct {
	// {
	//   "description": "The version definition currently just holds a reference to the power cap.",
	//   "properties": {
	//     "powerCapHash": {
	//       "description": "A reference to the power cap for this item version.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.PowerCaps.DestinyPowerCapDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// A reference to the power cap for this item version.
	PowerCapHash Hash[PowerCapDefinition] `json:"powerCapHash"`
}

// Destiny.Definitions.DestinyLocationDefinition
//
// A "Location" is a sort of shortcut for referring to a specific combination of Activity, Destination,
// Place, and even Bubble or NavPoint within a space.
// Most of this data isn't intrinsically useful to us, but Objectives refer to locations, and through
// that we can at least infer the Activity, Destination, and Place being referred to by the Objective.
type LocationDefinition struct {
	// {
	//   "description": "A \"Location\" is a sort of shortcut for referring to a specific combination of Activity, Destination, Place, and even Bubble or NavPoint within a space.\r\nMost of this data isn't intrinsically useful to us, but Objectives refer to locations, and through that we can at least infer the Activity, Destination, and Place being referred to by the Objective.",
	//   "properties": {
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "locationReleases": {
	//       "description": "A Location may refer to different specific spots in the world based on the world's current state. This is a list of those potential spots, and the data we can use at runtime to determine which one of the spots is the currently valid one.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyLocationReleaseDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "vendorHash": {
	//       "description": "If the location has a Vendor on it, this is the hash identifier for that Vendor. Look them up with DestinyVendorDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Locations"
	// }

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// A Location may refer to different specific spots in the world based on the world's current state.
	// This is a list of those potential spots, and the data we can use at runtime to determine which one
	// of the spots is the currently valid one.
	LocationReleases []LocationReleaseDefinition `json:"locationReleases"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// If the location has a Vendor on it, this is the hash identifier for that Vendor. Look them up with
	// DestinyVendorDefinition.
	VendorHash Hash[VendorDefinition] `json:"vendorHash"`
}

// Destiny.Definitions.DestinyLocationReleaseDefinition
//
// A specific "spot" referred to by a location. Only one of these can be active at a time for a given
// Location.
type LocationReleaseDefinition struct {
	// {
	//   "description": "A specific \"spot\" referred to by a location. Only one of these can be active at a time for a given Location.",
	//   "properties": {
	//     "activityBubbleName": {
	//       "description": "The Activity Bubble within the Destination. Look this up in the DestinyDestinationDefinition's bubbles and bubbleSettings properties.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "activityGraphHash": {
	//       "description": "The Activity Graph being pointed to by this location.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "activityGraphNodeHash": {
	//       "description": "The Activity Graph Node being pointed to by this location. (Remember that Activity Graph Node hashes are only unique within an Activity Graph: so use the combination to find the node being spoken of)",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "activityHash": {
	//       "description": "The Activity being pointed to by this location.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "activityPathBundle": {
	//       "description": "If we had map information, this would tell us something cool about the path this location wants you to take. I wish we had map information.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "activityPathDestination": {
	//       "description": "If we had map information, this would tell us about path information related to destination on the map. Sad. Maybe you can do something cool with it. Go to town man.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "destinationHash": {
	//       "description": "The Destination being pointed to by this location.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyDestinationDefinition"
	//       }
	//     },
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "Sadly, these don't appear to be populated anymore (ever?)",
	//       "type": "object"
	//     },
	//     "largeTransparentIcon": {
	//       "type": "string"
	//     },
	//     "mapIcon": {
	//       "type": "string"
	//     },
	//     "navPointType": {
	//       "description": "The type of Nav Point that this represents. See the enumeration for more info.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyActivityNavPointType"
	//       }
	//     },
	//     "smallTransparentIcon": {
	//       "type": "string"
	//     },
	//     "spawnPoint": {
	//       "description": "If we had map information, this spawnPoint would be interesting. But sadly, we don't have that info.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "worldPosition": {
	//       "description": "Looks like it should be the position on the map, but sadly it does not look populated... yet?",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The Activity Bubble within the Destination. Look this up in the DestinyDestinationDefinition's
	// bubbles and bubbleSettings properties.
	ActivityBubbleName uint32 `json:"activityBubbleName"`

	// The Activity Graph being pointed to by this location.
	ActivityGraphHash uint32 `json:"activityGraphHash"`

	// The Activity Graph Node being pointed to by this location. (Remember that Activity Graph Node hashes
	// are only unique within an Activity Graph: so use the combination to find the node being spoken of)
	ActivityGraphNodeHash uint32 `json:"activityGraphNodeHash"`

	// The Activity being pointed to by this location.
	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`

	// If we had map information, this would tell us something cool about the path this location wants you
	// to take. I wish we had map information.
	ActivityPathBundle uint32 `json:"activityPathBundle"`

	// If we had map information, this would tell us about path information related to destination on the
	// map. Sad. Maybe you can do something cool with it. Go to town man.
	ActivityPathDestination uint32 `json:"activityPathDestination"`

	// The Destination being pointed to by this location.
	DestinationHash Hash[DestinationDefinition] `json:"destinationHash"`

	// Sadly, these don't appear to be populated anymore (ever?)
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	LargeTransparentIcon string `json:"largeTransparentIcon"`

	MapIcon string `json:"mapIcon"`

	// The type of Nav Point that this represents. See the enumeration for more info.
	NavPointType ActivityNavPointType `json:"navPointType"`

	SmallTransparentIcon string `json:"smallTransparentIcon"`

	// If we had map information, this spawnPoint would be interesting. But sadly, we don't have that info.
	SpawnPoint uint32 `json:"spawnPoint"`

	// Looks like it should be the position on the map, but sadly it does not look populated... yet?
	WorldPosition []int32 `json:"worldPosition"`
}

// Destiny.Definitions.DestinyMaterialRequirement
//
// Many actions relating to items require you to expend materials: - Activating a talent node -
// Inserting a plug into a socket The items will refer to material requirements by a
// materialRequirementsHash in these cases, and this is the definition for those requirements in terms
// of the item required, how much of it is required and other interesting info. This is one of the
// rare/strange times where a single contract class is used both in definitions *and* in live data
// response contracts. I'm not sure yet whether I regret that.
type MaterialRequirement struct {
	// {
	//   "description": "Many actions relating to items require you to expend materials: - Activating a talent node - Inserting a plug into a socket The items will refer to material requirements by a materialRequirementsHash in these cases, and this is the definition for those requirements in terms of the item required, how much of it is required and other interesting info. This is one of the rare/strange times where a single contract class is used both in definitions *and* in live data response contracts. I'm not sure yet whether I regret that.",
	//   "properties": {
	//     "count": {
	//       "description": "The amount of the material required.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "countIsConstant": {
	//       "description": "If true, the material requirement count value is constant. Since The Witch Queen expansion, some material requirement counts can be dynamic and will need to be returned with an API call.",
	//       "type": "boolean"
	//     },
	//     "deleteOnAction": {
	//       "description": "If True, the material will be removed from the character's inventory when the action is performed.",
	//       "type": "boolean"
	//     },
	//     "hasVirtualStackSize": {
	//       "description": "If true, this material requirement references a virtual item stack size value. You can get that value from a corresponding DestinyMaterialRequirementSetState.",
	//       "type": "boolean"
	//     },
	//     "itemHash": {
	//       "description": "The hash identifier of the material required. Use it to look up the material's DestinyInventoryItemDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "omitFromRequirements": {
	//       "description": "If True, this requirement is \"silent\": don't bother showing it in a material requirements display. I mean, I'm not your mom: I'm not going to tell you you *can't* show it. But we won't show it in our UI.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	// The amount of the material required.
	Count int32 `json:"count"`

	// If true, the material requirement count value is constant. Since The Witch Queen expansion, some
	// material requirement counts can be dynamic and will need to be returned with an API call.
	CountIsConstant bool `json:"countIsConstant"`

	// If True, the material will be removed from the character's inventory when the action is performed.
	DeleteOnAction bool `json:"deleteOnAction"`

	// If true, this material requirement references a virtual item stack size value. You can get that
	// value from a corresponding DestinyMaterialRequirementSetState.
	HasVirtualStackSize bool `json:"hasVirtualStackSize"`

	// The hash identifier of the material required. Use it to look up the material's
	// DestinyInventoryItemDefinition.
	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`

	// If True, this requirement is "silent": don't bother showing it in a material requirements display. I
	// mean, I'm not your mom: I'm not going to tell you you *can't* show it. But we won't show it in our
	// UI.
	OmitFromRequirements bool `json:"omitFromRequirements"`
}

// Destiny.Definitions.DestinyMaterialRequirementSetDefinition
//
// Represent a set of material requirements: Items that either need to be owned or need to be consumed
// in order to perform an action.
// A variety of other entities refer to these as gatekeepers and payments for actions that can be
// performed in game.
type MaterialRequirementSetDefinition struct {
	// {
	//   "description": "Represent a set of material requirements: Items that either need to be owned or need to be consumed in order to perform an action.\r\nA variety of other entities refer to these as gatekeepers and payments for actions that can be performed in game.",
	//   "properties": {
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "materials": {
	//       "description": "The list of all materials that are required.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyMaterialRequirement"
	//       },
	//       "type": "array"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "MaterialRequirementSets"
	// }

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// The list of all materials that are required.
	Materials []MaterialRequirement `json:"materials"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyMedalTierDefinition
//
// An artificial construct of our own creation, to try and put some order on top of Medals and keep
// them from being one giant, unmanageable and unsorted blob of stats.
// Unfortunately, we haven't had time to do this evaluation yet in Destiny 2, so we're short on Medal
// Tiers. This will hopefully be updated over time, if Medals continue to exist.
type MedalTierDefinition struct {
	// {
	//   "description": "An artificial construct of our own creation, to try and put some order on top of Medals and keep them from being one giant, unmanageable and unsorted blob of stats.\r\nUnfortunately, we haven't had time to do this evaluation yet in Destiny 2, so we're short on Medal Tiers. This will hopefully be updated over time, if Medals continue to exist.",
	//   "properties": {
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "order": {
	//       "description": "If you're rendering medals by tier, render them in this order (ascending)",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "tierName": {
	//       "description": "The name of the tier.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "MedalTiers"
	// }

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If you're rendering medals by tier, render them in this order (ascending)
	Order int32 `json:"order"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// The name of the tier.
	TierName string `json:"tierName"`
}

// Destiny.Definitions.DestinyNodeActivationRequirement
//
// Talent nodes have requirements that must be met before they can be activated.
// This describes the material costs, the Level of the Talent Grid's progression required, and other
// conditional information that limits whether a talent node can be activated.
type NodeActivationRequirement struct {
	// {
	//   "description": "Talent nodes have requirements that must be met before they can be activated.\r\nThis describes the material costs, the Level of the Talent Grid's progression required, and other conditional information that limits whether a talent node can be activated.",
	//   "properties": {
	//     "gridLevel": {
	//       "description": "The Progression level on the Talent Grid required to activate this node.\r\nSee DestinyTalentGridDefinition.progressionHash for the related Progression, and read DestinyProgressionDefinition's documentation to learn more about Progressions.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "materialRequirementHashes": {
	//       "description": "The list of hash identifiers for material requirement sets: materials that are required for the node to be activated. See DestinyMaterialRequirementSetDefinition for more information about material requirements.\r\nIn this case, only a single DestinyMaterialRequirementSetDefinition will be chosen from this list, and we won't know which one will be chosen until an instance of the item is created.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyMaterialRequirementSetDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The Progression level on the Talent Grid required to activate this node.
	// See DestinyTalentGridDefinition.progressionHash for the related Progression, and read
	// DestinyProgressionDefinition's documentation to learn more about Progressions.
	GridLevel int32 `json:"gridLevel"`

	// The list of hash identifiers for material requirement sets: materials that are required for the node
	// to be activated. See DestinyMaterialRequirementSetDefinition for more information about material
	// requirements.
	// In this case, only a single DestinyMaterialRequirementSetDefinition will be chosen from this list,
	// and we won't know which one will be chosen until an instance of the item is created.
	MaterialRequirementHashes []uint32 `json:"materialRequirementHashes"`
}

// Destiny.Definitions.DestinyNodeSocketReplaceResponse
//
// This is a bit of an odd duck. Apparently, if talent nodes steps have this data, the game will go
// through on step activation and alter the first Socket it finds on the item that has a type matching
// the given socket type, inserting the indicated plug item.
type NodeSocketReplaceResponse struct {
	// {
	//   "description": "This is a bit of an odd duck. Apparently, if talent nodes steps have this data, the game will go through on step activation and alter the first Socket it finds on the item that has a type matching the given socket type, inserting the indicated plug item.",
	//   "properties": {
	//     "plugItemHash": {
	//       "description": "The hash identifier of the plug item that will be inserted into the socket found.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "socketTypeHash": {
	//       "description": "The hash identifier of the socket type to find amidst the item's sockets (the item to which this talent grid is attached). See DestinyInventoryItemDefinition.sockets.socketEntries to find the socket type of sockets on the item in question.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinySocketTypeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash identifier of the plug item that will be inserted into the socket found.
	PlugItemHash Hash[InventoryItemDefinition] `json:"plugItemHash"`

	// The hash identifier of the socket type to find amidst the item's sockets (the item to which this
	// talent grid is attached). See DestinyInventoryItemDefinition.sockets.socketEntries to find the
	// socket type of sockets on the item in question.
	SocketTypeHash Hash[SocketTypeDefinition] `json:"socketTypeHash"`
}

// Destiny.Definitions.DestinyNodeStepDefinition
//
// This defines the properties of a "Talent Node Step". When you see a talent node in game, the actual
// visible properties that you see (its icon, description, the perks and stats it provides) are not
// provided by the Node itself, but rather by the currently active Step on the node.
// When a Talent Node is activated, the currently active step's benefits are conferred upon the item
// and character.
// The currently active step on talent nodes are determined when an item is first instantiated.
// Sometimes it is random, sometimes it is more deterministic (particularly when a node has only a
// single step).
// Note that, when dealing with Talent Node Steps, you must ensure that you have the latest version of
// content. stepIndex and nodeStepHash - two ways of identifying the step within a node - are both
// content version dependent, and thus are subject to change between content updates.
type NodeStepDefinition struct {
	// {
	//   "description": "This defines the properties of a \"Talent Node Step\". When you see a talent node in game, the actual visible properties that you see (its icon, description, the perks and stats it provides) are not provided by the Node itself, but rather by the currently active Step on the node.\r\nWhen a Talent Node is activated, the currently active step's benefits are conferred upon the item and character.\r\nThe currently active step on talent nodes are determined when an item is first instantiated. Sometimes it is random, sometimes it is more deterministic (particularly when a node has only a single step).\r\nNote that, when dealing with Talent Node Steps, you must ensure that you have the latest version of content. stepIndex and nodeStepHash - two ways of identifying the step within a node - are both content version dependent, and thus are subject to change between content updates.",
	//   "properties": {
	//     "activationRequirement": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyNodeActivationRequirement"
	//         }
	//       ],
	//       "description": "If the step has requirements for activation (they almost always do, if nothing else than for the Talent Grid's Progression to have reached a certain level), they will be defined here.",
	//       "type": "object"
	//     },
	//     "affectsLevel": {
	//       "description": "If true, this step can affect the level of the item. See DestinyInventoryItemDefintion for more information about item levels and their effect on stats.",
	//       "type": "boolean"
	//     },
	//     "affectsQuality": {
	//       "description": "If this is true, the step affects the item's Quality in some way. See DestinyInventoryItemDefinition for more information about the meaning of Quality. I already made a joke about Zen and the Art of Motorcycle Maintenance elsewhere in the documentation, so I will avoid doing it again. Oops too late",
	//       "type": "boolean"
	//     },
	//     "canActivateNextStep": {
	//       "description": "There was a time when talent nodes could be activated multiple times, and the effects of subsequent Steps would be compounded on each other, essentially \"upgrading\" the node. We have moved away from this, but theoretically the capability still exists.\r\nI continue to return this in case it is used in the future: if true and this step is the current step in the node, you are allowed to activate the node a second time to receive the benefits of the next step in the node, which will then become the active step.",
	//       "type": "boolean"
	//     },
	//     "damageType": {
	//       "description": "An enum representing a damage type granted by activating this step, if any.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DamageType"
	//       }
	//     },
	//     "damageTypeHash": {
	//       "description": "If the step provides a damage type, this will be the hash identifier used to look up the damage type's DestinyDamageTypeDefinition.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyDamageTypeDefinition"
	//       }
	//     },
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "These are the display properties actually used to render the Talent Node. The currently active step's displayProperties are shown.",
	//       "type": "object"
	//     },
	//     "interactionDescription": {
	//       "description": "If you can interact with this node in some way, this is the localized description of that interaction.",
	//       "type": "string"
	//     },
	//     "isNextStepRandom": {
	//       "description": "If true, the next step to be chosen is random, and if you're allowed to activate the next step. (if canActivateNextStep = true)",
	//       "type": "boolean"
	//     },
	//     "nextStepIndex": {
	//       "description": "The stepIndex of the next step in the talent node, or -1 if this is the last step or if the next step to be chosen is random.\r\nThis doesn't really matter anymore unless canActivateNextStep begins to be used again.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "nodeStepHash": {
	//       "description": "The hash of this node step. Unfortunately, while it can be used to uniquely identify the step within a node, it is also content version dependent and should not be relied on without ensuring you have the latest vesion of content.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "perkHashes": {
	//       "description": "The list of hash identifiers for Perks (DestinySandboxPerkDefinition) that are applied when this step is active. Perks provide a variety of benefits and modifications - examine DestinySandboxPerkDefinition to learn more.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinySandboxPerkDefinition"
	//       }
	//     },
	//     "socketReplacements": {
	//       "description": "If this step is activated, this will be a list of information used to replace socket items with new Plugs. See DestinyInventoryItemDefinition for more information about sockets and plugs.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyNodeSocketReplaceResponse"
	//       },
	//       "type": "array"
	//     },
	//     "startProgressionBarAtProgress": {
	//       "description": "When the Talent Grid's progression reaches this value, the circular \"progress bar\" that surrounds the talent node should be shown.\r\nThis also indicates the lower bound of said progress bar, with the upper bound being the progress required to reach activationRequirement.gridLevel. (at some point I should precalculate the upper bound and put it in the definition to save people time)",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "statHashes": {
	//       "description": "When the step provides stat benefits on the item or character, this is the list of hash identifiers for stats (DestinyStatDefinition) that are provided.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyStatDefinition"
	//       }
	//     },
	//     "stepGroups": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyTalentNodeStepGroups"
	//         }
	//       ],
	//       "description": "In Destiny 1, the Armory's Perk Filtering was driven by a concept of TalentNodeStepGroups: categorizations of talent nodes based on their functionality. While the Armory isn't a BNet-facing thing for now, and the new Armory will need to account for Sockets rather than Talent Nodes, this categorization capability feels useful enough to still keep around.",
	//       "type": "object"
	//     },
	//     "stepIndex": {
	//       "description": "The index of this step in the list of Steps on the Talent Node.\r\nUnfortunately, this is the closest thing we have to an identifier for the Step: steps are not provided a content version agnostic identifier. This means that, when you are dealing with talent nodes, you will need to first ensure that you have the latest version of content.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// If the step has requirements for activation (they almost always do, if nothing else than for the
	// Talent Grid's Progression to have reached a certain level), they will be defined here.
	ActivationRequirement NodeActivationRequirement `json:"activationRequirement"`

	// If true, this step can affect the level of the item. See DestinyInventoryItemDefintion for more
	// information about item levels and their effect on stats.
	AffectsLevel bool `json:"affectsLevel"`

	// If this is true, the step affects the item's Quality in some way. See DestinyInventoryItemDefinition
	// for more information about the meaning of Quality. I already made a joke about Zen and the Art of
	// Motorcycle Maintenance elsewhere in the documentation, so I will avoid doing it again. Oops too late
	AffectsQuality bool `json:"affectsQuality"`

	// There was a time when talent nodes could be activated multiple times, and the effects of subsequent
	// Steps would be compounded on each other, essentially "upgrading" the node. We have moved away from
	// this, but theoretically the capability still exists.
	// I continue to return this in case it is used in the future: if true and this step is the current
	// step in the node, you are allowed to activate the node a second time to receive the benefits of the
	// next step in the node, which will then become the active step.
	CanActivateNextStep bool `json:"canActivateNextStep"`

	// An enum representing a damage type granted by activating this step, if any.
	DamageType DamageType `json:"damageType"`

	// If the step provides a damage type, this will be the hash identifier used to look up the damage
	// type's DestinyDamageTypeDefinition.
	DamageTypeHash Nullable[Hash[DamageTypeDefinition]] `json:"damageTypeHash,omitempty"`

	// These are the display properties actually used to render the Talent Node. The currently active
	// step's displayProperties are shown.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// If you can interact with this node in some way, this is the localized description of that
	// interaction.
	InteractionDescription string `json:"interactionDescription"`

	// If true, the next step to be chosen is random, and if you're allowed to activate the next step. (if
	// canActivateNextStep = true)
	IsNextStepRandom bool `json:"isNextStepRandom"`

	// The stepIndex of the next step in the talent node, or -1 if this is the last step or if the next
	// step to be chosen is random.
	// This doesn't really matter anymore unless canActivateNextStep begins to be used again.
	NextStepIndex int32 `json:"nextStepIndex"`

	// The hash of this node step. Unfortunately, while it can be used to uniquely identify the step within
	// a node, it is also content version dependent and should not be relied on without ensuring you have
	// the latest vesion of content.
	NodeStepHash uint32 `json:"nodeStepHash"`

	// The list of hash identifiers for Perks (DestinySandboxPerkDefinition) that are applied when this
	// step is active. Perks provide a variety of benefits and modifications - examine
	// DestinySandboxPerkDefinition to learn more.
	PerkHashes []uint32 `json:"perkHashes"`

	// If this step is activated, this will be a list of information used to replace socket items with new
	// Plugs. See DestinyInventoryItemDefinition for more information about sockets and plugs.
	SocketReplacements []NodeSocketReplaceResponse `json:"socketReplacements"`

	// When the Talent Grid's progression reaches this value, the circular "progress bar" that surrounds
	// the talent node should be shown.
	// This also indicates the lower bound of said progress bar, with the upper bound being the progress
	// required to reach activationRequirement.gridLevel. (at some point I should precalculate the upper
	// bound and put it in the definition to save people time)
	StartProgressionBarAtProgress int32 `json:"startProgressionBarAtProgress"`

	// When the step provides stat benefits on the item or character, this is the list of hash identifiers
	// for stats (DestinyStatDefinition) that are provided.
	StatHashes []uint32 `json:"statHashes"`

	// In Destiny 1, the Armory's Perk Filtering was driven by a concept of TalentNodeStepGroups:
	// categorizations of talent nodes based on their functionality. While the Armory isn't a BNet-facing
	// thing for now, and the new Armory will need to account for Sockets rather than Talent Nodes, this
	// categorization capability feels useful enough to still keep around.
	StepGroups TalentNodeStepGroups `json:"stepGroups"`

	// The index of this step in the list of Steps on the Talent Node.
	// Unfortunately, this is the closest thing we have to an identifier for the Step: steps are not
	// provided a content version agnostic identifier. This means that, when you are dealing with talent
	// nodes, you will need to first ensure that you have the latest version of content.
	StepIndex int32 `json:"stepIndex"`
}

// Destiny.Definitions.DestinyObjectiveDefinition
//
// Defines an "Objective".
// An objective is a specific task you should accomplish in the game. These are referred to by:
// - Quest Steps (which are DestinyInventoryItemDefinition entities with Objectives)
// - Challenges (which are Objectives defined on an DestinyActivityDefintion)
// - Milestones (which refer to Objectives that are defined on both Quest Steps and Activities)
// - Anything else that the designers decide to do later.
// Objectives have progress, a notion of having been Completed, human readable data describing the task
// to be accomplished, and a lot of optional tack-on data that can enhance the information provided
// about the task.
type ObjectiveDefinition struct {
	// {
	//   "description": "Defines an \"Objective\".\r\nAn objective is a specific task you should accomplish in the game. These are referred to by:\r\n- Quest Steps (which are DestinyInventoryItemDefinition entities with Objectives)\r\n- Challenges (which are Objectives defined on an DestinyActivityDefintion)\r\n- Milestones (which refer to Objectives that are defined on both Quest Steps and Activities)\r\n- Anything else that the designers decide to do later.\r\nObjectives have progress, a notion of having been Completed, human readable data describing the task to be accomplished, and a lot of optional tack-on data that can enhance the information provided about the task.",
	//   "properties": {
	//     "allowNegativeValue": {
	//       "description": "If true, the value is allowed to go negative.",
	//       "type": "boolean"
	//     },
	//     "allowOvercompletion": {
	//       "description": "If True, the progress will continue even beyond the point where the objective met its minimum completion requirements. Your UI will have to accommodate it.",
	//       "type": "boolean"
	//     },
	//     "allowValueChangeWhenCompleted": {
	//       "description": "If true, you can effectively \"un-complete\" this objective if you lose progress after crossing the completion threshold. \r\nIf False, once you complete the task it will remain completed forever by locking the value.",
	//       "type": "boolean"
	//     },
	//     "completedValueStyle": {
	//       "description": "The style to use when the objective is completed.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyUnlockValueUIStyle"
	//       }
	//     },
	//     "completionValue": {
	//       "description": "The value that the unlock value defined in unlockValueHash must reach in order for the objective to be considered Completed. Used in calculating progress and completion status.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "Ideally, this should tell you what your task is. I'm not going to lie to you though. Sometimes this doesn't have useful information at all. Which sucks, but there's nothing either of us can do about it.",
	//       "type": "object"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "inProgressValueStyle": {
	//       "description": "The style to use when the objective is still in progress.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyUnlockValueUIStyle"
	//       }
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "isCountingDownward": {
	//       "description": "If true, completion means having an unlock value less than or equal to the completionValue.\r\nIf False, completion means having an unlock value greater than or equal to the completionValue.",
	//       "type": "boolean"
	//     },
	//     "locationHash": {
	//       "description": "OPTIONAL: a hash identifier for the location at which this objective must be accomplished, if there is a location defined. Look up the DestinyLocationDefinition for this hash for that additional location info.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyLocationDefinition"
	//       }
	//     },
	//     "minimumVisibilityThreshold": {
	//       "description": "If nonzero, this is the minimum value at which the objective's progression should be shown. Otherwise, don't show it yet.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "perks": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectivePerkEntryDefinition"
	//         }
	//       ],
	//       "description": "If this objective enables Perks intrinsically, the conditions for that enabling are defined here.",
	//       "type": "object"
	//     },
	//     "progressDescription": {
	//       "description": "Text to describe the progress bar.",
	//       "type": "string"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "scope": {
	//       "description": "A shortcut for determining the most restrictive gating that this Objective is set to use. This includes both the dynamic determination of progress and of completion values. See the DestinyGatingScope enum's documentation for more details.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyGatingScope"
	//       }
	//     },
	//     "showValueOnComplete": {
	//       "description": "If True, you should continue showing the progression value in the UI after it's complete. I mean, we already do that in BNet anyways, but if you want to be better behaved than us you could honor this flag.",
	//       "type": "boolean"
	//     },
	//     "stats": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectiveStatEntryDefinition"
	//         }
	//       ],
	//       "description": "If this objective enables modifications on a player's stats intrinsically, the conditions are defined here.",
	//       "type": "object"
	//     },
	//     "uiLabel": {
	//       "description": "Objectives can have arbitrary UI-defined identifiers that define the style applied to objectives. For convenience, known UI labels will be defined in the uiStyle enum value.",
	//       "type": "string"
	//     },
	//     "uiStyle": {
	//       "description": "If the objective has a known UI label value, this property will represent it.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyObjectiveUiStyle"
	//       }
	//     },
	//     "valueStyle": {
	//       "description": "The UI style applied to the objective. It's an enum, take a look at DestinyUnlockValueUIStyle for details of the possible styles. Use this info as you wish to customize your UI.\r\nDEPRECATED: This is no longer populated by Destiny 2 game content. Please use inProgressValueStyle and completedValueStyle instead.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyUnlockValueUIStyle"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Objectives"
	// }

	// If true, the value is allowed to go negative.
	AllowNegativeValue bool `json:"allowNegativeValue"`

	// If True, the progress will continue even beyond the point where the objective met its minimum
	// completion requirements. Your UI will have to accommodate it.
	AllowOvercompletion bool `json:"allowOvercompletion"`

	// If true, you can effectively "un-complete" this objective if you lose progress after crossing the
	// completion threshold.
	// If False, once you complete the task it will remain completed forever by locking the value.
	AllowValueChangeWhenCompleted bool `json:"allowValueChangeWhenCompleted"`

	// The style to use when the objective is completed.
	CompletedValueStyle UnlockValueUIStyle `json:"completedValueStyle"`

	// The value that the unlock value defined in unlockValueHash must reach in order for the objective to
	// be considered Completed. Used in calculating progress and completion status.
	CompletionValue int32 `json:"completionValue"`

	// Ideally, this should tell you what your task is. I'm not going to lie to you though. Sometimes this
	// doesn't have useful information at all. Which sucks, but there's nothing either of us can do about
	// it.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The style to use when the objective is still in progress.
	InProgressValueStyle UnlockValueUIStyle `json:"inProgressValueStyle"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If true, completion means having an unlock value less than or equal to the completionValue.
	// If False, completion means having an unlock value greater than or equal to the completionValue.
	IsCountingDownward bool `json:"isCountingDownward"`

	// OPTIONAL: a hash identifier for the location at which this objective must be accomplished, if there
	// is a location defined. Look up the DestinyLocationDefinition for this hash for that additional
	// location info.
	LocationHash Hash[LocationDefinition] `json:"locationHash"`

	// If nonzero, this is the minimum value at which the objective's progression should be shown.
	// Otherwise, don't show it yet.
	MinimumVisibilityThreshold int32 `json:"minimumVisibilityThreshold"`

	// If this objective enables Perks intrinsically, the conditions for that enabling are defined here.
	Perks ObjectivePerkEntryDefinition `json:"perks"`

	// Text to describe the progress bar.
	ProgressDescription string `json:"progressDescription"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// A shortcut for determining the most restrictive gating that this Objective is set to use. This
	// includes both the dynamic determination of progress and of completion values. See the
	// DestinyGatingScope enum's documentation for more details.
	Scope GatingScope `json:"scope"`

	// If True, you should continue showing the progression value in the UI after it's complete. I mean, we
	// already do that in BNet anyways, but if you want to be better behaved than us you could honor this
	// flag.
	ShowValueOnComplete bool `json:"showValueOnComplete"`

	// If this objective enables modifications on a player's stats intrinsically, the conditions are
	// defined here.
	Stats ObjectiveStatEntryDefinition `json:"stats"`

	// Objectives can have arbitrary UI-defined identifiers that define the style applied to objectives.
	// For convenience, known UI labels will be defined in the uiStyle enum value.
	UiLabel string `json:"uiLabel"`

	// If the objective has a known UI label value, this property will represent it.
	UiStyle ObjectiveUiStyle `json:"uiStyle"`

	// The UI style applied to the objective. It's an enum, take a look at DestinyUnlockValueUIStyle for
	// details of the possible styles. Use this info as you wish to customize your UI.
	// DEPRECATED: This is no longer populated by Destiny 2 game content. Please use inProgressValueStyle
	// and completedValueStyle instead.
	ValueStyle UnlockValueUIStyle `json:"valueStyle"`
}

// Destiny.Definitions.DestinyObjectiveDisplayProperties
type ObjectiveDisplayProperties struct {
	// {
	//   "properties": {
	//     "activityHash": {
	//       "description": "The activity associated with this objective in the context of this item, if any.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "displayOnItemPreviewScreen": {
	//       "description": "If true, the game shows this objective on item preview screens.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	// The activity associated with this objective in the context of this item, if any.
	ActivityHash Nullable[Hash[ActivityDefinition]] `json:"activityHash,omitempty"`

	// If true, the game shows this objective on item preview screens.
	DisplayOnItemPreviewScreen bool `json:"displayOnItemPreviewScreen"`
}

// Destiny.Definitions.DestinyObjectivePerkEntryDefinition
//
// Defines the conditions under which an intrinsic perk is applied while participating in an Objective.
// These perks will generally not be benefit-granting perks, but rather a perk that modifies gameplay
// in some interesting way.
type ObjectivePerkEntryDefinition struct {
	// {
	//   "description": "Defines the conditions under which an intrinsic perk is applied while participating in an Objective.\r\nThese perks will generally not be benefit-granting perks, but rather a perk that modifies gameplay in some interesting way.",
	//   "properties": {
	//     "perkHash": {
	//       "description": "The hash identifier of the DestinySandboxPerkDefinition that will be applied to the character.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinySandboxPerkDefinition"
	//       }
	//     },
	//     "style": {
	//       "description": "An enumeration indicating whether it will be applied as long as the Objective is active, when it's completed, or until it's completed.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyObjectiveGrantStyle"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash identifier of the DestinySandboxPerkDefinition that will be applied to the character.
	PerkHash Hash[SandboxPerkDefinition] `json:"perkHash"`

	// An enumeration indicating whether it will be applied as long as the Objective is active, when it's
	// completed, or until it's completed.
	Style ObjectiveGrantStyle `json:"style"`
}

// Destiny.Definitions.DestinyObjectiveStatEntryDefinition
//
// Defines the conditions under which stat modifications will be applied to a Character while
// participating in an objective.
type ObjectiveStatEntryDefinition struct {
	// {
	//   "description": "Defines the conditions under which stat modifications will be applied to a Character while participating in an objective.",
	//   "properties": {
	//     "stat": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemInvestmentStatDefinition"
	//         }
	//       ],
	//       "description": "The stat being modified, and the value used.",
	//       "type": "object"
	//     },
	//     "style": {
	//       "description": "Whether it will be applied as long as the objective is active, when it's completed, or until it's completed.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyObjectiveGrantStyle"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The stat being modified, and the value used.
	Stat ItemInvestmentStatDefinition `json:"stat"`

	// Whether it will be applied as long as the objective is active, when it's completed, or until it's
	// completed.
	Style ObjectiveGrantStyle `json:"style"`
}

// Destiny.Definitions.DestinyPlaceDefinition
//
// Okay, so Activities (DestinyActivityDefinition) take place in Destinations
// (DestinyDestinationDefinition). Destinations are part of larger locations known as Places (you're
// reading its documentation right now).
// Places are more on the planetary scale, like "Earth" and "Your Mom."
type PlaceDefinition struct {
	// {
	//   "description": "Okay, so Activities (DestinyActivityDefinition) take place in Destinations (DestinyDestinationDefinition). Destinations are part of larger locations known as Places (you're reading its documentation right now).\r\nPlaces are more on the planetary scale, like \"Earth\" and \"Your Mom.\"",
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Places"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyPlugItemCraftingRequirements
type PlugItemCraftingRequirements struct {
	// {
	//   "properties": {
	//     "materialRequirementHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyMaterialRequirementSetDefinition"
	//       }
	//     },
	//     "requiredLevel": {
	//       "description": "If the plug has a known level requirement, it'll be available here.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "unlockRequirements": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyPlugItemCraftingUnlockRequirement"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	MaterialRequirementHashes []uint32 `json:"materialRequirementHashes"`

	// If the plug has a known level requirement, it'll be available here.
	RequiredLevel Nullable[int32] `json:"requiredLevel,omitempty"`

	UnlockRequirements []PlugItemCraftingUnlockRequirement `json:"unlockRequirements"`
}

// Destiny.Definitions.DestinyPlugItemCraftingUnlockRequirement
type PlugItemCraftingUnlockRequirement struct {
	// {
	//   "properties": {
	//     "failureDescription": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	FailureDescription string `json:"failureDescription"`
}

// Destiny.Definitions.DestinyProgressionDefinition
//
// A "Progression" in Destiny is best explained by an example.
// A Character's "Level" is a progression: it has Experience that can be earned, levels that can be
// gained, and is evaluated and displayed at various points in the game. A Character's "Faction
// Reputation" is also a progression for much the same reason.
// Progression is used by a variety of systems, and the definition of a Progression will generally only
// be useful if combining with live data (such as a character's
// DestinyCharacterProgressionComponent.progressions property, which holds that character's live
// Progression states).
// Fundamentally, a Progression measures your "Level" by evaluating the thresholds in its Steps (one
// step per level, except for the last step which can be repeated indefinitely for "Levels" that have
// no ceiling) against the total earned "progression points"/experience. (for simplicity purposes, we
// will henceforth refer to earned progression points as experience, though it need not be a mechanic
// that in any way resembles Experience in a traditional sense).
// Earned experience is calculated in a variety of ways, determined by the Progression's scope. These
// go from looking up a stored value to performing exceedingly obtuse calculations. This is why we
// provide live data in DestinyCharacterProgressionComponent.progressions, so you don't have to worry
// about those.
type ProgressionDefinition struct {
	// {
	//   "description": "A \"Progression\" in Destiny is best explained by an example.\r\nA Character's \"Level\" is a progression: it has Experience that can be earned, levels that can be gained, and is evaluated and displayed at various points in the game. A Character's \"Faction Reputation\" is also a progression for much the same reason.\r\nProgression is used by a variety of systems, and the definition of a Progression will generally only be useful if combining with live data (such as a character's DestinyCharacterProgressionComponent.progressions property, which holds that character's live Progression states).\r\nFundamentally, a Progression measures your \"Level\" by evaluating the thresholds in its Steps (one step per level, except for the last step which can be repeated indefinitely for \"Levels\" that have no ceiling) against the total earned \"progression points\"/experience. (for simplicity purposes, we will henceforth refer to earned progression points as experience, though it need not be a mechanic that in any way resembles Experience in a traditional sense).\r\nEarned experience is calculated in a variety of ways, determined by the Progression's scope. These go from looking up a stored value to performing exceedingly obtuse calculations. This is why we provide live data in DestinyCharacterProgressionComponent.progressions, so you don't have to worry about those.",
	//   "properties": {
	//     "color": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Misc.DestinyColor"
	//         }
	//       ],
	//       "description": "The #RGB string value for the color related to this progression, if there is one.",
	//       "type": "object"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionDisplayPropertiesDefinition"
	//     },
	//     "factionHash": {
	//       "description": "If the value exists, this is the hash identifier for the Faction that owns this Progression.\r\nThis is purely for convenience, if you're looking at a progression and want to know if and who it's related to in terms of Faction Reputation.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyFactionDefinition"
	//       }
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "rankIcon": {
	//       "description": "For progressions that have it, this is the rank icon we use in the Companion, displayed above the progressions' rank value.",
	//       "type": "string"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "repeatLastStep": {
	//       "description": "If this is True, then the progression doesn't have a maximum level.",
	//       "type": "boolean"
	//     },
	//     "rewardItems": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionRewardItemQuantity"
	//       },
	//       "type": "array"
	//     },
	//     "scope": {
	//       "description": "The \"Scope\" of the progression indicates the source of the progression's live data.\r\nSee the DestinyProgressionScope enum for more info: but essentially, a Progression can either be backed by a stored value, or it can be a calculated derivative of other values.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyProgressionScope"
	//       }
	//     },
	//     "source": {
	//       "description": "If there's a description of how to earn this progression in the local config, this will be that localized description.",
	//       "type": "string"
	//     },
	//     "steps": {
	//       "description": "Progressions are divided into Steps, which roughly equate to \"Levels\" in the traditional sense of a Progression. Notably, the last step can be repeated indefinitely if repeatLastStep is true, meaning that the calculation for your level is not as simple as comparing your current progress to the max progress of the steps. \r\nThese and more calculations are done for you if you grab live character progression data, such as in the DestinyCharacterProgressionComponent.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionStepDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "visible": {
	//       "description": "If true, the Progression is something worth showing to users.\r\nIf false, BNet isn't going to show it. But that doesn't mean you can't. We're all friends here.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Progressions"
	// }

	// The #RGB string value for the color related to this progression, if there is one.
	Color Color `json:"color"`

	DisplayProperties ProgressionDisplayPropertiesDefinition `json:"displayProperties"`

	// If the value exists, this is the hash identifier for the Faction that owns this Progression.
	// This is purely for convenience, if you're looking at a progression and want to know if and who it's
	// related to in terms of Faction Reputation.
	FactionHash Nullable[Hash[FactionDefinition]] `json:"factionHash,omitempty"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// For progressions that have it, this is the rank icon we use in the Companion, displayed above the
	// progressions' rank value.
	RankIcon string `json:"rankIcon"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// If this is True, then the progression doesn't have a maximum level.
	RepeatLastStep bool `json:"repeatLastStep"`

	RewardItems []ProgressionRewardItemQuantity `json:"rewardItems"`

	// The "Scope" of the progression indicates the source of the progression's live data.
	// See the DestinyProgressionScope enum for more info: but essentially, a Progression can either be
	// backed by a stored value, or it can be a calculated derivative of other values.
	Scope ProgressionScope `json:"scope"`

	// If there's a description of how to earn this progression in the local config, this will be that
	// localized description.
	Source string `json:"source"`

	// Progressions are divided into Steps, which roughly equate to "Levels" in the traditional sense of a
	// Progression. Notably, the last step can be repeated indefinitely if repeatLastStep is true, meaning
	// that the calculation for your level is not as simple as comparing your current progress to the max
	// progress of the steps.
	// These and more calculations are done for you if you grab live character progression data, such as in
	// the DestinyCharacterProgressionComponent.
	Steps []ProgressionStepDefinition `json:"steps"`

	// If true, the Progression is something worth showing to users.
	// If false, BNet isn't going to show it. But that doesn't mean you can't. We're all friends here.
	Visible bool `json:"visible"`
}

// Destiny.Definitions.DestinyProgressionDisplayPropertiesDefinition
type ProgressionDisplayPropertiesDefinition struct {
	// {
	//   "properties": {
	//     "description": {
	//       "type": "string"
	//     },
	//     "displayUnitsName": {
	//       "description": "When progressions show your \"experience\" gained, that bar has units (i.e. \"Experience\", \"Bad Dudes Snuffed Out\", whatever). This is the localized string for that unit of measurement.",
	//       "type": "string"
	//     },
	//     "hasIcon": {
	//       "type": "boolean"
	//     },
	//     "highResIcon": {
	//       "description": "If this item has a high-res icon (at least for now, many things won't), then the path to that icon will be here.",
	//       "type": "string"
	//     },
	//     "icon": {
	//       "description": "Note that \"icon\" is sometimes misleading, and should be interpreted in the context of the entity. For instance, in Destiny 1 the DestinyRecordBookDefinition's icon was a big picture of a book.\r\nBut usually, it will be a small square image that you can use as... well, an icon.\r\nThey are currently represented as 96px x 96px images.",
	//       "type": "string"
	//     },
	//     "iconSequences": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyIconSequenceDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "name": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Description string `json:"description"`

	// When progressions show your "experience" gained, that bar has units (i.e. "Experience", "Bad Dudes
	// Snuffed Out", whatever). This is the localized string for that unit of measurement.
	DisplayUnitsName string `json:"displayUnitsName"`

	HasIcon bool `json:"hasIcon"`

	// If this item has a high-res icon (at least for now, many things won't), then the path to that icon
	// will be here.
	HighResIcon string `json:"highResIcon"`

	// Note that "icon" is sometimes misleading, and should be interpreted in the context of the entity.
	// For instance, in Destiny 1 the DestinyRecordBookDefinition's icon was a big picture of a book.
	// But usually, it will be a small square image that you can use as... well, an icon.
	// They are currently represented as 96px x 96px images.
	Icon string `json:"icon"`

	IconSequences []IconSequenceDefinition `json:"iconSequences"`

	Name string `json:"name"`
}

// Destiny.Definitions.DestinyProgressionMappingDefinition
//
// Aggregations of multiple progressions.
// These are used to apply rewards to multiple progressions at once. They can sometimes have human
// readable data as well, but only extremely sporadically.
type ProgressionMappingDefinition struct {
	// {
	//   "description": "Aggregations of multiple progressions.\r\nThese are used to apply rewards to multiple progressions at once. They can sometimes have human readable data as well, but only extremely sporadically.",
	//   "properties": {
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "Infrequently defined in practice. Defer to the individual progressions' display properties.",
	//       "type": "object"
	//     },
	//     "displayUnits": {
	//       "description": "The localized unit of measurement for progression across the progressions defined in this mapping. Unfortunately, this is very infrequently defined. Defer to the individual progressions' display units.",
	//       "type": "string"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	// Infrequently defined in practice. Defer to the individual progressions' display properties.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The localized unit of measurement for progression across the progressions defined in this mapping.
	// Unfortunately, this is very infrequently defined. Defer to the individual progressions' display
	// units.
	DisplayUnits string `json:"displayUnits"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyProgressionRewardDefinition
//
// Inventory Items can reward progression when actions are performed on them. A common example of this
// in Destiny 1 was Bounties, which would reward Experience on your Character and the like when you
// completed the bounty.
// Note that this maps to a DestinyProgressionMappingDefinition, and *not* a
// DestinyProgressionDefinition directly. This is apparently so that multiple progressions can be
// granted progression points/experience at the same time.
type ProgressionRewardDefinition struct {
	// {
	//   "description": "Inventory Items can reward progression when actions are performed on them. A common example of this in Destiny 1 was Bounties, which would reward Experience on your Character and the like when you completed the bounty.\r\nNote that this maps to a DestinyProgressionMappingDefinition, and *not* a DestinyProgressionDefinition directly. This is apparently so that multiple progressions can be granted progression points/experience at the same time.",
	//   "properties": {
	//     "amount": {
	//       "description": "The amount of experience to give to each of the mapped progressions.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "applyThrottles": {
	//       "description": "If true, the game's internal mechanisms to throttle progression should be applied.",
	//       "type": "boolean"
	//     },
	//     "progressionMappingHash": {
	//       "description": "The hash identifier of the DestinyProgressionMappingDefinition that contains the progressions for which experience should be applied.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionMappingDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The amount of experience to give to each of the mapped progressions.
	Amount int32 `json:"amount"`

	// If true, the game's internal mechanisms to throttle progression should be applied.
	ApplyThrottles bool `json:"applyThrottles"`

	// The hash identifier of the DestinyProgressionMappingDefinition that contains the progressions for
	// which experience should be applied.
	ProgressionMappingHash Hash[ProgressionMappingDefinition] `json:"progressionMappingHash"`
}

// Destiny.Definitions.DestinyProgressionRewardItemQuantity
type ProgressionRewardItemQuantity struct {
	// {
	//   "properties": {
	//     "acquisitionBehavior": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyProgressionRewardItemAcquisitionBehavior"
	//       }
	//     },
	//     "claimUnlockDisplayStrings": {
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     },
	//     "hasConditionalVisibility": {
	//       "description": "Indicates that this item quantity may be conditionally shown or hidden, based on various sources of state. For example: server flags, account state, or character progress.",
	//       "type": "boolean"
	//     },
	//     "itemHash": {
	//       "description": "The hash identifier for the item in question. Use it to look up the item's DestinyInventoryItemDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "itemInstanceId": {
	//       "description": "If this quantity is referring to a specific instance of an item, this will have the item's instance ID. Normally, this will be null.",
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "quantity": {
	//       "description": "The amount of the item needed/available depending on the context of where DestinyItemQuantity is being used.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "rewardItemIndex": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "rewardedAtProgressionLevel": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "socketOverrides": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionSocketPlugOverride"
	//       },
	//       "type": "array"
	//     },
	//     "uiDisplayStyle": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	AcquisitionBehavior ProgressionRewardItemAcquisitionBehavior `json:"acquisitionBehavior"`

	ClaimUnlockDisplayStrings []string `json:"claimUnlockDisplayStrings"`

	// Indicates that this item quantity may be conditionally shown or hidden, based on various sources of
	// state. For example: server flags, account state, or character progress.
	HasConditionalVisibility bool `json:"hasConditionalVisibility"`

	// The hash identifier for the item in question. Use it to look up the item's
	// DestinyInventoryItemDefinition.
	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`

	// If this quantity is referring to a specific instance of an item, this will have the item's instance
	// ID. Normally, this will be null.
	ItemInstanceID Nullable[Int64] `json:"itemInstanceId,omitempty"`

	// The amount of the item needed/available depending on the context of where DestinyItemQuantity is
	// being used.
	Quantity int32 `json:"quantity"`

	RewardItemIndex int32 `json:"rewardItemIndex"`

	RewardedAtProgressionLevel int32 `json:"rewardedAtProgressionLevel"`

	SocketOverrides []ProgressionSocketPlugOverride `json:"socketOverrides"`

	UiDisplayStyle string `json:"uiDisplayStyle"`
}

// Destiny.Definitions.DestinyProgressionSocketPlugOverride
//
// The information for how progression item definitions should override a given socket with custom plug
// data.
type ProgressionSocketPlugOverride struct {
	// {
	//   "description": "The information for how progression item definitions should override a given socket with custom plug data.",
	//   "properties": {
	//     "overrideSingleItemHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "socketTypeHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	OverrideSingleItemHash Nullable[Hash[InventoryItemDefinition]] `json:"overrideSingleItemHash,omitempty"`

	SocketTypeHash uint32 `json:"socketTypeHash"`
}

// Destiny.Definitions.DestinyProgressionStepDefinition
//
// This defines a single Step in a progression (which roughly equates to a level. See
// DestinyProgressionDefinition for caveats).
type ProgressionStepDefinition struct {
	// {
	//   "description": "This defines a single Step in a progression (which roughly equates to a level. See DestinyProgressionDefinition for caveats).",
	//   "properties": {
	//     "displayEffectType": {
	//       "description": "This appears to be, when you \"level up\", whether a visual effect will display and on what entity. See DestinyProgressionStepDisplayEffect for slightly more info.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyProgressionStepDisplayEffect"
	//       }
	//     },
	//     "icon": {
	//       "description": "If this progression step has a specific icon related to it, this is the icon to show.",
	//       "type": "string"
	//     },
	//     "progressTotal": {
	//       "description": "The total amount of progression points/\"experience\" you will need to initially reach this step. If this is the last step and the progression is repeating indefinitely (DestinyProgressionDefinition.repeatLastStep), this will also be the progress needed to level it up further by repeating this step again.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "rewardItems": {
	//       "description": "A listing of items rewarded as a result of reaching this level.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemQuantity"
	//       },
	//       "type": "array"
	//     },
	//     "stepName": {
	//       "description": "Very rarely, Progressions will have localized text describing the Level of the progression. This will be that localized text, if it exists. Otherwise, the standard appears to be to simply show the level numerically.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// This appears to be, when you "level up", whether a visual effect will display and on what entity.
	// See DestinyProgressionStepDisplayEffect for slightly more info.
	DisplayEffectType ProgressionStepDisplayEffect `json:"displayEffectType"`

	// If this progression step has a specific icon related to it, this is the icon to show.
	Icon string `json:"icon"`

	// The total amount of progression points/"experience" you will need to initially reach this step. If
	// this is the last step and the progression is repeating indefinitely
	// (DestinyProgressionDefinition.repeatLastStep), this will also be the progress needed to level it up
	// further by repeating this step again.
	ProgressTotal int32 `json:"progressTotal"`

	// A listing of items rewarded as a result of reaching this level.
	RewardItems []ItemQuantity `json:"rewardItems"`

	// Very rarely, Progressions will have localized text describing the Level of the progression. This
	// will be that localized text, if it exists. Otherwise, the standard appears to be to simply show the
	// level numerically.
	StepName string `json:"stepName"`
}

// Destiny.Definitions.DestinyRaceDefinition
//
// In Destiny, "Races" are really more like "Species". Sort of. I mean, are the Awoken a separate
// species from humans? I'm not sure. But either way, they're defined here. You'll see Exo, Awoken, and
// Human as examples of these Species. Players will choose one for their character.
type RaceDefinition struct {
	// {
	//   "description": "In Destiny, \"Races\" are really more like \"Species\". Sort of. I mean, are the Awoken a separate species from humans? I'm not sure. But either way, they're defined here. You'll see Exo, Awoken, and Human as examples of these Species. Players will choose one for their character.",
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "genderedRaceNames": {
	//       "additionalProperties": {
	//         "type": "string"
	//       },
	//       "description": "A localized string referring to the singular form of the Race's name when referred to in gendered form. Keyed by the DestinyGender.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/Destiny.DestinyGender"
	//         }
	//       }
	//     },
	//     "genderedRaceNamesByGenderHash": {
	//       "additionalProperties": {
	//         "type": "string"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyGenderDefinition"
	//       }
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "raceType": {
	//       "description": "An enumeration defining the existing, known Races/Species for player characters. This value will be the enum value matching this definition.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyRace"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Races"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// A localized string referring to the singular form of the Race's name when referred to in gendered
	// form. Keyed by the DestinyGender.
	GenderedRaceNames map[string]string `json:"genderedRaceNames"`

	GenderedRaceNamesByGenderHash map[Hash[GenderDefinition]]string `json:"genderedRaceNamesByGenderHash"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// An enumeration defining the existing, known Races/Species for player characters. This value will be
	// the enum value matching this definition.
	RaceType Race `json:"raceType"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyRewardSourceCategory
//
// BNet's custom categorization of reward sources. We took a look at the existing ways that items could
// be spawned, and tried to make high-level categorizations of them. This needs to be re-evaluated for
// Destiny 2.
type RewardSourceCategory int32

const (
	RewardSourceCategory_None      = RewardSourceCategory(0)
	RewardSourceCategory_Activity  = RewardSourceCategory(1)
	RewardSourceCategory_Vendor    = RewardSourceCategory(2)
	RewardSourceCategory_Aggregate = RewardSourceCategory(3)
)

// Destiny.Definitions.DestinyRewardSourceDefinition
//
// Represents a heuristically-determined "item source" according to Bungie.net. These item sources are
// non-canonical: we apply a combination of special configuration and often-fragile heuristics to
// attempt to discern whether an item should be part of a given "source," but we have known cases of
// false positives and negatives due to our imperfect heuristics.
// Still, they provide a decent approximation for people trying to figure out how an item can be
// obtained. DestinyInventoryItemDefinition refers to sources in the sourceDatas.sourceHashes property
// for all sources we determined the item could spawn from.
// An example in Destiny 1 of a Source would be "Nightfall". If an item has the "Nightfall" source
// associated with it, it's extremely likely that you can earn that item while playing Nightfall,
// either during play or as an after-completion reward.
type RewardSourceDefinition struct {
	// {
	//   "description": "Represents a heuristically-determined \"item source\" according to Bungie.net. These item sources are non-canonical: we apply a combination of special configuration and often-fragile heuristics to attempt to discern whether an item should be part of a given \"source,\" but we have known cases of false positives and negatives due to our imperfect heuristics.\r\nStill, they provide a decent approximation for people trying to figure out how an item can be obtained. DestinyInventoryItemDefinition refers to sources in the sourceDatas.sourceHashes property for all sources we determined the item could spawn from.\r\nAn example in Destiny 1 of a Source would be \"Nightfall\". If an item has the \"Nightfall\" source associated with it, it's extremely likely that you can earn that item while playing Nightfall, either during play or as an after-completion reward.",
	//   "properties": {
	//     "category": {
	//       "description": "Sources are grouped into categories: common ways that items are provided. I hope to see this expand in Destiny 2 once we have time to generate accurate reward source data.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyRewardSourceCategory"
	//       }
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "RewardSources"
	// }

	// Sources are grouped into categories: common ways that items are provided. I hope to see this expand
	// in Destiny 2 once we have time to generate accurate reward source data.
	Category RewardSourceCategory `json:"category"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinySandboxPatternDefinition
type SandboxPatternDefinition struct {
	// {
	//   "properties": {
	//     "filters": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyArrangementRegionFilterDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "patternGlobalTagIdHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "patternHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "weaponContentGroupHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "weaponTranslationGroupHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "weaponType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemSubType"
	//       }
	//     },
	//     "weaponTypeHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "SandboxPatterns"
	// }

	Filters []ArrangementRegionFilterDefinition `json:"filters"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	PatternGlobalTagIdHash uint32 `json:"patternGlobalTagIdHash"`

	PatternHash uint32 `json:"patternHash"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	WeaponContentGroupHash uint32 `json:"weaponContentGroupHash"`

	WeaponTranslationGroupHash uint32 `json:"weaponTranslationGroupHash"`

	WeaponType ItemSubType `json:"weaponType"`

	WeaponTypeHash Nullable[uint32] `json:"weaponTypeHash,omitempty"`
}

// Destiny.Definitions.DestinySandboxPerkDefinition
//
// Perks are modifiers to a character or item that can be applied situationally.
// - Perks determine a weapon's damage type.
// - Perks put the Mods in Modifiers (they are literally the entity that bestows the Sandbox benefit
// for whatever fluff text about the modifier in the Socket, Plug or Talent Node)
// - Perks are applied for unique alterations of state in Objectives
// Anyways, I'm sure you can see why perks are so interesting.
// What Perks often don't have is human readable information, so we attempt to reverse engineer that by
// pulling that data from places that uniquely refer to these perks: namely, Talent Nodes and Plugs.
// That only gives us a subset of perks that are human readable, but those perks are the ones people
// generally care about anyways. The others are left as a mystery, their true purpose mostly unknown
// and undocumented.
type SandboxPerkDefinition struct {
	// {
	//   "description": "Perks are modifiers to a character or item that can be applied situationally.\r\n- Perks determine a weapon's damage type.\r\n- Perks put the Mods in Modifiers (they are literally the entity that bestows the Sandbox benefit for whatever fluff text about the modifier in the Socket, Plug or Talent Node)\r\n- Perks are applied for unique alterations of state in Objectives\r\nAnyways, I'm sure you can see why perks are so interesting.\r\nWhat Perks often don't have is human readable information, so we attempt to reverse engineer that by pulling that data from places that uniquely refer to these perks: namely, Talent Nodes and Plugs. That only gives us a subset of perks that are human readable, but those perks are the ones people generally care about anyways. The others are left as a mystery, their true purpose mostly unknown and undocumented.",
	//   "properties": {
	//     "damageType": {
	//       "description": "If this perk grants a damage type to a weapon, the damage type will be defined here.\r\nUnless you have a compelling reason to use this enum value, use the damageTypeHash instead to look up the actual DestinyDamageTypeDefinition.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DamageType"
	//       }
	//     },
	//     "damageTypeHash": {
	//       "description": "The hash identifier for looking up the DestinyDamageTypeDefinition, if this perk has a damage type.\r\nThis is preferred over using the damageType enumeration value, which has been left purely because it is occasionally convenient.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyDamageTypeDefinition"
	//       }
	//     },
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "These display properties are by no means guaranteed to be populated. Usually when it is, it's only because we back-filled them with the displayProperties of some Talent Node or Plug item that happened to be uniquely providing that perk.",
	//       "type": "object"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "isDisplayable": {
	//       "description": "If true, you can actually show the perk in the UI. Otherwise, it doesn't have useful player-facing information.",
	//       "type": "boolean"
	//     },
	//     "perkIdentifier": {
	//       "description": "The string identifier for the perk.",
	//       "type": "string"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "SandboxPerks"
	// }

	// If this perk grants a damage type to a weapon, the damage type will be defined here.
	// Unless you have a compelling reason to use this enum value, use the damageTypeHash instead to look
	// up the actual DestinyDamageTypeDefinition.
	DamageType DamageType `json:"damageType"`

	// The hash identifier for looking up the DestinyDamageTypeDefinition, if this perk has a damage type.
	// This is preferred over using the damageType enumeration value, which has been left purely because it
	// is occasionally convenient.
	DamageTypeHash Nullable[Hash[DamageTypeDefinition]] `json:"damageTypeHash,omitempty"`

	// These display properties are by no means guaranteed to be populated. Usually when it is, it's only
	// because we back-filled them with the displayProperties of some Talent Node or Plug item that
	// happened to be uniquely providing that perk.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If true, you can actually show the perk in the UI. Otherwise, it doesn't have useful player-facing
	// information.
	IsDisplayable bool `json:"isDisplayable"`

	// The string identifier for the perk.
	PerkIdentifier string `json:"perkIdentifier"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyStatDefinition
//
// This represents a stat that's applied to a character or an item (such as a weapon, piece of armor,
// or a vehicle).
// An example of a stat might be Attack Power on a weapon.
// Stats go through a complex set of transformations before they end up being shown to the user as a
// number or a progress bar, and those transformations are fundamentally intertwined with the concept
// of a "Stat Group" (DestinyStatGroupDefinition). Items have both Stats and a reference to a Stat
// Group, and it is the Stat Group that takes the raw stat information and gives it both rendering
// metadata (such as whether to show it as a number or a progress bar) and the final transformation
// data (interpolation tables to turn the raw investment stat into a display stat). Please see
// DestinyStatGroupDefinition for more information on that transformational process.
// Stats are segregated from Stat Groups because different items and types of items can refer to the
// same stat, but have different "scales" for the stat while still having the same underlying value.
// For example, both a Shotgun and an Auto Rifle may have a "raw" impact stat of 50, but the Auto
// Rifle's Stat Group will scale that 50 down so that, when it is displayed, it is a smaller value
// relative to the shotgun. (this is a totally made up example, don't assume shotguns have naturally
// higher impact than auto rifles because of this)
// A final caveat is that some stats, even after this "final" transformation, go through yet another
// set of transformations directly in the game as a result of dynamic, stateful scripts that get run.
// BNet has no access to these scripts, nor any way to know which scripts get executed. As a result,
// the stats for an item that you see in-game - particularly for stats that are often impacted by
// Perks, like Magazine Size - can change dramatically from what we return on Bungie.Net. This is a
// known issue with no fix coming down the pipeline. Take these stats with a grain of salt.
// Stats actually go through four transformations, for those interested:
// 1) "Sandbox" stat, the "most raw" form. These are pretty much useless without transformations
// applied, and thus are not currently returned in the API. If you really want these, we can provide
// them. Maybe someone could do something cool with it?
// 2) "Investment" stat (the stat's value after DestinyStatDefinition's interpolation tables and
// aggregation logic is applied to the "Sandbox" stat value)
// 3) "Display" stat (the stat's base UI-visible value after DestinyStatGroupDefinition's interpolation
// tables are applied to the Investment Stat value. For most stats, this is what is displayed.)
// 4) Underlying in-game stat (the stat's actual value according to the game, after the game runs
// dynamic scripts based on the game and character's state. This is the final transformation that BNet
// does not have access to. For most stats, this is not actually displayed to the user, with the
// exception of Magazine Size which is then piped back to the UI for display in-game, but not to BNet.)
type StatDefinition struct {
	// {
	//   "description": "This represents a stat that's applied to a character or an item (such as a weapon, piece of armor, or a vehicle).\r\nAn example of a stat might be Attack Power on a weapon.\r\nStats go through a complex set of transformations before they end up being shown to the user as a number or a progress bar, and those transformations are fundamentally intertwined with the concept of a \"Stat Group\" (DestinyStatGroupDefinition). Items have both Stats and a reference to a Stat Group, and it is the Stat Group that takes the raw stat information and gives it both rendering metadata (such as whether to show it as a number or a progress bar) and the final transformation data (interpolation tables to turn the raw investment stat into a display stat). Please see DestinyStatGroupDefinition for more information on that transformational process.\r\nStats are segregated from Stat Groups because different items and types of items can refer to the same stat, but have different \"scales\" for the stat while still having the same underlying value. For example, both a Shotgun and an Auto Rifle may have a \"raw\" impact stat of 50, but the Auto Rifle's Stat Group will scale that 50 down so that, when it is displayed, it is a smaller value relative to the shotgun. (this is a totally made up example, don't assume shotguns have naturally higher impact than auto rifles because of this)\r\nA final caveat is that some stats, even after this \"final\" transformation, go through yet another set of transformations directly in the game as a result of dynamic, stateful scripts that get run. BNet has no access to these scripts, nor any way to know which scripts get executed. As a result, the stats for an item that you see in-game - particularly for stats that are often impacted by Perks, like Magazine Size - can change dramatically from what we return on Bungie.Net. This is a known issue with no fix coming down the pipeline. Take these stats with a grain of salt.\r\nStats actually go through four transformations, for those interested:\r\n1) \"Sandbox\" stat, the \"most raw\" form. These are pretty much useless without transformations applied, and thus are not currently returned in the API. If you really want these, we can provide them. Maybe someone could do something cool with it?\r\n2) \"Investment\" stat (the stat's value after DestinyStatDefinition's interpolation tables and aggregation logic is applied to the \"Sandbox\" stat value)\r\n3) \"Display\" stat (the stat's base UI-visible value after DestinyStatGroupDefinition's interpolation tables are applied to the Investment Stat value. For most stats, this is what is displayed.)\r\n4) Underlying in-game stat (the stat's actual value according to the game, after the game runs dynamic scripts based on the game and character's state. This is the final transformation that BNet does not have access to. For most stats, this is not actually displayed to the user, with the exception of Magazine Size which is then piped back to the UI for display in-game, but not to BNet.)",
	//   "properties": {
	//     "aggregationType": {
	//       "description": "Stats can exist on a character or an item, and they may potentially be aggregated in different ways. The DestinyStatAggregationType enum value indicates the way that this stat is being aggregated.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyStatAggregationType"
	//       }
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hasComputedBlock": {
	//       "description": "True if the stat is computed rather than being delivered as a raw value on items.\r\nFor instance, the Light stat in Destiny 1 was a computed stat.",
	//       "type": "boolean"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "statCategory": {
	//       "description": "The category of the stat, according to the game.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyStatCategory"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Stats"
	// }

	// Stats can exist on a character or an item, and they may potentially be aggregated in different ways.
	// The DestinyStatAggregationType enum value indicates the way that this stat is being aggregated.
	AggregationType StatAggregationType `json:"aggregationType"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// True if the stat is computed rather than being delivered as a raw value on items.
	// For instance, the Light stat in Destiny 1 was a computed stat.
	HasComputedBlock bool `json:"hasComputedBlock"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// The category of the stat, according to the game.
	StatCategory StatCategory `json:"statCategory"`
}

// Destiny.Definitions.DestinyStatDisplayDefinition
//
// Describes the way that an Item Stat (see DestinyStatDefinition) is transformed using the
// DestinyStatGroupDefinition related to that item. See both of the aforementioned definitions for more
// information about the stages of stat transformation.
// This represents the transformation of a stat into a "Display" stat (the closest value that BNet can
// get to the in-game display value of the stat)
type StatDisplayDefinition struct {
	// {
	//   "description": "Describes the way that an Item Stat (see DestinyStatDefinition) is transformed using the DestinyStatGroupDefinition related to that item. See both of the aforementioned definitions for more information about the stages of stat transformation.\r\nThis represents the transformation of a stat into a \"Display\" stat (the closest value that BNet can get to the in-game display value of the stat)",
	//   "properties": {
	//     "displayAsNumeric": {
	//       "description": "If this is true, the stat should be displayed as a number. Otherwise, display it as a progress bar. Or, you know, do whatever you want. There's no displayAsNumeric police.",
	//       "type": "boolean"
	//     },
	//     "displayInterpolation": {
	//       "description": "The interpolation table representing how the Investment Stat is transformed into a Display Stat. \r\nSee DestinyStatDefinition for a description of the stages of stat transformation.",
	//       "items": {
	//         "$ref": "#/components/schemas/Interpolation.InterpolationPoint"
	//       },
	//       "type": "array"
	//     },
	//     "maximumValue": {
	//       "description": "Regardless of the output of interpolation, this is the maximum possible value that the stat can be. It should also be used as the upper bound for displaying the stat as a progress bar (the minimum always being 0)",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "statHash": {
	//       "description": "The hash identifier for the stat being transformed into a Display stat.\r\nUse it to look up the DestinyStatDefinition, or key into a DestinyInventoryItemDefinition's stats property.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyStatDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// If this is true, the stat should be displayed as a number. Otherwise, display it as a progress bar.
	// Or, you know, do whatever you want. There's no displayAsNumeric police.
	DisplayAsNumeric bool `json:"displayAsNumeric"`

	// The interpolation table representing how the Investment Stat is transformed into a Display Stat.
	// See DestinyStatDefinition for a description of the stages of stat transformation.
	DisplayInterpolation []InterpolationPoint `json:"displayInterpolation"`

	// Regardless of the output of interpolation, this is the maximum possible value that the stat can be.
	// It should also be used as the upper bound for displaying the stat as a progress bar (the minimum
	// always being 0)
	MaximumValue int32 `json:"maximumValue"`

	// The hash identifier for the stat being transformed into a Display stat.
	// Use it to look up the DestinyStatDefinition, or key into a DestinyInventoryItemDefinition's stats
	// property.
	StatHash Hash[StatDefinition] `json:"statHash"`
}

// Destiny.Definitions.DestinyStatGroupDefinition
//
// When an inventory item (DestinyInventoryItemDefinition) has Stats (such as Attack Power), the item
// will refer to a Stat Group. This definition enumerates the properties used to transform the item's
// "Investment" stats into "Display" stats.
// See DestinyStatDefinition's documentation for information about the transformation of Stats, and the
// meaning of an Investment vs. a Display stat.
// If you don't want to do these calculations on your own, fear not: pulling live data from the BNet
// endpoints will return display stat values pre-computed and ready for you to use. I highly recommend
// this approach, saves a lot of time and also accounts for certain stat modifiers that can't easily be
// accounted for without live data (such as stat modifiers on Talent Grids and Socket Plugs)
type StatGroupDefinition struct {
	// {
	//   "description": "When an inventory item (DestinyInventoryItemDefinition) has Stats (such as Attack Power), the item will refer to a Stat Group. This definition enumerates the properties used to transform the item's \"Investment\" stats into \"Display\" stats.\r\nSee DestinyStatDefinition's documentation for information about the transformation of Stats, and the meaning of an Investment vs. a Display stat.\r\nIf you don't want to do these calculations on your own, fear not: pulling live data from the BNet endpoints will return display stat values pre-computed and ready for you to use. I highly recommend this approach, saves a lot of time and also accounts for certain stat modifiers that can't easily be accounted for without live data (such as stat modifiers on Talent Grids and Socket Plugs)",
	//   "properties": {
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "maximumValue": {
	//       "description": "The maximum possible value that any stat in this group can be transformed into.\r\nThis is used by stats that *don't* have scaledStats entries below, but that still need to be displayed as a progress bar, in which case this is used as the upper bound for said progress bar. (the lower bound is always 0)",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "overrides": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyStatOverrideDefinition"
	//       },
	//       "description": "The game has the ability to override, based on the stat group, what the localized text is that is displayed for Stats being shown on the item.\r\nMercifully, no Stat Groups use this feature currently. If they start using them, we'll all need to start using them (and those of you who are more prudent than I am can go ahead and start pre-checking for this.)",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "scaledStats": {
	//       "description": "Any stat that requires scaling to be transformed from an \"Investment\" stat to a \"Display\" stat will have an entry in this list. For more information on what those types of stats mean and the transformation process, see DestinyStatDefinition.\r\nIn retrospect, I wouldn't mind if this was a dictionary keyed by the stat hash instead. But I'm going to leave it be because [[After Apple Picking]].",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyStatDisplayDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "uiPosition": {
	//       "description": "This apparently indicates the position of the stats in the UI? I've returned it in case anyone can use it, but it's not of any use to us on BNet. Something's being lost in translation with this value.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "StatGroups"
	// }

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// The maximum possible value that any stat in this group can be transformed into.
	// This is used by stats that *don't* have scaledStats entries below, but that still need to be
	// displayed as a progress bar, in which case this is used as the upper bound for said progress bar.
	// (the lower bound is always 0)
	MaximumValue int32 `json:"maximumValue"`

	// The game has the ability to override, based on the stat group, what the localized text is that is
	// displayed for Stats being shown on the item.
	// Mercifully, no Stat Groups use this feature currently. If they start using them, we'll all need to
	// start using them (and those of you who are more prudent than I am can go ahead and start
	// pre-checking for this.)
	Overrides map[uint32]StatOverrideDefinition `json:"overrides"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// Any stat that requires scaling to be transformed from an "Investment" stat to a "Display" stat will
	// have an entry in this list. For more information on what those types of stats mean and the
	// transformation process, see DestinyStatDefinition.
	// In retrospect, I wouldn't mind if this was a dictionary keyed by the stat hash instead. But I'm
	// going to leave it be because [[After Apple Picking]].
	ScaledStats []StatDisplayDefinition `json:"scaledStats"`

	// This apparently indicates the position of the stats in the UI? I've returned it in case anyone can
	// use it, but it's not of any use to us on BNet. Something's being lost in translation with this
	// value.
	UiPosition int32 `json:"uiPosition"`
}

// Destiny.Definitions.DestinyStatOverrideDefinition
//
// Stat Groups (DestinyStatGroupDefinition) has the ability to override the localized text associated
// with stats that are to be shown on the items with which they are associated.
// This defines a specific overridden stat. You could theoretically check these before rendering your
// stat UI, and for each stat that has an override show these displayProperties instead of those on the
// DestinyStatDefinition.
// Or you could be like us, and skip that for now because the game has yet to actually use this
// feature. But know that it's here, waiting for a resilliant young designer to take up the mantle and
// make us all look foolish by showing the wrong name for stats.
// Note that, if this gets used, the override will apply only to items using the overriding Stat Group.
// Other items will still show the default stat's name/description.
type StatOverrideDefinition struct {
	// {
	//   "description": "Stat Groups (DestinyStatGroupDefinition) has the ability to override the localized text associated with stats that are to be shown on the items with which they are associated.\r\nThis defines a specific overridden stat. You could theoretically check these before rendering your stat UI, and for each stat that has an override show these displayProperties instead of those on the DestinyStatDefinition.\r\nOr you could be like us, and skip that for now because the game has yet to actually use this feature. But know that it's here, waiting for a resilliant young designer to take up the mantle and make us all look foolish by showing the wrong name for stats.\r\nNote that, if this gets used, the override will apply only to items using the overriding Stat Group. Other items will still show the default stat's name/description.",
	//   "properties": {
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "The display properties to show instead of the base DestinyStatDefinition display properties.",
	//       "type": "object"
	//     },
	//     "statHash": {
	//       "description": "The hash identifier of the stat whose display properties are being overridden.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyStatDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The display properties to show instead of the base DestinyStatDefinition display properties.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The hash identifier of the stat whose display properties are being overridden.
	StatHash Hash[StatDefinition] `json:"statHash"`
}

// Destiny.Definitions.DestinyTalentExclusiveGroup
//
// As of Destiny 2, nodes can exist as part of "Exclusive Groups". These differ from exclusive sets in
// that, within the group, many nodes can be activated. But the act of activating any node in the group
// will cause "opposing" nodes (nodes in groups that are not allowed to be activated at the same time
// as this group) to deactivate.
type TalentExclusiveGroup struct {
	// {
	//   "description": "As of Destiny 2, nodes can exist as part of \"Exclusive Groups\". These differ from exclusive sets in that, within the group, many nodes can be activated. But the act of activating any node in the group will cause \"opposing\" nodes (nodes in groups that are not allowed to be activated at the same time as this group) to deactivate.",
	//   "properties": {
	//     "groupHash": {
	//       "description": "The identifier for this exclusive group. Only guaranteed unique within the talent grid, not globally.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "loreHash": {
	//       "description": "If this group has an associated piece of lore to show next to it, this will be the identifier for that DestinyLoreDefinition.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Lore.DestinyLoreDefinition"
	//       }
	//     },
	//     "nodeHashes": {
	//       "description": "A quick reference of the talent nodes that are part of this group, by their Talent Node hashes. (See DestinyTalentNodeDefinition.nodeHash)",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "opposingGroupHashes": {
	//       "description": "A quick reference of Groups whose nodes will be deactivated if any node in this group is activated.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "opposingNodeHashes": {
	//       "description": "A quick reference of Nodes that will be deactivated if any node in this group is activated, by their Talent Node hashes. (See DestinyTalentNodeDefinition.nodeHash)",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The identifier for this exclusive group. Only guaranteed unique within the talent grid, not
	// globally.
	GroupHash uint32 `json:"groupHash"`

	// If this group has an associated piece of lore to show next to it, this will be the identifier for
	// that DestinyLoreDefinition.
	LoreHash Nullable[Hash[LoreDefinition]] `json:"loreHash,omitempty"`

	// A quick reference of the talent nodes that are part of this group, by their Talent Node hashes. (See
	// DestinyTalentNodeDefinition.nodeHash)
	NodeHashes []uint32 `json:"nodeHashes"`

	// A quick reference of Groups whose nodes will be deactivated if any node in this group is activated.
	OpposingGroupHashes []uint32 `json:"opposingGroupHashes"`

	// A quick reference of Nodes that will be deactivated if any node in this group is activated, by their
	// Talent Node hashes. (See DestinyTalentNodeDefinition.nodeHash)
	OpposingNodeHashes []uint32 `json:"opposingNodeHashes"`
}

// Destiny.Definitions.DestinyTalentGridDefinition
//
// The time has unfortunately come to talk about Talent Grids.
// Talent Grids are the most complex and unintuitive part of the Destiny Definition data. Grab a cup of
// coffee before we begin, I can wait.
// Talent Grids were the primary way that items could be customized in Destiny 1. In Destiny 2, for
// now, talent grids have become exclusively used by Subclass/Build items: but the system is still in
// place for it to be used by items should the direction change back toward talent grids.
// Talent Grids have Nodes: the visual circles on the talent grid detail screen that have icons and can
// be activated if you meet certain requirements and pay costs. The actual visual data and effects,
// however, are driven by the "Steps" on Talent Nodes. Any given node will have 1:M of these steps, and
// the specific step that will be considered the "current" step (and thus the dictator of all benefits,
// visual state, and activation requirements on the Node) will almost always not be determined until an
// instance of the item is created. This is how, in Destiny 1, items were able to have such a wide
// variety of what users saw as "Perks": they were actually Talent Grids with nodes that had a wide
// variety of Steps, randomly chosen at the time of item creation.
// Now that Talent Grids are used exclusively by subclasses and builds, all of the properties within
// still apply: but there are additional visual elements on the Subclass/Build screens that are
// superimposed on top of the talent nodes. Unfortunately, BNet doesn't have this data: if you want to
// build a subclass screen, you will have to provide your own "decorative" assets, such as the visual
// connectors between nodes and the fancy colored-fire-bathed character standing behind the nodes.
// DestinyInventoryItem.talentGrid.talentGridHash defines an item's linked Talent Grid, which brings
// you to this definition that contains enough satic data about talent grids to make your head spin.
// These *must* be combined with instanced data - found when live data returns
// DestinyItemTalentGridComponent - in order to derive meaning. The instanced data will reference nodes
// and steps within these definitions, which you will then have to look up in the definition and
// combine with the instanced data to give the user the visual representation of their item's talent
// grid.
type TalentGridDefinition struct {
	// {
	//   "description": "The time has unfortunately come to talk about Talent Grids.\r\nTalent Grids are the most complex and unintuitive part of the Destiny Definition data. Grab a cup of coffee before we begin, I can wait.\r\nTalent Grids were the primary way that items could be customized in Destiny 1. In Destiny 2, for now, talent grids have become exclusively used by Subclass/Build items: but the system is still in place for it to be used by items should the direction change back toward talent grids.\r\nTalent Grids have Nodes: the visual circles on the talent grid detail screen that have icons and can be activated if you meet certain requirements and pay costs. The actual visual data and effects, however, are driven by the \"Steps\" on Talent Nodes. Any given node will have 1:M of these steps, and the specific step that will be considered the \"current\" step (and thus the dictator of all benefits, visual state, and activation requirements on the Node) will almost always not be determined until an instance of the item is created. This is how, in Destiny 1, items were able to have such a wide variety of what users saw as \"Perks\": they were actually Talent Grids with nodes that had a wide variety of Steps, randomly chosen at the time of item creation.\r\nNow that Talent Grids are used exclusively by subclasses and builds, all of the properties within still apply: but there are additional visual elements on the Subclass/Build screens that are superimposed on top of the talent nodes. Unfortunately, BNet doesn't have this data: if you want to build a subclass screen, you will have to provide your own \"decorative\" assets, such as the visual connectors between nodes and the fancy colored-fire-bathed character standing behind the nodes.\r\nDestinyInventoryItem.talentGrid.talentGridHash defines an item's linked Talent Grid, which brings you to this definition that contains enough satic data about talent grids to make your head spin. These *must* be combined with instanced data - found when live data returns DestinyItemTalentGridComponent - in order to derive meaning. The instanced data will reference nodes and steps within these definitions, which you will then have to look up in the definition and combine with the instanced data to give the user the visual representation of their item's talent grid.",
	//   "properties": {
	//     "exclusiveSets": {
	//       "description": "Talent Nodes can exist in \"exclusive sets\": these are sets of nodes in which only a single node in the set can be activated at any given time. Activating a node in this set will automatically deactivate the other nodes in the set (referred to as a \"Swap\").\r\nIf a node in the exclusive set has already been activated, the game will not charge you materials to activate another node in the set, even if you have never activated it before, because you already paid the cost to activate one node in the set.\r\nNot to be confused with Exclusive Groups. (how the heck do we NOT get confused by that? Jeez) See the groups property for information about that only-tangentially-related concept.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyTalentNodeExclusiveSetDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "gridLevelPerColumn": {
	//       "description": "The meaning of this has been lost in the sands of time: it still exists as a property, but appears to be unused in the modern UI of talent grids. It used to imply that each visual \"column\" of talent nodes required identical progression levels in order to be activated. Returning this value in case it is still useful to someone? Perhaps it's just a bit of interesting history.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "groups": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyTalentExclusiveGroup"
	//       },
	//       "description": "Talent Nodes can have \"Exclusive Groups\". These are not to be confused with Exclusive Sets (see exclusiveSets property).\r\nLook at the definition of DestinyTalentExclusiveGroup for more information and how they work. These groups are keyed by the \"groupHash\" from DestinyTalentExclusiveGroup.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "independentNodeIndexes": {
	//       "description": "This is a quick reference to the indexes of nodes that are not part of exclusive sets. Handy for knowing which talent nodes can only be activated directly, rather than via swapping.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "maxGridLevel": {
	//       "description": "The maximum possible level of the Talent Grid: at this level, any nodes are allowed to be activated.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "nodeCategories": {
	//       "description": "BNet wants to show talent nodes grouped by similar purpose with localized titles. This is the ordered list of those categories: if you want to show nodes by category, you can iterate over this list, render the displayProperties for the category as the title, and then iterate over the talent nodes referenced by the category to show the related nodes.\r\nNote that this is different from Exclusive Groups or Sets, because these categories also incorporate \"Independent\" nodes that belong to neither sets nor groups. These are purely for visual grouping of nodes rather than functional grouping.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyTalentNodeCategory"
	//       },
	//       "type": "array"
	//     },
	//     "nodes": {
	//       "description": "The list of Talent Nodes on the Grid (recall that Nodes themselves are really just locations in the UI to show whatever their current Step is. You will only know the current step for a node by retrieving instanced data through platform calls to the API that return DestinyItemTalentGridComponent).",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyTalentNodeDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "progressionHash": {
	//       "description": "The hash identifier of the Progression (DestinyProgressionDefinition) that drives whether and when Talent Nodes can be activated on the Grid. Items will have instances of this Progression, and will gain experience that will eventually cause the grid to increase in level. As the grid's level increases, it will cross the threshold where nodes can be activated. See DestinyTalentGridStepDefinition's activation requirements for more information.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionDefinition"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Talents"
	// }

	// Talent Nodes can exist in "exclusive sets": these are sets of nodes in which only a single node in
	// the set can be activated at any given time. Activating a node in this set will automatically
	// deactivate the other nodes in the set (referred to as a "Swap").
	// If a node in the exclusive set has already been activated, the game will not charge you materials to
	// activate another node in the set, even if you have never activated it before, because you already
	// paid the cost to activate one node in the set.
	// Not to be confused with Exclusive Groups. (how the heck do we NOT get confused by that? Jeez) See
	// the groups property for information about that only-tangentially-related concept.
	ExclusiveSets []TalentNodeExclusiveSetDefinition `json:"exclusiveSets"`

	// The meaning of this has been lost in the sands of time: it still exists as a property, but appears
	// to be unused in the modern UI of talent grids. It used to imply that each visual "column" of talent
	// nodes required identical progression levels in order to be activated. Returning this value in case
	// it is still useful to someone? Perhaps it's just a bit of interesting history.
	GridLevelPerColumn int32 `json:"gridLevelPerColumn"`

	// Talent Nodes can have "Exclusive Groups". These are not to be confused with Exclusive Sets (see
	// exclusiveSets property).
	// Look at the definition of DestinyTalentExclusiveGroup for more information and how they work. These
	// groups are keyed by the "groupHash" from DestinyTalentExclusiveGroup.
	Groups map[uint32]TalentExclusiveGroup `json:"groups"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// This is a quick reference to the indexes of nodes that are not part of exclusive sets. Handy for
	// knowing which talent nodes can only be activated directly, rather than via swapping.
	IndependentNodeIndexes []int32 `json:"independentNodeIndexes"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// The maximum possible level of the Talent Grid: at this level, any nodes are allowed to be activated.
	MaxGridLevel int32 `json:"maxGridLevel"`

	// BNet wants to show talent nodes grouped by similar purpose with localized titles. This is the
	// ordered list of those categories: if you want to show nodes by category, you can iterate over this
	// list, render the displayProperties for the category as the title, and then iterate over the talent
	// nodes referenced by the category to show the related nodes.
	// Note that this is different from Exclusive Groups or Sets, because these categories also incorporate
	// "Independent" nodes that belong to neither sets nor groups. These are purely for visual grouping of
	// nodes rather than functional grouping.
	NodeCategories []TalentNodeCategory `json:"nodeCategories"`

	// The list of Talent Nodes on the Grid (recall that Nodes themselves are really just locations in the
	// UI to show whatever their current Step is. You will only know the current step for a node by
	// retrieving instanced data through platform calls to the API that return
	// DestinyItemTalentGridComponent).
	Nodes []TalentNodeDefinition `json:"nodes"`

	// The hash identifier of the Progression (DestinyProgressionDefinition) that drives whether and when
	// Talent Nodes can be activated on the Grid. Items will have instances of this Progression, and will
	// gain experience that will eventually cause the grid to increase in level. As the grid's level
	// increases, it will cross the threshold where nodes can be activated. See
	// DestinyTalentGridStepDefinition's activation requirements for more information.
	ProgressionHash Hash[ProgressionDefinition] `json:"progressionHash"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyTalentNodeCategory
//
// An artificial construct provided by Bungie.Net, where we attempt to group talent nodes by
// functionality.
// This is a single set of references to Talent Nodes that share a common trait or purpose.
type TalentNodeCategory struct {
	// {
	//   "description": "An artificial construct provided by Bungie.Net, where we attempt to group talent nodes by functionality.\r\nThis is a single set of references to Talent Nodes that share a common trait or purpose.",
	//   "properties": {
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "Will contain at least the \"name\", which will be the title of the category. We will likely not have description and an icon yet, but I'm going to keep my options open.",
	//       "type": "object"
	//     },
	//     "identifier": {
	//       "description": "Mostly just for debug purposes, but if you find it useful you can have it. This is BNet's manually created identifier for this category.",
	//       "type": "string"
	//     },
	//     "isLoreDriven": {
	//       "description": "If true, we found the localized content in a related DestinyLoreDefinition instead of local BNet localization files. This is mostly for ease of my own future investigations.",
	//       "type": "boolean"
	//     },
	//     "nodeHashes": {
	//       "description": "The set of all hash identifiers for Talent Nodes (DestinyTalentNodeDefinition) in this Talent Grid that are part of this Category.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// Will contain at least the "name", which will be the title of the category. We will likely not have
	// description and an icon yet, but I'm going to keep my options open.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// Mostly just for debug purposes, but if you find it useful you can have it. This is BNet's manually
	// created identifier for this category.
	Identifier string `json:"identifier"`

	// If true, we found the localized content in a related DestinyLoreDefinition instead of local BNet
	// localization files. This is mostly for ease of my own future investigations.
	IsLoreDriven bool `json:"isLoreDriven"`

	// The set of all hash identifiers for Talent Nodes (DestinyTalentNodeDefinition) in this Talent Grid
	// that are part of this Category.
	NodeHashes []uint32 `json:"nodeHashes"`
}

// Destiny.Definitions.DestinyTalentNodeDefinition
//
// Talent Grids on items have Nodes. These nodes have positions in the talent grid's UI, and contain
// "Steps" (DestinyTalentNodeStepDefinition), one of whom will be the "Current" step.
// The Current Step determines the visual properties of the node, as well as what the node grants when
// it is activated.
// See DestinyTalentGridDefinition for a more complete overview of how Talent Grids work, and how they
// are used in Destiny 2 (and how they were used in Destiny 1).
type TalentNodeDefinition struct {
	// {
	//   "description": "Talent Grids on items have Nodes. These nodes have positions in the talent grid's UI, and contain \"Steps\" (DestinyTalentNodeStepDefinition), one of whom will be the \"Current\" step.\r\nThe Current Step determines the visual properties of the node, as well as what the node grants when it is activated.\r\nSee DestinyTalentGridDefinition for a more complete overview of how Talent Grids work, and how they are used in Destiny 2 (and how they were used in Destiny 1).",
	//   "properties": {
	//     "autoUnlocks": {
	//       "description": "If true, this node will automatically unlock when the Talent Grid's level reaches the required level of the current step of this node.",
	//       "type": "boolean"
	//     },
	//     "binaryPairNodeIndex": {
	//       "description": "At one point, Talent Nodes supported the idea of \"Binary Pairs\": nodes that overlapped each other visually, and where activating one deactivated the other. They ended up not being used, mostly because Exclusive Sets are *almost* a superset of this concept, but the potential for it to be used still exists in theory.\r\nIf this is ever used, this will be the index into the DestinyTalentGridDefinition.nodes property for the node that is the binary pair match to this node. Activating one deactivates the other.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "column": {
	//       "description": "The visual \"column\" where the node should be shown in the UI. If negative, the node is hidden.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "exclusiveWithNodeHashes": {
	//       "description": "The nodeHash values for nodes that are in an Exclusive Set with this node.\r\nSee DestinyTalentGridDefinition.exclusiveSets for more info about exclusive sets.\r\nAgain, note that these are nodeHashes and *not* nodeIndexes.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "groupHash": {
	//       "description": "As of Destiny 2, nodes can exist as part of \"Exclusive Groups\". These differ from exclusive sets in that, within the group, many nodes can be activated. But the act of activating any node in the group will cause \"opposing\" nodes (nodes in groups that are not allowed to be activated at the same time as this group) to deactivate.\r\nSee DestinyTalentExclusiveGroup for more information on the details. This is an identifier for this node's group, if it is part of one.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "ignoreForCompletion": {
	//       "description": "Comes from the talent grid node style: if true, then this node should be ignored for determining whether the grid is complete.",
	//       "type": "boolean"
	//     },
	//     "isRandom": {
	//       "description": "If this is true, the node's step is determined randomly rather than the first step being chosen.",
	//       "type": "boolean"
	//     },
	//     "isRandomRepurchasable": {
	//       "description": "If this is true, the node can be \"re-rolled\" to acquire a different random current step. This is not used, but still exists for a theoretical future of talent grids.",
	//       "type": "boolean"
	//     },
	//     "lastStepRepeats": {
	//       "description": "At one point, Nodes were going to be able to be activated multiple times, changing the current step and potentially piling on multiple effects from the previously activated steps. This property would indicate if the last step could be activated multiple times. \r\nThis is not currently used, but it isn't out of the question that this could end up being used again in a theoretical future.",
	//       "type": "boolean"
	//     },
	//     "layoutIdentifier": {
	//       "description": "A string identifier for a custom visual layout to apply to this talent node. Unfortunately, we do not have any data for rendering these custom layouts. It will be up to you to interpret these strings and change your UI if you want to have custom UI matching these layouts.",
	//       "type": "string"
	//     },
	//     "loreHash": {
	//       "description": "Talent nodes can be associated with a piece of Lore, generally rendered in a tooltip. This is the hash identifier of the lore element to show, if there is one to be show.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Lore.DestinyLoreDefinition"
	//       }
	//     },
	//     "nodeHash": {
	//       "description": "The hash identifier for the node, which unfortunately is also content version dependent but can be (and ideally, should be) used instead of the nodeIndex to uniquely identify the node.\r\nThe two exist side-by-side for backcompat reasons due to the Great Talent Node Restructuring of Destiny 1, and I ran out of time to remove one of them and standardize on the other. Sorry!",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "nodeIndex": {
	//       "description": "The index into the DestinyTalentGridDefinition's \"nodes\" property where this node is located. Used to uniquely identify the node within the Talent Grid. Note that this is content version dependent: make sure you have the latest version of content before trying to use these properties.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "nodeStyleIdentifier": {
	//       "description": "Comes from the talent grid node style: this identifier should be used to determine how to render the node in the UI.",
	//       "type": "string"
	//     },
	//     "prerequisiteNodeIndexes": {
	//       "description": "Indexes into the DestinyTalentGridDefinition.nodes property for any nodes that must be activated before this one is allowed to be activated.\r\nI would have liked to change this to hashes for Destiny 2, but we have run out of time.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "randomActivationRequirement": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyNodeActivationRequirement"
	//         }
	//       ],
	//       "description": "At one point, you were going to be able to repurchase talent nodes that had random steps, to \"re-roll\" the current step of the node (and thus change the properties of your item). This was to be the activation requirement for performing that re-roll.\r\nThe system still exists to do this, as far as I know, so it may yet come back around!",
	//       "type": "object"
	//     },
	//     "randomStartProgressionBarAtProgression": {
	//       "description": "If the node's step is randomly selected, this is the amount of the Talent Grid's progression experience at which the progression bar for the node should be shown.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "row": {
	//       "description": "The visual \"row\" where the node should be shown in the UI. If negative, then the node is hidden.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "steps": {
	//       "description": "At this point, \"steps\" have been obfuscated into conceptual entities, aggregating the underlying notions of \"properties\" and \"true steps\".\r\nIf you need to know a step as it truly exists - such as when recreating Node logic when processing Vendor data - you'll have to use the \"realSteps\" property below.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyNodeStepDefinition"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// If true, this node will automatically unlock when the Talent Grid's level reaches the required level
	// of the current step of this node.
	AutoUnlocks bool `json:"autoUnlocks"`

	// At one point, Talent Nodes supported the idea of "Binary Pairs": nodes that overlapped each other
	// visually, and where activating one deactivated the other. They ended up not being used, mostly
	// because Exclusive Sets are *almost* a superset of this concept, but the potential for it to be used
	// still exists in theory.
	// If this is ever used, this will be the index into the DestinyTalentGridDefinition.nodes property for
	// the node that is the binary pair match to this node. Activating one deactivates the other.
	BinaryPairNodeIndex int32 `json:"binaryPairNodeIndex"`

	// The visual "column" where the node should be shown in the UI. If negative, the node is hidden.
	Column int32 `json:"column"`

	// The nodeHash values for nodes that are in an Exclusive Set with this node.
	// See DestinyTalentGridDefinition.exclusiveSets for more info about exclusive sets.
	// Again, note that these are nodeHashes and *not* nodeIndexes.
	ExclusiveWithNodeHashes []uint32 `json:"exclusiveWithNodeHashes"`

	// As of Destiny 2, nodes can exist as part of "Exclusive Groups". These differ from exclusive sets in
	// that, within the group, many nodes can be activated. But the act of activating any node in the group
	// will cause "opposing" nodes (nodes in groups that are not allowed to be activated at the same time
	// as this group) to deactivate.
	// See DestinyTalentExclusiveGroup for more information on the details. This is an identifier for this
	// node's group, if it is part of one.
	GroupHash Nullable[uint32] `json:"groupHash,omitempty"`

	// Comes from the talent grid node style: if true, then this node should be ignored for determining
	// whether the grid is complete.
	IgnoreForCompletion bool `json:"ignoreForCompletion"`

	// If this is true, the node's step is determined randomly rather than the first step being chosen.
	IsRandom bool `json:"isRandom"`

	// If this is true, the node can be "re-rolled" to acquire a different random current step. This is not
	// used, but still exists for a theoretical future of talent grids.
	IsRandomRepurchasable bool `json:"isRandomRepurchasable"`

	// At one point, Nodes were going to be able to be activated multiple times, changing the current step
	// and potentially piling on multiple effects from the previously activated steps. This property would
	// indicate if the last step could be activated multiple times.
	// This is not currently used, but it isn't out of the question that this could end up being used again
	// in a theoretical future.
	LastStepRepeats bool `json:"lastStepRepeats"`

	// A string identifier for a custom visual layout to apply to this talent node. Unfortunately, we do
	// not have any data for rendering these custom layouts. It will be up to you to interpret these
	// strings and change your UI if you want to have custom UI matching these layouts.
	LayoutIdentifier string `json:"layoutIdentifier"`

	// Talent nodes can be associated with a piece of Lore, generally rendered in a tooltip. This is the
	// hash identifier of the lore element to show, if there is one to be show.
	LoreHash Nullable[Hash[LoreDefinition]] `json:"loreHash,omitempty"`

	// The hash identifier for the node, which unfortunately is also content version dependent but can be
	// (and ideally, should be) used instead of the nodeIndex to uniquely identify the node.
	// The two exist side-by-side for backcompat reasons due to the Great Talent Node Restructuring of
	// Destiny 1, and I ran out of time to remove one of them and standardize on the other. Sorry!
	NodeHash uint32 `json:"nodeHash"`

	// The index into the DestinyTalentGridDefinition's "nodes" property where this node is located. Used
	// to uniquely identify the node within the Talent Grid. Note that this is content version dependent:
	// make sure you have the latest version of content before trying to use these properties.
	NodeIndex int32 `json:"nodeIndex"`

	// Comes from the talent grid node style: this identifier should be used to determine how to render the
	// node in the UI.
	NodeStyleIdentifier string `json:"nodeStyleIdentifier"`

	// Indexes into the DestinyTalentGridDefinition.nodes property for any nodes that must be activated
	// before this one is allowed to be activated.
	// I would have liked to change this to hashes for Destiny 2, but we have run out of time.
	PrerequisiteNodeIndexes []int32 `json:"prerequisiteNodeIndexes"`

	// At one point, you were going to be able to repurchase talent nodes that had random steps, to
	// "re-roll" the current step of the node (and thus change the properties of your item). This was to be
	// the activation requirement for performing that re-roll.
	// The system still exists to do this, as far as I know, so it may yet come back around!
	RandomActivationRequirement NodeActivationRequirement `json:"randomActivationRequirement"`

	// If the node's step is randomly selected, this is the amount of the Talent Grid's progression
	// experience at which the progression bar for the node should be shown.
	RandomStartProgressionBarAtProgression int32 `json:"randomStartProgressionBarAtProgression"`

	// The visual "row" where the node should be shown in the UI. If negative, then the node is hidden.
	Row int32 `json:"row"`

	// At this point, "steps" have been obfuscated into conceptual entities, aggregating the underlying
	// notions of "properties" and "true steps".
	// If you need to know a step as it truly exists - such as when recreating Node logic when processing
	// Vendor data - you'll have to use the "realSteps" property below.
	Steps []NodeStepDefinition `json:"steps"`
}

// Destiny.Definitions.DestinyTalentNodeExclusiveSetDefinition
//
// The list of indexes into the Talent Grid's "nodes" property for nodes in this exclusive set. (See
// DestinyTalentNodeDefinition.nodeIndex)
type TalentNodeExclusiveSetDefinition struct {
	// {
	//   "description": "The list of indexes into the Talent Grid's \"nodes\" property for nodes in this exclusive set. (See DestinyTalentNodeDefinition.nodeIndex)",
	//   "properties": {
	//     "nodeIndexes": {
	//       "description": "The list of node indexes for the exclusive set. Historically, these were indexes. I would have liked to replace this with nodeHashes for consistency, but it's way too late for that. (9:09 PM, he's right!)",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The list of node indexes for the exclusive set. Historically, these were indexes. I would have liked
	// to replace this with nodeHashes for consistency, but it's way too late for that. (9:09 PM, he's
	// right!)
	NodeIndexes []int32 `json:"nodeIndexes"`
}

// Destiny.Definitions.DestinyTalentNodeStepDamageTypes
type TalentNodeStepDamageTypes int32

const (
	TalentNodeStepDamageTypes_None    = TalentNodeStepDamageTypes(0)
	TalentNodeStepDamageTypes_Kinetic = TalentNodeStepDamageTypes(1)
	TalentNodeStepDamageTypes_Arc     = TalentNodeStepDamageTypes(2)
	TalentNodeStepDamageTypes_Solar   = TalentNodeStepDamageTypes(4)
	TalentNodeStepDamageTypes_Void    = TalentNodeStepDamageTypes(8)
	TalentNodeStepDamageTypes_All     = TalentNodeStepDamageTypes(15)
)

// Destiny.Definitions.DestinyTalentNodeStepGroups
//
// These properties are an attempt to categorize talent node steps by certain common properties. See
// the related enumerations for the type of properties being categorized.
type TalentNodeStepGroups struct {
	// {
	//   "description": "These properties are an attempt to categorize talent node steps by certain common properties. See the related enumerations for the type of properties being categorized.",
	//   "properties": {
	//     "damageTypes": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyTalentNodeStepDamageTypes"
	//       }
	//     },
	//     "guardianAttributes": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyTalentNodeStepGuardianAttributes"
	//       }
	//     },
	//     "impactEffects": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyTalentNodeStepImpactEffects"
	//       }
	//     },
	//     "lightAbilities": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyTalentNodeStepLightAbilities"
	//       }
	//     },
	//     "weaponPerformance": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyTalentNodeStepWeaponPerformances"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	DamageTypes BitmaskSet[TalentNodeStepDamageTypes] `json:"damageTypes"`

	GuardianAttributes BitmaskSet[TalentNodeStepGuardianAttributes] `json:"guardianAttributes"`

	ImpactEffects BitmaskSet[TalentNodeStepImpactEffects] `json:"impactEffects"`

	LightAbilities BitmaskSet[TalentNodeStepLightAbilities] `json:"lightAbilities"`

	WeaponPerformance BitmaskSet[TalentNodeStepWeaponPerformances] `json:"weaponPerformance"`
}

// Destiny.Definitions.DestinyTalentNodeStepGuardianAttributes
type TalentNodeStepGuardianAttributes int32

const (
	TalentNodeStepGuardianAttributes_None         = TalentNodeStepGuardianAttributes(0)
	TalentNodeStepGuardianAttributes_Stats        = TalentNodeStepGuardianAttributes(1)
	TalentNodeStepGuardianAttributes_Shields      = TalentNodeStepGuardianAttributes(2)
	TalentNodeStepGuardianAttributes_Health       = TalentNodeStepGuardianAttributes(4)
	TalentNodeStepGuardianAttributes_Revive       = TalentNodeStepGuardianAttributes(8)
	TalentNodeStepGuardianAttributes_AimUnderFire = TalentNodeStepGuardianAttributes(16)
	TalentNodeStepGuardianAttributes_Radar        = TalentNodeStepGuardianAttributes(32)
	TalentNodeStepGuardianAttributes_Invisibility = TalentNodeStepGuardianAttributes(64)
	TalentNodeStepGuardianAttributes_Reputations  = TalentNodeStepGuardianAttributes(128)
	TalentNodeStepGuardianAttributes_All          = TalentNodeStepGuardianAttributes(255)
)

// Destiny.Definitions.DestinyTalentNodeStepImpactEffects
type TalentNodeStepImpactEffects int32

const (
	TalentNodeStepImpactEffects_None             = TalentNodeStepImpactEffects(0)
	TalentNodeStepImpactEffects_ArmorPiercing    = TalentNodeStepImpactEffects(1)
	TalentNodeStepImpactEffects_Ricochet         = TalentNodeStepImpactEffects(2)
	TalentNodeStepImpactEffects_Flinch           = TalentNodeStepImpactEffects(4)
	TalentNodeStepImpactEffects_CollateralDamage = TalentNodeStepImpactEffects(8)
	TalentNodeStepImpactEffects_Disorient        = TalentNodeStepImpactEffects(16)
	TalentNodeStepImpactEffects_HighlightTarget  = TalentNodeStepImpactEffects(32)
	TalentNodeStepImpactEffects_All              = TalentNodeStepImpactEffects(63)
)

// Destiny.Definitions.DestinyTalentNodeStepLightAbilities
type TalentNodeStepLightAbilities int32

const (
	TalentNodeStepLightAbilities_None          = TalentNodeStepLightAbilities(0)
	TalentNodeStepLightAbilities_Grenades      = TalentNodeStepLightAbilities(1)
	TalentNodeStepLightAbilities_Melee         = TalentNodeStepLightAbilities(2)
	TalentNodeStepLightAbilities_MovementModes = TalentNodeStepLightAbilities(4)
	TalentNodeStepLightAbilities_Orbs          = TalentNodeStepLightAbilities(8)
	TalentNodeStepLightAbilities_SuperEnergy   = TalentNodeStepLightAbilities(16)
	TalentNodeStepLightAbilities_SuperMods     = TalentNodeStepLightAbilities(32)
	TalentNodeStepLightAbilities_All           = TalentNodeStepLightAbilities(63)
)

// Destiny.Definitions.DestinyTalentNodeStepWeaponPerformances
type TalentNodeStepWeaponPerformances int32

const (
	TalentNodeStepWeaponPerformances_None                  = TalentNodeStepWeaponPerformances(0)
	TalentNodeStepWeaponPerformances_RateOfFire            = TalentNodeStepWeaponPerformances(1)
	TalentNodeStepWeaponPerformances_Damage                = TalentNodeStepWeaponPerformances(2)
	TalentNodeStepWeaponPerformances_Accuracy              = TalentNodeStepWeaponPerformances(4)
	TalentNodeStepWeaponPerformances_Range                 = TalentNodeStepWeaponPerformances(8)
	TalentNodeStepWeaponPerformances_Zoom                  = TalentNodeStepWeaponPerformances(16)
	TalentNodeStepWeaponPerformances_Recoil                = TalentNodeStepWeaponPerformances(32)
	TalentNodeStepWeaponPerformances_Ready                 = TalentNodeStepWeaponPerformances(64)
	TalentNodeStepWeaponPerformances_Reload                = TalentNodeStepWeaponPerformances(128)
	TalentNodeStepWeaponPerformances_HairTrigger           = TalentNodeStepWeaponPerformances(256)
	TalentNodeStepWeaponPerformances_AmmoAndMagazine       = TalentNodeStepWeaponPerformances(512)
	TalentNodeStepWeaponPerformances_TrackingAndDetonation = TalentNodeStepWeaponPerformances(1024)
	TalentNodeStepWeaponPerformances_ShotgunSpread         = TalentNodeStepWeaponPerformances(2048)
	TalentNodeStepWeaponPerformances_ChargeTime            = TalentNodeStepWeaponPerformances(4096)
	TalentNodeStepWeaponPerformances_All                   = TalentNodeStepWeaponPerformances(8191)
)

// Destiny.Definitions.DestinyUnlockDefinition
//
// Unlock Flags are small bits (literally, a bit, as in a boolean value) that the game server uses for
// an extremely wide range of state checks, progress storage, and other interesting tidbits of
// information.
type UnlockDefinition struct {
	// {
	//   "description": "Unlock Flags are small bits (literally, a bit, as in a boolean value) that the game server uses for an extremely wide range of state checks, progress storage, and other interesting tidbits of information.",
	//   "properties": {
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "Sometimes, but not frequently, these unlock flags also have human readable information: usually when they are being directly tested for some requirement, in which case the string is a localized description of why the requirement check failed.",
	//       "type": "object"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Unlocks"
	// }

	// Sometimes, but not frequently, these unlock flags also have human readable information: usually when
	// they are being directly tested for some requirement, in which case the string is a localized
	// description of why the requirement check failed.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyUnlockExpressionDefinition
//
// Where the sausage gets made. Unlock Expressions are the foundation of the game's gating mechanics
// and investment-related restrictions. They can test Unlock Flags and Unlock Values for certain
// states, using a sufficient amount of logical operators such that unlock expressions are effectively
// Turing complete.
// Use UnlockExpressionParser to evaluate expressions using an IUnlockContext parsed from Babel.
type UnlockExpressionDefinition struct {
	// {
	//   "description": "Where the sausage gets made. Unlock Expressions are the foundation of the game's gating mechanics and investment-related restrictions. They can test Unlock Flags and Unlock Values for certain states, using a sufficient amount of logical operators such that unlock expressions are effectively Turing complete.\r\nUse UnlockExpressionParser to evaluate expressions using an IUnlockContext parsed from Babel.",
	//   "properties": {
	//     "scope": {
	//       "description": "A shortcut for determining the most restrictive gating that this expression performs. See the DestinyGatingScope enum's documentation for more details.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyGatingScope"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// A shortcut for determining the most restrictive gating that this expression performs. See the
	// DestinyGatingScope enum's documentation for more details.
	Scope GatingScope `json:"scope"`
}

// Destiny.Definitions.DestinyUnlockValueDefinition
//
// An Unlock Value is an internal integer value, stored on the server and used in a variety of ways,
// most frequently for the gating/requirement checks that the game performs across all of its main
// features. They can also be used as the storage data for mapped Progressions, Objectives, and other
// features that require storage of variable numeric values.
type UnlockValueDefinition struct {
	// {
	//   "description": "An Unlock Value is an internal integer value, stored on the server and used in a variety of ways, most frequently for the gating/requirement checks that the game performs across all of its main features. They can also be used as the storage data for mapped Progressions, Objectives, and other features that require storage of variable numeric values.",
	//   "properties": {
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyVendorAcceptedItemDefinition
//
// If you ever wondered how the Vault works, here it is.
// The Vault is merely a set of inventory buckets that exist on your Profile/Account level. When you
// transfer items in the Vault, the game is using the Vault Vendor's
// DestinyVendorAcceptedItemDefinitions to see where the appropriate destination bucket is for the
// source bucket from whence your item is moving. If it finds such an entry, it transfers the item to
// the other bucket.
// The mechanics for Postmaster works similarly, which is also a vendor. All driven by Accepted Items.
type VendorAcceptedItemDefinition struct {
	// {
	//   "description": "If you ever wondered how the Vault works, here it is.\r\nThe Vault is merely a set of inventory buckets that exist on your Profile/Account level. When you transfer items in the Vault, the game is using the Vault Vendor's DestinyVendorAcceptedItemDefinitions to see where the appropriate destination bucket is for the source bucket from whence your item is moving. If it finds such an entry, it transfers the item to the other bucket.\r\nThe mechanics for Postmaster works similarly, which is also a vendor. All driven by Accepted Items.",
	//   "properties": {
	//     "acceptedInventoryBucketHash": {
	//       "description": "The \"source\" bucket for a transfer. When a user wants to transfer an item, the appropriate DestinyVendorDefinition's acceptedItems property is evaluated, looking for an entry where acceptedInventoryBucketHash matches the bucket that the item being transferred is currently located. If it exists, the item will be transferred into whatever bucket is defined by destinationInventoryBucketHash.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryBucketDefinition"
	//       }
	//     },
	//     "destinationInventoryBucketHash": {
	//       "description": "This is the bucket where the item being transferred will be put, given that it was being transferred *from* the bucket defined in acceptedInventoryBucketHash.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryBucketDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The "source" bucket for a transfer. When a user wants to transfer an item, the appropriate
	// DestinyVendorDefinition's acceptedItems property is evaluated, looking for an entry where
	// acceptedInventoryBucketHash matches the bucket that the item being transferred is currently located.
	// If it exists, the item will be transferred into whatever bucket is defined by
	// destinationInventoryBucketHash.
	AcceptedInventoryBucketHash Hash[InventoryBucketDefinition] `json:"acceptedInventoryBucketHash"`

	// This is the bucket where the item being transferred will be put, given that it was being transferred
	// *from* the bucket defined in acceptedInventoryBucketHash.
	DestinationInventoryBucketHash Hash[InventoryBucketDefinition] `json:"destinationInventoryBucketHash"`
}

// Destiny.Definitions.DestinyVendorActionDefinition
//
// If a vendor can ever end up performing actions, these are the properties that will be related to
// those actions. I'm not going to bother documenting this yet, as it is unused and unclear if it will
// ever be used... but in case it is ever populated and someone finds it useful, it is defined here.
type VendorActionDefinition struct {
	// {
	//   "description": "If a vendor can ever end up performing actions, these are the properties that will be related to those actions. I'm not going to bother documenting this yet, as it is unused and unclear if it will ever be used... but in case it is ever populated and someone finds it useful, it is defined here.",
	//   "properties": {
	//     "actionHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "actionId": {
	//       "type": "string"
	//     },
	//     "autoPerformAction": {
	//       "type": "boolean"
	//     },
	//     "description": {
	//       "type": "string"
	//     },
	//     "executeSeconds": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "icon": {
	//       "type": "string"
	//     },
	//     "isPositive": {
	//       "type": "boolean"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "verb": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	ActionHash uint32 `json:"actionHash"`

	ActionID string `json:"actionId"`

	AutoPerformAction bool `json:"autoPerformAction"`

	Description string `json:"description"`

	ExecuteSeconds int32 `json:"executeSeconds"`

	Icon string `json:"icon"`

	IsPositive bool `json:"isPositive"`

	Name string `json:"name"`

	Verb string `json:"verb"`
}

// Destiny.Definitions.DestinyVendorCategoryEntryDefinition
//
// This is the definition for a single Vendor Category, into which Sale Items are grouped.
type VendorCategoryEntryDefinition struct {
	// {
	//   "description": "This is the definition for a single Vendor Category, into which Sale Items are grouped.",
	//   "properties": {
	//     "buyStringOverride": {
	//       "description": "The localized string for making purchases from this category, if it is different from the vendor's string for purchasing.",
	//       "type": "string"
	//     },
	//     "categoryHash": {
	//       "description": "The hashed identifier for the category.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "categoryIndex": {
	//       "description": "The index of the category in the original category definitions for the vendor.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "disabledDescription": {
	//       "description": "If the category is disabled, this is the localized description to show.",
	//       "type": "string"
	//     },
	//     "displayTitle": {
	//       "description": "The localized title of the category.",
	//       "type": "string"
	//     },
	//     "hideFromRegularPurchase": {
	//       "description": "True if this category doesn't allow purchases.",
	//       "type": "boolean"
	//     },
	//     "hideIfNoCurrency": {
	//       "description": "If you don't have the currency required to buy items from this category, should the items be hidden?",
	//       "type": "boolean"
	//     },
	//     "isDisplayOnly": {
	//       "description": "If true, this category only displays items: you can't purchase anything in them.",
	//       "type": "boolean"
	//     },
	//     "isPreview": {
	//       "description": "Sometimes a category isn't actually used to sell items, but rather to preview them. This implies different UI (and manual placement of the category in the UI) in the game, and special treatment.",
	//       "type": "boolean"
	//     },
	//     "overlay": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorCategoryOverlayDefinition"
	//         }
	//       ],
	//       "description": "If this category has an overlay prompt that should appear, this contains the details of that prompt.",
	//       "type": "object"
	//     },
	//     "quantityAvailable": {
	//       "description": "The amount of items that will be available when this category is shown.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "resetIntervalMinutesOverride": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "resetOffsetMinutesOverride": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "showUnavailableItems": {
	//       "description": "If items aren't up for sale in this category, should we still show them (greyed out)?",
	//       "type": "boolean"
	//     },
	//     "sortValue": {
	//       "description": "Used in sorting items in vendors... but there's a lot more to it. Just go with the order provided in the itemIndexes property on the DestinyVendorCategoryComponent instead, it should be more reliable than trying to recalculate it yourself.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "vendorItemIndexes": {
	//       "description": "A shortcut for the vendor item indexes sold under this category. Saves us from some expensive reorganization at runtime.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The localized string for making purchases from this category, if it is different from the vendor's
	// string for purchasing.
	BuyStringOverride string `json:"buyStringOverride"`

	// The hashed identifier for the category.
	CategoryHash uint32 `json:"categoryHash"`

	// The index of the category in the original category definitions for the vendor.
	CategoryIndex int32 `json:"categoryIndex"`

	// If the category is disabled, this is the localized description to show.
	DisabledDescription string `json:"disabledDescription"`

	// The localized title of the category.
	DisplayTitle string `json:"displayTitle"`

	// True if this category doesn't allow purchases.
	HideFromRegularPurchase bool `json:"hideFromRegularPurchase"`

	// If you don't have the currency required to buy items from this category, should the items be hidden?
	HideIfNoCurrency bool `json:"hideIfNoCurrency"`

	// If true, this category only displays items: you can't purchase anything in them.
	IsDisplayOnly bool `json:"isDisplayOnly"`

	// Sometimes a category isn't actually used to sell items, but rather to preview them. This implies
	// different UI (and manual placement of the category in the UI) in the game, and special treatment.
	IsPreview bool `json:"isPreview"`

	// If this category has an overlay prompt that should appear, this contains the details of that prompt.
	Overlay VendorCategoryOverlayDefinition `json:"overlay"`

	// The amount of items that will be available when this category is shown.
	QuantityAvailable int32 `json:"quantityAvailable"`

	ResetIntervalMinutesOverride int32 `json:"resetIntervalMinutesOverride"`

	ResetOffsetMinutesOverride int32 `json:"resetOffsetMinutesOverride"`

	// If items aren't up for sale in this category, should we still show them (greyed out)?
	ShowUnavailableItems bool `json:"showUnavailableItems"`

	// Used in sorting items in vendors... but there's a lot more to it. Just go with the order provided in
	// the itemIndexes property on the DestinyVendorCategoryComponent instead, it should be more reliable
	// than trying to recalculate it yourself.
	SortValue int32 `json:"sortValue"`

	// A shortcut for the vendor item indexes sold under this category. Saves us from some expensive
	// reorganization at runtime.
	VendorItemIndexes []int32 `json:"vendorItemIndexes"`
}

// Destiny.Definitions.DestinyVendorCategoryOverlayDefinition
//
// The details of an overlay prompt to show to a user. They are all fairly self-explanatory localized
// strings that can be shown.
type VendorCategoryOverlayDefinition struct {
	// {
	//   "description": "The details of an overlay prompt to show to a user. They are all fairly self-explanatory localized strings that can be shown.",
	//   "properties": {
	//     "choiceDescription": {
	//       "type": "string"
	//     },
	//     "currencyItemHash": {
	//       "description": "If this overlay has a currency item that it features, this is said featured item.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "description": {
	//       "type": "string"
	//     },
	//     "icon": {
	//       "type": "string"
	//     },
	//     "title": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	ChoiceDescription string `json:"choiceDescription"`

	// If this overlay has a currency item that it features, this is said featured item.
	CurrencyItemHash Nullable[Hash[InventoryItemDefinition]] `json:"currencyItemHash,omitempty"`

	Description string `json:"description"`

	Icon string `json:"icon"`

	Title string `json:"title"`
}

// Destiny.Definitions.DestinyVendorDefinition
//
// These are the definitions for Vendors.
// In Destiny, a Vendor can be a lot of things - some things that you wouldn't expect, and some things
// that you don't even see directly in the game. Vendors are the Dolly Levi of the Destiny universe.
// - Traditional Vendors as you see in game: people who you come up to and who give you quests,
// rewards, or who you can buy things from.
// - Kiosks/Collections, which are really just Vendors that don't charge currency (or charge some
// pittance of a currency) and whose gating for purchases revolves more around your character's state.
// - Previews for rewards or the contents of sacks. These are implemented as Vendors, where you can't
// actually purchase from them but the items that they have for sale and the categories of sale items
// reflect the rewards or contents of the sack. This is so that the game could reuse the existing
// Vendor display UI for rewards and save a bunch of wheel reinvention.
// - Item Transfer capabilities, like the Vault and Postmaster. Vendors can have "acceptedItem" buckets
// that determine the source and destination buckets for transfers. When you interact with such a
// vendor, these buckets are what gets shown in the UI instead of any items that the Vendor would have
// for sale. Yep, the Vault is a vendor.
// It is pretty much guaranteed that they'll be used for even more features in the future. They have
// come to be seen more as generic categorized containers for items than "vendors" in a traditional
// sense, for better or worse.
// Where possible and time allows, we'll attempt to split those out into their own more digestible
// derived "Definitions": but often time does not allow that, as you can see from the above ways that
// vendors are used which we never split off from Vendor Definitions externally.
// Since Vendors are so many things to so many parts of the game, the definition is understandably
// complex. You will want to combine this data with live Vendor information from the API when it is
// available.
type VendorDefinition struct {
	// {
	//   "description": "These are the definitions for Vendors.\r\nIn Destiny, a Vendor can be a lot of things - some things that you wouldn't expect, and some things that you don't even see directly in the game. Vendors are the Dolly Levi of the Destiny universe.\r\n- Traditional Vendors as you see in game: people who you come up to and who give you quests, rewards, or who you can buy things from.\r\n- Kiosks/Collections, which are really just Vendors that don't charge currency (or charge some pittance of a currency) and whose gating for purchases revolves more around your character's state.\r\n- Previews for rewards or the contents of sacks. These are implemented as Vendors, where you can't actually purchase from them but the items that they have for sale and the categories of sale items reflect the rewards or contents of the sack. This is so that the game could reuse the existing Vendor display UI for rewards and save a bunch of wheel reinvention.\r\n- Item Transfer capabilities, like the Vault and Postmaster. Vendors can have \"acceptedItem\" buckets that determine the source and destination buckets for transfers. When you interact with such a vendor, these buckets are what gets shown in the UI instead of any items that the Vendor would have for sale. Yep, the Vault is a vendor.\r\nIt is pretty much guaranteed that they'll be used for even more features in the future. They have come to be seen more as generic categorized containers for items than \"vendors\" in a traditional sense, for better or worse.\r\nWhere possible and time allows, we'll attempt to split those out into their own more digestible derived \"Definitions\": but often time does not allow that, as you can see from the above ways that vendors are used which we never split off from Vendor Definitions externally.\r\nSince Vendors are so many things to so many parts of the game, the definition is understandably complex. You will want to combine this data with live Vendor information from the API when it is available.",
	//   "properties": {
	//     "acceptedItems": {
	//       "description": "If the Vendor is actually a vehicle for the transferring of items (like the Vault and Postmaster vendors), this defines the list of source-\u003edestination buckets for transferring.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorAcceptedItemDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "actions": {
	//       "description": "Describes \"actions\" that can be performed on a vendor. Currently, none of these exist. But theoretically a Vendor could let you interact with it by performing actions. We'll see what these end up looking like if they ever get used.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorActionDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "buyString": {
	//       "description": "If the vendor has a custom localized string describing the \"buy\" action, that is returned here.",
	//       "type": "string"
	//     },
	//     "categories": {
	//       "description": "These are the headers for sections of items that the vendor is selling. When you see items organized by category in the header, it is these categories that it is showing.\r\nWell, technically not *exactly* these. On BNet, it doesn't make sense to have categories be \"paged\" as we do in Destiny, so we run some heuristics to attempt to aggregate pages of categories together. \r\nThese are the categories post-concatenation, if the vendor had concatenation applied. If you want the pre-aggregated category data, use originalCategories.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorCategoryEntryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "consolidateCategories": {
	//       "description": "If TRUE, consolidate categories that only differ by trivial properties (such as having minor differences in name)",
	//       "type": "boolean"
	//     },
	//     "displayCategories": {
	//       "description": "Display Categories are different from \"categories\" in that these are specifically for visual grouping and display of categories in Vendor UI. \r\nThe \"categories\" structure is for validation of the contained items, and can be categorized entirely separately from \"Display Categories\", there need be and often will be no meaningful relationship between the two.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyDisplayCategoryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "displayItemHash": {
	//       "description": "If the vendor has an item that should be displayed as the \"featured\" item, this is the hash identifier for that DestinyVendorItemDefinition.\r\nApparently this is usually a related currency, like a reputation token. But it need not be restricted to that.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDisplayPropertiesDefinition"
	//     },
	//     "enabled": {
	//       "description": "If a vendor is not enabled, we won't even save the vendor's definition, and we won't return any items or info about them. It's as if they don't exist.",
	//       "type": "boolean"
	//     },
	//     "factionHash": {
	//       "description": "If the Vendor has a faction, this hash will be valid and point to a DestinyFactionDefinition.\r\nThe game UI and BNet often mine the faction definition for additional elements and details to place on the screen, such as the faction's Progression status (aka \"Reputation\").",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyFactionDefinition"
	//       }
	//     },
	//     "failureStrings": {
	//       "description": "If an item can't be purchased from the vendor, there may be many \"custom\"/game state specific reasons why not.\r\nThis is a list of localized strings with messages for those custom failures. The live BNet data will return a failureIndexes property for items that can't be purchased: using those values to index into this array, you can show the user the appropriate failure message for the item that can't be bought.",
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     },
	//     "groups": {
	//       "description": "A vendor can be a part of 0 or 1 \"groups\" at a time: a group being a collection of Vendors related by either location or function/purpose. It's used for our our Companion Vendor UI. Only one of these can be active for a Vendor at a time.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorGroupReference"
	//       },
	//       "type": "array"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "ignoreSaleItemHashes": {
	//       "description": "Some items don't make sense to return in the API, for example because they represent an action to be performed rather than an item being sold. I'd rather we not do this, but at least in the short term this is a workable workaround.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "inhibitBuying": {
	//       "description": "If this is true, you aren't allowed to buy whatever the vendor is selling.",
	//       "type": "boolean"
	//     },
	//     "inhibitSelling": {
	//       "description": "If this is true, you're not allowed to sell whatever the vendor is buying.",
	//       "type": "boolean"
	//     },
	//     "interactions": {
	//       "description": "In addition to selling items, vendors can have \"interactions\": UI where you \"talk\" with the vendor and they offer you a reward, some item, or merely acknowledge via dialog that you did something cool.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorInteractionDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "inventoryFlyouts": {
	//       "description": "If the vendor shows you items from your own inventory - such as the Vault vendor does - this data describes the UI around showing those inventory buckets and which ones get shown.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorInventoryFlyoutDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "itemList": {
	//       "description": "If the vendor sells items (or merely has a list of items to show like the \"Sack\" vendors do), this is the list of those items that the vendor can sell. From this list, only a subset will be available from the vendor at any given time, selected randomly and reset on the vendor's refresh interval.\r\nNote that a vendor can sell the same item multiple ways: for instance, nothing stops a vendor from selling you some specific weapon but using two different currencies, or the same weapon at multiple \"item levels\".",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorItemDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "locations": {
	//       "description": "A vendor can be at different places in the world depending on the game/character/account state. This is the list of possible locations for the vendor, along with conditions we use to determine which one is currently active.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Vendors.DestinyVendorLocationDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "originalCategories": {
	//       "description": "See the categories property for a description of categories and why originalCategories exists.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorCategoryEntryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "resetIntervalMinutes": {
	//       "description": "A number used for calculating the frequency of a vendor's inventory resetting/refreshing.\r\nDon't worry about calculating this - we do it on the server side and send you the next refresh date with the live data.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "resetOffsetMinutes": {
	//       "description": "Again, used for reset/refreshing of inventory. Don't worry too much about it. Unless you want to.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "returnWithVendorRequest": {
	//       "description": "As many of you know, Vendor data has historically been pretty brutal on the BNet servers. In an effort to reduce this workload, only Vendors with this flag set will be returned on Vendor requests. This allows us to filter out Vendors that don't dynamic data that's particularly useful: things like \"Preview/Sack\" vendors, for example, that you can usually suss out the details for using just the definitions themselves.",
	//       "type": "boolean"
	//     },
	//     "sellString": {
	//       "description": "Ditto for selling. Not that you can sell items to a vendor anymore. Will it come back? Who knows. The string's still there.",
	//       "type": "string"
	//     },
	//     "services": {
	//       "description": "BNet doesn't use this data yet, but it appears to be an optional list of flavor text about services that the Vendor can provide.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorServiceDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "unlockRanges": {
	//       "description": "If we were able to predict the dates when this Vendor will be visible/available, this will be the list of those date ranges. Sadly, we're not able to predict this very frequently, so this will often be useless data.",
	//       "items": {
	//         "$ref": "#/components/schemas/Dates.DateRange"
	//       },
	//       "type": "array"
	//     },
	//     "vendorBanner": {
	//       "description": "If the vendor has a custom banner image, that can be found here.",
	//       "type": "string"
	//     },
	//     "vendorIdentifier": {
	//       "description": "The internal identifier for the Vendor. A holdover from the old days of Vendors, but we don't have time to refactor it away.",
	//       "type": "string"
	//     },
	//     "vendorPortrait": {
	//       "description": "A portrait of the Vendor's smiling mug. Or frothing tentacles.",
	//       "type": "string"
	//     },
	//     "vendorProgressionType": {
	//       "description": "The type of reward progression that this vendor has. Default - The original rank progression from token redemption. Ritual - Progression from ranks in ritual content. For example: Crucible (Shaxx), Gambit (Drifter), and Battlegrounds (War Table).",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyVendorProgressionType"
	//       }
	//     },
	//     "vendorSubcategoryIdentifier": {
	//       "description": "The identifier of the VendorCategoryDefinition for this vendor's subcategory.",
	//       "type": "string"
	//     },
	//     "visible": {
	//       "description": "If a vendor is not visible, we still have and will give vendor definition info, but we won't use them for things like Advisors or UI.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Vendors"
	// }

	// If the Vendor is actually a vehicle for the transferring of items (like the Vault and Postmaster
	// vendors), this defines the list of source->destination buckets for transferring.
	AcceptedItems []VendorAcceptedItemDefinition `json:"acceptedItems"`

	// Describes "actions" that can be performed on a vendor. Currently, none of these exist. But
	// theoretically a Vendor could let you interact with it by performing actions. We'll see what these
	// end up looking like if they ever get used.
	Actions []VendorActionDefinition `json:"actions"`

	// If the vendor has a custom localized string describing the "buy" action, that is returned here.
	BuyString string `json:"buyString"`

	// These are the headers for sections of items that the vendor is selling. When you see items organized
	// by category in the header, it is these categories that it is showing.
	// Well, technically not *exactly* these. On BNet, it doesn't make sense to have categories be "paged"
	// as we do in Destiny, so we run some heuristics to attempt to aggregate pages of categories together.
	// These are the categories post-concatenation, if the vendor had concatenation applied. If you want
	// the pre-aggregated category data, use originalCategories.
	Categories []VendorCategoryEntryDefinition `json:"categories"`

	// If TRUE, consolidate categories that only differ by trivial properties (such as having minor
	// differences in name)
	ConsolidateCategories bool `json:"consolidateCategories"`

	// Display Categories are different from "categories" in that these are specifically for visual
	// grouping and display of categories in Vendor UI.
	// The "categories" structure is for validation of the contained items, and can be categorized entirely
	// separately from "Display Categories", there need be and often will be no meaningful relationship
	// between the two.
	DisplayCategories []DisplayCategoryDefinition `json:"displayCategories"`

	// If the vendor has an item that should be displayed as the "featured" item, this is the hash
	// identifier for that DestinyVendorItemDefinition.
	// Apparently this is usually a related currency, like a reputation token. But it need not be
	// restricted to that.
	DisplayItemHash Hash[InventoryItemDefinition] `json:"displayItemHash"`

	DisplayProperties VendorDisplayPropertiesDefinition `json:"displayProperties"`

	// If a vendor is not enabled, we won't even save the vendor's definition, and we won't return any
	// items or info about them. It's as if they don't exist.
	Enabled bool `json:"enabled"`

	// If the Vendor has a faction, this hash will be valid and point to a DestinyFactionDefinition.
	// The game UI and BNet often mine the faction definition for additional elements and details to place
	// on the screen, such as the faction's Progression status (aka "Reputation").
	FactionHash Hash[FactionDefinition] `json:"factionHash"`

	// If an item can't be purchased from the vendor, there may be many "custom"/game state specific
	// reasons why not.
	// This is a list of localized strings with messages for those custom failures. The live BNet data will
	// return a failureIndexes property for items that can't be purchased: using those values to index into
	// this array, you can show the user the appropriate failure message for the item that can't be bought.
	FailureStrings []string `json:"failureStrings"`

	// A vendor can be a part of 0 or 1 "groups" at a time: a group being a collection of Vendors related
	// by either location or function/purpose. It's used for our our Companion Vendor UI. Only one of these
	// can be active for a Vendor at a time.
	Groups []VendorGroupReference `json:"groups"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// Some items don't make sense to return in the API, for example because they represent an action to be
	// performed rather than an item being sold. I'd rather we not do this, but at least in the short term
	// this is a workable workaround.
	IgnoreSaleItemHashes []uint32 `json:"ignoreSaleItemHashes"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, you aren't allowed to buy whatever the vendor is selling.
	InhibitBuying bool `json:"inhibitBuying"`

	// If this is true, you're not allowed to sell whatever the vendor is buying.
	InhibitSelling bool `json:"inhibitSelling"`

	// In addition to selling items, vendors can have "interactions": UI where you "talk" with the vendor
	// and they offer you a reward, some item, or merely acknowledge via dialog that you did something
	// cool.
	Interactions []VendorInteractionDefinition `json:"interactions"`

	// If the vendor shows you items from your own inventory - such as the Vault vendor does - this data
	// describes the UI around showing those inventory buckets and which ones get shown.
	InventoryFlyouts []VendorInventoryFlyoutDefinition `json:"inventoryFlyouts"`

	// If the vendor sells items (or merely has a list of items to show like the "Sack" vendors do), this
	// is the list of those items that the vendor can sell. From this list, only a subset will be available
	// from the vendor at any given time, selected randomly and reset on the vendor's refresh interval.
	// Note that a vendor can sell the same item multiple ways: for instance, nothing stops a vendor from
	// selling you some specific weapon but using two different currencies, or the same weapon at multiple
	// "item levels".
	ItemList []VendorItemDefinition `json:"itemList"`

	// A vendor can be at different places in the world depending on the game/character/account state. This
	// is the list of possible locations for the vendor, along with conditions we use to determine which
	// one is currently active.
	Locations []VendorLocationDefinition `json:"locations"`

	// See the categories property for a description of categories and why originalCategories exists.
	OriginalCategories []VendorCategoryEntryDefinition `json:"originalCategories"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// A number used for calculating the frequency of a vendor's inventory resetting/refreshing.
	// Don't worry about calculating this - we do it on the server side and send you the next refresh date
	// with the live data.
	ResetIntervalMinutes int32 `json:"resetIntervalMinutes"`

	// Again, used for reset/refreshing of inventory. Don't worry too much about it. Unless you want to.
	ResetOffsetMinutes int32 `json:"resetOffsetMinutes"`

	// As many of you know, Vendor data has historically been pretty brutal on the BNet servers. In an
	// effort to reduce this workload, only Vendors with this flag set will be returned on Vendor requests.
	// This allows us to filter out Vendors that don't dynamic data that's particularly useful: things like
	// "Preview/Sack" vendors, for example, that you can usually suss out the details for using just the
	// definitions themselves.
	ReturnWithVendorRequest bool `json:"returnWithVendorRequest"`

	// Ditto for selling. Not that you can sell items to a vendor anymore. Will it come back? Who knows.
	// The string's still there.
	SellString string `json:"sellString"`

	// BNet doesn't use this data yet, but it appears to be an optional list of flavor text about services
	// that the Vendor can provide.
	Services []VendorServiceDefinition `json:"services"`

	// If we were able to predict the dates when this Vendor will be visible/available, this will be the
	// list of those date ranges. Sadly, we're not able to predict this very frequently, so this will often
	// be useless data.
	UnlockRanges []DateRange `json:"unlockRanges"`

	// If the vendor has a custom banner image, that can be found here.
	VendorBanner string `json:"vendorBanner"`

	// The internal identifier for the Vendor. A holdover from the old days of Vendors, but we don't have
	// time to refactor it away.
	VendorIdentifier string `json:"vendorIdentifier"`

	// A portrait of the Vendor's smiling mug. Or frothing tentacles.
	VendorPortrait string `json:"vendorPortrait"`

	// The type of reward progression that this vendor has. Default - The original rank progression from
	// token redemption. Ritual - Progression from ranks in ritual content. For example: Crucible (Shaxx),
	// Gambit (Drifter), and Battlegrounds (War Table).
	VendorProgressionType VendorProgressionType `json:"vendorProgressionType"`

	// The identifier of the VendorCategoryDefinition for this vendor's subcategory.
	VendorSubcategoryIdentifier string `json:"vendorSubcategoryIdentifier"`

	// If a vendor is not visible, we still have and will give vendor definition info, but we won't use
	// them for things like Advisors or UI.
	Visible bool `json:"visible"`
}

// Destiny.Definitions.DestinyVendorDisplayPropertiesDefinition
type VendorDisplayPropertiesDefinition struct {
	// {
	//   "properties": {
	//     "description": {
	//       "type": "string"
	//     },
	//     "hasIcon": {
	//       "type": "boolean"
	//     },
	//     "highResIcon": {
	//       "description": "If this item has a high-res icon (at least for now, many things won't), then the path to that icon will be here.",
	//       "type": "string"
	//     },
	//     "icon": {
	//       "description": "Note that \"icon\" is sometimes misleading, and should be interpreted in the context of the entity. For instance, in Destiny 1 the DestinyRecordBookDefinition's icon was a big picture of a book.\r\nBut usually, it will be a small square image that you can use as... well, an icon.\r\nThey are currently represented as 96px x 96px images.",
	//       "type": "string"
	//     },
	//     "iconSequences": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyIconSequenceDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "largeIcon": {
	//       "description": "I regret calling this a \"large icon\". It's more like a medium-sized image with a picture of the vendor's mug on it, trying their best to look cool. Not what one would call an icon.",
	//       "type": "string"
	//     },
	//     "largeTransparentIcon": {
	//       "description": "This is apparently the \"Watermark\". I am not certain offhand where this is actually used in the Game UI, but some people may find it useful.",
	//       "type": "string"
	//     },
	//     "mapIcon": {
	//       "description": "This is the icon used in the map overview, when the vendor is located on the map.",
	//       "type": "string"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "originalIcon": {
	//       "description": "If we replaced the icon with something more glitzy, this is the original icon that the vendor had according to the game's content. It may be more lame and/or have less razzle-dazzle. But who am I to tell you which icon to use.",
	//       "type": "string"
	//     },
	//     "requirementsDisplay": {
	//       "description": "Vendors, in addition to expected display property data, may also show some \"common requirements\" as statically defined definition data. This might be when a vendor accepts a single type of currency, or when the currency is unique to the vendor and the designers wanted to show that currency when you interact with the vendor.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorRequirementDisplayEntryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "smallTransparentIcon": {
	//       "description": "This is the icon used in parts of the game UI such as the vendor's waypoint.",
	//       "type": "string"
	//     },
	//     "subtitle": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Description string `json:"description"`

	HasIcon bool `json:"hasIcon"`

	// If this item has a high-res icon (at least for now, many things won't), then the path to that icon
	// will be here.
	HighResIcon string `json:"highResIcon"`

	// Note that "icon" is sometimes misleading, and should be interpreted in the context of the entity.
	// For instance, in Destiny 1 the DestinyRecordBookDefinition's icon was a big picture of a book.
	// But usually, it will be a small square image that you can use as... well, an icon.
	// They are currently represented as 96px x 96px images.
	Icon string `json:"icon"`

	IconSequences []IconSequenceDefinition `json:"iconSequences"`

	// I regret calling this a "large icon". It's more like a medium-sized image with a picture of the
	// vendor's mug on it, trying their best to look cool. Not what one would call an icon.
	LargeIcon string `json:"largeIcon"`

	// This is apparently the "Watermark". I am not certain offhand where this is actually used in the Game
	// UI, but some people may find it useful.
	LargeTransparentIcon string `json:"largeTransparentIcon"`

	// This is the icon used in the map overview, when the vendor is located on the map.
	MapIcon string `json:"mapIcon"`

	Name string `json:"name"`

	// If we replaced the icon with something more glitzy, this is the original icon that the vendor had
	// according to the game's content. It may be more lame and/or have less razzle-dazzle. But who am I to
	// tell you which icon to use.
	OriginalIcon string `json:"originalIcon"`

	// Vendors, in addition to expected display property data, may also show some "common requirements" as
	// statically defined definition data. This might be when a vendor accepts a single type of currency,
	// or when the currency is unique to the vendor and the designers wanted to show that currency when you
	// interact with the vendor.
	RequirementsDisplay []VendorRequirementDisplayEntryDefinition `json:"requirementsDisplay"`

	// This is the icon used in parts of the game UI such as the vendor's waypoint.
	SmallTransparentIcon string `json:"smallTransparentIcon"`

	Subtitle string `json:"subtitle"`
}

// Destiny.Definitions.DestinyVendorGroupDefinition
//
// BNet attempts to group vendors into similar collections. These groups aren't technically game
// canonical, but they are helpful for filtering vendors or showing them organized into a clean view on
// a webpage or app.
// These definitions represent the groups we've built. Unlike in Destiny 1, a Vendors' group may change
// dynamically as the game state changes: thus, you will want to check DestinyVendorComponent responses
// to find a vendor's currently active Group (if you care).
// Using this will let you group your vendors in your UI in a similar manner to how we will do grouping
// in the Companion.
type VendorGroupDefinition struct {
	// {
	//   "description": "BNet attempts to group vendors into similar collections. These groups aren't technically game canonical, but they are helpful for filtering vendors or showing them organized into a clean view on a webpage or app.\r\nThese definitions represent the groups we've built. Unlike in Destiny 1, a Vendors' group may change dynamically as the game state changes: thus, you will want to check DestinyVendorComponent responses to find a vendor's currently active Group (if you care).\r\nUsing this will let you group your vendors in your UI in a similar manner to how we will do grouping in the Companion.",
	//   "properties": {
	//     "categoryName": {
	//       "description": "For now, a group just has a name.",
	//       "type": "string"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "order": {
	//       "description": "The recommended order in which to render the groups, Ascending order.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "VendorGroups"
	// }

	// For now, a group just has a name.
	CategoryName string `json:"categoryName"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// The recommended order in which to render the groups, Ascending order.
	Order int32 `json:"order"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.DestinyVendorGroupReference
type VendorGroupReference struct {
	// {
	//   "properties": {
	//     "vendorGroupHash": {
	//       "description": "The DestinyVendorGroupDefinition to which this Vendor can belong.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorGroupDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The DestinyVendorGroupDefinition to which this Vendor can belong.
	VendorGroupHash Hash[VendorGroupDefinition] `json:"vendorGroupHash"`
}

// Destiny.Definitions.DestinyVendorInteractionDefinition
//
// A Vendor Interaction is a dialog shown by the vendor other than sale items or transfer screens. The
// vendor is showing you something, and asking you to reply to it by choosing an option or reward.
type VendorInteractionDefinition struct {
	// {
	//   "description": "A Vendor Interaction is a dialog shown by the vendor other than sale items or transfer screens. The vendor is showing you something, and asking you to reply to it by choosing an option or reward.",
	//   "properties": {
	//     "flavorLineOne": {
	//       "description": "If the vendor interaction has flavor text, this is some of it.",
	//       "type": "string"
	//     },
	//     "flavorLineTwo": {
	//       "description": "If the vendor interaction has flavor text, this is the rest of it.",
	//       "type": "string"
	//     },
	//     "headerDisplayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "The header for the interaction dialog.",
	//       "type": "object"
	//     },
	//     "instructions": {
	//       "description": "The localized text telling the player what to do when they see this dialog.",
	//       "type": "string"
	//     },
	//     "interactionIndex": {
	//       "description": "The position of this interaction in its parent array. Note that this is NOT content agnostic, and should not be used as such.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "interactionType": {
	//       "description": "The enumerated version of the possible UI hints for vendor interactions, which is a little easier to grok than the hash found in uiInteractionType.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.VendorInteractionType"
	//       }
	//     },
	//     "questlineItemHash": {
	//       "description": "If this interaction dialog is about a quest, this is the questline related to the interaction. You can use this to show the quest overview, or even the character's status with the quest if you use it to find the character's current Quest Step by checking their inventory against this questlineItemHash's DestinyInventoryItemDefinition.setData.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "replies": {
	//       "description": "The potential replies that the user can make to the interaction.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorInteractionReplyDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "rewardBlockLabel": {
	//       "description": "If this interaction is displaying rewards, this is the text to use for the header of the reward-displaying section of the interaction.",
	//       "type": "string"
	//     },
	//     "rewardVendorCategoryIndex": {
	//       "description": "If the vendor's reward list is sourced from one of his categories, this is the index into the category array of items to show.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "sackInteractionList": {
	//       "description": "If this interaction is meant to show you sacks, this is the list of types of sacks to be shown. If empty, the interaction is not meant to show sacks.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorInteractionSackEntryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "uiInteractionType": {
	//       "description": "A UI hint for the behavior of the interaction screen. This is useful to determine what type of interaction is occurring, such as a prompt to receive a rank up reward or a prompt to choose a reward for completing a quest. The hash isn't as useful as the Enum in retrospect, well what can you do. Try using interactionType instead.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "vendorCategoryIndex": {
	//       "description": "If \u003e= 0, this is the category of sale items to show along with this interaction dialog.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// If the vendor interaction has flavor text, this is some of it.
	FlavorLineOne string `json:"flavorLineOne"`

	// If the vendor interaction has flavor text, this is the rest of it.
	FlavorLineTwo string `json:"flavorLineTwo"`

	// The header for the interaction dialog.
	HeaderDisplayProperties DisplayPropertiesDefinition `json:"headerDisplayProperties"`

	// The localized text telling the player what to do when they see this dialog.
	Instructions string `json:"instructions"`

	// The position of this interaction in its parent array. Note that this is NOT content agnostic, and
	// should not be used as such.
	InteractionIndex int32 `json:"interactionIndex"`

	// The enumerated version of the possible UI hints for vendor interactions, which is a little easier to
	// grok than the hash found in uiInteractionType.
	InteractionType VendorInteractionType `json:"interactionType"`

	// If this interaction dialog is about a quest, this is the questline related to the interaction. You
	// can use this to show the quest overview, or even the character's status with the quest if you use it
	// to find the character's current Quest Step by checking their inventory against this
	// questlineItemHash's DestinyInventoryItemDefinition.setData.
	QuestlineItemHash Hash[InventoryItemDefinition] `json:"questlineItemHash"`

	// The potential replies that the user can make to the interaction.
	Replies []VendorInteractionReplyDefinition `json:"replies"`

	// If this interaction is displaying rewards, this is the text to use for the header of the
	// reward-displaying section of the interaction.
	RewardBlockLabel string `json:"rewardBlockLabel"`

	// If the vendor's reward list is sourced from one of his categories, this is the index into the
	// category array of items to show.
	RewardVendorCategoryIndex int32 `json:"rewardVendorCategoryIndex"`

	// If this interaction is meant to show you sacks, this is the list of types of sacks to be shown. If
	// empty, the interaction is not meant to show sacks.
	SackInteractionList []VendorInteractionSackEntryDefinition `json:"sackInteractionList"`

	// A UI hint for the behavior of the interaction screen. This is useful to determine what type of
	// interaction is occurring, such as a prompt to receive a rank up reward or a prompt to choose a
	// reward for completing a quest. The hash isn't as useful as the Enum in retrospect, well what can you
	// do. Try using interactionType instead.
	UiInteractionType uint32 `json:"uiInteractionType"`

	// If >= 0, this is the category of sale items to show along with this interaction dialog.
	VendorCategoryIndex int32 `json:"vendorCategoryIndex"`
}

// Destiny.Definitions.DestinyVendorInteractionReplyDefinition
//
// When the interaction is replied to, Reward sites will fire and items potentially selected based on
// whether the given unlock expression is TRUE.
// You can potentially choose one from multiple replies when replying to an interaction: this is how
// you get either/or rewards from vendors.
type VendorInteractionReplyDefinition struct {
	// {
	//   "description": "When the interaction is replied to, Reward sites will fire and items potentially selected based on whether the given unlock expression is TRUE.\r\nYou can potentially choose one from multiple replies when replying to an interaction: this is how you get either/or rewards from vendors.",
	//   "properties": {
	//     "itemRewardsSelection": {
	//       "description": "The rewards granted upon responding to the vendor.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyVendorInteractionRewardSelection"
	//       }
	//     },
	//     "reply": {
	//       "description": "The localized text for the reply.",
	//       "type": "string"
	//     },
	//     "replyType": {
	//       "description": "An enum indicating the type of reply being made.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyVendorReplyType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The rewards granted upon responding to the vendor.
	ItemRewardsSelection VendorInteractionRewardSelection `json:"itemRewardsSelection"`

	// The localized text for the reply.
	Reply string `json:"reply"`

	// An enum indicating the type of reply being made.
	ReplyType VendorReplyType `json:"replyType"`
}

// Destiny.Definitions.DestinyVendorInteractionSackEntryDefinition
//
// Compare this sackType to the sack identifier in the DestinyInventoryItemDefinition.vendorSackType
// property of items. If they match, show this sack with this interaction.
type VendorInteractionSackEntryDefinition struct {
	// {
	//   "description": "Compare this sackType to the sack identifier in the DestinyInventoryItemDefinition.vendorSackType property of items. If they match, show this sack with this interaction.",
	//   "properties": {
	//     "sackType": {
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	SackType uint32 `json:"sackType"`
}

// Destiny.Definitions.DestinyVendorInventoryFlyoutBucketDefinition
//
// Information about a single inventory bucket in a vendor flyout UI and how it is shown.
type VendorInventoryFlyoutBucketDefinition struct {
	// {
	//   "description": "Information about a single inventory bucket in a vendor flyout UI and how it is shown.",
	//   "properties": {
	//     "collapsible": {
	//       "description": "If true, the inventory bucket should be able to be collapsed visually.",
	//       "type": "boolean"
	//     },
	//     "inventoryBucketHash": {
	//       "description": "The inventory bucket whose contents should be shown.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryBucketDefinition"
	//       }
	//     },
	//     "sortItemsBy": {
	//       "description": "The methodology to use for sorting items from the flyout.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemSortType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// If true, the inventory bucket should be able to be collapsed visually.
	Collapsible bool `json:"collapsible"`

	// The inventory bucket whose contents should be shown.
	InventoryBucketHash Hash[InventoryBucketDefinition] `json:"inventoryBucketHash"`

	// The methodology to use for sorting items from the flyout.
	SortItemsBy ItemSortType `json:"sortItemsBy"`
}

// Destiny.Definitions.DestinyVendorInventoryFlyoutDefinition
//
// The definition for an "inventory flyout": a UI screen where we show you part of an otherwise hidden
// vendor inventory: like the Vault inventory buckets.
type VendorInventoryFlyoutDefinition struct {
	// {
	//   "description": "The definition for an \"inventory flyout\": a UI screen where we show you part of an otherwise hidden vendor inventory: like the Vault inventory buckets.",
	//   "properties": {
	//     "buckets": {
	//       "description": "A list of inventory buckets and other metadata to show on the screen.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorInventoryFlyoutBucketDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "The title and other common properties of the flyout.",
	//       "type": "object"
	//     },
	//     "equipmentSlotHash": {
	//       "description": "If this flyout is meant to show you the contents of the player's equipment slot, this is the slot to show.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "flyoutId": {
	//       "description": "An identifier for the flyout, in case anything else needs to refer to them.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "lockedDescription": {
	//       "description": "If the flyout is locked, this is the reason why.",
	//       "type": "string"
	//     },
	//     "suppressNewness": {
	//       "description": "If this is true, don't show any of the glistening \"this is a new item\" UI elements, like we show on the inventory items themselves in in-game UI.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	// A list of inventory buckets and other metadata to show on the screen.
	Buckets []VendorInventoryFlyoutBucketDefinition `json:"buckets"`

	// The title and other common properties of the flyout.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// If this flyout is meant to show you the contents of the player's equipment slot, this is the slot to
	// show.
	EquipmentSlotHash Nullable[uint32] `json:"equipmentSlotHash,omitempty"`

	// An identifier for the flyout, in case anything else needs to refer to them.
	FlyoutID uint32 `json:"flyoutId"`

	// If the flyout is locked, this is the reason why.
	LockedDescription string `json:"lockedDescription"`

	// If this is true, don't show any of the glistening "this is a new item" UI elements, like we show on
	// the inventory items themselves in in-game UI.
	SuppressNewness bool `json:"suppressNewness"`
}

// Destiny.Definitions.DestinyVendorItemDefinition
//
// This represents an item being sold by the vendor.
type VendorItemDefinition struct {
	// {
	//   "description": "This represents an item being sold by the vendor.",
	//   "properties": {
	//     "action": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorSaleItemActionBlockDefinition"
	//         }
	//       ],
	//       "description": "The action to be performed when purchasing the item, if it's not just \"buy\".",
	//       "type": "object"
	//     },
	//     "categoryIndex": {
	//       "description": "The index into the DestinyVendorDefinition.categories array, so you can find the category associated with this item.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "creationLevels": {
	//       "description": "The Default level at which the item will spawn. Almost always driven by an adjusto these days. Ideally should be singular. It's a long story how this ended up as a list, but there is always either going to be 0:1 of these entities.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemCreationEntryLevelDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "currencies": {
	//       "description": "This is a pre-compiled aggregation of item value and priceOverrideList, so that we have one place to check for what the purchaser must pay for the item. Use this instead of trying to piece together the price separately.\r\nThe somewhat crappy part about this is that, now that item quantity overrides have dynamic modifiers, this will not necessarily be statically true. If you were using this instead of live data, switch to using live data.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorItemQuantity"
	//       },
	//       "type": "array"
	//     },
	//     "displayCategory": {
	//       "description": "The string identifier for the category selling this item.",
	//       "type": "string"
	//     },
	//     "displayCategoryIndex": {
	//       "description": "This is an index specifically into the display category, as opposed to the server-side Categories (which do not need to match or pair with each other in any way: server side categories are really just structures for common validation. Display Category will let us more easily categorize items visually)",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "exclusivity": {
	//       "description": "If this item can only be purchased by a given platform, this indicates the platform to which it is restricted.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "expirationTooltip": {
	//       "description": "If this item can expire, this is the tooltip message to show with its expiration info.",
	//       "type": "string"
	//     },
	//     "failureIndexes": {
	//       "description": "An list of indexes into the DestinyVendorDefinition.failureStrings array, indicating the possible failure strings that can be relevant for this item.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "inventoryBucketHash": {
	//       "description": "The inventory bucket into which this item will be placed upon purchase.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryBucketDefinition"
	//       }
	//     },
	//     "isCrm": {
	//       "description": "If this sale can only be performed as the result of receiving a CRM offer, this is true.",
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "isOffer": {
	//       "description": "If this sale can only be performed as the result of an offer check, this is true.",
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "itemHash": {
	//       "description": "The hash identifier of the item being sold (DestinyInventoryItemDefinition).\r\nNote that a vendor can sell the same item in multiple ways, so don't assume that itemHash is a unique identifier for this entity.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "maximumLevel": {
	//       "description": "The maximum character level at which this item is available for sale.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "minimumLevel": {
	//       "description": "The minimum character level at which this item is available for sale.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "originalCategoryIndex": {
	//       "description": "Same as above, but for the original category indexes.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "purchasableScope": {
	//       "description": "Similar to visibilityScope, it represents the most restrictive scope that determines whether the item can be purchased. It will at least be as restrictive as visibilityScope, but could be more restrictive if the item has additional purchase requirements beyond whether it is merely visible or not.\r\nSee DestinyGatingScope's documentation for more information.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyGatingScope"
	//       }
	//     },
	//     "quantity": {
	//       "description": "The amount you will recieve of the item described in itemHash if you make the purchase.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redirectToSaleIndexes": {
	//       "description": "If this is populated, the purchase of this item should redirect to purchasing these other items instead.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "refundPolicy": {
	//       "description": "If this item can be refunded, this is the policy for what will be refundd, how, and in what time period.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyVendorItemRefundPolicy"
	//       }
	//     },
	//     "refundTimeLimit": {
	//       "description": "The amount of time before refundability of the newly purchased item will expire.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "socketOverrides": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorItemSocketOverride"
	//       },
	//       "type": "array"
	//     },
	//     "sortValue": {
	//       "description": "*if* the category this item is in supports non-default sorting, this value should represent the sorting value to use, pre-processed and ready to go.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "unpurchasable": {
	//       "description": "If true, this item is some sort of dummy sale item that cannot actually be purchased. It may be a display only item, or some fluff left by a content designer for testing purposes, or something that got disabled because it was a terrible idea. You get the picture. We won't know *why* it can't be purchased, only that it can't be. Sorry.\r\nThis is also only whether it's unpurchasable as a static property according to game content. There are other reasons why an item may or may not be purchasable at runtime, so even if this isn't set to True you should trust the runtime value for this sale item over the static definition if this is unset.",
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "vendorItemIndex": {
	//       "description": "The index into the DestinyVendorDefinition.saleList. This is what we use to refer to items being sold throughout live and definition data.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "visibilityScope": {
	//       "description": "The most restrictive scope that determines whether the item is available in the Vendor's inventory. See DestinyGatingScope's documentation for more information.\r\nThis can be determined by Unlock gating, or by whether or not the item has purchase level requirements (minimumLevel and maximumLevel properties).",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyGatingScope"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The action to be performed when purchasing the item, if it's not just "buy".
	Action VendorSaleItemActionBlockDefinition `json:"action"`

	// The index into the DestinyVendorDefinition.categories array, so you can find the category associated
	// with this item.
	CategoryIndex int32 `json:"categoryIndex"`

	// The Default level at which the item will spawn. Almost always driven by an adjusto these days.
	// Ideally should be singular. It's a long story how this ended up as a list, but there is always
	// either going to be 0:1 of these entities.
	CreationLevels []ItemCreationEntryLevelDefinition `json:"creationLevels"`

	// This is a pre-compiled aggregation of item value and priceOverrideList, so that we have one place to
	// check for what the purchaser must pay for the item. Use this instead of trying to piece together the
	// price separately.
	// The somewhat crappy part about this is that, now that item quantity overrides have dynamic
	// modifiers, this will not necessarily be statically true. If you were using this instead of live
	// data, switch to using live data.
	Currencies []VendorItemQuantity `json:"currencies"`

	// The string identifier for the category selling this item.
	DisplayCategory string `json:"displayCategory"`

	// This is an index specifically into the display category, as opposed to the server-side Categories
	// (which do not need to match or pair with each other in any way: server side categories are really
	// just structures for common validation. Display Category will let us more easily categorize items
	// visually)
	DisplayCategoryIndex int32 `json:"displayCategoryIndex"`

	// If this item can only be purchased by a given platform, this indicates the platform to which it is
	// restricted.
	Exclusivity BungieMembershipType `json:"exclusivity"`

	// If this item can expire, this is the tooltip message to show with its expiration info.
	ExpirationTooltip string `json:"expirationTooltip"`

	// An list of indexes into the DestinyVendorDefinition.failureStrings array, indicating the possible
	// failure strings that can be relevant for this item.
	FailureIndexes []int32 `json:"failureIndexes"`

	// The inventory bucket into which this item will be placed upon purchase.
	InventoryBucketHash Hash[InventoryBucketDefinition] `json:"inventoryBucketHash"`

	// If this sale can only be performed as the result of receiving a CRM offer, this is true.
	IsCrm Nullable[bool] `json:"isCrm,omitempty"`

	// If this sale can only be performed as the result of an offer check, this is true.
	IsOffer Nullable[bool] `json:"isOffer,omitempty"`

	// The hash identifier of the item being sold (DestinyInventoryItemDefinition).
	// Note that a vendor can sell the same item in multiple ways, so don't assume that itemHash is a
	// unique identifier for this entity.
	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`

	// The maximum character level at which this item is available for sale.
	MaximumLevel int32 `json:"maximumLevel"`

	// The minimum character level at which this item is available for sale.
	MinimumLevel int32 `json:"minimumLevel"`

	// Same as above, but for the original category indexes.
	OriginalCategoryIndex int32 `json:"originalCategoryIndex"`

	// Similar to visibilityScope, it represents the most restrictive scope that determines whether the
	// item can be purchased. It will at least be as restrictive as visibilityScope, but could be more
	// restrictive if the item has additional purchase requirements beyond whether it is merely visible or
	// not.
	// See DestinyGatingScope's documentation for more information.
	PurchasableScope GatingScope `json:"purchasableScope"`

	// The amount you will recieve of the item described in itemHash if you make the purchase.
	Quantity int32 `json:"quantity"`

	// If this is populated, the purchase of this item should redirect to purchasing these other items
	// instead.
	RedirectToSaleIndexes []int32 `json:"redirectToSaleIndexes"`

	// If this item can be refunded, this is the policy for what will be refundd, how, and in what time
	// period.
	RefundPolicy VendorItemRefundPolicy `json:"refundPolicy"`

	// The amount of time before refundability of the newly purchased item will expire.
	RefundTimeLimit int32 `json:"refundTimeLimit"`

	SocketOverrides []VendorItemSocketOverride `json:"socketOverrides"`

	// *if* the category this item is in supports non-default sorting, this value should represent the
	// sorting value to use, pre-processed and ready to go.
	SortValue int32 `json:"sortValue"`

	// If true, this item is some sort of dummy sale item that cannot actually be purchased. It may be a
	// display only item, or some fluff left by a content designer for testing purposes, or something that
	// got disabled because it was a terrible idea. You get the picture. We won't know *why* it can't be
	// purchased, only that it can't be. Sorry.
	// This is also only whether it's unpurchasable as a static property according to game content. There
	// are other reasons why an item may or may not be purchasable at runtime, so even if this isn't set to
	// True you should trust the runtime value for this sale item over the static definition if this is
	// unset.
	Unpurchasable Nullable[bool] `json:"unpurchasable,omitempty"`

	// The index into the DestinyVendorDefinition.saleList. This is what we use to refer to items being
	// sold throughout live and definition data.
	VendorItemIndex int32 `json:"vendorItemIndex"`

	// The most restrictive scope that determines whether the item is available in the Vendor's inventory.
	// See DestinyGatingScope's documentation for more information.
	// This can be determined by Unlock gating, or by whether or not the item has purchase level
	// requirements (minimumLevel and maximumLevel properties).
	VisibilityScope GatingScope `json:"visibilityScope"`
}

// Destiny.Definitions.DestinyVendorItemQuantity
//
// In addition to item quantity information for vendor prices, this also has any optional information
// that may exist about how the item's quantity can be modified. (unfortunately not information that is
// able to be read outside of the BNet servers, but it's there)
type VendorItemQuantity struct {
	// {
	//   "description": "In addition to item quantity information for vendor prices, this also has any optional information that may exist about how the item's quantity can be modified. (unfortunately not information that is able to be read outside of the BNet servers, but it's there)",
	//   "properties": {
	//     "hasConditionalVisibility": {
	//       "description": "Indicates that this item quantity may be conditionally shown or hidden, based on various sources of state. For example: server flags, account state, or character progress.",
	//       "type": "boolean"
	//     },
	//     "itemHash": {
	//       "description": "The hash identifier for the item in question. Use it to look up the item's DestinyInventoryItemDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "itemInstanceId": {
	//       "description": "If this quantity is referring to a specific instance of an item, this will have the item's instance ID. Normally, this will be null.",
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "quantity": {
	//       "description": "The amount of the item needed/available depending on the context of where DestinyItemQuantity is being used.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// Indicates that this item quantity may be conditionally shown or hidden, based on various sources of
	// state. For example: server flags, account state, or character progress.
	HasConditionalVisibility bool `json:"hasConditionalVisibility"`

	// The hash identifier for the item in question. Use it to look up the item's
	// DestinyInventoryItemDefinition.
	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`

	// If this quantity is referring to a specific instance of an item, this will have the item's instance
	// ID. Normally, this will be null.
	ItemInstanceID Nullable[Int64] `json:"itemInstanceId,omitempty"`

	// The amount of the item needed/available depending on the context of where DestinyItemQuantity is
	// being used.
	Quantity int32 `json:"quantity"`
}

// Destiny.Definitions.DestinyVendorItemSocketOverride
//
// The information for how the vendor purchase should override a given socket with custom plug data.
type VendorItemSocketOverride struct {
	// {
	//   "description": "The information for how the vendor purchase should override a given socket with custom plug data.",
	//   "properties": {
	//     "randomizedOptionsCount": {
	//       "description": "If this is greater than -1, the number of randomized plugs on this socket will be set to this quantity instead of whatever it's set to by default.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "singleItemHash": {
	//       "description": "If this is populated, the socket will be overridden with a specific plug.\r\nIf this isn't populated, it's being overridden by something more complicated that is only known by the Game Server and God, which means we can't tell you in advance what it'll be.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "socketTypeHash": {
	//       "description": "This appears to be used to select which socket ultimately gets the override defined here.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinySocketTypeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// If this is greater than -1, the number of randomized plugs on this socket will be set to this
	// quantity instead of whatever it's set to by default.
	RandomizedOptionsCount int32 `json:"randomizedOptionsCount"`

	// If this is populated, the socket will be overridden with a specific plug.
	// If this isn't populated, it's being overridden by something more complicated that is only known by
	// the Game Server and God, which means we can't tell you in advance what it'll be.
	SingleItemHash Nullable[Hash[InventoryItemDefinition]] `json:"singleItemHash,omitempty"`

	// This appears to be used to select which socket ultimately gets the override defined here.
	SocketTypeHash Hash[SocketTypeDefinition] `json:"socketTypeHash"`
}

// Destiny.Definitions.DestinyVendorRequirementDisplayEntryDefinition
//
// The localized properties of the requirementsDisplay, allowing information about the requirement or
// item being featured to be seen.
type VendorRequirementDisplayEntryDefinition struct {
	// {
	//   "description": "The localized properties of the requirementsDisplay, allowing information about the requirement or item being featured to be seen.",
	//   "properties": {
	//     "icon": {
	//       "type": "string"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "source": {
	//       "type": "string"
	//     },
	//     "type": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Icon string `json:"icon"`

	Name string `json:"name"`

	Source string `json:"source"`

	Type string `json:"type"`
}

// Destiny.Definitions.DestinyVendorSaleItemActionBlockDefinition
//
// Not terribly useful, some basic cooldown interaction info.
type VendorSaleItemActionBlockDefinition struct {
	// {
	//   "description": "Not terribly useful, some basic cooldown interaction info.",
	//   "properties": {
	//     "executeSeconds": {
	//       "format": "float",
	//       "type": "number"
	//     },
	//     "isPositive": {
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	ExecuteSeconds float64 `json:"executeSeconds"`

	IsPositive bool `json:"isPositive"`
}

// Destiny.Definitions.DestinyVendorServiceDefinition
//
// When a vendor provides services, this is the localized name of those services.
type VendorServiceDefinition struct {
	// {
	//   "description": "When a vendor provides services, this is the localized name of those services.",
	//   "properties": {
	//     "name": {
	//       "description": "The localized name of a service provided.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// The localized name of a service provided.
	Name string `json:"name"`
}

// Destiny.Definitions.Director.DestinyActivityGraphArtElementDefinition
//
// These Art Elements are meant to represent one-off visual effects overlaid on the map. Currently, we
// do not have a pipeline to import the assets for these overlays, so this info exists as a placeholder
// for when such a pipeline exists (if it ever will)
type ActivityGraphArtElementDefinition struct {
	// {
	//   "description": "These Art Elements are meant to represent one-off visual effects overlaid on the map. Currently, we do not have a pipeline to import the assets for these overlays, so this info exists as a placeholder for when such a pipeline exists (if it ever will)",
	//   "properties": {
	//     "position": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyPositionDefinition"
	//         }
	//       ],
	//       "description": "The position on the map of the art element.",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object"
	// }

	// The position on the map of the art element.
	Position PositionDefinition `json:"position"`
}

// Destiny.Definitions.Director.DestinyActivityGraphConnectionDefinition
//
// Nodes on a graph can be visually connected: this appears to be the information about which nodes to
// link. It appears to lack more detailed information, such as the path for that linking.
type ActivityGraphConnectionDefinition struct {
	// {
	//   "description": "Nodes on a graph can be visually connected: this appears to be the information about which nodes to link. It appears to lack more detailed information, such as the path for that linking.",
	//   "properties": {
	//     "destNodeHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "sourceNodeHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	DestNodeHash uint32 `json:"destNodeHash"`

	SourceNodeHash uint32 `json:"sourceNodeHash"`
}

// Destiny.Definitions.Director.DestinyActivityGraphDefinition
//
// Represents a Map View in the director: be them overview views, destination views, or other.
// They have nodes which map to activities, and other various visual elements that we (or others) may
// or may not be able to use.
// Activity graphs, most importantly, have nodes which can have activities in various states of
// playability.
// Unfortunately, activity graphs are combined at runtime with Game UI-only assets such as fragments of
// map images, various in-game special effects, decals etc... that we don't get in these definitions.
// If we end up having time, we may end up trying to manually populate those here: but the last time we
// tried that, before the lead-up to D1, it proved to be unmaintainable as the game's content changed.
// So don't bet the farm on us providing that content in this definition.
type ActivityGraphDefinition struct {
	// {
	//   "description": "Represents a Map View in the director: be them overview views, destination views, or other.\r\nThey have nodes which map to activities, and other various visual elements that we (or others) may or may not be able to use.\r\nActivity graphs, most importantly, have nodes which can have activities in various states of playability.\r\nUnfortunately, activity graphs are combined at runtime with Game UI-only assets such as fragments of map images, various in-game special effects, decals etc... that we don't get in these definitions.\r\nIf we end up having time, we may end up trying to manually populate those here: but the last time we tried that, before the lead-up to D1, it proved to be unmaintainable as the game's content changed. So don't bet the farm on us providing that content in this definition.",
	//   "properties": {
	//     "artElements": {
	//       "description": "Represents one-off/special UI elements that appear on the map.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Director.DestinyActivityGraphArtElementDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "connections": {
	//       "description": "Represents connections between graph nodes. However, it lacks context that we'd need to make good use of it.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Director.DestinyActivityGraphConnectionDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "displayObjectives": {
	//       "description": "Objectives can display on maps, and this is supposedly metadata for that. I have not had the time to analyze the details of what is useful within however: we could be missing important data to make this work. Expect this property to be expanded on later if possible.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Director.DestinyActivityGraphDisplayObjectiveDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "displayProgressions": {
	//       "description": "Progressions can also display on maps, but similarly to displayObjectives we appear to lack some required information and context right now. We will have to look into it later and add more data if possible.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Director.DestinyActivityGraphDisplayProgressionDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "linkedGraphs": {
	//       "description": "Represents links between this Activity Graph and other ones.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Director.DestinyLinkedGraphDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "nodes": {
	//       "description": "These represent the visual \"nodes\" on the map's view. These are the activities you can click on in the map.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Director.DestinyActivityGraphNodeDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "ActivityGraphs"
	// }

	// Represents one-off/special UI elements that appear on the map.
	ArtElements []ActivityGraphArtElementDefinition `json:"artElements"`

	// Represents connections between graph nodes. However, it lacks context that we'd need to make good
	// use of it.
	Connections []ActivityGraphConnectionDefinition `json:"connections"`

	// Objectives can display on maps, and this is supposedly metadata for that. I have not had the time to
	// analyze the details of what is useful within however: we could be missing important data to make
	// this work. Expect this property to be expanded on later if possible.
	DisplayObjectives []ActivityGraphDisplayObjectiveDefinition `json:"displayObjectives"`

	// Progressions can also display on maps, but similarly to displayObjectives we appear to lack some
	// required information and context right now. We will have to look into it later and add more data if
	// possible.
	DisplayProgressions []ActivityGraphDisplayProgressionDefinition `json:"displayProgressions"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// Represents links between this Activity Graph and other ones.
	LinkedGraphs []LinkedGraphDefinition `json:"linkedGraphs"`

	// These represent the visual "nodes" on the map's view. These are the activities you can click on in
	// the map.
	Nodes []ActivityGraphNodeDefinition `json:"nodes"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.Director.DestinyActivityGraphDisplayObjectiveDefinition
//
// When a Graph needs to show active Objectives, this defines those objectives as well as an
// identifier.
type ActivityGraphDisplayObjectiveDefinition struct {
	// {
	//   "description": "When a Graph needs to show active Objectives, this defines those objectives as well as an identifier.",
	//   "properties": {
	//     "id": {
	//       "description": "$NOTE $amola 2017-01-19 This field is apparently something that CUI uses to manually wire up objectives to display info. I am unsure how it works.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "objectiveHash": {
	//       "description": "The objective being shown on the map.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectiveDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// $NOTE $amola 2017-01-19 This field is apparently something that CUI uses to manually wire up
	// objectives to display info. I am unsure how it works.
	Id uint32 `json:"id"`

	// The objective being shown on the map.
	ObjectiveHash Hash[ObjectiveDefinition] `json:"objectiveHash"`
}

// Destiny.Definitions.Director.DestinyActivityGraphDisplayProgressionDefinition
//
// When a Graph needs to show active Progressions, this defines those objectives as well as an
// identifier.
type ActivityGraphDisplayProgressionDefinition struct {
	// {
	//   "description": "When a Graph needs to show active Progressions, this defines those objectives as well as an identifier.",
	//   "properties": {
	//     "id": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "progressionHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	Id uint32 `json:"id"`

	ProgressionHash uint32 `json:"progressionHash"`
}

// Destiny.Definitions.Director.DestinyActivityGraphNodeActivityDefinition
//
// The actual activity to be redirected to when you click on the node. Note that a node can have many
// Activities attached to it: but only one will be active at any given time. The list of Node
// Activities will be traversed, and the first one found to be active will be displayed. This way, a
// node can layer multiple variants of an activity on top of each other. For instance, one node can
// control the weekly Crucible Playlist. There are multiple possible playlists, but only one is active
// for the week.
type ActivityGraphNodeActivityDefinition struct {
	// {
	//   "description": "The actual activity to be redirected to when you click on the node. Note that a node can have many Activities attached to it: but only one will be active at any given time. The list of Node Activities will be traversed, and the first one found to be active will be displayed. This way, a node can layer multiple variants of an activity on top of each other. For instance, one node can control the weekly Crucible Playlist. There are multiple possible playlists, but only one is active for the week.",
	//   "properties": {
	//     "activityHash": {
	//       "description": "The activity that will be activated if the user clicks on this node. Controls all activity-related information displayed on the node if it is active (the text shown in the tooltip etc)",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "nodeActivityId": {
	//       "description": "An identifier for this node activity. It is only guaranteed to be unique within the Activity Graph.",
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// The activity that will be activated if the user clicks on this node. Controls all activity-related
	// information displayed on the node if it is active (the text shown in the tooltip etc)
	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`

	// An identifier for this node activity. It is only guaranteed to be unique within the Activity Graph.
	NodeActivityID uint32 `json:"nodeActivityId"`
}

// Destiny.Definitions.Director.DestinyActivityGraphNodeDefinition
//
// This is the position and other data related to nodes in the activity graph that you can click to
// launch activities. An Activity Graph node will only have one active Activity at a time, which will
// determine the activity to be launched (and, unless overrideDisplay information is provided, will
// also determine the tooltip and other UI related to the node)
type ActivityGraphNodeDefinition struct {
	// {
	//   "description": "This is the position and other data related to nodes in the activity graph that you can click to launch activities. An Activity Graph node will only have one active Activity at a time, which will determine the activity to be launched (and, unless overrideDisplay information is provided, will also determine the tooltip and other UI related to the node)",
	//   "properties": {
	//     "activities": {
	//       "description": "The node may have various possible activities that could be active for it, however only one may be active at a time. See the DestinyActivityGraphNodeActivityDefinition for details.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Director.DestinyActivityGraphNodeActivityDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "featuringStates": {
	//       "description": "The node may have various visual accents placed on it, or styles applied. These are the list of possible styles that the Node can have. The game iterates through each, looking for the first one that passes a check of the required game/character/account state in order to show that style, and then renders the node in that style.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Director.DestinyActivityGraphNodeFeaturingStateDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "nodeId": {
	//       "description": "An identifier for the Activity Graph Node, only guaranteed to be unique within its parent Activity Graph.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "overrideDisplay": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "The node *may* have display properties that override the active Activity's display properties.",
	//       "type": "object"
	//     },
	//     "position": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyPositionDefinition"
	//         }
	//       ],
	//       "description": "The position on the map for this node.",
	//       "type": "object"
	//     },
	//     "states": {
	//       "description": "Represents possible states that the graph node can be in. These are combined with some checking that happens in the game client and server to determine which state is actually active at any given time.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Director.DestinyActivityGraphNodeStateEntry"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The node may have various possible activities that could be active for it, however only one may be
	// active at a time. See the DestinyActivityGraphNodeActivityDefinition for details.
	Activities []ActivityGraphNodeActivityDefinition `json:"activities"`

	// The node may have various visual accents placed on it, or styles applied. These are the list of
	// possible styles that the Node can have. The game iterates through each, looking for the first one
	// that passes a check of the required game/character/account state in order to show that style, and
	// then renders the node in that style.
	FeaturingStates []ActivityGraphNodeFeaturingStateDefinition `json:"featuringStates"`

	// An identifier for the Activity Graph Node, only guaranteed to be unique within its parent Activity
	// Graph.
	NodeID uint32 `json:"nodeId"`

	// The node *may* have display properties that override the active Activity's display properties.
	OverrideDisplay DisplayPropertiesDefinition `json:"overrideDisplay"`

	// The position on the map for this node.
	Position PositionDefinition `json:"position"`

	// Represents possible states that the graph node can be in. These are combined with some checking that
	// happens in the game client and server to determine which state is actually active at any given time.
	States []ActivityGraphNodeStateEntry `json:"states"`
}

// Destiny.Definitions.Director.DestinyActivityGraphNodeFeaturingStateDefinition
//
// Nodes can have different visual states. This object represents a single visual state ("highlight
// type") that a node can be in, and the unlock expression condition to determine whether it should be
// set.
type ActivityGraphNodeFeaturingStateDefinition struct {
	// {
	//   "description": "Nodes can have different visual states. This object represents a single visual state (\"highlight type\") that a node can be in, and the unlock expression condition to determine whether it should be set.",
	//   "properties": {
	//     "highlightType": {
	//       "description": "The node can be highlighted in a variety of ways - the game iterates through these and finds the first FeaturingState that is valid at the present moment given the Game, Account, and Character state, and renders the node in that state. See the ActivityGraphNodeHighlightType enum for possible values.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.ActivityGraphNodeHighlightType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The node can be highlighted in a variety of ways - the game iterates through these and finds the
	// first FeaturingState that is valid at the present moment given the Game, Account, and Character
	// state, and renders the node in that state. See the ActivityGraphNodeHighlightType enum for possible
	// values.
	HighlightType ActivityGraphNodeHighlightType `json:"highlightType"`
}

// Destiny.Definitions.Director.DestinyActivityGraphNodeStateEntry
//
// Represents a single state that a graph node might end up in. Depending on what's going on in the
// game, graph nodes could be shown in different ways or even excluded from view entirely.
type ActivityGraphNodeStateEntry struct {
	// {
	//   "description": "Represents a single state that a graph node might end up in. Depending on what's going on in the game, graph nodes could be shown in different ways or even excluded from view entirely.",
	//   "properties": {
	//     "state": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyGraphNodeState"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	State GraphNodeState `json:"state"`
}

// Destiny.Definitions.Director.DestinyLinkedGraphDefinition
//
// This describes links between the current graph and others, as well as when that link is relevant.
type LinkedGraphDefinition struct {
	// {
	//   "description": "This describes links between the current graph and others, as well as when that link is relevant.",
	//   "properties": {
	//     "description": {
	//       "type": "string"
	//     },
	//     "linkedGraphId": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "linkedGraphs": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Director.DestinyLinkedGraphEntryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "overview": {
	//       "type": "string"
	//     },
	//     "unlockExpression": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.DestinyUnlockExpressionDefinition"
	//     }
	//   },
	//   "type": "object"
	// }

	Description string `json:"description"`

	LinkedGraphID uint32 `json:"linkedGraphId"`

	LinkedGraphs []LinkedGraphEntryDefinition `json:"linkedGraphs"`

	Name string `json:"name"`

	Overview string `json:"overview"`

	UnlockExpression UnlockExpressionDefinition `json:"unlockExpression"`
}

// Destiny.Definitions.Director.DestinyLinkedGraphEntryDefinition
type LinkedGraphEntryDefinition struct {
	// {
	//   "properties": {
	//     "activityGraphHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	ActivityGraphHash uint32 `json:"activityGraphHash"`
}

// Destiny.Definitions.EnergyTypes.DestinyEnergyTypeDefinition
//
// Represents types of Energy that can be used for costs and payments related to Armor 2.0 mods.
type EnergyTypeDefinition struct {
	// {
	//   "description": "Represents types of Energy that can be used for costs and payments related to Armor 2.0 mods.",
	//   "properties": {
	//     "capacityStatHash": {
	//       "description": "If this Energy Type can be used for determining the Type of Energy that an item can consume, this is the hash for the DestinyInvestmentStatDefinition that represents the stat which holds the Capacity for that energy type. (Note that this is optional because \"Any\" is a valid cost, but not valid for Capacity - an Armor must have a specific Energy Type for determining the energy type that the Armor is restricted to use)",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyStatDefinition"
	//       }
	//     },
	//     "costStatHash": {
	//       "description": "If this Energy Type can be used as a cost to pay for socketing Armor 2.0 items, this is the hash for the DestinyInvestmentStatDefinition that stores the plug's raw cost.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyStatDefinition"
	//       }
	//     },
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "The description of the energy type, icon etc...",
	//       "type": "object"
	//     },
	//     "enumValue": {
	//       "description": "We have an enumeration for Energy types for quick reference. This is the current definition's Energy type enum value.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyEnergyType"
	//       }
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "showIcon": {
	//       "description": "If TRUE, the game shows this Energy type's icon. Otherwise, it doesn't. Whether you show it or not is up to you.",
	//       "type": "boolean"
	//     },
	//     "transparentIconPath": {
	//       "description": "A variant of the icon that is transparent and colorless.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "EnergyTypes"
	// }

	// If this Energy Type can be used for determining the Type of Energy that an item can consume, this is
	// the hash for the DestinyInvestmentStatDefinition that represents the stat which holds the Capacity
	// for that energy type. (Note that this is optional because "Any" is a valid cost, but not valid for
	// Capacity - an Armor must have a specific Energy Type for determining the energy type that the Armor
	// is restricted to use)
	CapacityStatHash Nullable[Hash[StatDefinition]] `json:"capacityStatHash,omitempty"`

	// If this Energy Type can be used as a cost to pay for socketing Armor 2.0 items, this is the hash for
	// the DestinyInvestmentStatDefinition that stores the plug's raw cost.
	CostStatHash Hash[StatDefinition] `json:"costStatHash"`

	// The description of the energy type, icon etc...
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// We have an enumeration for Energy types for quick reference. This is the current definition's Energy
	// type enum value.
	EnumValue EnergyType `json:"enumValue"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// If TRUE, the game shows this Energy type's icon. Otherwise, it doesn't. Whether you show it or not
	// is up to you.
	ShowIcon bool `json:"showIcon"`

	// A variant of the icon that is transparent and colorless.
	TransparentIconPath string `json:"transparentIconPath"`
}

// Destiny.Definitions.FireteamFinder.DestinyActivityGraphReference
type ActivityGraphReference struct {
	// {
	//   "properties": {
	//     "activityGraphHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Director.DestinyActivityGraphDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	ActivityGraphHash Hash[ActivityGraphDefinition] `json:"activityGraphHash"`
}

// Destiny.Definitions.FireteamFinder.DestinyActivityInteractableReference
type ActivityInteractableReference struct {
	// {
	//   "properties": {
	//     "activityInteractableElementIndex": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "activityInteractableHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Activities.DestinyActivityInteractableDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	ActivityInteractableElementIndex int32 `json:"activityInteractableElementIndex"`

	ActivityInteractableHash Hash[ActivityInteractableDefinition] `json:"activityInteractableHash"`
}

// Destiny.Definitions.FireteamFinder.DestinyFireteamFinderActivityGraphDefinition
type FireteamFinderActivityGraphDefinition struct {
	// {
	//   "properties": {
	//     "children": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderActivityGraphDefinition"
	//       }
	//     },
	//     "color": {
	//       "$ref": "#/components/schemas/Destiny.Misc.DestinyColor"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "isPlayerElectedDifficultyNode": {
	//       "type": "boolean"
	//     },
	//     "parentHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderActivityGraphDefinition"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "relatedActivityHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "relatedActivitySetHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderActivitySetDefinition"
	//       }
	//     },
	//     "relatedDirectorNodes": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyActivityGraphReference"
	//       },
	//       "type": "array"
	//     },
	//     "relatedInteractableActivities": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyActivityInteractableReference"
	//       },
	//       "type": "array"
	//     },
	//     "relatedLocationHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyLocationDefinition"
	//       }
	//     },
	//     "selfAndAllDescendantHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderActivityGraphDefinition"
	//       }
	//     },
	//     "specificActivitySetHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderActivitySetDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "FireteamFinderActivityGraphs"
	// }

	Children []uint32 `json:"children"`

	Color Color `json:"color"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	IsPlayerElectedDifficultyNode bool `json:"isPlayerElectedDifficultyNode"`

	ParentHash Nullable[Hash[FireteamFinderActivityGraphDefinition]] `json:"parentHash,omitempty"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	RelatedActivityHashes []uint32 `json:"relatedActivityHashes"`

	RelatedActivitySetHashes []uint32 `json:"relatedActivitySetHashes"`

	RelatedDirectorNodes []ActivityGraphReference `json:"relatedDirectorNodes"`

	RelatedInteractableActivities []ActivityInteractableReference `json:"relatedInteractableActivities"`

	RelatedLocationHashes []uint32 `json:"relatedLocationHashes"`

	SelfAndAllDescendantHashes []uint32 `json:"selfAndAllDescendantHashes"`

	SpecificActivitySetHash Nullable[Hash[FireteamFinderActivitySetDefinition]] `json:"specificActivitySetHash,omitempty"`
}

// Destiny.Definitions.FireteamFinder.DestinyFireteamFinderActivitySetDefinition
type FireteamFinderActivitySetDefinition struct {
	// {
	//   "properties": {
	//     "activityGraphHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderActivityGraphDefinition"
	//       }
	//     },
	//     "activityHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "labelHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderLabelDefinition"
	//       }
	//     },
	//     "maximumPartySize": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "optionHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderOptionDefinition"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "FireteamFinderActivitySets"
	// }

	ActivityGraphHashes []uint32 `json:"activityGraphHashes"`

	ActivityHashes []uint32 `json:"activityHashes"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	LabelHashes []uint32 `json:"labelHashes"`

	MaximumPartySize int32 `json:"maximumPartySize"`

	OptionHashes []uint32 `json:"optionHashes"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.FireteamFinder.DestinyFireteamFinderConstantsDefinition
type FireteamFinderConstantsDefinition struct {
	// {
	//   "properties": {
	//     "allFireteamFinderActivityHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "fireteamFinderActivityGraphRootCategoryHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderActivityGraphDefinition"
	//       }
	//     },
	//     "guardianOathDisplayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "guardianOathTenets": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "FireteamFinderConstants"
	// }

	AllFireteamFinderActivityHashes []uint32 `json:"allFireteamFinderActivityHashes"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	FireteamFinderActivityGraphRootCategoryHashes []uint32 `json:"fireteamFinderActivityGraphRootCategoryHashes"`

	GuardianOathDisplayProperties DisplayPropertiesDefinition `json:"guardianOathDisplayProperties"`

	GuardianOathTenets []DisplayPropertiesDefinition `json:"guardianOathTenets"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.FireteamFinder.DestinyFireteamFinderLabelDefinition
type FireteamFinderLabelDefinition struct {
	// {
	//   "properties": {
	//     "allowInFields": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.FireteamFinderLabelFieldType"
	//       }
	//     },
	//     "descendingSortPriority": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "groupHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderLabelGroupDefinition"
	//       }
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "FireteamFinderLabels"
	// }

	AllowInFields FireteamFinderLabelFieldType `json:"allowInFields"`

	DescendingSortPriority int32 `json:"descendingSortPriority"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	GroupHash Hash[FireteamFinderLabelGroupDefinition] `json:"groupHash"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.FireteamFinder.DestinyFireteamFinderLabelGroupDefinition
type FireteamFinderLabelGroupDefinition struct {
	// {
	//   "properties": {
	//     "descendingSortPriority": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "FireteamFinderLabelGroups"
	// }

	DescendingSortPriority int32 `json:"descendingSortPriority"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.FireteamFinder.DestinyFireteamFinderOptionCreatorSettings
type FireteamFinderOptionCreatorSettings struct {
	// {
	//   "properties": {
	//     "control": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderOptionSettingsControl"
	//     }
	//   },
	//   "type": "object"
	// }

	Control FireteamFinderOptionSettingsControl `json:"control"`
}

// Destiny.Definitions.FireteamFinder.DestinyFireteamFinderOptionDefinition
type FireteamFinderOptionDefinition struct {
	// {
	//   "properties": {
	//     "availability": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.FireteamFinderOptionAvailability"
	//       }
	//     },
	//     "codeOptionType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.FireteamFinderCodeOptionType"
	//       }
	//     },
	//     "creatorSettings": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderOptionCreatorSettings"
	//     },
	//     "descendingSortPriority": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "groupHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderOptionGroupDefinition"
	//       }
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "searcherSettings": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderOptionSearcherSettings"
	//     },
	//     "uiDisplayStyle": {
	//       "type": "string"
	//     },
	//     "values": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderOptionValues"
	//     },
	//     "visibility": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.FireteamFinderOptionVisibility"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "FireteamFinderOptions"
	// }

	Availability BitmaskSet[FireteamFinderOptionAvailability] `json:"availability"`

	CodeOptionType FireteamFinderCodeOptionType `json:"codeOptionType"`

	CreatorSettings FireteamFinderOptionCreatorSettings `json:"creatorSettings"`

	DescendingSortPriority int32 `json:"descendingSortPriority"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	GroupHash Hash[FireteamFinderOptionGroupDefinition] `json:"groupHash"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	SearcherSettings FireteamFinderOptionSearcherSettings `json:"searcherSettings"`

	UiDisplayStyle string `json:"uiDisplayStyle"`

	Values FireteamFinderOptionValues `json:"values"`

	Visibility FireteamFinderOptionVisibility `json:"visibility"`
}

// Destiny.Definitions.FireteamFinder.DestinyFireteamFinderOptionGroupDefinition
type FireteamFinderOptionGroupDefinition struct {
	// {
	//   "properties": {
	//     "descendingSortPriority": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "FireteamFinderOptionGroups"
	// }

	DescendingSortPriority int32 `json:"descendingSortPriority"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.FireteamFinder.DestinyFireteamFinderOptionSearcherSettings
type FireteamFinderOptionSearcherSettings struct {
	// {
	//   "properties": {
	//     "control": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderOptionSettingsControl"
	//     },
	//     "searchFilterType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.FireteamFinderOptionSearchFilterType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	Control FireteamFinderOptionSettingsControl `json:"control"`

	SearchFilterType FireteamFinderOptionSearchFilterType `json:"searchFilterType"`
}

// Destiny.Definitions.FireteamFinder.DestinyFireteamFinderOptionSettingsControl
type FireteamFinderOptionSettingsControl struct {
	// {
	//   "properties": {
	//     "maxSelectedItems": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "minSelectedItems": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "type": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.FireteamFinderOptionControlType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	MaxSelectedItems int32 `json:"maxSelectedItems"`

	MinSelectedItems int32 `json:"minSelectedItems"`

	Type FireteamFinderOptionControlType `json:"type"`
}

// Destiny.Definitions.FireteamFinder.DestinyFireteamFinderOptionValueDefinition
type FireteamFinderOptionValueDefinition struct {
	// {
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "flags": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.FireteamFinderOptionValueFlags"
	//       }
	//     },
	//     "value": {
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	Flags BitmaskSet[FireteamFinderOptionValueFlags] `json:"flags"`

	Value uint32 `json:"value"`
}

// Destiny.Definitions.FireteamFinder.DestinyFireteamFinderOptionValues
type FireteamFinderOptionValues struct {
	// {
	//   "properties": {
	//     "displayFormatType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.FireteamFinderOptionDisplayFormat"
	//       }
	//     },
	//     "optionalFormatString": {
	//       "type": "string"
	//     },
	//     "optionalNull": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "type": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.FireteamFinderOptionValueProviderType"
	//       }
	//     },
	//     "valueDefinitions": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderOptionValueDefinition"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	DisplayFormatType FireteamFinderOptionDisplayFormat `json:"displayFormatType"`

	OptionalFormatString string `json:"optionalFormatString"`

	OptionalNull DisplayPropertiesDefinition `json:"optionalNull"`

	Type FireteamFinderOptionValueProviderType `json:"type"`

	ValueDefinitions []FireteamFinderOptionValueDefinition `json:"valueDefinitions"`
}

// Destiny.Definitions.GuardianRanks.DestinyGuardianRankConstantsDefinition
type GuardianRankConstantsDefinition struct {
	// {
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "guardianRankHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.GuardianRanks.DestinyGuardianRankDefinition"
	//       }
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "iconBackgrounds": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.GuardianRanks.DestinyGuardianRankIconBackgroundsDefinition"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "rankCount": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "rootNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "GuardianRankConstants"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	GuardianRankHashes []uint32 `json:"guardianRankHashes"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	IconBackgrounds GuardianRankIconBackgroundsDefinition `json:"iconBackgrounds"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	RankCount int32 `json:"rankCount"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	RootNodeHash Hash[PresentationNodeDefinition] `json:"rootNodeHash"`
}

// Destiny.Definitions.GuardianRanks.DestinyGuardianRankDefinition
type GuardianRankDefinition struct {
	// {
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "foregroundImagePath": {
	//       "type": "string"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "overlayImagePath": {
	//       "type": "string"
	//     },
	//     "overlayMaskImagePath": {
	//       "type": "string"
	//     },
	//     "presentationNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "rankNumber": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "GuardianRanks"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	ForegroundImagePath string `json:"foregroundImagePath"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	OverlayImagePath string `json:"overlayImagePath"`

	OverlayMaskImagePath string `json:"overlayMaskImagePath"`

	PresentationNodeHash Hash[PresentationNodeDefinition] `json:"presentationNodeHash"`

	RankNumber int32 `json:"rankNumber"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.GuardianRanks.DestinyGuardianRankIconBackgroundsDefinition
type GuardianRankIconBackgroundsDefinition struct {
	// {
	//   "properties": {
	//     "backgroundEmptyBlueGradientBorderedImagePath": {
	//       "type": "string"
	//     },
	//     "backgroundEmptyBorderedImagePath": {
	//       "type": "string"
	//     },
	//     "backgroundFilledBlueBorderedImagePath": {
	//       "type": "string"
	//     },
	//     "backgroundFilledBlueGradientBorderedImagePath": {
	//       "type": "string"
	//     },
	//     "backgroundFilledBlueLowAlphaImagePath": {
	//       "type": "string"
	//     },
	//     "backgroundFilledBlueMediumAlphaImagePath": {
	//       "type": "string"
	//     },
	//     "backgroundFilledGrayHeavyAlphaBorderedImagePath": {
	//       "type": "string"
	//     },
	//     "backgroundFilledGrayMediumAlphaBorderedImagePath": {
	//       "type": "string"
	//     },
	//     "backgroundFilledWhiteImagePath": {
	//       "type": "string"
	//     },
	//     "backgroundFilledWhiteMediumAlphaImagePath": {
	//       "type": "string"
	//     },
	//     "backgroundPlateBlackAlphaImagePath": {
	//       "type": "string"
	//     },
	//     "backgroundPlateBlackImagePath": {
	//       "type": "string"
	//     },
	//     "backgroundPlateWhiteImagePath": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	BackgroundEmptyBlueGradientBorderedImagePath string `json:"backgroundEmptyBlueGradientBorderedImagePath"`

	BackgroundEmptyBorderedImagePath string `json:"backgroundEmptyBorderedImagePath"`

	BackgroundFilledBlueBorderedImagePath string `json:"backgroundFilledBlueBorderedImagePath"`

	BackgroundFilledBlueGradientBorderedImagePath string `json:"backgroundFilledBlueGradientBorderedImagePath"`

	BackgroundFilledBlueLowAlphaImagePath string `json:"backgroundFilledBlueLowAlphaImagePath"`

	BackgroundFilledBlueMediumAlphaImagePath string `json:"backgroundFilledBlueMediumAlphaImagePath"`

	BackgroundFilledGrayHeavyAlphaBorderedImagePath string `json:"backgroundFilledGrayHeavyAlphaBorderedImagePath"`

	BackgroundFilledGrayMediumAlphaBorderedImagePath string `json:"backgroundFilledGrayMediumAlphaBorderedImagePath"`

	BackgroundFilledWhiteImagePath string `json:"backgroundFilledWhiteImagePath"`

	BackgroundFilledWhiteMediumAlphaImagePath string `json:"backgroundFilledWhiteMediumAlphaImagePath"`

	BackgroundPlateBlackAlphaImagePath string `json:"backgroundPlateBlackAlphaImagePath"`

	BackgroundPlateBlackImagePath string `json:"backgroundPlateBlackImagePath"`

	BackgroundPlateWhiteImagePath string `json:"backgroundPlateWhiteImagePath"`
}

// Destiny.Definitions.Items.DestinyDerivedItemCategoryDefinition
//
// A shortcut for the fact that some items have a "Preview Vendor" - See
// DestinyInventoryItemDefinition.preview.previewVendorHash - that is intended to be used to show what
// items you can get as a result of acquiring or using this item.
// A common example of this in Destiny 1 was Eververse "Boxes," which could have many possible items.
// This "Preview Vendor" is not a vendor you can actually see in the game, but it defines categories
// and sale items for all of the possible items you could get from the Box so that the game can show
// them to you. We summarize that info here so that you don't have to do that Vendor lookup and
// aggregation manually.
type DerivedItemCategoryDefinition struct {
	// {
	//   "description": "A shortcut for the fact that some items have a \"Preview Vendor\" - See DestinyInventoryItemDefinition.preview.previewVendorHash - that is intended to be used to show what items you can get as a result of acquiring or using this item.\r\nA common example of this in Destiny 1 was Eververse \"Boxes,\" which could have many possible items. This \"Preview Vendor\" is not a vendor you can actually see in the game, but it defines categories and sale items for all of the possible items you could get from the Box so that the game can show them to you. We summarize that info here so that you don't have to do that Vendor lookup and aggregation manually.",
	//   "properties": {
	//     "categoryDescription": {
	//       "description": "The localized string for the category title. This will be something describing the items you can get as a group, or your likelihood/the quantity you'll get.",
	//       "type": "string"
	//     },
	//     "items": {
	//       "description": "This is the list of all of the items for this category and the basic properties we'll know about them.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Items.DestinyDerivedItemDefinition"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The localized string for the category title. This will be something describing the items you can get
	// as a group, or your likelihood/the quantity you'll get.
	CategoryDescription string `json:"categoryDescription"`

	// This is the list of all of the items for this category and the basic properties we'll know about
	// them.
	Items []DerivedItemDefinition `json:"items"`
}

// Destiny.Definitions.Items.DestinyDerivedItemDefinition
//
// This is a reference to, and summary data for, a specific item that you can get as a result of Using
// or Acquiring some other Item (For example, this could be summary information for an Emote that you
// can get by opening an an Eververse Box) See DestinyDerivedItemCategoryDefinition for more
// information.
type DerivedItemDefinition struct {
	// {
	//   "description": "This is a reference to, and summary data for, a specific item that you can get as a result of Using or Acquiring some other Item (For example, this could be summary information for an Emote that you can get by opening an an Eververse Box) See DestinyDerivedItemCategoryDefinition for more information.",
	//   "properties": {
	//     "iconPath": {
	//       "description": "An icon for the item.",
	//       "type": "string"
	//     },
	//     "itemDescription": {
	//       "description": "A brief description of the item.",
	//       "type": "string"
	//     },
	//     "itemDetail": {
	//       "description": "Additional details about the derived item, in addition to the description.",
	//       "type": "string"
	//     },
	//     "itemHash": {
	//       "description": "The hash for the DestinyInventoryItemDefinition of this derived item, if there is one. Sometimes we are given this information as a manual override, in which case there won't be an actual DestinyInventoryItemDefinition for what we display, but you can still show the strings from this object itself.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "itemName": {
	//       "description": "The name of the derived item.",
	//       "type": "string"
	//     },
	//     "vendorItemIndex": {
	//       "description": "If the item was derived from a \"Preview Vendor\", this will be an index into the DestinyVendorDefinition's itemList property. Otherwise, -1.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// An icon for the item.
	IconPath string `json:"iconPath"`

	// A brief description of the item.
	ItemDescription string `json:"itemDescription"`

	// Additional details about the derived item, in addition to the description.
	ItemDetail string `json:"itemDetail"`

	// The hash for the DestinyInventoryItemDefinition of this derived item, if there is one. Sometimes we
	// are given this information as a manual override, in which case there won't be an actual
	// DestinyInventoryItemDefinition for what we display, but you can still show the strings from this
	// object itself.
	ItemHash Nullable[uint32] `json:"itemHash,omitempty"`

	// The name of the derived item.
	ItemName string `json:"itemName"`

	// If the item was derived from a "Preview Vendor", this will be an index into the
	// DestinyVendorDefinition's itemList property. Otherwise, -1.
	VendorItemIndex int32 `json:"vendorItemIndex"`
}

// Destiny.Definitions.Items.DestinyEnergyCapacityEntry
//
// Items can have Energy Capacity, and plugs can provide that capacity such as on a piece of Armor in
// Armor 2.0. This is how much "Energy" can be spent on activating plugs for this item.
type EnergyCapacityEntry struct {
	// {
	//   "description": "Items can have Energy Capacity, and plugs can provide that capacity such as on a piece of Armor in Armor 2.0. This is how much \"Energy\" can be spent on activating plugs for this item.",
	//   "properties": {
	//     "capacityValue": {
	//       "description": "How much energy capacity this plug provides.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "energyType": {
	//       "description": "The Energy Type for this energy capacity, in enum form for easy use.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyEnergyType"
	//       }
	//     },
	//     "energyTypeHash": {
	//       "description": "Energy provided by a plug is always of a specific type - this is the hash identifier for the energy type for which it provides Capacity.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.EnergyTypes.DestinyEnergyTypeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// How much energy capacity this plug provides.
	CapacityValue int32 `json:"capacityValue"`

	// The Energy Type for this energy capacity, in enum form for easy use.
	EnergyType EnergyType `json:"energyType"`

	// Energy provided by a plug is always of a specific type - this is the hash identifier for the energy
	// type for which it provides Capacity.
	EnergyTypeHash Hash[EnergyTypeDefinition] `json:"energyTypeHash"`
}

// Destiny.Definitions.Items.DestinyEnergyCostEntry
//
// Some plugs cost Energy, which is a stat on the item that can be increased by other plugs (that, at
// least in Armor 2.0, have a "masterworks-like" mechanic for upgrading). If a plug has costs, the
// details of that cost are defined here.
type EnergyCostEntry struct {
	// {
	//   "description": "Some plugs cost Energy, which is a stat on the item that can be increased by other plugs (that, at least in Armor 2.0, have a \"masterworks-like\" mechanic for upgrading). If a plug has costs, the details of that cost are defined here.",
	//   "properties": {
	//     "energyCost": {
	//       "description": "The Energy cost for inserting this plug.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "energyType": {
	//       "description": "The type of energy that this plug costs, in enum form.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyEnergyType"
	//       }
	//     },
	//     "energyTypeHash": {
	//       "description": "The type of energy that this plug costs, as a reference to the DestinyEnergyTypeDefinition of the energy type.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.EnergyTypes.DestinyEnergyTypeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The Energy cost for inserting this plug.
	EnergyCost int32 `json:"energyCost"`

	// The type of energy that this plug costs, in enum form.
	EnergyType EnergyType `json:"energyType"`

	// The type of energy that this plug costs, as a reference to the DestinyEnergyTypeDefinition of the
	// energy type.
	EnergyTypeHash Hash[EnergyTypeDefinition] `json:"energyTypeHash"`
}

// Destiny.Definitions.Items.DestinyItemPlugDefinition
//
// If an item is a Plug, its DestinyInventoryItemDefinition.plug property will be populated with an
// instance of one of these bad boys.
// This gives information about when it can be inserted, what the plug's category is (and thus whether
// it is compatible with a socket... see DestinySocketTypeDefinition for information about Plug
// Categories and socket compatibility), whether it is enabled and other Plug info.
type ItemPlugDefinition struct {
	// {
	//   "description": "If an item is a Plug, its DestinyInventoryItemDefinition.plug property will be populated with an instance of one of these bad boys.\r\nThis gives information about when it can be inserted, what the plug's category is (and thus whether it is compatible with a socket... see DestinySocketTypeDefinition for information about Plug Categories and socket compatibility), whether it is enabled and other Plug info.",
	//   "properties": {
	//     "alternatePlugStyle": {
	//       "description": "The alternate plug of the plug: only applies when the item is in states that only the server can know about and control, unfortunately. See AlternateUiPlugLabel for the related label info.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.PlugUiStyles"
	//       }
	//     },
	//     "alternateUiPlugLabel": {
	//       "description": "If the plug meets certain state requirements, it may have an alternative label applied to it. This is the alternative label that will be applied in such a situation.",
	//       "type": "string"
	//     },
	//     "enabledMaterialRequirementHash": {
	//       "description": "It's not enough for the plug to be inserted. It has to be enabled as well. For it to be enabled, it may require materials. This is the hash identifier for the DestinyMaterialRequirementSetDefinition for those requirements, if there is one.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyMaterialRequirementSetDefinition"
	//       }
	//     },
	//     "enabledRules": {
	//       "description": "The rules around whether the plug, once inserted, is enabled and providing its benefits.\r\nThe live data DestinyItemPlugComponent.enableFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Items.DestinyPlugRuleDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "energyCapacity": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Items.DestinyEnergyCapacityEntry"
	//         }
	//       ],
	//       "description": "IF not null, this plug provides Energy capacity to the item in which it is socketed. In Armor 2.0 for example, is implemented in a similar way to Masterworks, where visually it's a single area of the UI being clicked on to \"Upgrade\" to higher energy levels, but it's actually socketing new plugs.",
	//       "type": "object"
	//     },
	//     "energyCost": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Items.DestinyEnergyCostEntry"
	//         }
	//       ],
	//       "description": "IF not null, this plug has an energy cost. This contains the details of that cost.",
	//       "type": "object"
	//     },
	//     "insertionMaterialRequirementHash": {
	//       "description": "If inserting this plug requires materials, this is the hash identifier for looking up the DestinyMaterialRequirementSetDefinition for those requirements.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyMaterialRequirementSetDefinition"
	//       }
	//     },
	//     "insertionRules": {
	//       "description": "The rules around when this plug can be inserted into a socket, aside from the socket's individual restrictions.\r\nThe live data DestinyItemPlugComponent.insertFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Items.DestinyPlugRuleDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "isDummyPlug": {
	//       "description": "If TRUE, this plug is used for UI display purposes only, and doesn't have any interesting effects of its own.",
	//       "type": "boolean"
	//     },
	//     "onActionRecreateSelf": {
	//       "description": "If you successfully socket the item, this will determine whether or not you get \"refunded\" on the plug.",
	//       "type": "boolean"
	//     },
	//     "parentItemOverride": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Items.DestinyParentItemOverride"
	//         }
	//       ],
	//       "description": "Do you ever get the feeling that a system has become so overburdened by edge cases that it probably should have become some other system entirely? So do I!\r\nIn totally unrelated news, Plugs can now override properties of their parent items. This is some of the relevant definition data for those overrides.\r\nIf this is populated, it will have the override data to be applied when this plug is applied to an item.",
	//       "type": "object"
	//     },
	//     "plugAvailability": {
	//       "description": "Indicates the rules about when this plug can be used. See the PlugAvailabilityMode enumeration for more information!",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.PlugAvailabilityMode"
	//       }
	//     },
	//     "plugCategoryHash": {
	//       "description": "The hash for the plugCategoryIdentifier. You can use this instead if you wish: I put both in the definition for debugging purposes.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "plugCategoryIdentifier": {
	//       "description": "The string identifier for the plug's category. Use the socket's DestinySocketTypeDefinition.plugWhitelist to determine whether this plug can be inserted into the socket.",
	//       "type": "string"
	//     },
	//     "plugStyle": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.PlugUiStyles"
	//       }
	//     },
	//     "previewItemOverrideHash": {
	//       "description": "In the game, if you're inspecting a plug item directly, this will be the item shown with the plug attached. Look up the DestinyInventoryItemDefinition for this hash for the item.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "uiPlugLabel": {
	//       "description": "Plugs can have arbitrary, UI-defined identifiers that the UI designers use to determine the style applied to plugs. Unfortunately, we have neither a definitive list of these labels nor advance warning of when new labels might be applied or how that relates to how they get rendered. If you want to, you can refer to known labels to change your own styles: but know that new ones can be created arbitrarily, and we have no way of associating the labels with any specific UI style guidance... you'll have to piece that together on your end. Or do what we do, and just show plugs more generically, without specialized styles.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// The alternate plug of the plug: only applies when the item is in states that only the server can
	// know about and control, unfortunately. See AlternateUiPlugLabel for the related label info.
	AlternatePlugStyle BitmaskSet[PlugUiStyles] `json:"alternatePlugStyle"`

	// If the plug meets certain state requirements, it may have an alternative label applied to it. This
	// is the alternative label that will be applied in such a situation.
	AlternateUiPlugLabel string `json:"alternateUiPlugLabel"`

	// It's not enough for the plug to be inserted. It has to be enabled as well. For it to be enabled, it
	// may require materials. This is the hash identifier for the DestinyMaterialRequirementSetDefinition
	// for those requirements, if there is one.
	EnabledMaterialRequirementHash Hash[MaterialRequirementSetDefinition] `json:"enabledMaterialRequirementHash"`

	// The rules around whether the plug, once inserted, is enabled and providing its benefits.
	// The live data DestinyItemPlugComponent.enableFailIndexes will be an index into this array, so you
	// can pull out the failure strings appropriate for the user.
	EnabledRules []PlugRuleDefinition `json:"enabledRules"`

	// IF not null, this plug provides Energy capacity to the item in which it is socketed. In Armor 2.0
	// for example, is implemented in a similar way to Masterworks, where visually it's a single area of
	// the UI being clicked on to "Upgrade" to higher energy levels, but it's actually socketing new plugs.
	EnergyCapacity EnergyCapacityEntry `json:"energyCapacity"`

	// IF not null, this plug has an energy cost. This contains the details of that cost.
	EnergyCost EnergyCostEntry `json:"energyCost"`

	// If inserting this plug requires materials, this is the hash identifier for looking up the
	// DestinyMaterialRequirementSetDefinition for those requirements.
	InsertionMaterialRequirementHash Hash[MaterialRequirementSetDefinition] `json:"insertionMaterialRequirementHash"`

	// The rules around when this plug can be inserted into a socket, aside from the socket's individual
	// restrictions.
	// The live data DestinyItemPlugComponent.insertFailIndexes will be an index into this array, so you
	// can pull out the failure strings appropriate for the user.
	InsertionRules []PlugRuleDefinition `json:"insertionRules"`

	// If TRUE, this plug is used for UI display purposes only, and doesn't have any interesting effects of
	// its own.
	IsDummyPlug bool `json:"isDummyPlug"`

	// If you successfully socket the item, this will determine whether or not you get "refunded" on the
	// plug.
	OnActionRecreateSelf bool `json:"onActionRecreateSelf"`

	// Do you ever get the feeling that a system has become so overburdened by edge cases that it probably
	// should have become some other system entirely? So do I!
	// In totally unrelated news, Plugs can now override properties of their parent items. This is some of
	// the relevant definition data for those overrides.
	// If this is populated, it will have the override data to be applied when this plug is applied to an
	// item.
	ParentItemOverride ParentItemOverride `json:"parentItemOverride"`

	// Indicates the rules about when this plug can be used. See the PlugAvailabilityMode enumeration for
	// more information!
	PlugAvailability PlugAvailabilityMode `json:"plugAvailability"`

	// The hash for the plugCategoryIdentifier. You can use this instead if you wish: I put both in the
	// definition for debugging purposes.
	PlugCategoryHash uint32 `json:"plugCategoryHash"`

	// The string identifier for the plug's category. Use the socket's
	// DestinySocketTypeDefinition.plugWhitelist to determine whether this plug can be inserted into the
	// socket.
	PlugCategoryIdentifier string `json:"plugCategoryIdentifier"`

	PlugStyle BitmaskSet[PlugUiStyles] `json:"plugStyle"`

	// In the game, if you're inspecting a plug item directly, this will be the item shown with the plug
	// attached. Look up the DestinyInventoryItemDefinition for this hash for the item.
	PreviewItemOverrideHash Hash[InventoryItemDefinition] `json:"previewItemOverrideHash"`

	// Plugs can have arbitrary, UI-defined identifiers that the UI designers use to determine the style
	// applied to plugs. Unfortunately, we have neither a definitive list of these labels nor advance
	// warning of when new labels might be applied or how that relates to how they get rendered. If you
	// want to, you can refer to known labels to change your own styles: but know that new ones can be
	// created arbitrarily, and we have no way of associating the labels with any specific UI style
	// guidance... you'll have to piece that together on your end. Or do what we do, and just show plugs
	// more generically, without specialized styles.
	UiPlugLabel string `json:"uiPlugLabel"`
}

// Destiny.Definitions.Items.DestinyItemTierTypeDefinition
//
// Defines the tier type of an item. Mostly this provides human readable properties for types like
// Common, Rare, etc...
// It also provides some base data for infusion that could be useful.
type ItemTierTypeDefinition struct {
	// {
	//   "description": "Defines the tier type of an item. Mostly this provides human readable properties for types like Common, Rare, etc...\r\nIt also provides some base data for infusion that could be useful.",
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "infusionProcess": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Items.DestinyItemTierTypeInfusionBlock"
	//         }
	//       ],
	//       "description": "If this tier defines infusion properties, they will be contained here.",
	//       "type": "object"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "ItemTierTypes"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this tier defines infusion properties, they will be contained here.
	InfusionProcess ItemTierTypeInfusionBlock `json:"infusionProcess"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.Items.DestinyItemTierTypeInfusionBlock
type ItemTierTypeInfusionBlock struct {
	// {
	//   "properties": {
	//     "baseQualityTransferRatio": {
	//       "description": "The default portion of quality that will transfer from the infuser to the infusee item. (InfuserQuality - InfuseeQuality) * baseQualityTransferRatio = base quality transferred.",
	//       "format": "float",
	//       "type": "number"
	//     },
	//     "minimumQualityIncrement": {
	//       "description": "As long as InfuserQuality \u003e InfuseeQuality, the amount of quality bestowed is guaranteed to be at least this value, even if the transferRatio would dictate that it should be less. The total amount of quality that ends up in the Infusee cannot exceed the Infuser's quality however (for instance, if you infuse a 300 item with a 301 item and the minimum quality increment is 10, the infused item will not end up with 310 quality)",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// The default portion of quality that will transfer from the infuser to the infusee item.
	// (InfuserQuality - InfuseeQuality) * baseQualityTransferRatio = base quality transferred.
	BaseQualityTransferRatio float64 `json:"baseQualityTransferRatio"`

	// As long as InfuserQuality > InfuseeQuality, the amount of quality bestowed is guaranteed to be at
	// least this value, even if the transferRatio would dictate that it should be less. The total amount
	// of quality that ends up in the Infusee cannot exceed the Infuser's quality however (for instance, if
	// you infuse a 300 item with a 301 item and the minimum quality increment is 10, the infused item will
	// not end up with 310 quality)
	MinimumQualityIncrement int32 `json:"minimumQualityIncrement"`
}

// Destiny.Definitions.Items.DestinyParentItemOverride
type ParentItemOverride struct {
	// {
	//   "properties": {
	//     "additionalEquipRequirementsDisplayStrings": {
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     },
	//     "pipIcon": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	AdditionalEquipRequirementsDisplayStrings []string `json:"additionalEquipRequirementsDisplayStrings"`

	PipIcon string `json:"pipIcon"`
}

// Destiny.Definitions.Items.DestinyPlugRuleDefinition
//
// Dictates a rule around whether the plug is enabled or insertable.
// In practice, the live Destiny data will refer to these entries by index. You can then look up that
// index in the appropriate property (enabledRules or insertionRules) to get the localized string for
// the failure message if it failed.
type PlugRuleDefinition struct {
	// {
	//   "description": "Dictates a rule around whether the plug is enabled or insertable.\r\nIn practice, the live Destiny data will refer to these entries by index. You can then look up that index in the appropriate property (enabledRules or insertionRules) to get the localized string for the failure message if it failed.",
	//   "properties": {
	//     "failureMessage": {
	//       "description": "The localized string to show if this rule fails.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// The localized string to show if this rule fails.
	FailureMessage string `json:"failureMessage"`
}

// Destiny.Definitions.Loadouts.DestinyLoadoutColorDefinition
type LoadoutColorDefinition struct {
	// {
	//   "properties": {
	//     "colorImagePath": {
	//       "type": "string"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "LoadoutColors"
	// }

	ColorImagePath string `json:"colorImagePath"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.Loadouts.DestinyLoadoutConstantsDefinition
type LoadoutConstantsDefinition struct {
	// {
	//   "properties": {
	//     "blackIconImagePath": {
	//       "description": "This is a color-inverted version of the whiteIconImagePath.",
	//       "type": "string"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "loadoutColorHashes": {
	//       "description": "A list of the loadout color hashes in index order, for convenience.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Loadouts.DestinyLoadoutColorDefinition"
	//       }
	//     },
	//     "loadoutCountPerCharacter": {
	//       "description": "The maximum number of loadouts available to each character. The loadouts component API response can return fewer loadouts than this, as more loadouts are unlocked by reaching higher Guardian Ranks.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "loadoutIconHashes": {
	//       "description": "A list of the loadout icon hashes in index order, for convenience.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Loadouts.DestinyLoadoutIconDefinition"
	//       }
	//     },
	//     "loadoutNameHashes": {
	//       "description": "A list of the loadout name hashes in index order, for convenience.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Loadouts.DestinyLoadoutNameDefinition"
	//       }
	//     },
	//     "loadoutPreviewFilterOutSocketCategoryHashes": {
	//       "description": "A list of the socket category hashes to be filtered out of loadout item preview displays.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinySocketCategoryDefinition"
	//       }
	//     },
	//     "loadoutPreviewFilterOutSocketTypeHashes": {
	//       "description": "A list of the socket type hashes to be filtered out of loadout item preview displays.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinySocketTypeDefinition"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "whiteIconImagePath": {
	//       "description": "This is the same icon as the one in the display properties, offered here as well with a more descriptive name.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "LoadoutConstants"
	// }

	// This is a color-inverted version of the whiteIconImagePath.
	BlackIconImagePath string `json:"blackIconImagePath"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// A list of the loadout color hashes in index order, for convenience.
	LoadoutColorHashes []uint32 `json:"loadoutColorHashes"`

	// The maximum number of loadouts available to each character. The loadouts component API response can
	// return fewer loadouts than this, as more loadouts are unlocked by reaching higher Guardian Ranks.
	LoadoutCountPerCharacter int32 `json:"loadoutCountPerCharacter"`

	// A list of the loadout icon hashes in index order, for convenience.
	LoadoutIconHashes []uint32 `json:"loadoutIconHashes"`

	// A list of the loadout name hashes in index order, for convenience.
	LoadoutNameHashes []uint32 `json:"loadoutNameHashes"`

	// A list of the socket category hashes to be filtered out of loadout item preview displays.
	LoadoutPreviewFilterOutSocketCategoryHashes []uint32 `json:"loadoutPreviewFilterOutSocketCategoryHashes"`

	// A list of the socket type hashes to be filtered out of loadout item preview displays.
	LoadoutPreviewFilterOutSocketTypeHashes []uint32 `json:"loadoutPreviewFilterOutSocketTypeHashes"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// This is the same icon as the one in the display properties, offered here as well with a more
	// descriptive name.
	WhiteIconImagePath string `json:"whiteIconImagePath"`
}

// Destiny.Definitions.Loadouts.DestinyLoadoutIconDefinition
type LoadoutIconDefinition struct {
	// {
	//   "properties": {
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "iconImagePath": {
	//       "type": "string"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "LoadoutIcons"
	// }

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	IconImagePath string `json:"iconImagePath"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.Loadouts.DestinyLoadoutNameDefinition
type LoadoutNameDefinition struct {
	// {
	//   "properties": {
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "LoadoutNames"
	// }

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	Name string `json:"name"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.Lore.DestinyLoreDefinition
//
// These are definitions for in-game "Lore," meant to be narrative enhancements of the game experience.
// DestinyInventoryItemDefinitions for interesting items point to these definitions, but nothing's
// stopping you from scraping all of these and doing something cool with them. If they end up having
// cool data.
type LoreDefinition struct {
	// {
	//   "description": "These are definitions for in-game \"Lore,\" meant to be narrative enhancements of the game experience.\r\nDestinyInventoryItemDefinitions for interesting items point to these definitions, but nothing's stopping you from scraping all of these and doing something cool with them. If they end up having cool data.",
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "subtitle": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Lore"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	Subtitle string `json:"subtitle"`
}

// Destiny.Definitions.Metrics.DestinyMetricDefinition
type MetricDefinition struct {
	// {
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "lowerValueIsBetter": {
	//       "type": "boolean"
	//     },
	//     "parentNodeHashes": {
	//       "description": "A quick reference to presentation nodes that have this node as a child. Presentation nodes can be parented under multiple parents.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "presentationNodeType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyPresentationNodeType"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "trackingObjectiveHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectiveDefinition"
	//       }
	//     },
	//     "traitHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Traits.DestinyTraitDefinition"
	//       }
	//     },
	//     "traitIds": {
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Metrics"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	LowerValueIsBetter bool `json:"lowerValueIsBetter"`

	// A quick reference to presentation nodes that have this node as a child. Presentation nodes can be
	// parented under multiple parents.
	ParentNodeHashes []uint32 `json:"parentNodeHashes"`

	PresentationNodeType PresentationNodeType `json:"presentationNodeType"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	TrackingObjectiveHash Hash[ObjectiveDefinition] `json:"trackingObjectiveHash"`

	TraitHashes []uint32 `json:"traitHashes"`

	TraitIds []string `json:"traitIds"`
}

// Destiny.Definitions.Milestones.DestinyMilestoneActivityDefinition
//
// Milestones can have associated activities which provide additional information about the context,
// challenges, modifiers, state etc... related to this Milestone.
// Information we need to be able to return that data is defined here, along with Tier data to
// establish a relationship between a conceptual Activity and its difficulty levels and variants.
type MilestoneActivityDefinition struct {
	// {
	//   "description": "Milestones can have associated activities which provide additional information about the context, challenges, modifiers, state etc... related to this Milestone. \r\nInformation we need to be able to return that data is defined here, along with Tier data to establish a relationship between a conceptual Activity and its difficulty levels and variants.",
	//   "properties": {
	//     "conceptualActivityHash": {
	//       "description": "The \"Conceptual\" activity hash. Basically, we picked the lowest level activity and are treating it as the canonical definition of the activity for rendering purposes.\r\nIf you care about the specific difficulty modes and variations, use the activities under \"Variants\".",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "variants": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneActivityVariantDefinition"
	//       },
	//       "description": "A milestone-referenced activity can have many variants, such as Tiers or alternative modes of play.\r\nEven if there is only a single variant, the details for these are represented within as a variant definition.\r\nIt is assumed that, if this DestinyMilestoneActivityDefinition is active, then all variants should be active.\r\nIf a Milestone could ever split the variants' active status conditionally, they should all have their own DestinyMilestoneActivityDefinition instead! The potential duplication will be worth it for the obviousness of processing and use.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The "Conceptual" activity hash. Basically, we picked the lowest level activity and are treating it
	// as the canonical definition of the activity for rendering purposes.
	// If you care about the specific difficulty modes and variations, use the activities under "Variants".
	ConceptualActivityHash Hash[ActivityDefinition] `json:"conceptualActivityHash"`

	// A milestone-referenced activity can have many variants, such as Tiers or alternative modes of play.
	// Even if there is only a single variant, the details for these are represented within as a variant
	// definition.
	// It is assumed that, if this DestinyMilestoneActivityDefinition is active, then all variants should
	// be active.
	// If a Milestone could ever split the variants' active status conditionally, they should all have
	// their own DestinyMilestoneActivityDefinition instead! The potential duplication will be worth it for
	// the obviousness of processing and use.
	Variants map[Hash[ActivityDefinition]]MilestoneActivityVariantDefinition `json:"variants"`
}

// Destiny.Definitions.Milestones.DestinyMilestoneActivityVariantDefinition
//
// Represents a variant on an activity for a Milestone: a specific difficulty tier, or a specific
// activity variant for example.
// These will often have more specific details, such as an associated Guided Game, progression steps,
// tier-specific rewards, and custom values.
type MilestoneActivityVariantDefinition struct {
	// {
	//   "description": "Represents a variant on an activity for a Milestone: a specific difficulty tier, or a specific activity variant for example.\r\nThese will often have more specific details, such as an associated Guided Game, progression steps, tier-specific rewards, and custom values.",
	//   "properties": {
	//     "activityHash": {
	//       "description": "The hash to use for looking up the variant Activity's definition (DestinyActivityDefinition), where you can find its distinguishing characteristics such as difficulty level and recommended light level. \r\nFrequently, that will be the only distinguishing characteristics in practice, which is somewhat of a bummer.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "order": {
	//       "description": "If you care to do so, render the variants in the order prescribed by this value.\r\nWhen you combine live Milestone data with the definition, the order becomes more useful because you'll be cross-referencing between the definition and live data.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash to use for looking up the variant Activity's definition (DestinyActivityDefinition), where
	// you can find its distinguishing characteristics such as difficulty level and recommended light
	// level.
	// Frequently, that will be the only distinguishing characteristics in practice, which is somewhat of a
	// bummer.
	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`

	// If you care to do so, render the variants in the order prescribed by this value.
	// When you combine live Milestone data with the definition, the order becomes more useful because
	// you'll be cross-referencing between the definition and live data.
	Order int32 `json:"order"`
}

// Destiny.Definitions.Milestones.DestinyMilestoneChallengeActivityDefinition
type MilestoneChallengeActivityDefinition struct {
	// {
	//   "properties": {
	//     "activityGraphNodes": {
	//       "description": "If the activity and its challenge is visible on any of these nodes, it will be returned.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneChallengeActivityGraphNodeEntry"
	//       },
	//       "type": "array"
	//     },
	//     "activityHash": {
	//       "description": "The activity for which this challenge is active.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "challenges": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneChallengeDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "phases": {
	//       "description": "Phases related to this activity, if there are any.\r\nThese will be listed in the order in which they will appear in the actual activity.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneChallengeActivityPhase"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// If the activity and its challenge is visible on any of these nodes, it will be returned.
	ActivityGraphNodes []MilestoneChallengeActivityGraphNodeEntry `json:"activityGraphNodes"`

	// The activity for which this challenge is active.
	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`

	Challenges []MilestoneChallengeDefinition `json:"challenges"`

	// Phases related to this activity, if there are any.
	// These will be listed in the order in which they will appear in the actual activity.
	Phases []MilestoneChallengeActivityPhase `json:"phases"`
}

// Destiny.Definitions.Milestones.DestinyMilestoneChallengeActivityGraphNodeEntry
type MilestoneChallengeActivityGraphNodeEntry struct {
	// {
	//   "properties": {
	//     "activityGraphHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "activityGraphNodeHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	ActivityGraphHash uint32 `json:"activityGraphHash"`

	ActivityGraphNodeHash uint32 `json:"activityGraphNodeHash"`
}

// Destiny.Definitions.Milestones.DestinyMilestoneChallengeActivityPhase
type MilestoneChallengeActivityPhase struct {
	// {
	//   "properties": {
	//     "phaseHash": {
	//       "description": "The hash identifier of the activity's phase.",
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash identifier of the activity's phase.
	PhaseHash uint32 `json:"phaseHash"`
}

// Destiny.Definitions.Milestones.DestinyMilestoneChallengeDefinition
type MilestoneChallengeDefinition struct {
	// {
	//   "properties": {
	//     "challengeObjectiveHash": {
	//       "description": "The challenge related to this milestone.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectiveDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The challenge related to this milestone.
	ChallengeObjectiveHash Hash[ObjectiveDefinition] `json:"challengeObjectiveHash"`
}

// Destiny.Definitions.Milestones.DestinyMilestoneDefinition
//
// Milestones are an in-game concept where they're attempting to tell you what you can do next in-game.
// If that sounds a lot like Advisors in Destiny 1, it is! So we threw out Advisors in the Destiny 2
// API and tacked all of the data we would have put on Advisors onto Milestones instead.
// Each Milestone represents something going on in the game right now:
// - A "ritual activity" you can perform, like nightfall
// - A "special event" that may have activities related to it, like Taco Tuesday (there's no Taco
// Tuesday in Destiny 2)
// - A checklist you can fulfill, like helping your Clan complete all of its weekly objectives
// - A tutorial quest you can play through, like the introduction to the Crucible.
// Most of these milestones appear in game as well. Some of them are BNet only, because we're so extra.
// You're welcome.
// There are some important caveats to understand about how we currently render Milestones and their
// deficiencies. The game currently doesn't have any content that actually tells you oughtright *what*
// the Milestone is: that is to say, what you'll be doing. The best we get is either a description of
// the overall Milestone, or of the Quest that the Milestone is having you partake in: which is usually
// something that assumes you already know what it's talking about, like "Complete 5 Challenges". 5
// Challenges for what? What's a challenge? These are not questions that the Milestone data will answer
// for you unfortunately.
// This isn't great, and in the future I'd like to add some custom text to give you more contextual
// information to pass on to your users. But for now, you can do what we do to render what little
// display info we do have:
// Start by looking at the currently active quest (ideally, you've fetched DestinyMilestone or
// DestinyPublicMilestone data from the API, so you know the currently active quest for the Milestone
// in question). Look up the Quests property in the Milestone Definition, and check if it has display
// properties. If it does, show that as the description of the Milestone. If it doesn't, fall back on
// the Milestone's description.
// This approach will let you avoid, whenever possible, the even less useful (and sometimes
// nonexistant) milestone-level names and descriptions.
type MilestoneDefinition struct {
	// {
	//   "description": "Milestones are an in-game concept where they're attempting to tell you what you can do next in-game.\r\nIf that sounds a lot like Advisors in Destiny 1, it is! So we threw out Advisors in the Destiny 2 API and tacked all of the data we would have put on Advisors onto Milestones instead.\r\nEach Milestone represents something going on in the game right now:\r\n- A \"ritual activity\" you can perform, like nightfall\r\n- A \"special event\" that may have activities related to it, like Taco Tuesday (there's no Taco Tuesday in Destiny 2)\r\n- A checklist you can fulfill, like helping your Clan complete all of its weekly objectives\r\n- A tutorial quest you can play through, like the introduction to the Crucible.\r\nMost of these milestones appear in game as well. Some of them are BNet only, because we're so extra. You're welcome.\r\nThere are some important caveats to understand about how we currently render Milestones and their deficiencies. The game currently doesn't have any content that actually tells you oughtright *what* the Milestone is: that is to say, what you'll be doing. The best we get is either a description of the overall Milestone, or of the Quest that the Milestone is having you partake in: which is usually something that assumes you already know what it's talking about, like \"Complete 5 Challenges\". 5 Challenges for what? What's a challenge? These are not questions that the Milestone data will answer for you unfortunately.\r\nThis isn't great, and in the future I'd like to add some custom text to give you more contextual information to pass on to your users. But for now, you can do what we do to render what little display info we do have:\r\nStart by looking at the currently active quest (ideally, you've fetched DestinyMilestone or DestinyPublicMilestone data from the API, so you know the currently active quest for the Milestone in question). Look up the Quests property in the Milestone Definition, and check if it has display properties. If it does, show that as the description of the Milestone. If it doesn't, fall back on the Milestone's description.\r\nThis approach will let you avoid, whenever possible, the even less useful (and sometimes nonexistant) milestone-level names and descriptions.",
	//   "properties": {
	//     "activities": {
	//       "description": "A Milestone can now be represented by one or more activities directly (without a backing Quest), and that activity can have many challenges, modifiers, and related to it.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneChallengeActivityDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "defaultOrder": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "displayPreference": {
	//       "description": "A hint to the UI to indicate what to show as the display properties for this Milestone when showing \"Live\" milestone data. Feel free to show more than this if desired: this hint is meant to simplify our own UI, but it may prove useful to you as well.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneDisplayPreference"
	//       }
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "explorePrioritizesActivityImage": {
	//       "description": "If TRUE, \"Explore Destiny\" (the front page of BNet and the companion app) prioritize using the activity image over any overriding Quest or Milestone image provided. This unfortunate hack is brought to you by Trials of The Nine.",
	//       "type": "boolean"
	//     },
	//     "friendlyName": {
	//       "description": "If the milestone has a friendly identifier for association with other features - such as Recruiting - that identifier can be found here. This is \"friendly\" in that it looks better in a URL than whatever the identifier for the Milestone actually is.",
	//       "type": "string"
	//     },
	//     "hasPredictableDates": {
	//       "description": "A shortcut for clients - and the server - to understand whether we can predict the start and end dates for this event. In practice, there are multiple ways that an event could have predictable date ranges, but not all events will be able to be predicted via any mechanism (for instance, events that are manually triggered on and off)",
	//       "type": "boolean"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "image": {
	//       "description": "A custom image someone made just for the milestone. Isn't that special?",
	//       "type": "string"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "isInGameMilestone": {
	//       "description": "Some milestones are explicit objectives that you can see and interact with in the game. Some milestones are more conceptual, built by BNet to help advise you on activities and events that happen in-game but that aren't explicitly shown in game as Milestones. If this is TRUE, you can see this as a milestone in the game. If this is FALSE, it's an event or activity you can participate in, but you won't see it as a Milestone in the game's UI.",
	//       "type": "boolean"
	//     },
	//     "milestoneType": {
	//       "description": "An enumeration listing one of the possible types of milestones. Check out the DestinyMilestoneType enum for more info!",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneType"
	//       }
	//     },
	//     "quests": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneQuestDefinition"
	//       },
	//       "description": "The full set of possible Quests that give the overview of the Milestone event/activity in question. Only one of these can be active at a time for a given Conceptual Milestone, but many of them may be \"available\" for the user to choose from. (for instance, with Milestones you can choose from the three available Quests, but only one can be active at a time) Keyed by the quest item.\r\nAs of Forsaken (~September 2018), Quest-style Milestones are being removed for many types of activities. There will likely be further revisions to the Milestone concept in the future.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "recruitable": {
	//       "description": "If True, then the Milestone has been integrated with BNet's recruiting feature.",
	//       "type": "boolean"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "rewards": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneRewardCategoryDefinition"
	//       },
	//       "description": "If this milestone can provide rewards, this will define the categories into which the individual reward entries are placed.\r\nThis is keyed by the Category's hash, which is only guaranteed to be unique within a given Milestone.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "showInExplorer": {
	//       "description": "If TRUE, this entry should be returned in the list of milestones for the \"Explore Destiny\" (i.e. new BNet homepage) features of Bungie.net (as long as the underlying event is active) Note that this is a property specifically used by BNet and the companion app for the \"Live Events\" feature of the front page/welcome view: it's not a reflection of what you see in-game.",
	//       "type": "boolean"
	//     },
	//     "showInMilestones": {
	//       "description": "Determines whether we'll show this Milestone in the user's personal Milestones list.",
	//       "type": "boolean"
	//     },
	//     "values": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneValueDefinition"
	//       },
	//       "description": "Sometimes, milestones will have arbitrary values associated with them that are of interest to us or to third party developers. This is the collection of those values' definitions, keyed by the identifier of the value and providing useful definition information such as localizable names and descriptions for the value.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "vendors": {
	//       "description": "Sometimes, milestones will have rewards provided by Vendors. This definition gives the information needed to understand which vendors are relevant, the order in which they should be returned if order matters, and the conditions under which the Vendor is relevant to the user.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneVendorDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "vendorsDisplayTitle": {
	//       "description": "If you're going to show Vendors for the Milestone, you can use this as a localized \"header\" for the section where you show that vendor data. It'll provide a more context-relevant clue about what the vendor's role is in the Milestone.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Milestones"
	// }

	// A Milestone can now be represented by one or more activities directly (without a backing Quest), and
	// that activity can have many challenges, modifiers, and related to it.
	Activities []MilestoneChallengeActivityDefinition `json:"activities"`

	DefaultOrder int32 `json:"defaultOrder"`

	// A hint to the UI to indicate what to show as the display properties for this Milestone when showing
	// "Live" milestone data. Feel free to show more than this if desired: this hint is meant to simplify
	// our own UI, but it may prove useful to you as well.
	DisplayPreference MilestoneDisplayPreference `json:"displayPreference"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// If TRUE, "Explore Destiny" (the front page of BNet and the companion app) prioritize using the
	// activity image over any overriding Quest or Milestone image provided. This unfortunate hack is
	// brought to you by Trials of The Nine.
	ExplorePrioritizesActivityImage bool `json:"explorePrioritizesActivityImage"`

	// If the milestone has a friendly identifier for association with other features - such as Recruiting
	// - that identifier can be found here. This is "friendly" in that it looks better in a URL than
	// whatever the identifier for the Milestone actually is.
	FriendlyName string `json:"friendlyName"`

	// A shortcut for clients - and the server - to understand whether we can predict the start and end
	// dates for this event. In practice, there are multiple ways that an event could have predictable date
	// ranges, but not all events will be able to be predicted via any mechanism (for instance, events that
	// are manually triggered on and off)
	HasPredictableDates bool `json:"hasPredictableDates"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// A custom image someone made just for the milestone. Isn't that special?
	Image string `json:"image"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// Some milestones are explicit objectives that you can see and interact with in the game. Some
	// milestones are more conceptual, built by BNet to help advise you on activities and events that
	// happen in-game but that aren't explicitly shown in game as Milestones. If this is TRUE, you can see
	// this as a milestone in the game. If this is FALSE, it's an event or activity you can participate in,
	// but you won't see it as a Milestone in the game's UI.
	IsInGameMilestone bool `json:"isInGameMilestone"`

	// An enumeration listing one of the possible types of milestones. Check out the DestinyMilestoneType
	// enum for more info!
	MilestoneType MilestoneType `json:"milestoneType"`

	// The full set of possible Quests that give the overview of the Milestone event/activity in question.
	// Only one of these can be active at a time for a given Conceptual Milestone, but many of them may be
	// "available" for the user to choose from. (for instance, with Milestones you can choose from the
	// three available Quests, but only one can be active at a time) Keyed by the quest item.
	// As of Forsaken (~September 2018), Quest-style Milestones are being removed for many types of
	// activities. There will likely be further revisions to the Milestone concept in the future.
	Quests map[uint32]MilestoneQuestDefinition `json:"quests"`

	// If True, then the Milestone has been integrated with BNet's recruiting feature.
	Recruitable bool `json:"recruitable"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// If this milestone can provide rewards, this will define the categories into which the individual
	// reward entries are placed.
	// This is keyed by the Category's hash, which is only guaranteed to be unique within a given
	// Milestone.
	Rewards map[uint32]MilestoneRewardCategoryDefinition `json:"rewards"`

	// If TRUE, this entry should be returned in the list of milestones for the "Explore Destiny" (i.e. new
	// BNet homepage) features of Bungie.net (as long as the underlying event is active) Note that this is
	// a property specifically used by BNet and the companion app for the "Live Events" feature of the
	// front page/welcome view: it's not a reflection of what you see in-game.
	ShowInExplorer bool `json:"showInExplorer"`

	// Determines whether we'll show this Milestone in the user's personal Milestones list.
	ShowInMilestones bool `json:"showInMilestones"`

	// Sometimes, milestones will have arbitrary values associated with them that are of interest to us or
	// to third party developers. This is the collection of those values' definitions, keyed by the
	// identifier of the value and providing useful definition information such as localizable names and
	// descriptions for the value.
	Values map[string]MilestoneValueDefinition `json:"values"`

	// Sometimes, milestones will have rewards provided by Vendors. This definition gives the information
	// needed to understand which vendors are relevant, the order in which they should be returned if order
	// matters, and the conditions under which the Vendor is relevant to the user.
	Vendors []MilestoneVendorDefinition `json:"vendors"`

	// If you're going to show Vendors for the Milestone, you can use this as a localized "header" for the
	// section where you show that vendor data. It'll provide a more context-relevant clue about what the
	// vendor's role is in the Milestone.
	VendorsDisplayTitle string `json:"vendorsDisplayTitle"`
}

// Destiny.Definitions.Milestones.DestinyMilestoneDisplayPreference
//
// A hint for the UI as to what display information ought to be shown. Defaults to showing the static
// MilestoneDefinition's display properties.
//
//	If for some reason the indicated property is not populated, fall back to the
//
// MilestoneDefinition.displayProperties.
type MilestoneDisplayPreference int32

const (
	MilestoneDisplayPreference_MilestoneDefinition       = MilestoneDisplayPreference(0)
	MilestoneDisplayPreference_CurrentQuestSteps         = MilestoneDisplayPreference(1)
	MilestoneDisplayPreference_CurrentActivityChallenges = MilestoneDisplayPreference(2)
)

// Destiny.Definitions.Milestones.DestinyMilestoneQuestDefinition
//
// Any data we need to figure out whether this Quest Item is the currently active one for the
// conceptual Milestone. Even just typing this description, I already regret it.
type MilestoneQuestDefinition struct {
	// {
	//   "description": "Any data we need to figure out whether this Quest Item is the currently active one for the conceptual Milestone. Even just typing this description, I already regret it.",
	//   "properties": {
	//     "activities": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneActivityDefinition"
	//       },
	//       "description": "The full set of all possible \"conceptual activities\" that are related to this Milestone. Tiers or alternative modes of play within these conceptual activities will be defined as sub-entities. Keyed by the Conceptual Activity Hash. Use the key to look up DestinyActivityDefinition.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "destinationHash": {
	//       "description": "Sometimes, a Milestone's quest is related to an entire Destination rather than a specific activity. In that situation, this will be the hash of that Destination. Hotspots are currently the only Milestones that expose this data, but that does not preclude this data from being returned for other Milestones in the future.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyDestinationDefinition"
	//       }
	//     },
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "The individual quests may have different definitions from the overall milestone: if there's a specific active quest, use these displayProperties instead of that of the overall DestinyMilestoneDefinition.",
	//       "type": "object"
	//     },
	//     "overrideImage": {
	//       "description": "If populated, this image can be shown instead of the generic milestone's image when this quest is live, or it can be used to show a background image for the quest itself that differs from that of the Activity or the Milestone.",
	//       "type": "string"
	//     },
	//     "questItemHash": {
	//       "description": "The item representing this Milestone quest. Use this hash to look up the DestinyInventoryItemDefinition for the quest to find its steps and human readable data.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "questRewards": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneQuestRewardsDefinition"
	//         }
	//       ],
	//       "description": "The rewards you will get for completing this quest, as best as we could extract them from our data. Sometimes, it'll be a decent amount of data. Sometimes, it's going to be sucky. Sorry.",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object"
	// }

	// The full set of all possible "conceptual activities" that are related to this Milestone. Tiers or
	// alternative modes of play within these conceptual activities will be defined as sub-entities. Keyed
	// by the Conceptual Activity Hash. Use the key to look up DestinyActivityDefinition.
	Activities map[Hash[ActivityDefinition]]MilestoneActivityDefinition `json:"activities"`

	// Sometimes, a Milestone's quest is related to an entire Destination rather than a specific activity.
	// In that situation, this will be the hash of that Destination. Hotspots are currently the only
	// Milestones that expose this data, but that does not preclude this data from being returned for other
	// Milestones in the future.
	DestinationHash Nullable[Hash[DestinationDefinition]] `json:"destinationHash,omitempty"`

	// The individual quests may have different definitions from the overall milestone: if there's a
	// specific active quest, use these displayProperties instead of that of the overall
	// DestinyMilestoneDefinition.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// If populated, this image can be shown instead of the generic milestone's image when this quest is
	// live, or it can be used to show a background image for the quest itself that differs from that of
	// the Activity or the Milestone.
	OverrideImage string `json:"overrideImage"`

	// The item representing this Milestone quest. Use this hash to look up the
	// DestinyInventoryItemDefinition for the quest to find its steps and human readable data.
	QuestItemHash Hash[InventoryItemDefinition] `json:"questItemHash"`

	// The rewards you will get for completing this quest, as best as we could extract them from our data.
	// Sometimes, it'll be a decent amount of data. Sometimes, it's going to be sucky. Sorry.
	QuestRewards MilestoneQuestRewardsDefinition `json:"questRewards"`
}

// Destiny.Definitions.Milestones.DestinyMilestoneQuestRewardItem
//
// A subclass of DestinyItemQuantity, that provides not just the item and its quantity but also
// information that BNet can - at some point - use internally to provide more robust runtime
// information about the item's qualities.
// If you want it, please ask! We're just out of time to wire it up right now. Or a clever person just
// may do it with our existing endpoints.
type MilestoneQuestRewardItem struct {
	// {
	//   "description": "A subclass of DestinyItemQuantity, that provides not just the item and its quantity but also information that BNet can - at some point - use internally to provide more robust runtime information about the item's qualities.\r\nIf you want it, please ask! We're just out of time to wire it up right now. Or a clever person just may do it with our existing endpoints.",
	//   "properties": {
	//     "hasConditionalVisibility": {
	//       "description": "Indicates that this item quantity may be conditionally shown or hidden, based on various sources of state. For example: server flags, account state, or character progress.",
	//       "type": "boolean"
	//     },
	//     "itemHash": {
	//       "description": "The hash identifier for the item in question. Use it to look up the item's DestinyInventoryItemDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "itemInstanceId": {
	//       "description": "If this quantity is referring to a specific instance of an item, this will have the item's instance ID. Normally, this will be null.",
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "quantity": {
	//       "description": "The amount of the item needed/available depending on the context of where DestinyItemQuantity is being used.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "vendorHash": {
	//       "description": "The quest reward item *may* be associated with a vendor. If so, this is that vendor. Use this hash to look up the DestinyVendorDefinition.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     },
	//     "vendorItemIndex": {
	//       "description": "The quest reward item *may* be associated with a vendor. If so, this is the index of the item being sold, which we can use at runtime to find instanced item information for the reward item.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// Indicates that this item quantity may be conditionally shown or hidden, based on various sources of
	// state. For example: server flags, account state, or character progress.
	HasConditionalVisibility bool `json:"hasConditionalVisibility"`

	// The hash identifier for the item in question. Use it to look up the item's
	// DestinyInventoryItemDefinition.
	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`

	// If this quantity is referring to a specific instance of an item, this will have the item's instance
	// ID. Normally, this will be null.
	ItemInstanceID Nullable[Int64] `json:"itemInstanceId,omitempty"`

	// The amount of the item needed/available depending on the context of where DestinyItemQuantity is
	// being used.
	Quantity int32 `json:"quantity"`

	// The quest reward item *may* be associated with a vendor. If so, this is that vendor. Use this hash
	// to look up the DestinyVendorDefinition.
	VendorHash Nullable[Hash[VendorDefinition]] `json:"vendorHash,omitempty"`

	// The quest reward item *may* be associated with a vendor. If so, this is the index of the item being
	// sold, which we can use at runtime to find instanced item information for the reward item.
	VendorItemIndex Nullable[int32] `json:"vendorItemIndex,omitempty"`
}

// Destiny.Definitions.Milestones.DestinyMilestoneQuestRewardsDefinition
//
// If rewards are given in a quest - as opposed to overall in the entire Milestone - there's way less
// to track. We're going to simplify this contract as a result. However, this also gives us the
// opportunity to potentially put more than just item information into the reward data if we're able to
// mine it out in the future. Remember this if you come back and ask "why are quest reward items nested
// inside of their own class?"
type MilestoneQuestRewardsDefinition struct {
	// {
	//   "description": "If rewards are given in a quest - as opposed to overall in the entire Milestone - there's way less to track. We're going to simplify this contract as a result. However, this also gives us the opportunity to potentially put more than just item information into the reward data if we're able to mine it out in the future. Remember this if you come back and ask \"why are quest reward items nested inside of their own class?\"",
	//   "properties": {
	//     "items": {
	//       "description": "The items that represent your reward for completing the quest.\r\nBe warned, these could be \"dummy\" items: items that are only used to render a good-looking in-game tooltip, but aren't the actual items themselves.\r\nFor instance, when experience is given there's often a dummy item representing \"experience\", with quantity being the amount of experience you got. We don't have a programmatic association between those and whatever Progression is actually getting that experience... yet.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneQuestRewardItem"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The items that represent your reward for completing the quest.
	// Be warned, these could be "dummy" items: items that are only used to render a good-looking in-game
	// tooltip, but aren't the actual items themselves.
	// For instance, when experience is given there's often a dummy item representing "experience", with
	// quantity being the amount of experience you got. We don't have a programmatic association between
	// those and whatever Progression is actually getting that experience... yet.
	Items []MilestoneQuestRewardItem `json:"items"`
}

// Destiny.Definitions.Milestones.DestinyMilestoneRewardCategoryDefinition
//
// The definition of a category of rewards, that contains many individual rewards.
type MilestoneRewardCategoryDefinition struct {
	// {
	//   "description": "The definition of a category of rewards, that contains many individual rewards.",
	//   "properties": {
	//     "categoryHash": {
	//       "description": "Identifies the reward category. Only guaranteed unique within this specific component!",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "categoryIdentifier": {
	//       "description": "The string identifier for the category, if you want to use it for some end. Guaranteed unique within the specific component.",
	//       "type": "string"
	//     },
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "Hopefully this is obvious by now.",
	//       "type": "object"
	//     },
	//     "order": {
	//       "description": "If you want to use BNet's recommended order for rendering categories programmatically, use this value and compare it to other categories to determine the order in which they should be rendered. I don't feel great about putting this here, I won't lie.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "rewardEntries": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneRewardEntryDefinition"
	//       },
	//       "description": "If this milestone can provide rewards, this will define the sets of rewards that can be earned, the conditions under which they can be acquired, internal data that we'll use at runtime to determine whether you've already earned or redeemed this set of rewards, and the category that this reward should be placed under.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// Identifies the reward category. Only guaranteed unique within this specific component!
	CategoryHash uint32 `json:"categoryHash"`

	// The string identifier for the category, if you want to use it for some end. Guaranteed unique within
	// the specific component.
	CategoryIdentifier string `json:"categoryIdentifier"`

	// Hopefully this is obvious by now.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// If you want to use BNet's recommended order for rendering categories programmatically, use this
	// value and compare it to other categories to determine the order in which they should be rendered. I
	// don't feel great about putting this here, I won't lie.
	Order int32 `json:"order"`

	// If this milestone can provide rewards, this will define the sets of rewards that can be earned, the
	// conditions under which they can be acquired, internal data that we'll use at runtime to determine
	// whether you've already earned or redeemed this set of rewards, and the category that this reward
	// should be placed under.
	RewardEntries map[uint32]MilestoneRewardEntryDefinition `json:"rewardEntries"`
}

// Destiny.Definitions.Milestones.DestinyMilestoneRewardEntryDefinition
//
// The definition of a specific reward, which may be contained in a category of rewards and that has
// optional information about how it is obtained.
type MilestoneRewardEntryDefinition struct {
	// {
	//   "description": "The definition of a specific reward, which may be contained in a category of rewards and that has optional information about how it is obtained.",
	//   "properties": {
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "For us to bother returning this info, we should be able to return some kind of information about why these rewards are grouped together. This is ideally that information. Look at how confident I am that this will always remain true.",
	//       "type": "object"
	//     },
	//     "items": {
	//       "description": "The items you will get as rewards, and how much of it you'll get.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemQuantity"
	//       },
	//       "type": "array"
	//     },
	//     "order": {
	//       "description": "If you want to follow BNet's ordering of these rewards, use this number within a given category to order the rewards. Yeah, I know. I feel dirty too.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "rewardEntryHash": {
	//       "description": "The identifier for this reward entry. Runtime data will refer to reward entries by this hash. Only guaranteed unique within the specific Milestone.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "rewardEntryIdentifier": {
	//       "description": "The string identifier, if you care about it. Only guaranteed unique within the specific Milestone.",
	//       "type": "string"
	//     },
	//     "vendorHash": {
	//       "description": "If this reward is redeemed at a Vendor, this is the hash of the Vendor to go to in order to redeem the reward. Use this hash to look up the DestinyVendorDefinition.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// For us to bother returning this info, we should be able to return some kind of information about why
	// these rewards are grouped together. This is ideally that information. Look at how confident I am
	// that this will always remain true.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The items you will get as rewards, and how much of it you'll get.
	Items []ItemQuantity `json:"items"`

	// If you want to follow BNet's ordering of these rewards, use this number within a given category to
	// order the rewards. Yeah, I know. I feel dirty too.
	Order int32 `json:"order"`

	// The identifier for this reward entry. Runtime data will refer to reward entries by this hash. Only
	// guaranteed unique within the specific Milestone.
	RewardEntryHash uint32 `json:"rewardEntryHash"`

	// The string identifier, if you care about it. Only guaranteed unique within the specific Milestone.
	RewardEntryIdentifier string `json:"rewardEntryIdentifier"`

	// If this reward is redeemed at a Vendor, this is the hash of the Vendor to go to in order to redeem
	// the reward. Use this hash to look up the DestinyVendorDefinition.
	VendorHash Nullable[Hash[VendorDefinition]] `json:"vendorHash,omitempty"`
}

// Destiny.Definitions.Milestones.DestinyMilestoneType
//
// The type of milestone. Milestones can be Tutorials, one-time/triggered/non-repeating but not
// necessarily tutorials, or Repeating Milestones.
type MilestoneType int32

const (
	MilestoneType_Unknown  = MilestoneType(0)
	MilestoneType_Tutorial = MilestoneType(1)
	MilestoneType_OneTime  = MilestoneType(2)
	MilestoneType_Weekly   = MilestoneType(3)
	MilestoneType_Daily    = MilestoneType(4)
	MilestoneType_Special  = MilestoneType(5)
)

// Destiny.Definitions.Milestones.DestinyMilestoneValueDefinition
//
// The definition for information related to a key/value pair that is relevant for a particular
// Milestone or component within the Milestone.
// This lets us more flexibly pass up information that's useful to someone, even if it's not
// necessarily us.
type MilestoneValueDefinition struct {
	// {
	//   "description": "The definition for information related to a key/value pair that is relevant for a particular Milestone or component within the Milestone. \r\nThis lets us more flexibly pass up information that's useful to someone, even if it's not necessarily us.",
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "key": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	Key string `json:"key"`
}

// Destiny.Definitions.Milestones.DestinyMilestoneVendorDefinition
//
// If the Milestone or a component has vendors whose inventories could/should be displayed that are
// relevant to it, this will return the vendor in question.
// It also contains information we need to determine whether that vendor is actually relevant at the
// moment, given the user's current state.
type MilestoneVendorDefinition struct {
	// {
	//   "description": "If the Milestone or a component has vendors whose inventories could/should be displayed that are relevant to it, this will return the vendor in question. \r\nIt also contains information we need to determine whether that vendor is actually relevant at the moment, given the user's current state.",
	//   "properties": {
	//     "vendorHash": {
	//       "description": "The hash of the vendor whose wares should be shown as associated with the Milestone.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash of the vendor whose wares should be shown as associated with the Milestone.
	VendorHash Hash[VendorDefinition] `json:"vendorHash"`
}

// Destiny.Definitions.PowerCaps.DestinyPowerCapDefinition
//
// Defines a 'power cap' (limit) for gear items, based on the rarity tier and season of release.
type PowerCapDefinition struct {
	// {
	//   "description": "Defines a 'power cap' (limit) for gear items, based on the rarity tier and season of release.",
	//   "properties": {
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "powerCap": {
	//       "description": "The raw value for a power cap.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "PowerCaps"
	// }

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// The raw value for a power cap.
	PowerCap int32 `json:"powerCap"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.Presentation.DestinyPresentationChildBlock
type PresentationChildBlock struct {
	// {
	//   "properties": {
	//     "displayStyle": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyPresentationDisplayStyle"
	//       }
	//     },
	//     "parentPresentationNodeHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "presentationNodeType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyPresentationNodeType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	DisplayStyle PresentationDisplayStyle `json:"displayStyle"`

	ParentPresentationNodeHashes []uint32 `json:"parentPresentationNodeHashes"`

	PresentationNodeType PresentationNodeType `json:"presentationNodeType"`
}

// Destiny.Definitions.Presentation.DestinyPresentationNodeBaseDefinition
//
// This is the base class for all presentation system children. Presentation Nodes, Records,
// Collectibles, and Metrics.
type PresentationNodeBaseDefinition struct {
	// {
	//   "description": "This is the base class for all presentation system children. Presentation Nodes, Records, Collectibles, and Metrics.",
	//   "properties": {
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "parentNodeHashes": {
	//       "description": "A quick reference to presentation nodes that have this node as a child. Presentation nodes can be parented under multiple parents.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "presentationNodeType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyPresentationNodeType"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "traitHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Traits.DestinyTraitDefinition"
	//       }
	//     },
	//     "traitIds": {
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// A quick reference to presentation nodes that have this node as a child. Presentation nodes can be
	// parented under multiple parents.
	ParentNodeHashes []uint32 `json:"parentNodeHashes"`

	PresentationNodeType PresentationNodeType `json:"presentationNodeType"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	TraitHashes []uint32 `json:"traitHashes"`

	TraitIds []string `json:"traitIds"`
}

// Destiny.Definitions.Presentation.DestinyPresentationNodeChildEntry
type PresentationNodeChildEntry struct {
	// {
	//   "properties": {
	//     "nodeDisplayPriority": {
	//       "description": "Use this value to sort the presentation node children in ascending order.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "presentationNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// Use this value to sort the presentation node children in ascending order.
	NodeDisplayPriority uint32 `json:"nodeDisplayPriority"`

	PresentationNodeHash Hash[PresentationNodeDefinition] `json:"presentationNodeHash"`
}

// Destiny.Definitions.Presentation.DestinyPresentationNodeChildEntryBase
type PresentationNodeChildEntryBase struct {
	// {
	//   "properties": {
	//     "nodeDisplayPriority": {
	//       "description": "Use this value to sort the presentation node children in ascending order.",
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// Use this value to sort the presentation node children in ascending order.
	NodeDisplayPriority uint32 `json:"nodeDisplayPriority"`
}

// Destiny.Definitions.Presentation.DestinyPresentationNodeChildrenBlock
//
// As/if presentation nodes begin to host more entities as children, these lists will be added to. One
// list property exists per type of entity that can be treated as a child of this presentation node,
// and each holds the identifier of the entity and any associated information needed to display the UI
// for that entity (if anything)
type PresentationNodeChildrenBlock struct {
	// {
	//   "description": "As/if presentation nodes begin to host more entities as children, these lists will be added to. One list property exists per type of entity that can be treated as a child of this presentation node, and each holds the identifier of the entity and any associated information needed to display the UI for that entity (if anything)",
	//   "properties": {
	//     "collectibles": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeCollectibleChildEntry"
	//       },
	//       "type": "array"
	//     },
	//     "craftables": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeCraftableChildEntry"
	//       },
	//       "type": "array"
	//     },
	//     "metrics": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeMetricChildEntry"
	//       },
	//       "type": "array"
	//     },
	//     "presentationNodes": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeChildEntry"
	//       },
	//       "type": "array"
	//     },
	//     "records": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeRecordChildEntry"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	Collectibles []PresentationNodeCollectibleChildEntry `json:"collectibles"`

	Craftables []PresentationNodeCraftableChildEntry `json:"craftables"`

	Metrics []PresentationNodeMetricChildEntry `json:"metrics"`

	PresentationNodes []PresentationNodeChildEntry `json:"presentationNodes"`

	Records []PresentationNodeRecordChildEntry `json:"records"`
}

// Destiny.Definitions.Presentation.DestinyPresentationNodeCollectibleChildEntry
type PresentationNodeCollectibleChildEntry struct {
	// {
	//   "properties": {
	//     "collectibleHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Collectibles.DestinyCollectibleDefinition"
	//       }
	//     },
	//     "nodeDisplayPriority": {
	//       "description": "Use this value to sort the presentation node children in ascending order.",
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	CollectibleHash Hash[CollectibleDefinition] `json:"collectibleHash"`

	// Use this value to sort the presentation node children in ascending order.
	NodeDisplayPriority uint32 `json:"nodeDisplayPriority"`
}

// Destiny.Definitions.Presentation.DestinyPresentationNodeCraftableChildEntry
type PresentationNodeCraftableChildEntry struct {
	// {
	//   "properties": {
	//     "craftableItemHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "nodeDisplayPriority": {
	//       "description": "Use this value to sort the presentation node children in ascending order.",
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	CraftableItemHash Hash[InventoryItemDefinition] `json:"craftableItemHash"`

	// Use this value to sort the presentation node children in ascending order.
	NodeDisplayPriority uint32 `json:"nodeDisplayPriority"`
}

// Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition
//
// A PresentationNode is an entity that represents a logical grouping of other entities
// visually/organizationally.
// For now, Presentation Nodes may contain the following... but it may be used for more in the future:
// - Collectibles - Records (Or, as the public will call them, "Triumphs." Don't ask me why we're
// overloading the term "Triumph", it still hurts me to think about it) - Metrics (aka Stat Trackers) -
// Other Presentation Nodes, allowing a tree of Presentation Nodes to be created
// Part of me wants to break these into conceptual definitions per entity being collected, but the
// possibility of these different types being mixed in the same UI and the possibility that it could
// actually be more useful to return the "bare metal" presentation node concept has resulted in me
// deciding against that for the time being.
// We'll see if I come to regret this as well.
type PresentationNodeDefinition struct {
	// {
	//   "description": "A PresentationNode is an entity that represents a logical grouping of other entities visually/organizationally.\r\nFor now, Presentation Nodes may contain the following... but it may be used for more in the future:\r\n- Collectibles - Records (Or, as the public will call them, \"Triumphs.\" Don't ask me why we're overloading the term \"Triumph\", it still hurts me to think about it) - Metrics (aka Stat Trackers) - Other Presentation Nodes, allowing a tree of Presentation Nodes to be created\r\nPart of me wants to break these into conceptual definitions per entity being collected, but the possibility of these different types being mixed in the same UI and the possibility that it could actually be more useful to return the \"bare metal\" presentation node concept has resulted in me deciding against that for the time being.\r\nWe'll see if I come to regret this as well.",
	//   "properties": {
	//     "children": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeChildrenBlock"
	//         }
	//       ],
	//       "description": "The child entities contained by this presentation node.",
	//       "type": "object"
	//     },
	//     "completionRecordHash": {
	//       "description": "If this presentation node has an associated \"Record\" that you can accomplish for completing its children, this is the identifier of that Record.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Records.DestinyRecordDefinition"
	//       }
	//     },
	//     "disableChildSubscreenNavigation": {
	//       "description": "If this presentation node has children, but the game doesn't let you inspect the details of those children, that is indicated here.",
	//       "type": "boolean"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "displayStyle": {
	//       "description": "A hint for how to display this presentation node when it's shown in a list.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyPresentationDisplayStyle"
	//       }
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "isSeasonal": {
	//       "description": "Primarily for Guardian Ranks, this property if the contents of this node are tied to the current season. These nodes are shown with a different color for the in-game Guardian Ranks display.",
	//       "type": "boolean"
	//     },
	//     "maxCategoryRecordScore": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "nodeType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyPresentationNodeType"
	//       }
	//     },
	//     "objectiveHash": {
	//       "description": "If this presentation node shows a related objective (for instance, if it tracks the progress of its children), the objective being tracked is indicated here.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectiveDefinition"
	//       }
	//     },
	//     "originalIcon": {
	//       "description": "The original icon for this presentation node, before we futzed with it.",
	//       "type": "string"
	//     },
	//     "parentNodeHashes": {
	//       "description": "A quick reference to presentation nodes that have this node as a child. Presentation nodes can be parented under multiple parents.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "presentationNodeType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyPresentationNodeType"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "requirements": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeRequirementsBlock"
	//         }
	//       ],
	//       "description": "The requirements for being able to interact with this presentation node and its children.",
	//       "type": "object"
	//     },
	//     "rootViewIcon": {
	//       "description": "Some presentation nodes are meant to be explicitly shown on the \"root\" or \"entry\" screens for the feature to which they are related. You should use this icon when showing them on such a view, if you have a similar \"entry point\" view in your UI. If you don't have a UI, then I guess it doesn't matter either way does it?",
	//       "type": "string"
	//     },
	//     "scope": {
	//       "description": "Indicates whether this presentation node's state is determined on a per-character or on an account-wide basis.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyScope"
	//       }
	//     },
	//     "screenStyle": {
	//       "description": "A hint for how to display this presentation node when it's shown in its own detail screen.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyPresentationScreenStyle"
	//       }
	//     },
	//     "traitHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Traits.DestinyTraitDefinition"
	//       }
	//     },
	//     "traitIds": {
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "PresentationNodes"
	// }

	// The child entities contained by this presentation node.
	Children PresentationNodeChildrenBlock `json:"children"`

	// If this presentation node has an associated "Record" that you can accomplish for completing its
	// children, this is the identifier of that Record.
	CompletionRecordHash Nullable[Hash[RecordDefinition]] `json:"completionRecordHash,omitempty"`

	// If this presentation node has children, but the game doesn't let you inspect the details of those
	// children, that is indicated here.
	DisableChildSubscreenNavigation bool `json:"disableChildSubscreenNavigation"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// A hint for how to display this presentation node when it's shown in a list.
	DisplayStyle PresentationDisplayStyle `json:"displayStyle"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// Primarily for Guardian Ranks, this property if the contents of this node are tied to the current
	// season. These nodes are shown with a different color for the in-game Guardian Ranks display.
	IsSeasonal bool `json:"isSeasonal"`

	MaxCategoryRecordScore int32 `json:"maxCategoryRecordScore"`

	NodeType PresentationNodeType `json:"nodeType"`

	// If this presentation node shows a related objective (for instance, if it tracks the progress of its
	// children), the objective being tracked is indicated here.
	ObjectiveHash Nullable[Hash[ObjectiveDefinition]] `json:"objectiveHash,omitempty"`

	// The original icon for this presentation node, before we futzed with it.
	OriginalIcon string `json:"originalIcon"`

	// A quick reference to presentation nodes that have this node as a child. Presentation nodes can be
	// parented under multiple parents.
	ParentNodeHashes []uint32 `json:"parentNodeHashes"`

	PresentationNodeType PresentationNodeType `json:"presentationNodeType"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// The requirements for being able to interact with this presentation node and its children.
	Requirements PresentationNodeRequirementsBlock `json:"requirements"`

	// Some presentation nodes are meant to be explicitly shown on the "root" or "entry" screens for the
	// feature to which they are related. You should use this icon when showing them on such a view, if you
	// have a similar "entry point" view in your UI. If you don't have a UI, then I guess it doesn't matter
	// either way does it?
	RootViewIcon string `json:"rootViewIcon"`

	// Indicates whether this presentation node's state is determined on a per-character or on an
	// account-wide basis.
	Scope Scope `json:"scope"`

	// A hint for how to display this presentation node when it's shown in its own detail screen.
	ScreenStyle PresentationScreenStyle `json:"screenStyle"`

	TraitHashes []uint32 `json:"traitHashes"`

	TraitIds []string `json:"traitIds"`
}

// Destiny.Definitions.Presentation.DestinyPresentationNodeMetricChildEntry
type PresentationNodeMetricChildEntry struct {
	// {
	//   "properties": {
	//     "metricHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Metrics.DestinyMetricDefinition"
	//       }
	//     },
	//     "nodeDisplayPriority": {
	//       "description": "Use this value to sort the presentation node children in ascending order.",
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	MetricHash Hash[MetricDefinition] `json:"metricHash"`

	// Use this value to sort the presentation node children in ascending order.
	NodeDisplayPriority uint32 `json:"nodeDisplayPriority"`
}

// Destiny.Definitions.Presentation.DestinyPresentationNodeRecordChildEntry
type PresentationNodeRecordChildEntry struct {
	// {
	//   "properties": {
	//     "nodeDisplayPriority": {
	//       "description": "Use this value to sort the presentation node children in ascending order.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "recordHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Records.DestinyRecordDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// Use this value to sort the presentation node children in ascending order.
	NodeDisplayPriority uint32 `json:"nodeDisplayPriority"`

	RecordHash Hash[RecordDefinition] `json:"recordHash"`
}

// Destiny.Definitions.Presentation.DestinyPresentationNodeRequirementsBlock
//
// Presentation nodes can be restricted by various requirements. This defines the rules of those
// requirements, and the message(s) to be shown if these requirements aren't met.
type PresentationNodeRequirementsBlock struct {
	// {
	//   "description": "Presentation nodes can be restricted by various requirements. This defines the rules of those requirements, and the message(s) to be shown if these requirements aren't met.",
	//   "properties": {
	//     "entitlementUnavailableMessage": {
	//       "description": "If this node is not accessible due to Entitlements (for instance, you don't own the required game expansion), this is the message to show.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// If this node is not accessible due to Entitlements (for instance, you don't own the required game
	// expansion), this is the message to show.
	EntitlementUnavailableMessage string `json:"entitlementUnavailableMessage"`
}

// Destiny.Definitions.Presentation.DestinyScoredPresentationNodeBaseDefinition
type ScoredPresentationNodeBaseDefinition struct {
	// {
	//   "properties": {
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "maxCategoryRecordScore": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "parentNodeHashes": {
	//       "description": "A quick reference to presentation nodes that have this node as a child. Presentation nodes can be parented under multiple parents.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "presentationNodeType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyPresentationNodeType"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "traitHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Traits.DestinyTraitDefinition"
	//       }
	//     },
	//     "traitIds": {
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	MaxCategoryRecordScore int32 `json:"maxCategoryRecordScore"`

	// A quick reference to presentation nodes that have this node as a child. Presentation nodes can be
	// parented under multiple parents.
	ParentNodeHashes []uint32 `json:"parentNodeHashes"`

	PresentationNodeType PresentationNodeType `json:"presentationNodeType"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	TraitHashes []uint32 `json:"traitHashes"`

	TraitIds []string `json:"traitIds"`
}

// Destiny.Definitions.Progression.DestinyProgressionLevelRequirementDefinition
//
// These are pre-constructed collections of data that can be used to determine the Level Requirement
// for an item given a Progression to be tested (such as the Character's level).
// For instance, say a character receives a new Auto Rifle, and that Auto Rifle's
// DestinyInventoryItemDefinition.quality.progressionLevelRequirementHash property is pointing at one
// of these DestinyProgressionLevelRequirementDefinitions. Let's pretend also that the progressionHash
// it is pointing at is the Character Level progression. In that situation, the character's level will
// be used to interpolate a value in the requirementCurve property. The value picked up from that
// interpolation will be the required level for the item.
type ProgressionLevelRequirementDefinition struct {
	// {
	//   "description": "These are pre-constructed collections of data that can be used to determine the Level Requirement for an item given a Progression to be tested (such as the Character's level).\r\nFor instance, say a character receives a new Auto Rifle, and that Auto Rifle's DestinyInventoryItemDefinition.quality.progressionLevelRequirementHash property is pointing at one of these DestinyProgressionLevelRequirementDefinitions. Let's pretend also that the progressionHash it is pointing at is the Character Level progression. In that situation, the character's level will be used to interpolate a value in the requirementCurve property. The value picked up from that interpolation will be the required level for the item.",
	//   "properties": {
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "progressionHash": {
	//       "description": "The progression whose level should be used to determine the level requirement.\r\nLook up the DestinyProgressionDefinition with this hash for more information about the progression in question.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionDefinition"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "requirementCurve": {
	//       "description": "A curve of level requirements, weighted by the related progressions' level.\r\nInterpolate against this curve with the character's progression level to determine what the level requirement of the generated item that is using this data will be.",
	//       "items": {
	//         "$ref": "#/components/schemas/Interpolation.InterpolationPointFloat"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "ProgressionLevelRequirements"
	// }

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// The progression whose level should be used to determine the level requirement.
	// Look up the DestinyProgressionDefinition with this hash for more information about the progression
	// in question.
	ProgressionHash Hash[ProgressionDefinition] `json:"progressionHash"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// A curve of level requirements, weighted by the related progressions' level.
	// Interpolate against this curve with the character's progression level to determine what the level
	// requirement of the generated item that is using this data will be.
	RequirementCurve []InterpolationPointFloat `json:"requirementCurve"`
}

// Destiny.Definitions.Records.DestinyRecordCompletionBlock
type RecordCompletionBlock struct {
	// {
	//   "properties": {
	//     "ScoreValue": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "partialCompletionObjectiveCountThreshold": {
	//       "description": "The number of objectives that must be completed before the objective is considered \"complete\"",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "shouldFireToast": {
	//       "type": "boolean"
	//     },
	//     "toastStyle": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyRecordToastStyle"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	ScoreValue int32 `json:"ScoreValue"`

	// The number of objectives that must be completed before the objective is considered "complete"
	PartialCompletionObjectiveCountThreshold int32 `json:"partialCompletionObjectiveCountThreshold"`

	ShouldFireToast bool `json:"shouldFireToast"`

	ToastStyle RecordToastStyle `json:"toastStyle"`
}

// Destiny.Definitions.Records.DestinyRecordDefinition
type RecordDefinition struct {
	// {
	//   "properties": {
	//     "completionInfo": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Records.DestinyRecordCompletionBlock"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "expirationInfo": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Records.DestinyRecordExpirationBlock"
	//     },
	//     "forTitleGilding": {
	//       "type": "boolean"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "intervalInfo": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Records.DestinyRecordIntervalBlock"
	//         }
	//       ],
	//       "description": "Some records have multiple 'interval' objectives, and the record may be claimed at each completed interval",
	//       "type": "object"
	//     },
	//     "loreHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Lore.DestinyLoreDefinition"
	//       }
	//     },
	//     "objectiveHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectiveDefinition"
	//       }
	//     },
	//     "parentNodeHashes": {
	//       "description": "A quick reference to presentation nodes that have this node as a child. Presentation nodes can be parented under multiple parents.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "presentationInfo": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationChildBlock"
	//     },
	//     "presentationNodeType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyPresentationNodeType"
	//       }
	//     },
	//     "recordTypeName": {
	//       "description": "A display name for the type of record this is (Triumphs, Lore, Medals, Seasonal Challenge, etc.).",
	//       "type": "string"
	//     },
	//     "recordValueStyle": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyRecordValueStyle"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "requirements": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeRequirementsBlock"
	//     },
	//     "rewardItems": {
	//       "description": "If there is any publicly available information about rewards earned for achieving this record, this is the list of those items.\r\n However, note that some records intentionally have \"hidden\" rewards. These will not be returned in this list.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemQuantity"
	//       },
	//       "type": "array"
	//     },
	//     "scope": {
	//       "description": "Indicates whether this Record's state is determined on a per-character or on an account-wide basis.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyScope"
	//       }
	//     },
	//     "shouldShowLargeIcons": {
	//       "description": "A hint to show a large icon for a reward",
	//       "type": "boolean"
	//     },
	//     "stateInfo": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Records.SchemaRecordStateBlock"
	//     },
	//     "titleInfo": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Records.DestinyRecordTitleBlock"
	//     },
	//     "traitHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Traits.DestinyTraitDefinition"
	//       }
	//     },
	//     "traitIds": {
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Records"
	// }

	CompletionInfo RecordCompletionBlock `json:"completionInfo"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	ExpirationInfo RecordExpirationBlock `json:"expirationInfo"`

	ForTitleGilding bool `json:"forTitleGilding"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// Some records have multiple 'interval' objectives, and the record may be claimed at each completed
	// interval
	IntervalInfo RecordIntervalBlock `json:"intervalInfo"`

	LoreHash Nullable[Hash[LoreDefinition]] `json:"loreHash,omitempty"`

	ObjectiveHashes []uint32 `json:"objectiveHashes"`

	// A quick reference to presentation nodes that have this node as a child. Presentation nodes can be
	// parented under multiple parents.
	ParentNodeHashes []uint32 `json:"parentNodeHashes"`

	PresentationInfo PresentationChildBlock `json:"presentationInfo"`

	PresentationNodeType PresentationNodeType `json:"presentationNodeType"`

	// A display name for the type of record this is (Triumphs, Lore, Medals, Seasonal Challenge, etc.).
	RecordTypeName string `json:"recordTypeName"`

	RecordValueStyle RecordValueStyle `json:"recordValueStyle"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	Requirements PresentationNodeRequirementsBlock `json:"requirements"`

	// If there is any publicly available information about rewards earned for achieving this record, this
	// is the list of those items.
	//
	//	However, note that some records intentionally have "hidden" rewards. These will not be returned in
	//
	// this list.
	RewardItems []ItemQuantity `json:"rewardItems"`

	// Indicates whether this Record's state is determined on a per-character or on an account-wide basis.
	Scope Scope `json:"scope"`

	// A hint to show a large icon for a reward
	ShouldShowLargeIcons bool `json:"shouldShowLargeIcons"`

	StateInfo SchemaRecordStateBlock `json:"stateInfo"`

	TitleInfo RecordTitleBlock `json:"titleInfo"`

	TraitHashes []uint32 `json:"traitHashes"`

	TraitIds []string `json:"traitIds"`
}

// Destiny.Definitions.Records.DestinyRecordExpirationBlock
//
// If this record has an expiration after which it cannot be earned, this is some information about
// that expiration.
type RecordExpirationBlock struct {
	// {
	//   "description": "If this record has an expiration after which it cannot be earned, this is some information about that expiration.",
	//   "properties": {
	//     "description": {
	//       "type": "string"
	//     },
	//     "hasExpiration": {
	//       "type": "boolean"
	//     },
	//     "icon": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Description string `json:"description"`

	HasExpiration bool `json:"hasExpiration"`

	Icon string `json:"icon"`
}

// Destiny.Definitions.Records.DestinyRecordIntervalBlock
type RecordIntervalBlock struct {
	// {
	//   "properties": {
	//     "intervalObjectives": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Records.DestinyRecordIntervalObjective"
	//       },
	//       "type": "array"
	//     },
	//     "intervalRewards": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Records.DestinyRecordIntervalRewards"
	//       },
	//       "type": "array"
	//     },
	//     "originalObjectiveArrayInsertionIndex": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	IntervalObjectives []RecordIntervalObjective `json:"intervalObjectives"`

	IntervalRewards []RecordIntervalRewards `json:"intervalRewards"`

	OriginalObjectiveArrayInsertionIndex int32 `json:"originalObjectiveArrayInsertionIndex"`
}

// Destiny.Definitions.Records.DestinyRecordIntervalObjective
type RecordIntervalObjective struct {
	// {
	//   "properties": {
	//     "intervalObjectiveHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectiveDefinition"
	//       }
	//     },
	//     "intervalScoreValue": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	IntervalObjectiveHash Hash[ObjectiveDefinition] `json:"intervalObjectiveHash"`

	IntervalScoreValue int32 `json:"intervalScoreValue"`
}

// Destiny.Definitions.Records.DestinyRecordIntervalRewards
type RecordIntervalRewards struct {
	// {
	//   "properties": {
	//     "intervalRewardItems": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemQuantity"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	IntervalRewardItems []ItemQuantity `json:"intervalRewardItems"`
}

// Destiny.Definitions.Records.DestinyRecordTitleBlock
type RecordTitleBlock struct {
	// {
	//   "properties": {
	//     "gildingTrackingRecordHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Records.DestinyRecordDefinition"
	//       }
	//     },
	//     "hasTitle": {
	//       "type": "boolean"
	//     },
	//     "titlesByGender": {
	//       "additionalProperties": {
	//         "type": "string"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/Destiny.DestinyGender"
	//         }
	//       }
	//     },
	//     "titlesByGenderHash": {
	//       "additionalProperties": {
	//         "type": "string"
	//       },
	//       "description": "For those who prefer to use the definitions.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyGenderDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	GildingTrackingRecordHash Nullable[Hash[RecordDefinition]] `json:"gildingTrackingRecordHash,omitempty"`

	HasTitle bool `json:"hasTitle"`

	TitlesByGender map[string]string `json:"titlesByGender"`

	// For those who prefer to use the definitions.
	TitlesByGenderHash map[Hash[GenderDefinition]]string `json:"titlesByGenderHash"`
}

// Destiny.Definitions.Records.SchemaRecordStateBlock
type SchemaRecordStateBlock struct {
	// {
	//   "properties": {
	//     "featuredPriority": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "obscuredDescription": {
	//       "description": "A display description override to show when this record is 'obscured' instead of the default obscured display description.",
	//       "type": "string"
	//     },
	//     "obscuredName": {
	//       "description": "A display name override to show when this record is 'obscured' instead of the default obscured display name.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	FeaturedPriority int32 `json:"featuredPriority"`

	// A display description override to show when this record is 'obscured' instead of the default
	// obscured display description.
	ObscuredDescription string `json:"obscuredDescription"`

	// A display name override to show when this record is 'obscured' instead of the default obscured
	// display name.
	ObscuredName string `json:"obscuredName"`
}

// Destiny.Definitions.Reporting.DestinyReportReasonCategoryDefinition
//
// If you're going to report someone for a Terms of Service violation, you need to choose a category
// and reason for the report. This definition holds both the categories and the reasons within those
// categories, for simplicity and my own laziness' sake.
// Note tha this means that, to refer to a Reason by reasonHash, you need a combination of the
// reasonHash *and* the associated ReasonCategory's hash: there are some reasons defined under multiple
// categories.
type ReportReasonCategoryDefinition struct {
	// {
	//   "description": "If you're going to report someone for a Terms of Service violation, you need to choose a category and reason for the report. This definition holds both the categories and the reasons within those categories, for simplicity and my own laziness' sake.\r\nNote tha this means that, to refer to a Reason by reasonHash, you need a combination of the reasonHash *and* the associated ReasonCategory's hash: there are some reasons defined under multiple categories.",
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "reasons": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Reporting.DestinyReportReasonDefinition"
	//       },
	//       "description": "The specific reasons for the report under this category.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "ReportReasonCategories"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// The specific reasons for the report under this category.
	Reasons map[uint32]ReportReasonDefinition `json:"reasons"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.Reporting.DestinyReportReasonDefinition
//
// A specific reason for being banned. Only accessible under the related category
// (DestinyReportReasonCategoryDefinition) under which it is shown. Note that this means that report
// reasons' reasonHash are not globally unique: and indeed, entries like "Other" are defined under most
// categories for example.
type ReportReasonDefinition struct {
	// {
	//   "description": "A specific reason for being banned. Only accessible under the related category (DestinyReportReasonCategoryDefinition) under which it is shown. Note that this means that report reasons' reasonHash are not globally unique: and indeed, entries like \"Other\" are defined under most categories for example.",
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "reasonHash": {
	//       "description": "The identifier for the reason: they are only guaranteed unique under the Category in which they are found.",
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The identifier for the reason: they are only guaranteed unique under the Category in which they are
	// found.
	ReasonHash uint32 `json:"reasonHash"`
}

// Destiny.Definitions.Seasons.DestinyEventCardDefinition
//
// Defines the properties of an 'Event Card' in Destiny 2, to coincide with a seasonal event for
// additional challenges, premium rewards, a new seal, and a special title. For example: Solstice of
// Heroes 2022.
type EventCardDefinition struct {
	// {
	//   "description": "Defines the properties of an 'Event Card' in Destiny 2, to coincide with a seasonal event for additional challenges, premium rewards, a new seal, and a special title. For example: Solstice of Heroes 2022.",
	//   "properties": {
	//     "color": {
	//       "$ref": "#/components/schemas/Destiny.Misc.DestinyColor"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "endTime": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "eventCardCurrencyList": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "images": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Seasons.DestinyEventCardImages"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "linkRedirectPath": {
	//       "type": "string"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "rewardProgressionHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionDefinition"
	//       }
	//     },
	//     "sealPresentationNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "ticketCurrencyItemHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "ticketVendorCategoryHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "ticketVendorHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     },
	//     "triumphsPresentationNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "weeklyChallengesPresentationNodeHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "EventCards"
	// }

	Color Color `json:"color"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	EndTime Int64 `json:"endTime"`

	EventCardCurrencyList []uint32 `json:"eventCardCurrencyList"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	Images EventCardImages `json:"images"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	LinkRedirectPath string `json:"linkRedirectPath"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	RewardProgressionHash Nullable[Hash[ProgressionDefinition]] `json:"rewardProgressionHash,omitempty"`

	SealPresentationNodeHash Hash[PresentationNodeDefinition] `json:"sealPresentationNodeHash"`

	TicketCurrencyItemHash Hash[InventoryItemDefinition] `json:"ticketCurrencyItemHash"`

	TicketVendorCategoryHash uint32 `json:"ticketVendorCategoryHash"`

	TicketVendorHash Hash[VendorDefinition] `json:"ticketVendorHash"`

	TriumphsPresentationNodeHash Hash[PresentationNodeDefinition] `json:"triumphsPresentationNodeHash"`

	WeeklyChallengesPresentationNodeHash Nullable[Hash[PresentationNodeDefinition]] `json:"weeklyChallengesPresentationNodeHash,omitempty"`
}

// Destiny.Definitions.Seasons.DestinyEventCardImages
type EventCardImages struct {
	// {
	//   "properties": {
	//     "cardCompleteImagePath": {
	//       "type": "string"
	//     },
	//     "cardCompleteWrapImagePath": {
	//       "type": "string"
	//     },
	//     "cardIncompleteImagePath": {
	//       "type": "string"
	//     },
	//     "progressIconImagePath": {
	//       "type": "string"
	//     },
	//     "themeBackgroundImagePath": {
	//       "type": "string"
	//     },
	//     "unownedCardSleeveImagePath": {
	//       "type": "string"
	//     },
	//     "unownedCardSleeveWrapImagePath": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	CardCompleteImagePath string `json:"cardCompleteImagePath"`

	CardCompleteWrapImagePath string `json:"cardCompleteWrapImagePath"`

	CardIncompleteImagePath string `json:"cardIncompleteImagePath"`

	ProgressIconImagePath string `json:"progressIconImagePath"`

	ThemeBackgroundImagePath string `json:"themeBackgroundImagePath"`

	UnownedCardSleeveImagePath string `json:"unownedCardSleeveImagePath"`

	UnownedCardSleeveWrapImagePath string `json:"unownedCardSleeveWrapImagePath"`
}

// Destiny.Definitions.Seasons.DestinySeasonActDefinition
//
// Defines the name, start time and ranks included in an Act of an Episode.
type SeasonActDefinition struct {
	// {
	//   "description": "Defines the name, start time and ranks included in an Act of an Episode.",
	//   "properties": {
	//     "displayName": {
	//       "description": "The name of the Act.",
	//       "type": "string"
	//     },
	//     "rankCount": {
	//       "description": "The number of ranks included in the Act.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "startTime": {
	//       "description": "The start time of the Act.",
	//       "format": "date-time",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// The name of the Act.
	DisplayName string `json:"displayName"`

	// The number of ranks included in the Act.
	RankCount int32 `json:"rankCount"`

	// The start time of the Act.
	StartTime Timestamp `json:"startTime"`
}

// Destiny.Definitions.Seasons.DestinySeasonDefinition
//
// Defines a canonical "Season" of Destiny: a range of a few months where the game highlights certain
// challenges, provides new loot, has new Clan-related rewards and celebrates various seasonal events.
type SeasonDefinition struct {
	// {
	//   "description": "Defines a canonical \"Season\" of Destiny: a range of a few months where the game highlights certain challenges, provides new loot, has new Clan-related rewards and celebrates various seasonal events.",
	//   "properties": {
	//     "acts": {
	//       "description": "A list of Acts for the Episode",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Seasons.DestinySeasonActDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "artifactItemHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "backgroundImagePath": {
	//       "type": "string"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "endDate": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "preview": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Seasons.DestinySeasonPreviewDefinition"
	//         }
	//       ],
	//       "description": "Optional - Defines the promotional text, images, and links to preview this season.",
	//       "type": "object"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "sealPresentationNodeHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "seasonNumber": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "seasonPassHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Seasons.DestinySeasonPassDefinition"
	//       }
	//     },
	//     "seasonPassProgressionHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionDefinition"
	//       }
	//     },
	//     "seasonalChallengesPresentationNodeHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Presentation.DestinyPresentationNodeDefinition"
	//       }
	//     },
	//     "startDate": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Seasons"
	// }

	// A list of Acts for the Episode
	Acts []SeasonActDefinition `json:"acts"`

	ArtifactItemHash Nullable[Hash[InventoryItemDefinition]] `json:"artifactItemHash,omitempty"`

	BackgroundImagePath string `json:"backgroundImagePath"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	EndDate Nullable[Timestamp] `json:"endDate,omitempty"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// Optional - Defines the promotional text, images, and links to preview this season.
	Preview SeasonPreviewDefinition `json:"preview"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	SealPresentationNodeHash Nullable[Hash[PresentationNodeDefinition]] `json:"sealPresentationNodeHash,omitempty"`

	SeasonNumber int32 `json:"seasonNumber"`

	SeasonPassHash Nullable[Hash[SeasonPassDefinition]] `json:"seasonPassHash,omitempty"`

	SeasonPassProgressionHash Nullable[Hash[ProgressionDefinition]] `json:"seasonPassProgressionHash,omitempty"`

	SeasonalChallengesPresentationNodeHash Nullable[Hash[PresentationNodeDefinition]] `json:"seasonalChallengesPresentationNodeHash,omitempty"`

	StartDate Nullable[Timestamp] `json:"startDate,omitempty"`
}

// Destiny.Definitions.Seasons.DestinySeasonPassDefinition
type SeasonPassDefinition struct {
	// {
	//   "properties": {
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "prestigeProgressionHash": {
	//       "description": "I know what you're thinking, but I promise we're not going to duplicate and drown you. Instead, we're giving you sweet, sweet power bonuses.\r\n Prestige progression is further progression that you can make on the Season pass after you gain max ranks, that will ultimately increase your power/light level over the theoretical limit.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionDefinition"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "rewardProgressionHash": {
	//       "description": "This is the progression definition related to the progression for the initial levels 1-100 that provide item rewards for the Season pass. Further experience after you reach the limit is provided in the \"Prestige\" progression referred to by prestigeProgressionHash.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "SeasonPasses"
	// }

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// I know what you're thinking, but I promise we're not going to duplicate and drown you. Instead,
	// we're giving you sweet, sweet power bonuses.
	//
	//	Prestige progression is further progression that you can make on the Season pass after you gain max
	//
	// ranks, that will ultimately increase your power/light level over the theoretical limit.
	PrestigeProgressionHash Hash[ProgressionDefinition] `json:"prestigeProgressionHash"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// This is the progression definition related to the progression for the initial levels 1-100 that
	// provide item rewards for the Season pass. Further experience after you reach the limit is provided
	// in the "Prestige" progression referred to by prestigeProgressionHash.
	RewardProgressionHash Hash[ProgressionDefinition] `json:"rewardProgressionHash"`
}

// Destiny.Definitions.Seasons.DestinySeasonPreviewDefinition
//
// Defines the promotional text, images, and links to preview this season.
type SeasonPreviewDefinition struct {
	// {
	//   "description": "Defines the promotional text, images, and links to preview this season.",
	//   "properties": {
	//     "description": {
	//       "description": "A localized description of the season.",
	//       "type": "string"
	//     },
	//     "images": {
	//       "description": "A list of images to preview the seasonal content. Should have at least three to show.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Seasons.DestinySeasonPreviewImageDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "linkPath": {
	//       "description": "A relative path to learn more about the season. Web browsers should be automatically redirected to the user's Bungie.net locale. For example: \"/SeasonOfTheChosen\" will redirect to \"/7/en/Seasons/SeasonOfTheChosen\" for English users.",
	//       "type": "string"
	//     },
	//     "videoLink": {
	//       "description": "An optional link to a localized video, probably YouTube.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// A localized description of the season.
	Description string `json:"description"`

	// A list of images to preview the seasonal content. Should have at least three to show.
	Images []SeasonPreviewImageDefinition `json:"images"`

	// A relative path to learn more about the season. Web browsers should be automatically redirected to
	// the user's Bungie.net locale. For example: "/SeasonOfTheChosen" will redirect to
	// "/7/en/Seasons/SeasonOfTheChosen" for English users.
	LinkPath string `json:"linkPath"`

	// An optional link to a localized video, probably YouTube.
	VideoLink string `json:"videoLink"`
}

// Destiny.Definitions.Seasons.DestinySeasonPreviewImageDefinition
//
// Defines the thumbnail icon, high-res image, and video link for promotional images
type SeasonPreviewImageDefinition struct {
	// {
	//   "description": "Defines the thumbnail icon, high-res image, and video link for promotional images",
	//   "properties": {
	//     "highResImage": {
	//       "description": "An optional path to a high-resolution image, probably 1920x1080.",
	//       "type": "string"
	//     },
	//     "thumbnailImage": {
	//       "description": "A thumbnail icon path to preview seasonal content, probably 480x270.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// An optional path to a high-resolution image, probably 1920x1080.
	HighResImage string `json:"highResImage"`

	// A thumbnail icon path to preview seasonal content, probably 480x270.
	ThumbnailImage string `json:"thumbnailImage"`
}

// Destiny.Definitions.Social.DestinySocialCommendationDefinition
type SocialCommendationDefinition struct {
	// {
	//   "properties": {
	//     "activityGivingLimit": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "cardImagePath": {
	//       "type": "string"
	//     },
	//     "color": {
	//       "$ref": "#/components/schemas/Destiny.Misc.DestinyColor"
	//     },
	//     "displayActivities": {
	//       "description": "The display properties for the the activities that this commendation is available in.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "displayPriority": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "parentCommendationNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Social.DestinySocialCommendationNodeDefinition"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "SocialCommendations"
	// }

	ActivityGivingLimit int32 `json:"activityGivingLimit"`

	CardImagePath string `json:"cardImagePath"`

	Color Color `json:"color"`

	// The display properties for the the activities that this commendation is available in.
	DisplayActivities []DisplayPropertiesDefinition `json:"displayActivities"`

	DisplayPriority int32 `json:"displayPriority"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	ParentCommendationNodeHash Hash[SocialCommendationNodeDefinition] `json:"parentCommendationNodeHash"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.Social.DestinySocialCommendationNodeDefinition
type SocialCommendationNodeDefinition struct {
	// {
	//   "properties": {
	//     "childCommendationHashes": {
	//       "description": "A list of hashes that map to child commendations.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Social.DestinySocialCommendationDefinition"
	//       }
	//     },
	//     "childCommendationNodeHashes": {
	//       "description": "A list of hashes that map to child commendation nodes. Only the root commendations node is expected to have child nodes.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Social.DestinySocialCommendationNodeDefinition"
	//       }
	//     },
	//     "color": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Misc.DestinyColor"
	//         }
	//       ],
	//       "description": "The color associated with this group of commendations.",
	//       "type": "object"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "parentCommendationNodeHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Social.DestinySocialCommendationNodeDefinition"
	//       }
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "tintedIcon": {
	//       "description": "A version of the displayProperties icon tinted with the color of this node.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "SocialCommendationNodes"
	// }

	// A list of hashes that map to child commendations.
	ChildCommendationHashes []uint32 `json:"childCommendationHashes"`

	// A list of hashes that map to child commendation nodes. Only the root commendations node is expected
	// to have child nodes.
	ChildCommendationNodeHashes []uint32 `json:"childCommendationNodeHashes"`

	// The color associated with this group of commendations.
	Color Color `json:"color"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	ParentCommendationNodeHash Hash[SocialCommendationNodeDefinition] `json:"parentCommendationNodeHash"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// A version of the displayProperties icon tinted with the color of this node.
	TintedIcon string `json:"tintedIcon"`
}

// Destiny.Definitions.Sockets.DestinyInsertPlugActionDefinition
//
// Data related to what happens while a plug is being inserted, mostly for UI purposes.
type InsertPlugActionDefinition struct {
	// {
	//   "description": "Data related to what happens while a plug is being inserted, mostly for UI purposes.",
	//   "properties": {
	//     "actionExecuteSeconds": {
	//       "description": "How long it takes for the Plugging of the item to be completed once it is initiated, if you care.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "actionType": {
	//       "description": "The type of action being performed when you act on this Socket Type. The most common value is \"insert plug\", but there are others as well (for instance, a \"Masterwork\" socket may allow for Re-initialization, and an Infusion socket allows for items to be consumed to upgrade the item)",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.SocketTypeActionType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// How long it takes for the Plugging of the item to be completed once it is initiated, if you care.
	ActionExecuteSeconds int32 `json:"actionExecuteSeconds"`

	// The type of action being performed when you act on this Socket Type. The most common value is
	// "insert plug", but there are others as well (for instance, a "Masterwork" socket may allow for
	// Re-initialization, and an Infusion socket allows for items to be consumed to upgrade the item)
	ActionType SocketTypeActionType `json:"actionType"`
}

// Destiny.Definitions.Sockets.DestinyPlugSetDefinition
//
// Sometimes, we have large sets of reusable plugs that are defined identically and thus can (and in
// some cases, are so large that they *must*) be shared across the places where they are used. These
// are the definitions for those reusable sets of plugs.
//
//	See DestinyItemSocketEntryDefinition.plugSource and reusablePlugSetHash for the relationship
//
// between these reusable plug sets and the sockets that leverage them (for starters, Emotes).
//
//	As of the release of Shadowkeep (Late 2019), these will begin to be sourced from game content
//
// directly - which means there will be many more of them, but it also means we may not get all data
// that we used to get for them.
//
//	DisplayProperties, in particular, will no longer be guaranteed to contain valid information. We
//
// will make a best effort to guess what ought to be populated there where possible, but it will be
// invalid for many/most plug sets.
type PlugSetDefinition struct {
	// {
	//   "description": "Sometimes, we have large sets of reusable plugs that are defined identically and thus can (and in some cases, are so large that they *must*) be shared across the places where they are used. These are the definitions for those reusable sets of plugs. \r\n See DestinyItemSocketEntryDefinition.plugSource and reusablePlugSetHash for the relationship between these reusable plug sets and the sockets that leverage them (for starters, Emotes).\r\n As of the release of Shadowkeep (Late 2019), these will begin to be sourced from game content directly - which means there will be many more of them, but it also means we may not get all data that we used to get for them.\r\n DisplayProperties, in particular, will no longer be guaranteed to contain valid information. We will make a best effort to guess what ought to be populated there where possible, but it will be invalid for many/most plug sets.",
	//   "properties": {
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "If you want to show these plugs in isolation, these are the display properties for them.",
	//       "type": "object"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "isFakePlugSet": {
	//       "description": "Mostly for our debugging or reporting bugs, BNet is making \"fake\" plug sets in a desperate effort to reduce socket sizes.\r\n If this is true, the plug set was generated by BNet: if it looks wrong, that's a good indicator that it's bungie.net that fucked this up.",
	//       "type": "boolean"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "reusablePlugItems": {
	//       "description": "This is a list of pre-determined plugs that can be plugged into this socket, without the character having the plug in their inventory.\r\nIf this list is populated, you will not be allowed to plug an arbitrary item in the socket: you will only be able to choose from one of these reusable plugs.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyItemSocketEntryPlugItemRandomizedDefinition"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "PlugSets"
	// }

	// If you want to show these plugs in isolation, these are the display properties for them.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// Mostly for our debugging or reporting bugs, BNet is making "fake" plug sets in a desperate effort to
	// reduce socket sizes.
	//
	//	If this is true, the plug set was generated by BNet: if it looks wrong, that's a good indicator
	//
	// that it's bungie.net that fucked this up.
	IsFakePlugSet bool `json:"isFakePlugSet"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// This is a list of pre-determined plugs that can be plugged into this socket, without the character
	// having the plug in their inventory.
	// If this list is populated, you will not be allowed to plug an arbitrary item in the socket: you will
	// only be able to choose from one of these reusable plugs.
	ReusablePlugItems []ItemSocketEntryPlugItemRandomizedDefinition `json:"reusablePlugItems"`
}

// Destiny.Definitions.Sockets.DestinyPlugWhitelistEntryDefinition
//
// Defines a plug "Category" that is allowed to be plugged into a socket of this type.
// This should be compared against a given plug item's
// DestinyInventoryItemDefinition.plug.plugCategoryHash, which indicates the plug item's category.
type PlugWhitelistEntryDefinition struct {
	// {
	//   "description": "Defines a plug \"Category\" that is allowed to be plugged into a socket of this type.\r\nThis should be compared against a given plug item's DestinyInventoryItemDefinition.plug.plugCategoryHash, which indicates the plug item's category.",
	//   "properties": {
	//     "categoryHash": {
	//       "description": "The hash identifier of the Plug Category to compare against the plug item's plug.plugCategoryHash.\r\nNote that this does NOT relate to any Definition in itself, it is only used for comparison purposes.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "categoryIdentifier": {
	//       "description": "The string identifier for the category, which is here mostly for debug purposes.",
	//       "type": "string"
	//     },
	//     "reinitializationPossiblePlugHashes": {
	//       "description": "The list of all plug items (DestinyInventoryItemDefinition) that the socket may randomly be populated with when reinitialized.\r\nWhich ones you should actually show are determined by the plug being inserted into the socket, and the socket’s type.\r\nWhen you inspect the plug that could go into a Masterwork Socket, look up the socket type of the socket being inspected and find the DestinySocketTypeDefinition.\r\nThen, look at the Plugs that can fit in that socket. Find the Whitelist in the DestinySocketTypeDefinition that matches the plug item’s categoryhash.\r\nThat whitelist entry will potentially have a new “reinitializationPossiblePlugHashes” property.If it does, that means we know what it will roll if you try to insert this plug into this socket.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash identifier of the Plug Category to compare against the plug item's plug.plugCategoryHash.
	// Note that this does NOT relate to any Definition in itself, it is only used for comparison purposes.
	CategoryHash uint32 `json:"categoryHash"`

	// The string identifier for the category, which is here mostly for debug purposes.
	CategoryIdentifier string `json:"categoryIdentifier"`

	// The list of all plug items (DestinyInventoryItemDefinition) that the socket may randomly be
	// populated with when reinitialized.
	// Which ones you should actually show are determined by the plug being inserted into the socket, and
	// the socket’s type.
	// When you inspect the plug that could go into a Masterwork Socket, look up the socket type of the
	// socket being inspected and find the DestinySocketTypeDefinition.
	// Then, look at the Plugs that can fit in that socket. Find the Whitelist in the
	// DestinySocketTypeDefinition that matches the plug item’s categoryhash.
	// That whitelist entry will potentially have a new “reinitializationPossiblePlugHashes” property.If it
	// does, that means we know what it will roll if you try to insert this plug into this socket.
	ReinitializationPossiblePlugHashes []uint32 `json:"reinitializationPossiblePlugHashes"`
}

// Destiny.Definitions.Sockets.DestinySocketCategoryDefinition
//
// Sockets on an item are organized into Categories visually.
// You can find references to the socket category defined on an item's
// DestinyInventoryItemDefinition.sockets.socketCategories property.
// This has the display information for rendering the categories' header, and a hint for how the UI
// should handle showing this category.
// The shitty thing about this, however, is that the socket categories' UI style can be overridden by
// the item's UI style. For instance, the Socket Category used by Emote Sockets says it's "consumable,"
// but that's a lie: they're all reusable, and overridden by the detail UI pages in ways that we can't
// easily account for in the API.
// As a result, I will try to compile these rules into the individual sockets on items, and provide the
// best hint possible there through the plugSources property. In the future, I may attempt to use this
// information in conjunction with the item to provide a more usable UI hint on the socket layer, but
// for now improving the consistency of plugSources is the best I have time to provide. (See
// https://github.com/Bungie-net/api/issues/522 for more info)
type SocketCategoryDefinition struct {
	// {
	//   "description": "Sockets on an item are organized into Categories visually.\r\nYou can find references to the socket category defined on an item's DestinyInventoryItemDefinition.sockets.socketCategories property.\r\nThis has the display information for rendering the categories' header, and a hint for how the UI should handle showing this category.\r\nThe shitty thing about this, however, is that the socket categories' UI style can be overridden by the item's UI style. For instance, the Socket Category used by Emote Sockets says it's \"consumable,\" but that's a lie: they're all reusable, and overridden by the detail UI pages in ways that we can't easily account for in the API.\r\nAs a result, I will try to compile these rules into the individual sockets on items, and provide the best hint possible there through the plugSources property. In the future, I may attempt to use this information in conjunction with the item to provide a more usable UI hint on the socket layer, but for now improving the consistency of plugSources is the best I have time to provide. (See https://github.com/Bungie-net/api/issues/522 for more info)",
	//   "properties": {
	//     "categoryStyle": {
	//       "description": "Same as uiCategoryStyle, but in a more usable enumeration form.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinySocketCategoryStyle"
	//       }
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "uiCategoryStyle": {
	//       "description": "A string hinting to the game's UI system about how the sockets in this category should be displayed.\r\nBNet doesn't use it: it's up to you to find valid values and make your own special UI if you want to honor this category style.",
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "SocketCategories"
	// }

	// Same as uiCategoryStyle, but in a more usable enumeration form.
	CategoryStyle SocketCategoryStyle `json:"categoryStyle"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	// A string hinting to the game's UI system about how the sockets in this category should be displayed.
	// BNet doesn't use it: it's up to you to find valid values and make your own special UI if you want to
	// honor this category style.
	UiCategoryStyle uint32 `json:"uiCategoryStyle"`
}

// Destiny.Definitions.Sockets.DestinySocketTypeDefinition
//
// All Sockets have a "Type": a set of common properties that determine when the socket allows Plugs to
// be inserted, what Categories of Plugs can be inserted, and whether the socket is even visible at all
// given the current game/character/account state.
// See DestinyInventoryItemDefinition for more information about Socketed items and Plugs.
type SocketTypeDefinition struct {
	// {
	//   "description": "All Sockets have a \"Type\": a set of common properties that determine when the socket allows Plugs to be inserted, what Categories of Plugs can be inserted, and whether the socket is even visible at all given the current game/character/account state.\r\nSee DestinyInventoryItemDefinition for more information about Socketed items and Plugs.",
	//   "properties": {
	//     "alwaysRandomizeSockets": {
	//       "type": "boolean"
	//     },
	//     "avoidDuplicatesOnInitialization": {
	//       "type": "boolean"
	//     },
	//     "currencyScalars": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinySocketTypeScalarMaterialRequirementEntry"
	//       },
	//       "type": "array"
	//     },
	//     "displayProperties": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//         }
	//       ],
	//       "description": "There are fields for this display data, but they appear to be unpopulated as of now. I am not sure where in the UI these would show if they even were populated, but I will continue to return this data in case it becomes useful.",
	//       "type": "object"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "hideDuplicateReusablePlugs": {
	//       "type": "boolean"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "insertAction": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinyInsertPlugActionDefinition"
	//         }
	//       ],
	//       "description": "Defines what happens when a plug is inserted into sockets of this type.",
	//       "type": "object"
	//     },
	//     "isPreviewEnabled": {
	//       "type": "boolean"
	//     },
	//     "overridesUiAppearance": {
	//       "description": "This property indicates if the socket type determines whether Emblem icons and nameplates should be overridden by the inserted plug item's icon and nameplate.",
	//       "type": "boolean"
	//     },
	//     "plugWhitelist": {
	//       "description": "A list of Plug \"Categories\" that are allowed to be plugged into sockets of this type.\r\nThese should be compared against a given plug item's DestinyInventoryItemDefinition.plug.plugCategoryHash, which indicates the plug item's category.\r\nIf the plug's category matches any whitelisted plug, or if the whitelist is empty, it is allowed to be inserted.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinyPlugWhitelistEntryDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     },
	//     "socketCategoryHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Sockets.DestinySocketCategoryDefinition"
	//       }
	//     },
	//     "visibility": {
	//       "description": "Sometimes a socket isn't visible. These are some of the conditions under which sockets of this type are not visible. Unfortunately, the truth of visibility is much, much more complex. Best to rely on the live data for whether the socket is visible and enabled.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinySocketVisibility"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "SocketTypes"
	// }

	AlwaysRandomizeSockets bool `json:"alwaysRandomizeSockets"`

	AvoidDuplicatesOnInitialization bool `json:"avoidDuplicatesOnInitialization"`

	CurrencyScalars []SocketTypeScalarMaterialRequirementEntry `json:"currencyScalars"`

	// There are fields for this display data, but they appear to be unpopulated as of now. I am not sure
	// where in the UI these would show if they even were populated, but I will continue to return this
	// data in case it becomes useful.
	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	HideDuplicateReusablePlugs bool `json:"hideDuplicateReusablePlugs"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// Defines what happens when a plug is inserted into sockets of this type.
	InsertAction InsertPlugActionDefinition `json:"insertAction"`

	IsPreviewEnabled bool `json:"isPreviewEnabled"`

	// This property indicates if the socket type determines whether Emblem icons and nameplates should be
	// overridden by the inserted plug item's icon and nameplate.
	OverridesUiAppearance bool `json:"overridesUiAppearance"`

	// A list of Plug "Categories" that are allowed to be plugged into sockets of this type.
	// These should be compared against a given plug item's
	// DestinyInventoryItemDefinition.plug.plugCategoryHash, which indicates the plug item's category.
	// If the plug's category matches any whitelisted plug, or if the whitelist is empty, it is allowed to
	// be inserted.
	PlugWhitelist []PlugWhitelistEntryDefinition `json:"plugWhitelist"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`

	SocketCategoryHash Hash[SocketCategoryDefinition] `json:"socketCategoryHash"`

	// Sometimes a socket isn't visible. These are some of the conditions under which sockets of this type
	// are not visible. Unfortunately, the truth of visibility is much, much more complex. Best to rely on
	// the live data for whether the socket is visible and enabled.
	Visibility SocketVisibility `json:"visibility"`
}

// Destiny.Definitions.Sockets.DestinySocketTypeScalarMaterialRequirementEntry
type SocketTypeScalarMaterialRequirementEntry struct {
	// {
	//   "properties": {
	//     "currencyItemHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "scalarValue": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	CurrencyItemHash Hash[InventoryItemDefinition] `json:"currencyItemHash"`

	ScalarValue int32 `json:"scalarValue"`
}

// Destiny.Definitions.Sources.DestinyItemSourceDefinition
//
// Properties of a DestinyInventoryItemDefinition that store all of the information we were able to
// discern about how the item spawns, and where you can find the item.
// Items will have many of these sources, one per level at which it spawns, to try and give more
// granular data about where items spawn for specific level ranges.
type ItemSourceDefinition struct {
	// {
	//   "description": "Properties of a DestinyInventoryItemDefinition that store all of the information we were able to discern about how the item spawns, and where you can find the item.\r\nItems will have many of these sources, one per level at which it spawns, to try and give more granular data about where items spawn for specific level ranges.",
	//   "properties": {
	//     "computedStats": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemStatDefinition"
	//       },
	//       "description": "The stats computed for this level/quality range.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "level": {
	//       "description": "The level at which the item spawns. Essentially the Primary Key for this source data: there will be multiple of these source entries per item that has source data, grouped by the level at which the item spawns.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "maxLevelRequired": {
	//       "description": "The maximum Character Level required for equipping the item when the item spawns at the item level defined on this DestinyItemSourceDefinition, as far as we saw in our processing.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "maxQuality": {
	//       "description": "The maximum quality at which the item spawns for this level.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "minLevelRequired": {
	//       "description": "The minimum Character Level required for equipping the item when the item spawns at the item level defined on this DestinyItemSourceDefinition, as far as we saw in our processing.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "minQuality": {
	//       "description": "The minimum Quality at which the item spawns for this level. Examine DestinyInventoryItemDefinition for more information about what Quality means. Just don't ask Phaedrus about it, he'll never stop talking and you'll have to write a book about it.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "sourceHashes": {
	//       "description": "The DestinyRewardSourceDefinitions found that can spawn the item at this level.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyRewardSourceDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The stats computed for this level/quality range.
	ComputedStats map[uint32]InventoryItemStatDefinition `json:"computedStats"`

	// The level at which the item spawns. Essentially the Primary Key for this source data: there will be
	// multiple of these source entries per item that has source data, grouped by the level at which the
	// item spawns.
	Level int32 `json:"level"`

	// The maximum Character Level required for equipping the item when the item spawns at the item level
	// defined on this DestinyItemSourceDefinition, as far as we saw in our processing.
	MaxLevelRequired int32 `json:"maxLevelRequired"`

	// The maximum quality at which the item spawns for this level.
	MaxQuality int32 `json:"maxQuality"`

	// The minimum Character Level required for equipping the item when the item spawns at the item level
	// defined on this DestinyItemSourceDefinition, as far as we saw in our processing.
	MinLevelRequired int32 `json:"minLevelRequired"`

	// The minimum Quality at which the item spawns for this level. Examine DestinyInventoryItemDefinition
	// for more information about what Quality means. Just don't ask Phaedrus about it, he'll never stop
	// talking and you'll have to write a book about it.
	MinQuality int32 `json:"minQuality"`

	// The DestinyRewardSourceDefinitions found that can spawn the item at this level.
	SourceHashes []uint32 `json:"sourceHashes"`
}

// Destiny.Definitions.Traits.DestinyTraitDefinition
type TraitDefinition struct {
	// {
	//   "properties": {
	//     "displayHint": {
	//       "description": "An identifier for how this trait can be displayed. For example: a 'keyword' hint to show an explanation for certain related terms.",
	//       "type": "string"
	//     },
	//     "displayProperties": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Common.DestinyDisplayPropertiesDefinition"
	//     },
	//     "hash": {
	//       "description": "The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.\r\nWhen entities refer to each other in Destiny content, it is this hash that they are referring to.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "index": {
	//       "description": "The index of the entity as it was found in the investment tables.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "redacted": {
	//       "description": "If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "Traits"
	// }

	// An identifier for how this trait can be displayed. For example: a 'keyword' hint to show an
	// explanation for certain related terms.
	DisplayHint string `json:"displayHint"`

	DisplayProperties DisplayPropertiesDefinition `json:"displayProperties"`

	// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not
	// globally.
	// When entities refer to each other in Destiny content, it is this hash that they are referring to.
	Hash uint32 `json:"hash"`

	// The index of the entity as it was found in the investment tables.
	Index int32 `json:"index"`

	// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet
	// allowed to show it. Sorry!
	Redacted bool `json:"redacted"`
}

// Destiny.Definitions.Vendors.DestinyVendorLocationDefinition
//
// These definitions represent vendors' locations and relevant display information at different times
// in the game.
type VendorLocationDefinition struct {
	// {
	//   "description": "These definitions represent vendors' locations and relevant display information at different times in the game.",
	//   "properties": {
	//     "backgroundImagePath": {
	//       "description": "The relative path to the background image representing this Vendor at this location, for use in a banner.",
	//       "type": "string"
	//     },
	//     "destinationHash": {
	//       "description": "The hash identifier for a Destination at which this vendor may be located. Each destination where a Vendor may exist will only ever have a single entry.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyDestinationDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The relative path to the background image representing this Vendor at this location, for use in a
	// banner.
	BackgroundImagePath string `json:"backgroundImagePath"`

	// The hash identifier for a Destination at which this vendor may be located. Each destination where a
	// Vendor may exist will only ever have a single entry.
	DestinationHash Hash[DestinationDefinition] `json:"destinationHash"`
}

// Destiny.DestinyActivity
//
// Represents the "Live" data that we can obtain about a Character's status with a specific Activity.
// This will tell you whether the character can participate in the activity, as well as some other
// basic mutable information.
// Meant to be combined with static DestinyActivityDefinition data for a full picture of the Activity.
type Activity struct {
	// {
	//   "description": "Represents the \"Live\" data that we can obtain about a Character's status with a specific Activity. This will tell you whether the character can participate in the activity, as well as some other basic mutable information. \r\nMeant to be combined with static DestinyActivityDefinition data for a full picture of the Activity.",
	//   "properties": {
	//     "activityHash": {
	//       "description": "The hash identifier of the Activity. Use this to look up the DestinyActivityDefinition of the activity.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "booleanActivityOptions": {
	//       "additionalProperties": {
	//         "type": "boolean"
	//       },
	//       "description": "The set of activity options for this activity, keyed by an identifier that's unique for this activity (not guaranteed to be unique between or across all activities, though should be unique for every *variant* of a given *conceptual* activity: for instance, the original D2 Raid has many variant DestinyActivityDefinitions. While other activities could potentially have the same option hashes, for any given D2 base Raid variant the hash will be unique).\r\nAs a concrete example of this data, the hashes you get for Raids will correspond to the currently active \"Challenge Mode\".\r\nWe don't have any human readable information for these, but saavy 3rd party app users could manually associate the key (a hash identifier for the \"option\" that is enabled/disabled) and the value (whether it's enabled or disabled presently)\r\nOn our side, we don't necessarily even know what these are used for (the game designers know, but we don't), and we have no human readable data for them. In order to use them, you will have to do some experimentation.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "canJoin": {
	//       "description": "If true, the user is allowed to join with another Fireteam in this activity.",
	//       "type": "boolean"
	//     },
	//     "canLead": {
	//       "description": "If true, the user is allowed to lead a Fireteam into this activity.",
	//       "type": "boolean"
	//     },
	//     "challenges": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Challenges.DestinyChallengeStatus"
	//       },
	//       "type": "array"
	//     },
	//     "difficultyTier": {
	//       "description": "A DestinyActivityDifficultyTier enum value indicating the difficulty of the activity.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyActivityDifficultyTier"
	//       }
	//     },
	//     "displayLevel": {
	//       "description": "The difficulty level of the activity, if applicable.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "isCompleted": {
	//       "description": "If true, we both have the ability to know that the user has completed this activity and they have completed it. Unfortunately, we can't necessarily know this for all activities. As such, this should probably only be used if you already know in advance which specific activities you wish to check.",
	//       "type": "boolean"
	//     },
	//     "isNew": {
	//       "description": "If true, then the activity should have a \"new\" indicator in the Director UI.",
	//       "type": "boolean"
	//     },
	//     "isVisible": {
	//       "description": "If true, the user should be able to see this activity.",
	//       "type": "boolean"
	//     },
	//     "loadoutRequirementIndex": {
	//       "description": "If returned, this is the index into the DestinyActivityDefinition's \"loadouts\" property, indicating the currently active loadout requirements.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "modifierHashes": {
	//       "description": "If the activity has modifiers, this will be the list of modifiers that all variants have in common. Perform lookups against DestinyActivityModifierDefinition which defines the modifier being applied to get at the modifier data.\r\nNote that, in the DestiyActivityDefinition, you will see many more modifiers than this being referred to: those are all *possible* modifiers for the activity, not the active ones. Use only the active ones to match what's really live.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.ActivityModifiers.DestinyActivityModifierDefinition"
	//       }
	//     },
	//     "recommendedLight": {
	//       "description": "The recommended light level for the activity, if applicable.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash identifier of the Activity. Use this to look up the DestinyActivityDefinition of the
	// activity.
	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`

	// The set of activity options for this activity, keyed by an identifier that's unique for this
	// activity (not guaranteed to be unique between or across all activities, though should be unique for
	// every *variant* of a given *conceptual* activity: for instance, the original D2 Raid has many
	// variant DestinyActivityDefinitions. While other activities could potentially have the same option
	// hashes, for any given D2 base Raid variant the hash will be unique).
	// As a concrete example of this data, the hashes you get for Raids will correspond to the currently
	// active "Challenge Mode".
	// We don't have any human readable information for these, but saavy 3rd party app users could manually
	// associate the key (a hash identifier for the "option" that is enabled/disabled) and the value
	// (whether it's enabled or disabled presently)
	// On our side, we don't necessarily even know what these are used for (the game designers know, but we
	// don't), and we have no human readable data for them. In order to use them, you will have to do some
	// experimentation.
	BooleanActivityOptions map[uint32]bool `json:"booleanActivityOptions"`

	// If true, the user is allowed to join with another Fireteam in this activity.
	CanJoin bool `json:"canJoin"`

	// If true, the user is allowed to lead a Fireteam into this activity.
	CanLead bool `json:"canLead"`

	Challenges []ChallengeStatus `json:"challenges"`

	// A DestinyActivityDifficultyTier enum value indicating the difficulty of the activity.
	DifficultyTier ActivityDifficultyTier `json:"difficultyTier"`

	// The difficulty level of the activity, if applicable.
	DisplayLevel Nullable[int32] `json:"displayLevel,omitempty"`

	// If true, we both have the ability to know that the user has completed this activity and they have
	// completed it. Unfortunately, we can't necessarily know this for all activities. As such, this should
	// probably only be used if you already know in advance which specific activities you wish to check.
	IsCompleted bool `json:"isCompleted"`

	// If true, then the activity should have a "new" indicator in the Director UI.
	IsNew bool `json:"isNew"`

	// If true, the user should be able to see this activity.
	IsVisible bool `json:"isVisible"`

	// If returned, this is the index into the DestinyActivityDefinition's "loadouts" property, indicating
	// the currently active loadout requirements.
	LoadoutRequirementIndex Nullable[int32] `json:"loadoutRequirementIndex,omitempty"`

	// If the activity has modifiers, this will be the list of modifiers that all variants have in common.
	// Perform lookups against DestinyActivityModifierDefinition which defines the modifier being applied
	// to get at the modifier data.
	// Note that, in the DestiyActivityDefinition, you will see many more modifiers than this being
	// referred to: those are all *possible* modifiers for the activity, not the active ones. Use only the
	// active ones to match what's really live.
	ModifierHashes []uint32 `json:"modifierHashes"`

	// The recommended light level for the activity, if applicable.
	RecommendedLight Nullable[int32] `json:"recommendedLight,omitempty"`
}

// Destiny.DestinyActivityDifficultyTier
//
// An enumeration representing the potential difficulty levels of an activity. Their names are... more
// qualitative than quantitative.
type ActivityDifficultyTier int32

const (
	ActivityDifficultyTier_Trivial          = ActivityDifficultyTier(0)
	ActivityDifficultyTier_Easy             = ActivityDifficultyTier(1)
	ActivityDifficultyTier_Normal           = ActivityDifficultyTier(2)
	ActivityDifficultyTier_Challenging      = ActivityDifficultyTier(3)
	ActivityDifficultyTier_Hard             = ActivityDifficultyTier(4)
	ActivityDifficultyTier_Brave            = ActivityDifficultyTier(5)
	ActivityDifficultyTier_AlmostImpossible = ActivityDifficultyTier(6)
	ActivityDifficultyTier_Impossible       = ActivityDifficultyTier(7)
)

// Destiny.DestinyActivityModeCategory
//
// Activity Modes are grouped into a few possible broad categories.
type ActivityModeCategory int32

const (
	ActivityModeCategory_None           = ActivityModeCategory(0)
	ActivityModeCategory_PvE            = ActivityModeCategory(1)
	ActivityModeCategory_PvP            = ActivityModeCategory(2)
	ActivityModeCategory_PvECompetitive = ActivityModeCategory(3)
)

// Destiny.DestinyActivityNavPointType
type ActivityNavPointType int32

const (
	ActivityNavPointType_Inactive             = ActivityNavPointType(0)
	ActivityNavPointType_PrimaryObjective     = ActivityNavPointType(1)
	ActivityNavPointType_SecondaryObjective   = ActivityNavPointType(2)
	ActivityNavPointType_TravelObjective      = ActivityNavPointType(3)
	ActivityNavPointType_PublicEventObjective = ActivityNavPointType(4)
	ActivityNavPointType_AmmoCache            = ActivityNavPointType(5)
	ActivityNavPointType_PointTypeFlag        = ActivityNavPointType(6)
	ActivityNavPointType_CapturePoint         = ActivityNavPointType(7)
	ActivityNavPointType_DefensiveEncounter   = ActivityNavPointType(8)
	ActivityNavPointType_GhostInteraction     = ActivityNavPointType(9)
	ActivityNavPointType_KillAi               = ActivityNavPointType(10)
	ActivityNavPointType_QuestItem            = ActivityNavPointType(11)
	ActivityNavPointType_PatrolMission        = ActivityNavPointType(12)
	ActivityNavPointType_Incoming             = ActivityNavPointType(13)
	ActivityNavPointType_ArenaObjective       = ActivityNavPointType(14)
	ActivityNavPointType_AutomationHint       = ActivityNavPointType(15)
	ActivityNavPointType_TrackedQuest         = ActivityNavPointType(16)
)

// Destiny.DestinyAmmunitionType
type AmmunitionType int32

const (
	AmmunitionType_None    = AmmunitionType(0)
	AmmunitionType_Primary = AmmunitionType(1)
	AmmunitionType_Special = AmmunitionType(2)
	AmmunitionType_Heavy   = AmmunitionType(3)
	AmmunitionType_Unknown = AmmunitionType(4)
)

// Destiny.DestinyBreakerType
//
// A plug can optionally have a "Breaker Type": a special ability that can affect units in unique ways.
// Activating this plug can grant one of these types.
type BreakerType int32

const (
	BreakerType_None           = BreakerType(0)
	BreakerType_ShieldPiercing = BreakerType(1)
	BreakerType_Disruption     = BreakerType(2)
	BreakerType_Stagger        = BreakerType(3)
)

// Destiny.DestinyClass
type Class int32

const (
	Class_Titan   = Class(0)
	Class_Hunter  = Class(1)
	Class_Warlock = Class(2)
	Class_Unknown = Class(3)
)

// Destiny.DestinyCollectibleState
//
// A Flags Enumeration/bitmask where each bit represents a different state that the Collectible can be
// in. A collectible can be in any number of these states, and you can choose to use or ignore any or
// all of them when making your own UI that shows Collectible info. Our displays are going to honor
// them, but we're also the kind of people who only pretend to inhale before quickly passing it to the
// left. So, you know, do what you got to do.
// (All joking aside, please note the caveat I mention around the Invisible flag: there are cases where
// it is in the best interest of your users to honor these flags even if you're a "show all the data"
// person. Collector-oriented compulsion is a very unfortunate and real thing, and I would hate to
// instill that compulsion in others through showing them items that they cannot earn. Please consider
// this when you are making your own apps/sites.)
type CollectibleState int32

const (
	CollectibleState_None                             = CollectibleState(0)
	CollectibleState_NotAcquired                      = CollectibleState(1)
	CollectibleState_Obscured                         = CollectibleState(2)
	CollectibleState_Invisible                        = CollectibleState(4)
	CollectibleState_CannotAffordMaterialRequirements = CollectibleState(8)
	CollectibleState_InventorySpaceUnavailable        = CollectibleState(16)
	CollectibleState_UniquenessViolation              = CollectibleState(32)
	CollectibleState_PurchaseDisabled                 = CollectibleState(64)
)

// Destiny.DestinyComponentType
//
// Represents the possible components that can be returned from Destiny "Get" calls such as GetProfile,
// GetCharacter, GetVendor etc...
// When making one of these requests, you will pass one or more of these components as a comma
// separated list in the "?components=" querystring parameter. For instance, if you want baseline
// Profile data, Character Data, and character progressions, you would pass
// "?components=Profiles,Characters,CharacterProgressions" You may use either the numerical or string
// values.
type ComponentType int32

const (
	ComponentType_None                  = ComponentType(0)
	ComponentType_Profiles              = ComponentType(100)
	ComponentType_VendorReceipts        = ComponentType(101)
	ComponentType_ProfileInventories    = ComponentType(102)
	ComponentType_ProfileCurrencies     = ComponentType(103)
	ComponentType_ProfileProgression    = ComponentType(104)
	ComponentType_PlatformSilver        = ComponentType(105)
	ComponentType_Characters            = ComponentType(200)
	ComponentType_CharacterInventories  = ComponentType(201)
	ComponentType_CharacterProgressions = ComponentType(202)
	ComponentType_CharacterRenderData   = ComponentType(203)
	ComponentType_CharacterActivities   = ComponentType(204)
	ComponentType_CharacterEquipment    = ComponentType(205)
	ComponentType_CharacterLoadouts     = ComponentType(206)
	ComponentType_ItemInstances         = ComponentType(300)
	ComponentType_ItemObjectives        = ComponentType(301)
	ComponentType_ItemPerks             = ComponentType(302)
	ComponentType_ItemRenderData        = ComponentType(303)
	ComponentType_ItemStats             = ComponentType(304)
	ComponentType_ItemSockets           = ComponentType(305)
	ComponentType_ItemTalentGrids       = ComponentType(306)
	ComponentType_ItemCommonData        = ComponentType(307)
	ComponentType_ItemPlugStates        = ComponentType(308)
	ComponentType_ItemPlugObjectives    = ComponentType(309)
	ComponentType_ItemReusablePlugs     = ComponentType(310)
	ComponentType_Vendors               = ComponentType(400)
	ComponentType_VendorCategories      = ComponentType(401)
	ComponentType_VendorSales           = ComponentType(402)
	ComponentType_Kiosks                = ComponentType(500)
	ComponentType_CurrencyLookups       = ComponentType(600)
	ComponentType_PresentationNodes     = ComponentType(700)
	ComponentType_Collectibles          = ComponentType(800)
	ComponentType_Records               = ComponentType(900)
	ComponentType_Transitory            = ComponentType(1000)
	ComponentType_Metrics               = ComponentType(1100)
	ComponentType_StringVariables       = ComponentType(1200)
	ComponentType_Craftables            = ComponentType(1300)
	ComponentType_SocialCommendations   = ComponentType(1400)
)

// Destiny.DestinyEnergyType
//
// Represents the socket energy types for Armor 2.0, Ghosts 2.0, and Stasis subclasses.
type EnergyType int32

const (
	EnergyType_Any      = EnergyType(0)
	EnergyType_Arc      = EnergyType(1)
	EnergyType_Thermal  = EnergyType(2)
	EnergyType_Void     = EnergyType(3)
	EnergyType_Ghost    = EnergyType(4)
	EnergyType_Subclass = EnergyType(5)
	EnergyType_Stasis   = EnergyType(6)
)

// Destiny.DestinyEquipItemResult
//
// The results of an Equipping operation performed through the Destiny API.
type EquipItemResult struct {
	// {
	//   "description": "The results of an Equipping operation performed through the Destiny API.",
	//   "properties": {
	//     "equipStatus": {
	//       "description": "A PlatformErrorCodes enum indicating whether it succeeded, and if it failed why.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Exceptions.PlatformErrorCodes"
	//       }
	//     },
	//     "itemInstanceId": {
	//       "description": "The instance ID of the item in question (all items that can be equipped must, but definition, be Instanced and thus have an Instance ID that you can use to refer to them)",
	//       "format": "int64",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// A PlatformErrorCodes enum indicating whether it succeeded, and if it failed why.
	EquipStatus PlatformErrorCodes `json:"equipStatus"`

	// The instance ID of the item in question (all items that can be equipped must, but definition, be
	// Instanced and thus have an Instance ID that you can use to refer to them)
	ItemInstanceID Int64 `json:"itemInstanceId"`
}

// Destiny.DestinyEquipItemResults
//
// The results of a bulk Equipping operation performed through the Destiny API.
type EquipItemResults struct {
	// {
	//   "description": "The results of a bulk Equipping operation performed through the Destiny API.",
	//   "properties": {
	//     "equipResults": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyEquipItemResult"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	EquipResults []EquipItemResult `json:"equipResults"`
}

// Destiny.DestinyGamePrivacySetting
//
// A player can choose to restrict requests to join their Fireteam to specific states. These are the
// possible states a user can choose.
type GamePrivacySetting int32

const (
	GamePrivacySetting_Open               = GamePrivacySetting(0)
	GamePrivacySetting_ClanAndFriendsOnly = GamePrivacySetting(1)
	GamePrivacySetting_FriendsOnly        = GamePrivacySetting(2)
	GamePrivacySetting_InvitationOnly     = GamePrivacySetting(3)
	GamePrivacySetting_Closed             = GamePrivacySetting(4)
)

// Destiny.DestinyGameVersions
//
// A flags enumeration/bitmask indicating the versions of the game that a given user has purchased.
type GameVersions int32

const (
	GameVersions_None              = GameVersions(0)
	GameVersions_Destiny2          = GameVersions(1)
	GameVersions_DLC1              = GameVersions(2)
	GameVersions_DLC2              = GameVersions(4)
	GameVersions_Forsaken          = GameVersions(8)
	GameVersions_YearTwoAnnualPass = GameVersions(16)
	GameVersions_Shadowkeep        = GameVersions(32)
	GameVersions_BeyondLight       = GameVersions(64)
	GameVersions_Anniversary30th   = GameVersions(128)
	GameVersions_TheWitchQueen     = GameVersions(256)
	GameVersions_Lightfall         = GameVersions(512)
	GameVersions_TheFinalShape     = GameVersions(1024)
)

// Destiny.DestinyGatingScope
//
// This enumeration represents the most restrictive type of gating that is being performed by an
// entity. This is useful as a shortcut to avoid a lot of lookups when determining whether the gating
// on an Entity applies to everyone equally, or to their specific Profile or Character states.
// None = There is no gating on this item.
// Global = The gating on this item is based entirely on global game state. It will be gated the same
// for everyone.
// Clan = The gating on this item is at the Clan level. For instance, if you're gated by Clan level
// this will be the case.
// Profile = The gating includes Profile-specific checks, but not on the Profile's characters. An
// example of this might be when you acquire an Emblem: the Emblem will be available in your Kiosk for
// all characters in your Profile from that point onward.
// Character = The gating includes Character-specific checks, including character level restrictions.
// An example of this might be an item that you can't purchase from a Vendor until you reach a specific
// Character Level.
// Item = The gating includes item-specific checks. For BNet, this generally implies that we'll show
// this data only on a character level or deeper.
// AssumedWorstCase = The unlocks and checks being used for this calculation are of an unknown type and
// are used for unknown purposes. For instance, if some great person decided that an unlock value
// should be globally scoped, but then the game changes it using character-specific data in a way that
// BNet doesn't know about. Because of the open-ended potential for this to occur, many unlock checks
// for "globally" scoped unlock data may be assumed as the worst case unless it has been specifically
// whitelisted as otherwise. That sucks, but them's the breaks.
type GatingScope int32

const (
	GatingScope_None             = GatingScope(0)
	GatingScope_Global           = GatingScope(1)
	GatingScope_Clan             = GatingScope(2)
	GatingScope_Profile          = GatingScope(3)
	GatingScope_Character        = GatingScope(4)
	GatingScope_Item             = GatingScope(5)
	GatingScope_AssumedWorstCase = GatingScope(6)
)

// Destiny.DestinyGender
type Gender int32

const (
	Gender_Male    = Gender(0)
	Gender_Female  = Gender(1)
	Gender_Unknown = Gender(2)
)

// Destiny.DestinyGraphNodeState
//
// Represents a potential state of an Activity Graph node.
type GraphNodeState int32

const (
	GraphNodeState_Hidden     = GraphNodeState(0)
	GraphNodeState_Visible    = GraphNodeState(1)
	GraphNodeState_Teaser     = GraphNodeState(2)
	GraphNodeState_Incomplete = GraphNodeState(3)
	GraphNodeState_Completed  = GraphNodeState(4)
)

// Destiny.DestinyItemQuantity
//
// Used in a number of Destiny contracts to return data about an item stack and its quantity. Can
// optionally return an itemInstanceId if the item is instanced - in which case, the quantity returned
// will be 1. If it's not... uh, let me know okay? Thanks.
type ItemQuantity struct {
	// {
	//   "description": "Used in a number of Destiny contracts to return data about an item stack and its quantity. Can optionally return an itemInstanceId if the item is instanced - in which case, the quantity returned will be 1. If it's not... uh, let me know okay? Thanks.",
	//   "properties": {
	//     "hasConditionalVisibility": {
	//       "description": "Indicates that this item quantity may be conditionally shown or hidden, based on various sources of state. For example: server flags, account state, or character progress.",
	//       "type": "boolean"
	//     },
	//     "itemHash": {
	//       "description": "The hash identifier for the item in question. Use it to look up the item's DestinyInventoryItemDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "itemInstanceId": {
	//       "description": "If this quantity is referring to a specific instance of an item, this will have the item's instance ID. Normally, this will be null.",
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "quantity": {
	//       "description": "The amount of the item needed/available depending on the context of where DestinyItemQuantity is being used.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// Indicates that this item quantity may be conditionally shown or hidden, based on various sources of
	// state. For example: server flags, account state, or character progress.
	HasConditionalVisibility bool `json:"hasConditionalVisibility"`

	// The hash identifier for the item in question. Use it to look up the item's
	// DestinyInventoryItemDefinition.
	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`

	// If this quantity is referring to a specific instance of an item, this will have the item's instance
	// ID. Normally, this will be null.
	ItemInstanceID Nullable[Int64] `json:"itemInstanceId,omitempty"`

	// The amount of the item needed/available depending on the context of where DestinyItemQuantity is
	// being used.
	Quantity int32 `json:"quantity"`
}

// Destiny.DestinyItemSortType
//
// Determines how items are sorted in an inventory bucket.
type ItemSortType int32

const (
	ItemSortType_ItemId    = ItemSortType(0)
	ItemSortType_Timestamp = ItemSortType(1)
	ItemSortType_StackSize = ItemSortType(2)
)

// Destiny.DestinyItemSubType
//
// This Enumeration further classifies items by more specific categorizations than DestinyItemType. The
// "Sub-Type" is where we classify and categorize items one step further in specificity: "Auto Rifle"
// instead of just "Weapon" for example, or "Vanguard Bounty" instead of merely "Bounty".
// These sub-types are provided for historical compatibility with Destiny 1, but an ideal alternative
// is to use DestinyItemCategoryDefinitions and the DestinyItemDefinition.itemCategories property
// instead. Item Categories allow for arbitrary hierarchies of specificity, and for items to belong to
// multiple categories across multiple hierarchies simultaneously. For this enum, we pick a single type
// as a "best guess" fit.
// NOTE: This is not all of the item types available, and some of these are holdovers from Destiny 1
// that may or may not still exist.
type ItemSubType int32

const (
	ItemSubType_None                  = ItemSubType(0)
	ItemSubType_Crucible              = ItemSubType(1)
	ItemSubType_Vanguard              = ItemSubType(2)
	ItemSubType_Exotic                = ItemSubType(5)
	ItemSubType_AutoRifle             = ItemSubType(6)
	ItemSubType_Shotgun               = ItemSubType(7)
	ItemSubType_Machinegun            = ItemSubType(8)
	ItemSubType_HandCannon            = ItemSubType(9)
	ItemSubType_RocketLauncher        = ItemSubType(10)
	ItemSubType_FusionRifle           = ItemSubType(11)
	ItemSubType_SniperRifle           = ItemSubType(12)
	ItemSubType_PulseRifle            = ItemSubType(13)
	ItemSubType_ScoutRifle            = ItemSubType(14)
	ItemSubType_Crm                   = ItemSubType(16)
	ItemSubType_Sidearm               = ItemSubType(17)
	ItemSubType_Sword                 = ItemSubType(18)
	ItemSubType_Mask                  = ItemSubType(19)
	ItemSubType_Shader                = ItemSubType(20)
	ItemSubType_Ornament              = ItemSubType(21)
	ItemSubType_FusionRifleLine       = ItemSubType(22)
	ItemSubType_GrenadeLauncher       = ItemSubType(23)
	ItemSubType_SubmachineGun         = ItemSubType(24)
	ItemSubType_TraceRifle            = ItemSubType(25)
	ItemSubType_HelmetArmor           = ItemSubType(26)
	ItemSubType_GauntletsArmor        = ItemSubType(27)
	ItemSubType_ChestArmor            = ItemSubType(28)
	ItemSubType_LegArmor              = ItemSubType(29)
	ItemSubType_ClassArmor            = ItemSubType(30)
	ItemSubType_Bow                   = ItemSubType(31)
	ItemSubType_DummyRepeatableBounty = ItemSubType(32)
	ItemSubType_Glaive                = ItemSubType(33)
)

// Destiny.DestinyItemType
//
// An enumeration that indicates the high-level "type" of the item, attempting to iron out the context
// specific differences for specific instances of an entity. For instance, though a weapon may be of
// various weapon "Types", in DestinyItemType they are all classified as "Weapon". This allows for
// better filtering on a higher level of abstraction for the concept of types.
//
//	This enum is provided for historical compatibility with Destiny 1, but an ideal alternative is to
//
// use DestinyItemCategoryDefinitions and the DestinyItemDefinition.itemCategories property instead.
// Item Categories allow for arbitrary hierarchies of specificity, and for items to belong to multiple
// categories across multiple hierarchies simultaneously. For this enum, we pick a single type as a
// "best guess" fit.
//
//	NOTE: This is not all of the item types available, and some of these are holdovers from Destiny 1
//
// that may or may not still exist.
//
//	I keep updating these because they're so damn convenient. I guess I shouldn't fight it.
type ItemType int32

const (
	ItemType_None              = ItemType(0)
	ItemType_Currency          = ItemType(1)
	ItemType_Armor             = ItemType(2)
	ItemType_Weapon            = ItemType(3)
	ItemType_Message           = ItemType(7)
	ItemType_Engram            = ItemType(8)
	ItemType_Consumable        = ItemType(9)
	ItemType_ExchangeMaterial  = ItemType(10)
	ItemType_MissionReward     = ItemType(11)
	ItemType_QuestStep         = ItemType(12)
	ItemType_QuestStepComplete = ItemType(13)
	ItemType_Emblem            = ItemType(14)
	ItemType_Quest             = ItemType(15)
	ItemType_Subclass          = ItemType(16)
	ItemType_ClanBanner        = ItemType(17)
	ItemType_Aura              = ItemType(18)
	ItemType_Mod               = ItemType(19)
	ItemType_Dummy             = ItemType(20)
	ItemType_Ship              = ItemType(21)
	ItemType_Vehicle           = ItemType(22)
	ItemType_Emote             = ItemType(23)
	ItemType_Ghost             = ItemType(24)
	ItemType_Package           = ItemType(25)
	ItemType_Bounty            = ItemType(26)
	ItemType_Wrapper           = ItemType(27)
	ItemType_SeasonalArtifact  = ItemType(28)
	ItemType_Finisher          = ItemType(29)
	ItemType_Pattern           = ItemType(30)
)

// Destiny.DestinyJoinClosedReasons
//
// A Flags enumeration representing the reasons why a person can't join this user's fireteam.
type JoinClosedReasons int32

const (
	JoinClosedReasons_None                  = JoinClosedReasons(0)
	JoinClosedReasons_InMatchmaking         = JoinClosedReasons(1)
	JoinClosedReasons_Loading               = JoinClosedReasons(2)
	JoinClosedReasons_SoloMode              = JoinClosedReasons(4)
	JoinClosedReasons_InternalReasons       = JoinClosedReasons(8)
	JoinClosedReasons_DisallowedByGameState = JoinClosedReasons(16)
	JoinClosedReasons_Offline               = JoinClosedReasons(32768)
)

// Destiny.DestinyObjectiveGrantStyle
//
// Some Objectives provide perks, generally as part of providing some kind of interesting modifier for
// a Challenge or Quest. This indicates when the Perk is granted.
type ObjectiveGrantStyle int32

const (
	ObjectiveGrantStyle_WhenIncomplete = ObjectiveGrantStyle(0)
	ObjectiveGrantStyle_WhenComplete   = ObjectiveGrantStyle(1)
	ObjectiveGrantStyle_Always         = ObjectiveGrantStyle(2)
)

// Destiny.DestinyObjectiveUiStyle
//
// If the objective has a known UI label, this enumeration will represent it.
type ObjectiveUiStyle int32

const (
	ObjectiveUiStyle_None                        = ObjectiveUiStyle(0)
	ObjectiveUiStyle_Highlighted                 = ObjectiveUiStyle(1)
	ObjectiveUiStyle_CraftingWeaponLevel         = ObjectiveUiStyle(2)
	ObjectiveUiStyle_CraftingWeaponLevelProgress = ObjectiveUiStyle(3)
	ObjectiveUiStyle_CraftingWeaponTimestamp     = ObjectiveUiStyle(4)
	ObjectiveUiStyle_CraftingMementos            = ObjectiveUiStyle(5)
	ObjectiveUiStyle_CraftingMementoTitle        = ObjectiveUiStyle(6)
)

// Destiny.DestinyPartyMemberStates
//
// A flags enumeration that represents a Fireteam Member's status.
type PartyMemberStates int32

const (
	PartyMemberStates_None           = PartyMemberStates(0)
	PartyMemberStates_FireteamMember = PartyMemberStates(1)
	PartyMemberStates_PosseMember    = PartyMemberStates(2)
	PartyMemberStates_GroupMember    = PartyMemberStates(4)
	PartyMemberStates_PartyLeader    = PartyMemberStates(8)
)

// Destiny.DestinyPresentationDisplayStyle
//
// A hint for how the presentation node should be displayed when shown in a list. How you use this is
// your UI is up to you.
type PresentationDisplayStyle int32

const (
	PresentationDisplayStyle_Category                 = PresentationDisplayStyle(0)
	PresentationDisplayStyle_Badge                    = PresentationDisplayStyle(1)
	PresentationDisplayStyle_Medals                   = PresentationDisplayStyle(2)
	PresentationDisplayStyle_Collectible              = PresentationDisplayStyle(3)
	PresentationDisplayStyle_Record                   = PresentationDisplayStyle(4)
	PresentationDisplayStyle_SeasonalTriumph          = PresentationDisplayStyle(5)
	PresentationDisplayStyle_GuardianRank             = PresentationDisplayStyle(6)
	PresentationDisplayStyle_CategoryCollectibles     = PresentationDisplayStyle(7)
	PresentationDisplayStyle_CategoryCurrencies       = PresentationDisplayStyle(8)
	PresentationDisplayStyle_CategoryEmblems          = PresentationDisplayStyle(9)
	PresentationDisplayStyle_CategoryEmotes           = PresentationDisplayStyle(10)
	PresentationDisplayStyle_CategoryEngrams          = PresentationDisplayStyle(11)
	PresentationDisplayStyle_CategoryFinishers        = PresentationDisplayStyle(12)
	PresentationDisplayStyle_CategoryGhosts           = PresentationDisplayStyle(13)
	PresentationDisplayStyle_CategoryMisc             = PresentationDisplayStyle(14)
	PresentationDisplayStyle_CategoryMods             = PresentationDisplayStyle(15)
	PresentationDisplayStyle_CategoryOrnaments        = PresentationDisplayStyle(16)
	PresentationDisplayStyle_CategoryShaders          = PresentationDisplayStyle(17)
	PresentationDisplayStyle_CategoryShips            = PresentationDisplayStyle(18)
	PresentationDisplayStyle_CategorySpawnfx          = PresentationDisplayStyle(19)
	PresentationDisplayStyle_CategoryUpgradeMaterials = PresentationDisplayStyle(20)
)

// Destiny.DestinyPresentationNodeState
//
// I know this doesn't look like a Flags Enumeration/bitmask right now, but I assure you it is. This is
// the possible states that a Presentation Node can be in, and it is almost certain that its potential
// states will increase in the future. So don't treat it like a straight up enumeration.
type PresentationNodeState int32

const (
	PresentationNodeState_None      = PresentationNodeState(0)
	PresentationNodeState_Invisible = PresentationNodeState(1)
	PresentationNodeState_Obscured  = PresentationNodeState(2)
)

// Destiny.DestinyPresentationNodeType
type PresentationNodeType int32

const (
	PresentationNodeType_Default      = PresentationNodeType(0)
	PresentationNodeType_Category     = PresentationNodeType(1)
	PresentationNodeType_Collectibles = PresentationNodeType(2)
	PresentationNodeType_Records      = PresentationNodeType(3)
	PresentationNodeType_Metric       = PresentationNodeType(4)
	PresentationNodeType_Craftable    = PresentationNodeType(5)
)

// Destiny.DestinyPresentationScreenStyle
//
// A hint for what screen should be shown when this presentation node is clicked into. How you use this
// is your UI is up to you.
type PresentationScreenStyle int32

const (
	PresentationScreenStyle_Default      = PresentationScreenStyle(0)
	PresentationScreenStyle_CategorySets = PresentationScreenStyle(1)
	PresentationScreenStyle_Badge        = PresentationScreenStyle(2)
)

// Destiny.DestinyProgression
//
// Information about a current character's status with a Progression. A progression is a value that can
// increase with activity and has levels. Think Character Level and Reputation Levels. Combine this
// "live" data with the related DestinyProgressionDefinition for a full picture of the Progression.
type Progression struct {
	// {
	//   "description": "Information about a current character's status with a Progression. A progression is a value that can increase with activity and has levels. Think Character Level and Reputation Levels. Combine this \"live\" data with the related DestinyProgressionDefinition for a full picture of the Progression.",
	//   "properties": {
	//     "currentProgress": {
	//       "description": "This is the total amount of progress obtained overall for this progression (for instance, the total amount of Character Level experience earned)",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "currentResetCount": {
	//       "description": "The number of resets of this progression you've executed this season, if applicable to this progression.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "dailyLimit": {
	//       "description": "If this progression has a daily limit, this is that limit.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "dailyProgress": {
	//       "description": "The amount of progress earned today for this progression.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "level": {
	//       "description": "This is the level of the progression (for instance, the Character Level).",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "levelCap": {
	//       "description": "This is the maximum possible level you can achieve for this progression (for example, the maximum character level obtainable)",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "nextLevelAt": {
	//       "description": "The total amount of progression (i.e. \"Experience\") needed in order to reach the next level.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "progressToNextLevel": {
	//       "description": "The amount of progression (i.e. \"Experience\") needed to reach the next level of this Progression. Jeez, progression is such an overloaded word.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "progressionHash": {
	//       "description": "The hash identifier of the Progression in question. Use it to look up the DestinyProgressionDefinition in static data.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionDefinition"
	//       }
	//     },
	//     "rewardItemSocketOverrideStates": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.DestinyProgressionRewardItemSocketOverrideState"
	//       },
	//       "description": "Information about items stats and states that have socket overrides, if there is any data for it.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "int32",
	//         "type": "integer"
	//       }
	//     },
	//     "rewardItemStates": {
	//       "description": "Information about historical rewards for this progression, if there is any data for it.",
	//       "items": {
	//         "description": "Represents the different states a progression reward item can be in.",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": true,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/Destiny.DestinyProgressionRewardItemState"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "seasonResets": {
	//       "description": "Information about historical resets of this progression, if there is any data for it.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyProgressionResetEntry"
	//       },
	//       "type": "array"
	//     },
	//     "stepIndex": {
	//       "description": "Progressions define their levels in \"steps\". Since the last step may be repeatable, the user may be at a higher level than the actual Step achieved in the progression. Not necessarily useful, but potentially interesting for those cruising the API. Relate this to the \"steps\" property of the DestinyProgression to see which step the user is on, if you care about that. (Note that this is Content Version dependent since it refers to indexes.)",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "weeklyLimit": {
	//       "description": "If this progression has a weekly limit, this is that limit.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "weeklyProgress": {
	//       "description": "The amount of progress earned toward this progression in the current week.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// This is the total amount of progress obtained overall for this progression (for instance, the total
	// amount of Character Level experience earned)
	CurrentProgress int32 `json:"currentProgress"`

	// The number of resets of this progression you've executed this season, if applicable to this
	// progression.
	CurrentResetCount Nullable[int32] `json:"currentResetCount,omitempty"`

	// If this progression has a daily limit, this is that limit.
	DailyLimit int32 `json:"dailyLimit"`

	// The amount of progress earned today for this progression.
	DailyProgress int32 `json:"dailyProgress"`

	// This is the level of the progression (for instance, the Character Level).
	Level int32 `json:"level"`

	// This is the maximum possible level you can achieve for this progression (for example, the maximum
	// character level obtainable)
	LevelCap int32 `json:"levelCap"`

	// The total amount of progression (i.e. "Experience") needed in order to reach the next level.
	NextLevelAt int32 `json:"nextLevelAt"`

	// The amount of progression (i.e. "Experience") needed to reach the next level of this Progression.
	// Jeez, progression is such an overloaded word.
	ProgressToNextLevel int32 `json:"progressToNextLevel"`

	// The hash identifier of the Progression in question. Use it to look up the
	// DestinyProgressionDefinition in static data.
	ProgressionHash Hash[ProgressionDefinition] `json:"progressionHash"`

	// Information about items stats and states that have socket overrides, if there is any data for it.
	RewardItemSocketOverrideStates map[int32]ProgressionRewardItemSocketOverrideState `json:"rewardItemSocketOverrideStates"`

	// Information about historical rewards for this progression, if there is any data for it.
	RewardItemStates []BitmaskSet[ProgressionRewardItemState] `json:"rewardItemStates"`

	// Information about historical resets of this progression, if there is any data for it.
	SeasonResets []ProgressionResetEntry `json:"seasonResets"`

	// Progressions define their levels in "steps". Since the last step may be repeatable, the user may be
	// at a higher level than the actual Step achieved in the progression. Not necessarily useful, but
	// potentially interesting for those cruising the API. Relate this to the "steps" property of the
	// DestinyProgression to see which step the user is on, if you care about that. (Note that this is
	// Content Version dependent since it refers to indexes.)
	StepIndex int32 `json:"stepIndex"`

	// If this progression has a weekly limit, this is that limit.
	WeeklyLimit int32 `json:"weeklyLimit"`

	// The amount of progress earned toward this progression in the current week.
	WeeklyProgress int32 `json:"weeklyProgress"`
}

// Destiny.DestinyProgressionResetEntry
//
// Represents a season and the number of resets you had in that season.
//
//	We do not necessarily - even for progressions with resets - track it over all seasons. So be
//
// careful and check the season numbers being returned.
type ProgressionResetEntry struct {
	// {
	//   "description": "Represents a season and the number of resets you had in that season.\r\n We do not necessarily - even for progressions with resets - track it over all seasons. So be careful and check the season numbers being returned.",
	//   "properties": {
	//     "resets": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "season": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	Resets int32 `json:"resets"`

	Season int32 `json:"season"`
}

// Destiny.DestinyProgressionRewardItemAcquisitionBehavior
//
// Represents the different kinds of acquisition behavior for progression reward items.
type ProgressionRewardItemAcquisitionBehavior int32

const (
	ProgressionRewardItemAcquisitionBehavior_Instant             = ProgressionRewardItemAcquisitionBehavior(0)
	ProgressionRewardItemAcquisitionBehavior_PlayerClaimRequired = ProgressionRewardItemAcquisitionBehavior(1)
)

// Destiny.DestinyProgressionRewardItemSocketOverrideState
//
// Represents the stats and item state if applicable for progression reward items with socket overrides
type ProgressionRewardItemSocketOverrideState struct {
	// {
	//   "description": "Represents the stats and item state if applicable for progression reward items with socket overrides",
	//   "properties": {
	//     "itemState": {
	//       "description": "Information about the item state, specifically deepsight if there is any data for it",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.ItemState"
	//       }
	//     },
	//     "rewardItemStats": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.DestinyStat"
	//       },
	//       "description": "Information about the computed stats from socket and plug overrides for this progression, if there is any data for it.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyStatDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// Information about the item state, specifically deepsight if there is any data for it
	ItemState BitmaskSet[ItemState] `json:"itemState"`

	// Information about the computed stats from socket and plug overrides for this progression, if there
	// is any data for it.
	RewardItemStats map[Hash[StatDefinition]]Stat `json:"rewardItemStats"`
}

// Destiny.DestinyProgressionRewardItemState
//
// Represents the different states a progression reward item can be in.
type ProgressionRewardItemState int32

const (
	ProgressionRewardItemState_None         = ProgressionRewardItemState(0)
	ProgressionRewardItemState_Invisible    = ProgressionRewardItemState(1)
	ProgressionRewardItemState_Earned       = ProgressionRewardItemState(2)
	ProgressionRewardItemState_Claimed      = ProgressionRewardItemState(4)
	ProgressionRewardItemState_ClaimAllowed = ProgressionRewardItemState(8)
)

// Destiny.DestinyProgressionScope
//
// There are many Progressions in Destiny (think Character Level, or Reputation). These are the various
// "Scopes" of Progressions, which affect many things: * Where/if they are stored * How they are
// calculated * Where they can be used in other game logic
type ProgressionScope int32

const (
	ProgressionScope_Account               = ProgressionScope(0)
	ProgressionScope_Character             = ProgressionScope(1)
	ProgressionScope_Clan                  = ProgressionScope(2)
	ProgressionScope_Item                  = ProgressionScope(3)
	ProgressionScope_ImplicitFromEquipment = ProgressionScope(4)
	ProgressionScope_Mapped                = ProgressionScope(5)
	ProgressionScope_MappedAggregate       = ProgressionScope(6)
	ProgressionScope_MappedStat            = ProgressionScope(7)
	ProgressionScope_MappedUnlockValue     = ProgressionScope(8)
)

// Destiny.DestinyProgressionStepDisplayEffect
//
// If progression is earned, this determines whether the progression shows visual effects on the
// character or its item - or neither.
type ProgressionStepDisplayEffect int32

const (
	ProgressionStepDisplayEffect_None      = ProgressionStepDisplayEffect(0)
	ProgressionStepDisplayEffect_Character = ProgressionStepDisplayEffect(1)
	ProgressionStepDisplayEffect_Item      = ProgressionStepDisplayEffect(2)
)

// Destiny.DestinyRace
type Race int32

const (
	Race_Human   = Race(0)
	Race_Awoken  = Race(1)
	Race_Exo     = Race(2)
	Race_Unknown = Race(3)
)

// Destiny.DestinyRecordState
//
// A Flags enumeration/bitmask where each bit represents a possible state that a Record/Triumph can be
// in.
type RecordState int32

const (
	RecordState_None                  = RecordState(0)
	RecordState_RecordRedeemed        = RecordState(1)
	RecordState_RewardUnavailable     = RecordState(2)
	RecordState_ObjectiveNotCompleted = RecordState(4)
	RecordState_Obscured              = RecordState(8)
	RecordState_Invisible             = RecordState(16)
	RecordState_EntitlementUnowned    = RecordState(32)
	RecordState_CanEquipTitle         = RecordState(64)
)

// Destiny.DestinyRecordToastStyle
type RecordToastStyle int32

const (
	RecordToastStyle_None                               = RecordToastStyle(0)
	RecordToastStyle_Record                             = RecordToastStyle(1)
	RecordToastStyle_Lore                               = RecordToastStyle(2)
	RecordToastStyle_Badge                              = RecordToastStyle(3)
	RecordToastStyle_MetaRecord                         = RecordToastStyle(4)
	RecordToastStyle_MedalComplete                      = RecordToastStyle(5)
	RecordToastStyle_SeasonChallengeComplete            = RecordToastStyle(6)
	RecordToastStyle_GildedTitleComplete                = RecordToastStyle(7)
	RecordToastStyle_CraftingRecipeUnlocked             = RecordToastStyle(8)
	RecordToastStyle_ToastGuardianRankDetails           = RecordToastStyle(9)
	RecordToastStyle_PathfinderObjectiveCompleteRituals = RecordToastStyle(10)
	RecordToastStyle_PathfinderObjectiveCompleteSchism  = RecordToastStyle(11)
	RecordToastStyle_PathfinderObjectiveCompletePvp     = RecordToastStyle(12)
	RecordToastStyle_PathfinderObjectiveCompleteStrikes = RecordToastStyle(13)
	RecordToastStyle_PathfinderObjectiveCompleteGambit  = RecordToastStyle(14)
)

// Destiny.DestinyRecordValueStyle
type RecordValueStyle int32

const (
	RecordValueStyle_Integer      = RecordValueStyle(0)
	RecordValueStyle_Percentage   = RecordValueStyle(1)
	RecordValueStyle_Milliseconds = RecordValueStyle(2)
	RecordValueStyle_Boolean      = RecordValueStyle(3)
	RecordValueStyle_Decimal      = RecordValueStyle(4)
)

// Destiny.DestinyScope
//
// There's a lot of places where we need to know scope on more than just a profile or character level.
// For everything else, there's this more generic sense of scope.
type Scope int32

const (
	Scope_Profile   = Scope(0)
	Scope_Character = Scope(1)
)

// Destiny.DestinySocketCategoryStyle
//
// Represents the possible and known UI styles used by the game for rendering Socket Categories.
type SocketCategoryStyle int32

const (
	SocketCategoryStyle_Unknown     = SocketCategoryStyle(0)
	SocketCategoryStyle_Reusable    = SocketCategoryStyle(1)
	SocketCategoryStyle_Consumable  = SocketCategoryStyle(2)
	SocketCategoryStyle_Unlockable  = SocketCategoryStyle(3)
	SocketCategoryStyle_Intrinsic   = SocketCategoryStyle(4)
	SocketCategoryStyle_EnergyMeter = SocketCategoryStyle(5)
	SocketCategoryStyle_LargePerk   = SocketCategoryStyle(6)
	SocketCategoryStyle_Abilities   = SocketCategoryStyle(7)
	SocketCategoryStyle_Supers      = SocketCategoryStyle(8)
)

// Destiny.DestinySocketVisibility
type SocketVisibility int32

const (
	SocketVisibility_Visible                  = SocketVisibility(0)
	SocketVisibility_Hidden                   = SocketVisibility(1)
	SocketVisibility_HiddenWhenEmpty          = SocketVisibility(2)
	SocketVisibility_HiddenIfNoPlugsAvailable = SocketVisibility(3)
)

// Destiny.DestinyStat
//
// Represents a stat on an item *or* Character (NOT a Historical Stat, but a physical attribute stat
// like Attack, Defense etc...)
type Stat struct {
	// {
	//   "description": "Represents a stat on an item *or* Character (NOT a Historical Stat, but a physical attribute stat like Attack, Defense etc...)",
	//   "properties": {
	//     "statHash": {
	//       "description": "The hash identifier for the Stat. Use it to look up the DestinyStatDefinition for static data about the stat.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyStatDefinition"
	//       }
	//     },
	//     "value": {
	//       "description": "The current value of the Stat.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash identifier for the Stat. Use it to look up the DestinyStatDefinition for static data about
	// the stat.
	StatHash Hash[StatDefinition] `json:"statHash"`

	// The current value of the Stat.
	Value int32 `json:"value"`
}

// Destiny.DestinyStatAggregationType
//
// When a Stat (DestinyStatDefinition) is aggregated, this is the rules used for determining the level
// and formula used for aggregation.
// * CharacterAverage = apply a weighted average using the related DestinyStatGroupDefinition on the
// DestinyInventoryItemDefinition across the character's equipped items. See both of those definitions
// for details. * Character = don't aggregate: the stat should be located and used directly on the
// character. * Item = don't aggregate: the stat should be located and used directly on the item.
type StatAggregationType int32

const (
	StatAggregationType_CharacterAverage = StatAggregationType(0)
	StatAggregationType_Character        = StatAggregationType(1)
	StatAggregationType_Item             = StatAggregationType(2)
)

// Destiny.DestinyStatCategory
//
// At last, stats have categories. Use this for whatever purpose you might wish.
type StatCategory int32

const (
	StatCategory_Gameplay = StatCategory(0)
	StatCategory_Weapon   = StatCategory(1)
	StatCategory_Defense  = StatCategory(2)
	StatCategory_Primary  = StatCategory(3)
)

// Destiny.DestinyTalentNode
//
// I see you've come to find out more about Talent Nodes. I'm so sorry. Talent Nodes are the
// conceptual, visual nodes that appear on Talent Grids. Talent Grids, in Destiny 1, were found on
// almost every instanced item: they had Nodes that could be activated to change the properties of the
// item. In Destiny 2, Talent Grids only exist for Builds/Subclasses, and while the basic concept is
// the same (Nodes can be activated once you've gained sufficient Experience on the Item, and provide
// effects), there are some new concepts from Destiny 1. Examine DestinyTalentGridDefinition and its
// subordinates for more information. This is the "Live" information for the current status of a Talent
// Node on a specific item. Talent Nodes have many Steps, but only one can be active at any one time:
// and it is the Step that determines both the visual and the game state-changing properties that the
// Node provides. Examine this and DestinyTalentNodeStepDefinition carefully. *IMPORTANT NOTE* Talent
// Nodes are, unfortunately, Content Version DEPENDENT. Though they refer to hashes for Nodes and
// Steps, those hashes are not guaranteed to be immutable across content versions. This is a source of
// great exasperation for me, but as a result anyone using Talent Grid data must ensure that the
// content version of their static content matches that of the server responses before showing or
// making decisions based on talent grid data.
type TalentNode struct {
	// {
	//   "description": "I see you've come to find out more about Talent Nodes. I'm so sorry. Talent Nodes are the conceptual, visual nodes that appear on Talent Grids. Talent Grids, in Destiny 1, were found on almost every instanced item: they had Nodes that could be activated to change the properties of the item. In Destiny 2, Talent Grids only exist for Builds/Subclasses, and while the basic concept is the same (Nodes can be activated once you've gained sufficient Experience on the Item, and provide effects), there are some new concepts from Destiny 1. Examine DestinyTalentGridDefinition and its subordinates for more information. This is the \"Live\" information for the current status of a Talent Node on a specific item. Talent Nodes have many Steps, but only one can be active at any one time: and it is the Step that determines both the visual and the game state-changing properties that the Node provides. Examine this and DestinyTalentNodeStepDefinition carefully. *IMPORTANT NOTE* Talent Nodes are, unfortunately, Content Version DEPENDENT. Though they refer to hashes for Nodes and Steps, those hashes are not guaranteed to be immutable across content versions. This is a source of great exasperation for me, but as a result anyone using Talent Grid data must ensure that the content version of their static content matches that of the server responses before showing or making decisions based on talent grid data.",
	//   "properties": {
	//     "activationGridLevel": {
	//       "description": "The progression level required on the Talent Grid in order to be able to activate this talent node. Talent Grids have their own Progression - similar to Character Level, but in this case it is experience related to the item itself.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "hidden": {
	//       "description": "Whether or not the talent node is actually visible in the game's UI. Whether you want to show it in your own UI is up to you! I'm not gonna tell you who to sock it to.",
	//       "type": "boolean"
	//     },
	//     "isActivated": {
	//       "description": "If true, the node is activated: it's current step then provides its benefits.",
	//       "type": "boolean"
	//     },
	//     "materialsToUpgrade": {
	//       "description": "If the node has material requirements to be activated, this is the list of those requirements.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyMaterialRequirement"
	//       },
	//       "type": "array"
	//     },
	//     "nodeHash": {
	//       "description": "The hash of the Talent Node being referred to (in DestinyTalentGridDefinition.nodes). Deceptively CONTENT VERSION DEPENDENT. We have no guarantee of the hash's immutability between content versions.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "nodeIndex": {
	//       "description": "The index of the Talent Node being referred to (an index into DestinyTalentGridDefinition.nodes[]). CONTENT VERSION DEPENDENT.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "nodeStatsBlock": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.DestinyTalentNodeStatBlock"
	//         }
	//       ],
	//       "description": "This property has some history. A talent grid can provide stats on both the item it's related to and the character equipping the item. This returns data about those stat bonuses.",
	//       "type": "object"
	//     },
	//     "progressPercent": {
	//       "description": "If you want to show a progress bar or circle for how close this talent node is to being activate-able, this is the percentage to show. It follows the node's underlying rules about when the progress bar should first show up, and when it should be filled.",
	//       "format": "float",
	//       "type": "number"
	//     },
	//     "state": {
	//       "description": "An DestinyTalentNodeState enum value indicating the node's state: whether it can be activated or swapped, and why not if neither can be performed.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyTalentNodeState"
	//       }
	//     },
	//     "stepIndex": {
	//       "description": "The currently relevant Step for the node. It is this step that has rendering data for the node and the benefits that are provided if the node is activated. (the actual rules for benefits provided are extremely complicated in theory, but with how Talent Grids are being used in Destiny 2 you don't have to worry about a lot of those old Destiny 1 rules.) This is an index into: DestinyTalentGridDefinition.nodes[nodeIndex].steps[stepIndex]",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// The progression level required on the Talent Grid in order to be able to activate this talent node.
	// Talent Grids have their own Progression - similar to Character Level, but in this case it is
	// experience related to the item itself.
	ActivationGridLevel int32 `json:"activationGridLevel"`

	// Whether or not the talent node is actually visible in the game's UI. Whether you want to show it in
	// your own UI is up to you! I'm not gonna tell you who to sock it to.
	Hidden bool `json:"hidden"`

	// If true, the node is activated: it's current step then provides its benefits.
	IsActivated bool `json:"isActivated"`

	// If the node has material requirements to be activated, this is the list of those requirements.
	MaterialsToUpgrade []MaterialRequirement `json:"materialsToUpgrade"`

	// The hash of the Talent Node being referred to (in DestinyTalentGridDefinition.nodes). Deceptively
	// CONTENT VERSION DEPENDENT. We have no guarantee of the hash's immutability between content versions.
	NodeHash uint32 `json:"nodeHash"`

	// The index of the Talent Node being referred to (an index into DestinyTalentGridDefinition.nodes[]).
	// CONTENT VERSION DEPENDENT.
	NodeIndex int32 `json:"nodeIndex"`

	// This property has some history. A talent grid can provide stats on both the item it's related to and
	// the character equipping the item. This returns data about those stat bonuses.
	NodeStatsBlock TalentNodeStatBlock `json:"nodeStatsBlock"`

	// If you want to show a progress bar or circle for how close this talent node is to being
	// activate-able, this is the percentage to show. It follows the node's underlying rules about when the
	// progress bar should first show up, and when it should be filled.
	ProgressPercent float64 `json:"progressPercent"`

	// An DestinyTalentNodeState enum value indicating the node's state: whether it can be activated or
	// swapped, and why not if neither can be performed.
	State TalentNodeState `json:"state"`

	// The currently relevant Step for the node. It is this step that has rendering data for the node and
	// the benefits that are provided if the node is activated. (the actual rules for benefits provided are
	// extremely complicated in theory, but with how Talent Grids are being used in Destiny 2 you don't
	// have to worry about a lot of those old Destiny 1 rules.) This is an index into:
	// DestinyTalentGridDefinition.nodes[nodeIndex].steps[stepIndex]
	StepIndex int32 `json:"stepIndex"`
}

// Destiny.DestinyTalentNodeStatBlock
//
// This property has some history. A talent grid can provide stats on both the item it's related to and
// the character equipping the item. This returns data about those stat bonuses.
type TalentNodeStatBlock struct {
	// {
	//   "description": "This property has some history. A talent grid can provide stats on both the item it's related to and the character equipping the item. This returns data about those stat bonuses.",
	//   "properties": {
	//     "currentStepStats": {
	//       "description": "The stat benefits conferred when this talent node is activated for the current Step that is active on the node.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyStat"
	//       },
	//       "type": "array"
	//     },
	//     "nextStepStats": {
	//       "description": "This is a holdover from the old days of Destiny 1, when a node could be activated multiple times, conferring multiple steps worth of benefits: you would use this property to show what activating the \"next\" step on the node would provide vs. what the current step is providing. While Nodes are currently not being used this way, the underlying system for this functionality still exists. I hesitate to remove this property while the ability for designers to make such a talent grid still exists. Whether you want to show it is up to you.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyStat"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The stat benefits conferred when this talent node is activated for the current Step that is active
	// on the node.
	CurrentStepStats []Stat `json:"currentStepStats"`

	// This is a holdover from the old days of Destiny 1, when a node could be activated multiple times,
	// conferring multiple steps worth of benefits: you would use this property to show what activating the
	// "next" step on the node would provide vs. what the current step is providing. While Nodes are
	// currently not being used this way, the underlying system for this functionality still exists. I
	// hesitate to remove this property while the ability for designers to make such a talent grid still
	// exists. Whether you want to show it is up to you.
	NextStepStats []Stat `json:"nextStepStats"`
}

// Destiny.DestinyTalentNodeState
type TalentNodeState int32

const (
	TalentNodeState_Invalid         = TalentNodeState(0)
	TalentNodeState_CanUpgrade      = TalentNodeState(1)
	TalentNodeState_NoPoints        = TalentNodeState(2)
	TalentNodeState_NoPrerequisites = TalentNodeState(3)
	TalentNodeState_NoSteps         = TalentNodeState(4)
	TalentNodeState_NoUnlock        = TalentNodeState(5)
	TalentNodeState_NoMaterial      = TalentNodeState(6)
	TalentNodeState_NoGridLevel     = TalentNodeState(7)
	TalentNodeState_SwappingLocked  = TalentNodeState(8)
	TalentNodeState_MustSwap        = TalentNodeState(9)
	TalentNodeState_Complete        = TalentNodeState(10)
	TalentNodeState_Unknown         = TalentNodeState(11)
	TalentNodeState_CreationOnly    = TalentNodeState(12)
	TalentNodeState_Hidden          = TalentNodeState(13)
)

// Destiny.DestinyUnlockStatus
//
// Indicates the status of an "Unlock Flag" on a Character or Profile.
// These are individual bits of state that can be either set or not set, and sometimes provide
// interesting human-readable information in their related DestinyUnlockDefinition.
type UnlockStatus struct {
	// {
	//   "description": "Indicates the status of an \"Unlock Flag\" on a Character or Profile.\r\nThese are individual bits of state that can be either set or not set, and sometimes provide interesting human-readable information in their related DestinyUnlockDefinition.",
	//   "properties": {
	//     "isSet": {
	//       "description": "Whether the unlock flag is set.",
	//       "type": "boolean"
	//     },
	//     "unlockHash": {
	//       "description": "The hash identifier for the Unlock Flag. Use to lookup DestinyUnlockDefinition for static data. Not all unlocks have human readable data - in fact, most don't. But when they do, it can be very useful to show. Even if they don't have human readable data, you might be able to infer the meaning of an unlock flag with a bit of experimentation...",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyUnlockDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// Whether the unlock flag is set.
	IsSet bool `json:"isSet"`

	// The hash identifier for the Unlock Flag. Use to lookup DestinyUnlockDefinition for static data. Not
	// all unlocks have human readable data - in fact, most don't. But when they do, it can be very useful
	// to show. Even if they don't have human readable data, you might be able to infer the meaning of an
	// unlock flag with a bit of experimentation...
	UnlockHash Hash[UnlockDefinition] `json:"unlockHash"`
}

// Destiny.DestinyUnlockValueUIStyle
//
// If you're showing an unlock value in the UI, this is the format in which it should be shown. You'll
// have to build your own algorithms on the client side to determine how best to render these options.
type UnlockValueUIStyle int32

const (
	UnlockValueUIStyle_Automatic          = UnlockValueUIStyle(0)
	UnlockValueUIStyle_Fraction           = UnlockValueUIStyle(1)
	UnlockValueUIStyle_Checkbox           = UnlockValueUIStyle(2)
	UnlockValueUIStyle_Percentage         = UnlockValueUIStyle(3)
	UnlockValueUIStyle_DateTime           = UnlockValueUIStyle(4)
	UnlockValueUIStyle_FractionFloat      = UnlockValueUIStyle(5)
	UnlockValueUIStyle_Integer            = UnlockValueUIStyle(6)
	UnlockValueUIStyle_TimeDuration       = UnlockValueUIStyle(7)
	UnlockValueUIStyle_Hidden             = UnlockValueUIStyle(8)
	UnlockValueUIStyle_Multiplier         = UnlockValueUIStyle(9)
	UnlockValueUIStyle_GreenPips          = UnlockValueUIStyle(10)
	UnlockValueUIStyle_RedPips            = UnlockValueUIStyle(11)
	UnlockValueUIStyle_ExplicitPercentage = UnlockValueUIStyle(12)
	UnlockValueUIStyle_RawFloat           = UnlockValueUIStyle(13)
	UnlockValueUIStyle_LevelAndReward     = UnlockValueUIStyle(14)
)

// Destiny.DestinyVendorFilter
//
// Indicates the type of filter to apply to Vendor results.
type VendorFilter int32

const (
	VendorFilter_None           = VendorFilter(0)
	VendorFilter_ApiPurchasable = VendorFilter(1)
)

// Destiny.DestinyVendorInteractionRewardSelection
//
// When a Vendor Interaction provides rewards, they'll either let you choose one or let you have all of
// them. This determines which it will be.
type VendorInteractionRewardSelection int32

const (
	VendorInteractionRewardSelection_None = VendorInteractionRewardSelection(0)
	VendorInteractionRewardSelection_One  = VendorInteractionRewardSelection(1)
	VendorInteractionRewardSelection_All  = VendorInteractionRewardSelection(2)
)

// Destiny.DestinyVendorItemRefundPolicy
//
// The action that happens when the user attempts to refund an item.
type VendorItemRefundPolicy int32

const (
	VendorItemRefundPolicy_NotRefundable  = VendorItemRefundPolicy(0)
	VendorItemRefundPolicy_DeletesItem    = VendorItemRefundPolicy(1)
	VendorItemRefundPolicy_RevokesLicense = VendorItemRefundPolicy(2)
)

// Destiny.DestinyVendorItemState
//
// The possible states of Destiny Profile Records. IMPORTANT: Any given item can theoretically have
// many of these states simultaneously: as a result, this was altered to be a flags enumeration/bitmask
// for v3.2.0.
type VendorItemState int32

const (
	VendorItemState_None                     = VendorItemState(0)
	VendorItemState_Incomplete               = VendorItemState(1)
	VendorItemState_RewardAvailable          = VendorItemState(2)
	VendorItemState_Complete                 = VendorItemState(4)
	VendorItemState_New                      = VendorItemState(8)
	VendorItemState_Featured                 = VendorItemState(16)
	VendorItemState_Ending                   = VendorItemState(32)
	VendorItemState_OnSale                   = VendorItemState(64)
	VendorItemState_Owned                    = VendorItemState(128)
	VendorItemState_WideView                 = VendorItemState(256)
	VendorItemState_NexusAttention           = VendorItemState(512)
	VendorItemState_SetDiscount              = VendorItemState(1024)
	VendorItemState_PriceDrop                = VendorItemState(2048)
	VendorItemState_DailyOffer               = VendorItemState(4096)
	VendorItemState_Charity                  = VendorItemState(8192)
	VendorItemState_SeasonalRewardExpiration = VendorItemState(16384)
	VendorItemState_BestDeal                 = VendorItemState(32768)
	VendorItemState_Popular                  = VendorItemState(65536)
	VendorItemState_Free                     = VendorItemState(131072)
	VendorItemState_Locked                   = VendorItemState(262144)
	VendorItemState_Paracausal               = VendorItemState(524288)
	VendorItemState_Cryptarch                = VendorItemState(1048576)
	VendorItemState_ArtifactPerkOwned        = VendorItemState(2097152)
	VendorItemState_Savings                  = VendorItemState(4194304)
	VendorItemState_Ineligible               = VendorItemState(8388608)
	VendorItemState_ArtifactPerkBoosted      = VendorItemState(16777216)
)

// Destiny.DestinyVendorProgressionType
//
// Describes the type of progression that a vendor has.
type VendorProgressionType int32

const (
	VendorProgressionType_Default           = VendorProgressionType(0)
	VendorProgressionType_Ritual            = VendorProgressionType(1)
	VendorProgressionType_NoSeasonalRefresh = VendorProgressionType(2)
)

// Destiny.DestinyVendorReplyType
//
// This determines the type of reply that a Vendor will have during an Interaction.
type VendorReplyType int32

const (
	VendorReplyType_Accept   = VendorReplyType(0)
	VendorReplyType_Decline  = VendorReplyType(1)
	VendorReplyType_Complete = VendorReplyType(2)
)

// Destiny.DyeReference
type DyeReference struct {
	// {
	//   "properties": {
	//     "channelHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "dyeHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	ChannelHash uint32 `json:"channelHash"`

	DyeHash uint32 `json:"dyeHash"`
}

// Destiny.Entities.Characters.DestinyCharacterActivitiesComponent
//
// This component holds activity data for a character. It will tell you about the character's current
// activity status, as well as activities that are available to the user.
type CharacterActivitiesComponent struct {
	// {
	//   "description": "This component holds activity data for a character. It will tell you about the character's current activity status, as well as activities that are available to the user.",
	//   "properties": {
	//     "availableActivities": {
	//       "description": "The list of activities that the user can play.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyActivity"
	//       },
	//       "type": "array"
	//     },
	//     "availableActivityInteractables": {
	//       "description": "The list of activity interactables that the player can interact with.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyActivityInteractableReference"
	//       },
	//       "type": "array"
	//     },
	//     "currentActivityHash": {
	//       "description": "If the user is in an activity, this will be the hash of the Activity being played. Note that you must combine this info with currentActivityModeHash to get a real picture of what the user is doing right now. For instance, PVP \"Activities\" are just maps: it's the ActivityMode that determines what type of PVP game they're playing.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "currentActivityModeHash": {
	//       "description": "If the user is in an activity, this will be the hash of the activity mode being played. Combine with currentActivityHash to give a person a full picture of what they're doing right now.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityModeDefinition"
	//       }
	//     },
	//     "currentActivityModeHashes": {
	//       "description": "If the user is in an activity, this will be the hashes of the DestinyActivityModeDefinition being played. Combine with currentActivityHash to give a person a full picture of what they're doing right now.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityModeDefinition"
	//       }
	//     },
	//     "currentActivityModeType": {
	//       "description": "And the current activity's most specific mode type, if it can be found.",
	//       "enum": [
	//         "0",
	//         "2",
	//         "3",
	//         "4",
	//         "5",
	//         "6",
	//         "7",
	//         "9",
	//         "10",
	//         "11",
	//         "12",
	//         "13",
	//         "15",
	//         "16",
	//         "17",
	//         "18",
	//         "19",
	//         "20",
	//         "21",
	//         "22",
	//         "24",
	//         "25",
	//         "26",
	//         "27",
	//         "28",
	//         "29",
	//         "30",
	//         "31",
	//         "32",
	//         "37",
	//         "38",
	//         "39",
	//         "40",
	//         "41",
	//         "42",
	//         "43",
	//         "44",
	//         "45",
	//         "46",
	//         "47",
	//         "48",
	//         "49",
	//         "50",
	//         "51",
	//         "52",
	//         "53",
	//         "54",
	//         "55",
	//         "56",
	//         "57",
	//         "58",
	//         "59",
	//         "60",
	//         "61",
	//         "62",
	//         "63",
	//         "64",
	//         "65",
	//         "66",
	//         "67",
	//         "68",
	//         "69",
	//         "70",
	//         "71",
	//         "72",
	//         "73",
	//         "74",
	//         "75",
	//         "76",
	//         "77",
	//         "78",
	//         "79",
	//         "80",
	//         "81",
	//         "82",
	//         "83",
	//         "84",
	//         "85",
	//         "86",
	//         "87",
	//         "88",
	//         "89",
	//         "90",
	//         "91",
	//         "92"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "None",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Story",
	//           "numericValue": "2"
	//         },
	//         {
	//           "identifier": "Strike",
	//           "numericValue": "3"
	//         },
	//         {
	//           "identifier": "Raid",
	//           "numericValue": "4"
	//         },
	//         {
	//           "identifier": "AllPvP",
	//           "numericValue": "5"
	//         },
	//         {
	//           "identifier": "Patrol",
	//           "numericValue": "6"
	//         },
	//         {
	//           "identifier": "AllPvE",
	//           "numericValue": "7"
	//         },
	//         {
	//           "identifier": "Reserved9",
	//           "numericValue": "9"
	//         },
	//         {
	//           "identifier": "Control",
	//           "numericValue": "10"
	//         },
	//         {
	//           "identifier": "Reserved11",
	//           "numericValue": "11"
	//         },
	//         {
	//           "description": "Clash -\u003e Destiny's name for Team Deathmatch. 4v4 combat, the team with the highest kills at the end of time wins.",
	//           "identifier": "Clash",
	//           "numericValue": "12"
	//         },
	//         {
	//           "identifier": "Reserved13",
	//           "numericValue": "13"
	//         },
	//         {
	//           "identifier": "CrimsonDoubles",
	//           "numericValue": "15"
	//         },
	//         {
	//           "identifier": "Nightfall",
	//           "numericValue": "16"
	//         },
	//         {
	//           "identifier": "HeroicNightfall",
	//           "numericValue": "17"
	//         },
	//         {
	//           "identifier": "AllStrikes",
	//           "numericValue": "18"
	//         },
	//         {
	//           "identifier": "IronBanner",
	//           "numericValue": "19"
	//         },
	//         {
	//           "identifier": "Reserved20",
	//           "numericValue": "20"
	//         },
	//         {
	//           "identifier": "Reserved21",
	//           "numericValue": "21"
	//         },
	//         {
	//           "identifier": "Reserved22",
	//           "numericValue": "22"
	//         },
	//         {
	//           "identifier": "Reserved24",
	//           "numericValue": "24"
	//         },
	//         {
	//           "identifier": "AllMayhem",
	//           "numericValue": "25"
	//         },
	//         {
	//           "identifier": "Reserved26",
	//           "numericValue": "26"
	//         },
	//         {
	//           "identifier": "Reserved27",
	//           "numericValue": "27"
	//         },
	//         {
	//           "identifier": "Reserved28",
	//           "numericValue": "28"
	//         },
	//         {
	//           "identifier": "Reserved29",
	//           "numericValue": "29"
	//         },
	//         {
	//           "identifier": "Reserved30",
	//           "numericValue": "30"
	//         },
	//         {
	//           "identifier": "Supremacy",
	//           "numericValue": "31"
	//         },
	//         {
	//           "identifier": "PrivateMatchesAll",
	//           "numericValue": "32"
	//         },
	//         {
	//           "identifier": "Survival",
	//           "numericValue": "37"
	//         },
	//         {
	//           "identifier": "Countdown",
	//           "numericValue": "38"
	//         },
	//         {
	//           "identifier": "TrialsOfTheNine",
	//           "numericValue": "39"
	//         },
	//         {
	//           "identifier": "Social",
	//           "numericValue": "40"
	//         },
	//         {
	//           "identifier": "TrialsCountdown",
	//           "numericValue": "41"
	//         },
	//         {
	//           "identifier": "TrialsSurvival",
	//           "numericValue": "42"
	//         },
	//         {
	//           "identifier": "IronBannerControl",
	//           "numericValue": "43"
	//         },
	//         {
	//           "identifier": "IronBannerClash",
	//           "numericValue": "44"
	//         },
	//         {
	//           "identifier": "IronBannerSupremacy",
	//           "numericValue": "45"
	//         },
	//         {
	//           "identifier": "ScoredNightfall",
	//           "numericValue": "46"
	//         },
	//         {
	//           "identifier": "ScoredHeroicNightfall",
	//           "numericValue": "47"
	//         },
	//         {
	//           "identifier": "Rumble",
	//           "numericValue": "48"
	//         },
	//         {
	//           "identifier": "AllDoubles",
	//           "numericValue": "49"
	//         },
	//         {
	//           "identifier": "Doubles",
	//           "numericValue": "50"
	//         },
	//         {
	//           "identifier": "PrivateMatchesClash",
	//           "numericValue": "51"
	//         },
	//         {
	//           "identifier": "PrivateMatchesControl",
	//           "numericValue": "52"
	//         },
	//         {
	//           "identifier": "PrivateMatchesSupremacy",
	//           "numericValue": "53"
	//         },
	//         {
	//           "identifier": "PrivateMatchesCountdown",
	//           "numericValue": "54"
	//         },
	//         {
	//           "identifier": "PrivateMatchesSurvival",
	//           "numericValue": "55"
	//         },
	//         {
	//           "identifier": "PrivateMatchesMayhem",
	//           "numericValue": "56"
	//         },
	//         {
	//           "identifier": "PrivateMatchesRumble",
	//           "numericValue": "57"
	//         },
	//         {
	//           "identifier": "HeroicAdventure",
	//           "numericValue": "58"
	//         },
	//         {
	//           "identifier": "Showdown",
	//           "numericValue": "59"
	//         },
	//         {
	//           "identifier": "Lockdown",
	//           "numericValue": "60"
	//         },
	//         {
	//           "identifier": "Scorched",
	//           "numericValue": "61"
	//         },
	//         {
	//           "identifier": "ScorchedTeam",
	//           "numericValue": "62"
	//         },
	//         {
	//           "identifier": "Gambit",
	//           "numericValue": "63"
	//         },
	//         {
	//           "identifier": "AllPvECompetitive",
	//           "numericValue": "64"
	//         },
	//         {
	//           "identifier": "Breakthrough",
	//           "numericValue": "65"
	//         },
	//         {
	//           "identifier": "BlackArmoryRun",
	//           "numericValue": "66"
	//         },
	//         {
	//           "identifier": "Salvage",
	//           "numericValue": "67"
	//         },
	//         {
	//           "identifier": "IronBannerSalvage",
	//           "numericValue": "68"
	//         },
	//         {
	//           "identifier": "PvPCompetitive",
	//           "numericValue": "69"
	//         },
	//         {
	//           "identifier": "PvPQuickplay",
	//           "numericValue": "70"
	//         },
	//         {
	//           "identifier": "ClashQuickplay",
	//           "numericValue": "71"
	//         },
	//         {
	//           "identifier": "ClashCompetitive",
	//           "numericValue": "72"
	//         },
	//         {
	//           "identifier": "ControlQuickplay",
	//           "numericValue": "73"
	//         },
	//         {
	//           "identifier": "ControlCompetitive",
	//           "numericValue": "74"
	//         },
	//         {
	//           "identifier": "GambitPrime",
	//           "numericValue": "75"
	//         },
	//         {
	//           "identifier": "Reckoning",
	//           "numericValue": "76"
	//         },
	//         {
	//           "identifier": "Menagerie",
	//           "numericValue": "77"
	//         },
	//         {
	//           "identifier": "VexOffensive",
	//           "numericValue": "78"
	//         },
	//         {
	//           "identifier": "NightmareHunt",
	//           "numericValue": "79"
	//         },
	//         {
	//           "identifier": "Elimination",
	//           "numericValue": "80"
	//         },
	//         {
	//           "identifier": "Momentum",
	//           "numericValue": "81"
	//         },
	//         {
	//           "identifier": "Dungeon",
	//           "numericValue": "82"
	//         },
	//         {
	//           "identifier": "Sundial",
	//           "numericValue": "83"
	//         },
	//         {
	//           "identifier": "TrialsOfOsiris",
	//           "numericValue": "84"
	//         },
	//         {
	//           "identifier": "Dares",
	//           "numericValue": "85"
	//         },
	//         {
	//           "identifier": "Offensive",
	//           "numericValue": "86"
	//         },
	//         {
	//           "identifier": "LostSector",
	//           "numericValue": "87"
	//         },
	//         {
	//           "identifier": "Rift",
	//           "numericValue": "88"
	//         },
	//         {
	//           "identifier": "ZoneControl",
	//           "numericValue": "89"
	//         },
	//         {
	//           "identifier": "IronBannerRift",
	//           "numericValue": "90"
	//         },
	//         {
	//           "identifier": "IronBannerZoneControl",
	//           "numericValue": "91"
	//         },
	//         {
	//           "identifier": "Relic",
	//           "numericValue": "92"
	//         }
	//       ]
	//     },
	//     "currentActivityModeTypes": {
	//       "description": "All Activity Modes that apply to the current activity being played, in enum form.",
	//       "items": {
	//         "description": "For historical reasons, this list will have both D1 and D2-relevant Activity Modes in it. Please don't take this to mean that some D1-only feature is coming back!",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.DestinyActivityModeType"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "currentPlaylistActivityHash": {
	//       "description": "If the user is in a playlist, this is the hash identifier for the playlist that they chose.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "dateActivityStarted": {
	//       "description": "The last date that the user started playing an activity.",
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "lastCompletedStoryHash": {
	//       "description": "This will have the activity hash of the last completed story/campaign mission, in case you care about that.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "CharacterActivities"
	// }

	// The list of activities that the user can play.
	AvailableActivities []Activity `json:"availableActivities"`

	// The list of activity interactables that the player can interact with.
	AvailableActivityInteractables []ActivityInteractableReference `json:"availableActivityInteractables"`

	// If the user is in an activity, this will be the hash of the Activity being played. Note that you
	// must combine this info with currentActivityModeHash to get a real picture of what the user is doing
	// right now. For instance, PVP "Activities" are just maps: it's the ActivityMode that determines what
	// type of PVP game they're playing.
	CurrentActivityHash Hash[ActivityDefinition] `json:"currentActivityHash"`

	// If the user is in an activity, this will be the hash of the activity mode being played. Combine with
	// currentActivityHash to give a person a full picture of what they're doing right now.
	CurrentActivityModeHash Hash[ActivityModeDefinition] `json:"currentActivityModeHash"`

	// If the user is in an activity, this will be the hashes of the DestinyActivityModeDefinition being
	// played. Combine with currentActivityHash to give a person a full picture of what they're doing right
	// now.
	CurrentActivityModeHashes []uint32 `json:"currentActivityModeHashes"`

	// And the current activity's most specific mode type, if it can be found.
	CurrentActivityModeType Nullable[int32] `json:"currentActivityModeType,omitempty"`

	// All Activity Modes that apply to the current activity being played, in enum form.
	CurrentActivityModeTypes []ActivityModeType `json:"currentActivityModeTypes"`

	// If the user is in a playlist, this is the hash identifier for the playlist that they chose.
	CurrentPlaylistActivityHash Nullable[Hash[ActivityDefinition]] `json:"currentPlaylistActivityHash,omitempty"`

	// The last date that the user started playing an activity.
	DateActivityStarted Timestamp `json:"dateActivityStarted"`

	// This will have the activity hash of the last completed story/campaign mission, in case you care
	// about that.
	LastCompletedStoryHash Hash[ActivityDefinition] `json:"lastCompletedStoryHash"`
}

// Destiny.Entities.Characters.DestinyCharacterComponent
//
// This component contains base properties of the character. You'll probably want to always request
// this component, but hey you do you.
type CharacterComponent struct {
	// {
	//   "description": "This component contains base properties of the character. You'll probably want to always request this component, but hey you do you.",
	//   "properties": {
	//     "baseCharacterLevel": {
	//       "description": "The \"base\" level of your character, not accounting for any light level.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "characterId": {
	//       "description": "The unique identifier for the character.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "classHash": {
	//       "description": "Use this hash to look up the character's DestinyClassDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyClassDefinition"
	//       }
	//     },
	//     "classType": {
	//       "description": "Mostly for historical purposes at this point, this is an enumeration for the character's class.\r\nIt'll be preferable in the general case to look up the related definition: but for some people this was too convenient to remove.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyClass"
	//       }
	//     },
	//     "dateLastPlayed": {
	//       "description": "The last date that the user played Destiny.",
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "emblemBackgroundPath": {
	//       "description": "A shortcut path to the user's currently equipped emblem background image. If you're just showing summary info for a user, this is more convenient than examining their equipped emblem and looking up the definition.",
	//       "type": "string"
	//     },
	//     "emblemColor": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Misc.DestinyColor"
	//         }
	//       ],
	//       "description": "A shortcut for getting the background color of the user's currently equipped emblem without having to do a DestinyInventoryItemDefinition lookup.",
	//       "type": "object"
	//     },
	//     "emblemHash": {
	//       "description": "The hash of the currently equipped emblem for the user. Can be used to look up the DestinyInventoryItemDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "emblemPath": {
	//       "description": "A shortcut path to the user's currently equipped emblem image. If you're just showing summary info for a user, this is more convenient than examining their equipped emblem and looking up the definition.",
	//       "type": "string"
	//     },
	//     "genderHash": {
	//       "description": "Use this hash to look up the character's DestinyGenderDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyGenderDefinition"
	//       }
	//     },
	//     "genderType": {
	//       "description": "Mostly for historical purposes at this point, this is an enumeration for the character's Gender.\r\nIt'll be preferable in the general case to look up the related definition: but for some people this was too convenient to remove. And yeah, it's an enumeration and not a boolean. Fight me.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyGender"
	//       }
	//     },
	//     "levelProgression": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.DestinyProgression"
	//         }
	//       ],
	//       "description": "The progression that indicates your character's level. Not their light level, but their character level: you know, the thing you max out a couple hours in and then ignore for the sake of light level.",
	//       "type": "object"
	//     },
	//     "light": {
	//       "description": "The user's calculated \"Light Level\". Light level is an indicator of your power that mostly matters in the end game, once you've reached the maximum character level: it's a level that's dependent on the average Attack/Defense power of your items.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "membershipId": {
	//       "description": "Every Destiny Profile has a membershipId. This is provided on the character as well for convenience.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "description": "membershipType tells you the platform on which the character plays. Examine the BungieMembershipType enumeration for possible values.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "minutesPlayedThisSession": {
	//       "description": "If the user is currently playing, this is how long they've been playing.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "minutesPlayedTotal": {
	//       "description": "If this value is 525,600, then they played Destiny for a year. Or they're a very dedicated Rent fan. Note that this includes idle time, not just time spent actually in activities shooting things.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "percentToNextLevel": {
	//       "description": "A number between 0 and 100, indicating the whole and fractional % remaining to get to the next character level.",
	//       "format": "float",
	//       "type": "number"
	//     },
	//     "raceHash": {
	//       "description": "Use this hash to look up the character's DestinyRaceDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyRaceDefinition"
	//       }
	//     },
	//     "raceType": {
	//       "description": "Mostly for historical purposes at this point, this is an enumeration for the character's race.\r\nIt'll be preferable in the general case to look up the related definition: but for some people this was too convenient to remove.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyRace"
	//       }
	//     },
	//     "stats": {
	//       "additionalProperties": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "description": "Your character's stats, such as Agility, Resilience, etc... *not* historical stats.\r\nYou'll have to call a different endpoint for those.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "titleRecordHash": {
	//       "description": "If this Character has a title assigned to it, this is the identifier of the DestinyRecordDefinition that has that title information.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Records.DestinyRecordDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "Characters"
	// }

	// The "base" level of your character, not accounting for any light level.
	BaseCharacterLevel int32 `json:"baseCharacterLevel"`

	// The unique identifier for the character.
	CharacterID Int64 `json:"characterId"`

	// Use this hash to look up the character's DestinyClassDefinition.
	ClassHash Hash[ClassDefinition] `json:"classHash"`

	// Mostly for historical purposes at this point, this is an enumeration for the character's class.
	// It'll be preferable in the general case to look up the related definition: but for some people this
	// was too convenient to remove.
	ClassType Class `json:"classType"`

	// The last date that the user played Destiny.
	DateLastPlayed Timestamp `json:"dateLastPlayed"`

	// A shortcut path to the user's currently equipped emblem background image. If you're just showing
	// summary info for a user, this is more convenient than examining their equipped emblem and looking up
	// the definition.
	EmblemBackgroundPath string `json:"emblemBackgroundPath"`

	// A shortcut for getting the background color of the user's currently equipped emblem without having
	// to do a DestinyInventoryItemDefinition lookup.
	EmblemColor Color `json:"emblemColor"`

	// The hash of the currently equipped emblem for the user. Can be used to look up the
	// DestinyInventoryItemDefinition.
	EmblemHash Hash[InventoryItemDefinition] `json:"emblemHash"`

	// A shortcut path to the user's currently equipped emblem image. If you're just showing summary info
	// for a user, this is more convenient than examining their equipped emblem and looking up the
	// definition.
	EmblemPath string `json:"emblemPath"`

	// Use this hash to look up the character's DestinyGenderDefinition.
	GenderHash Hash[GenderDefinition] `json:"genderHash"`

	// Mostly for historical purposes at this point, this is an enumeration for the character's Gender.
	// It'll be preferable in the general case to look up the related definition: but for some people this
	// was too convenient to remove. And yeah, it's an enumeration and not a boolean. Fight me.
	GenderType Gender `json:"genderType"`

	// The progression that indicates your character's level. Not their light level, but their character
	// level: you know, the thing you max out a couple hours in and then ignore for the sake of light
	// level.
	LevelProgression Progression `json:"levelProgression"`

	// The user's calculated "Light Level". Light level is an indicator of your power that mostly matters
	// in the end game, once you've reached the maximum character level: it's a level that's dependent on
	// the average Attack/Defense power of your items.
	Light int32 `json:"light"`

	// Every Destiny Profile has a membershipId. This is provided on the character as well for convenience.
	MembershipID Int64 `json:"membershipId"`

	// membershipType tells you the platform on which the character plays. Examine the BungieMembershipType
	// enumeration for possible values.
	MembershipType BungieMembershipType `json:"membershipType"`

	// If the user is currently playing, this is how long they've been playing.
	MinutesPlayedThisSession Int64 `json:"minutesPlayedThisSession"`

	// If this value is 525,600, then they played Destiny for a year. Or they're a very dedicated Rent fan.
	// Note that this includes idle time, not just time spent actually in activities shooting things.
	MinutesPlayedTotal Int64 `json:"minutesPlayedTotal"`

	// A number between 0 and 100, indicating the whole and fractional % remaining to get to the next
	// character level.
	PercentToNextLevel float64 `json:"percentToNextLevel"`

	// Use this hash to look up the character's DestinyRaceDefinition.
	RaceHash Hash[RaceDefinition] `json:"raceHash"`

	// Mostly for historical purposes at this point, this is an enumeration for the character's race.
	// It'll be preferable in the general case to look up the related definition: but for some people this
	// was too convenient to remove.
	RaceType Race `json:"raceType"`

	// Your character's stats, such as Agility, Resilience, etc... *not* historical stats.
	// You'll have to call a different endpoint for those.
	Stats map[uint32]int32 `json:"stats"`

	// If this Character has a title assigned to it, this is the identifier of the DestinyRecordDefinition
	// that has that title information.
	TitleRecordHash Nullable[Hash[RecordDefinition]] `json:"titleRecordHash,omitempty"`
}

// Destiny.Entities.Characters.DestinyCharacterProgressionComponent
//
// This component returns anything that could be considered "Progression" on a user: data where the
// user is gaining levels, reputation, completions, rewards, etc...
type CharacterProgressionComponent struct {
	// {
	//   "description": "This component returns anything that could be considered \"Progression\" on a user: data where the user is gaining levels, reputation, completions, rewards, etc...",
	//   "properties": {
	//     "checklists": {
	//       "additionalProperties": {
	//         "additionalProperties": {
	//           "type": "boolean"
	//         },
	//         "type": "object",
	//         "x-dictionary-key": {
	//           "format": "uint32",
	//           "type": "integer"
	//         }
	//       },
	//       "description": "The set of checklists that can be examined for this specific character, keyed by the hash identifier of the Checklist (DestinyChecklistDefinition)\r\nFor each checklist returned, its value is itself a Dictionary keyed by the checklist's hash identifier with the value being a boolean indicating if it's been discovered yet.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Checklists.DestinyChecklistDefinition"
	//       }
	//     },
	//     "factions": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Progression.DestinyFactionProgression"
	//       },
	//       "description": "A dictionary of all known Factions, keyed by the Faction's hash. It contains data about this character's status with the faction.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyFactionDefinition"
	//       }
	//     },
	//     "milestones": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Milestones.DestinyMilestone"
	//       },
	//       "description": "Milestones are related to the simple progressions shown in the game, but return additional and hopefully helpful information for users about the specifics of the Milestone's status.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneDefinition"
	//       }
	//     },
	//     "progressions": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.DestinyProgression"
	//       },
	//       "description": "A Dictionary of all known progressions for the Character, keyed by the Progression's hash.\r\nNot all progressions have user-facing data, but those who do will have that data contained in the DestinyProgressionDefinition.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionDefinition"
	//       }
	//     },
	//     "quests": {
	//       "description": "If the user has any active quests, the quests' statuses will be returned here.\r\n Note that quests have been largely supplanted by Milestones, but that doesn't mean that they won't make a comeback independent of milestones at some point.\r\n (Fun fact: quests came back as I feared they would, but we never looped back to populate this... I'm going to put that in the backlog.)",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Quests.DestinyQuestStatus"
	//       },
	//       "type": "array"
	//     },
	//     "seasonalArtifact": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Artifacts.DestinyArtifactCharacterScoped"
	//         }
	//       ],
	//       "description": "Data related to your progress on the current season's artifact that can vary per character.",
	//       "type": "object"
	//     },
	//     "uninstancedItemObjectives": {
	//       "additionalProperties": {
	//         "items": {
	//           "$ref": "#/components/schemas/Destiny.Quests.DestinyObjectiveProgress"
	//         },
	//         "type": "array"
	//       },
	//       "description": "Sometimes, you have items in your inventory that don't have instances, but still have Objective information. This provides you that objective information for uninstanced items. \r\nThis dictionary is keyed by the item's hash: which you can use to look up the name and description for the overall task(s) implied by the objective. The value is the list of objectives for this item, and their statuses.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "uninstancedItemPerks": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Entities.Items.DestinyItemPerksComponent"
	//       },
	//       "description": "Sometimes, you have items in your inventory that don't have instances, but still have perks (for example: Trials passage cards). This gives you the perk information for uninstanced items.\r\nThis dictionary is keyed by item hash, which you can use to look up the corresponding item definition. The value is the list of perks states for the item.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "CharacterProgressions"
	// }

	// The set of checklists that can be examined for this specific character, keyed by the hash identifier
	// of the Checklist (DestinyChecklistDefinition)
	// For each checklist returned, its value is itself a Dictionary keyed by the checklist's hash
	// identifier with the value being a boolean indicating if it's been discovered yet.
	Checklists map[Hash[ChecklistDefinition]]map[uint32]bool `json:"checklists"`

	// A dictionary of all known Factions, keyed by the Faction's hash. It contains data about this
	// character's status with the faction.
	Factions map[Hash[FactionDefinition]]FactionProgression `json:"factions"`

	// Milestones are related to the simple progressions shown in the game, but return additional and
	// hopefully helpful information for users about the specifics of the Milestone's status.
	Milestones map[Hash[MilestoneDefinition]]Milestone `json:"milestones"`

	// A Dictionary of all known progressions for the Character, keyed by the Progression's hash.
	// Not all progressions have user-facing data, but those who do will have that data contained in the
	// DestinyProgressionDefinition.
	Progressions map[Hash[ProgressionDefinition]]Progression `json:"progressions"`

	// If the user has any active quests, the quests' statuses will be returned here.
	//
	//	Note that quests have been largely supplanted by Milestones, but that doesn't mean that they won't
	//
	// make a comeback independent of milestones at some point.
	//
	//	(Fun fact: quests came back as I feared they would, but we never looped back to populate this...
	//
	// I'm going to put that in the backlog.)
	Quests []QuestStatus `json:"quests"`

	// Data related to your progress on the current season's artifact that can vary per character.
	SeasonalArtifact ArtifactCharacterScoped `json:"seasonalArtifact"`

	// Sometimes, you have items in your inventory that don't have instances, but still have Objective
	// information. This provides you that objective information for uninstanced items.
	// This dictionary is keyed by the item's hash: which you can use to look up the name and description
	// for the overall task(s) implied by the objective. The value is the list of objectives for this item,
	// and their statuses.
	UninstancedItemObjectives map[Hash[InventoryItemDefinition]][]ObjectiveProgress `json:"uninstancedItemObjectives"`

	// Sometimes, you have items in your inventory that don't have instances, but still have perks (for
	// example: Trials passage cards). This gives you the perk information for uninstanced items.
	// This dictionary is keyed by item hash, which you can use to look up the corresponding item
	// definition. The value is the list of perks states for the item.
	UninstancedItemPerks map[Hash[InventoryItemDefinition]]ItemPerksComponent `json:"uninstancedItemPerks"`
}

// Destiny.Entities.Characters.DestinyCharacterRenderComponent
//
// Only really useful if you're attempting to render the character's current appearance in 3D, this
// returns a bare minimum of information, pre-aggregated, that you'll need to perform that rendering.
// Note that you need to combine this with other 3D assets and data from our servers.
// Examine the Javascript returned by https://bungie.net/sharedbundle/spasm to see how we use this
// data, but be warned: the rabbit hole goes pretty deep.
type CharacterRenderComponent struct {
	// {
	//   "description": "Only really useful if you're attempting to render the character's current appearance in 3D, this returns a bare minimum of information, pre-aggregated, that you'll need to perform that rendering. Note that you need to combine this with other 3D assets and data from our servers.\r\nExamine the Javascript returned by https://bungie.net/sharedbundle/spasm to see how we use this data, but be warned: the rabbit hole goes pretty deep.",
	//   "properties": {
	//     "customDyes": {
	//       "description": "Custom dyes, calculated by iterating over the character's equipped items. Useful for pre-fetching all of the dye data needed from our server.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DyeReference"
	//       },
	//       "type": "array"
	//     },
	//     "customization": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Character.DestinyCharacterCustomization"
	//         }
	//       ],
	//       "description": "This is actually something that Spasm.js *doesn't* do right now, and that we don't return assets for yet. This is the data about what character customization options you picked. You can combine this with DestinyCharacterCustomizationOptionDefinition to show some cool info, and hopefully someday to actually render a user's face in 3D. We'll see if we ever end up with time for that.",
	//       "type": "object"
	//     },
	//     "peerView": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Character.DestinyCharacterPeerView"
	//         }
	//       ],
	//       "description": "A minimal view of:\r\n- Equipped items\r\n- The rendering-related custom options on those equipped items\r\nCombined, that should be enough to render all of the items on the equipped character.",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "CharacterRenderData"
	// }

	// Custom dyes, calculated by iterating over the character's equipped items. Useful for pre-fetching
	// all of the dye data needed from our server.
	CustomDyes []DyeReference `json:"customDyes"`

	// This is actually something that Spasm.js *doesn't* do right now, and that we don't return assets for
	// yet. This is the data about what character customization options you picked. You can combine this
	// with DestinyCharacterCustomizationOptionDefinition to show some cool info, and hopefully someday to
	// actually render a user's face in 3D. We'll see if we ever end up with time for that.
	Customization CharacterCustomization `json:"customization"`

	// A minimal view of:
	// - Equipped items
	// - The rendering-related custom options on those equipped items
	// Combined, that should be enough to render all of the items on the equipped character.
	PeerView CharacterPeerView `json:"peerView"`
}

// Destiny.Entities.Inventory.DestinyInventoryComponent
//
// A list of minimal information for items in an inventory: be it a character's inventory, or a
// Profile's inventory. (Note that the Vault is a collection of inventory buckets in the Profile's
// inventory)
// Inventory Items returned here are in a flat list, but importantly they have a bucketHash property
// that indicates the specific inventory bucket that is holding them. These buckets constitute things
// like the separate sections of the Vault, the user's inventory slots, etc. See
// DestinyInventoryBucketDefinition for more info.
type InventoryComponent struct {
	// {
	//   "description": "A list of minimal information for items in an inventory: be it a character's inventory, or a Profile's inventory. (Note that the Vault is a collection of inventory buckets in the Profile's inventory)\r\nInventory Items returned here are in a flat list, but importantly they have a bucketHash property that indicates the specific inventory bucket that is holding them. These buckets constitute things like the separate sections of the Vault, the user's inventory slots, etc. See DestinyInventoryBucketDefinition for more info.",
	//   "properties": {
	//     "items": {
	//       "description": "The items in this inventory. If you care to bucket them, use the item's bucketHash property to group them.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Entities.Items.DestinyItemComponent"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The items in this inventory. If you care to bucket them, use the item's bucketHash property to group
	// them.
	Items []ItemComponent `json:"items"`
}

// Destiny.Entities.Items.DestinyItemComponent
//
// The base item component, filled with properties that are generally useful to know in any item
// request or that don't feel worthwhile to put in their own component.
type ItemComponent struct {
	// {
	//   "description": "The base item component, filled with properties that are generally useful to know in any item request or that don't feel worthwhile to put in their own component.",
	//   "properties": {
	//     "bindStatus": {
	//       "description": "If the item is bound to a location, it will be specified in this enum.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.ItemBindStatus"
	//       }
	//     },
	//     "bucketHash": {
	//       "description": "The hash identifier for the specific inventory bucket in which the item is located.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryBucketDefinition"
	//       }
	//     },
	//     "expirationDate": {
	//       "description": "If the item can expire, this is the date at which it will/did expire.",
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "isWrapper": {
	//       "description": "If this is true, the object is actually a \"wrapper\" of the object it's representing. This means that it's not the actual item itself, but rather an item that must be \"opened\" in game before you have and can use the item.\r\n Wrappers are an evolution of \"bundles\", which give an easy way to let you preview the contents of what you purchased while still letting you get a refund before you \"open\" it.",
	//       "type": "boolean"
	//     },
	//     "itemHash": {
	//       "description": "The identifier for the item's definition, which is where most of the useful static information for the item can be found.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "itemInstanceId": {
	//       "description": "If the item is instanced, it will have an instance ID. Lack of an instance ID implies that the item has no distinct local qualities aside from stack size.",
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "itemValueVisibility": {
	//       "description": "If available, a list that describes which item values (rewards) should be shown (true) or hidden (false).",
	//       "items": {
	//         "type": "boolean"
	//       },
	//       "type": "array"
	//     },
	//     "location": {
	//       "description": "An easy reference for where the item is located. Redundant if you got the item from an Inventory, but useful when making detail calls on specific items.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.ItemLocation"
	//       }
	//     },
	//     "lockable": {
	//       "description": "If the item can be locked, this will indicate that state.",
	//       "type": "boolean"
	//     },
	//     "metricHash": {
	//       "description": "The identifier for the currently-selected metric definition, to be displayed on the emblem nameplate.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Metrics.DestinyMetricDefinition"
	//       }
	//     },
	//     "metricObjective": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Quests.DestinyObjectiveProgress"
	//         }
	//       ],
	//       "description": "The objective progress for the currently-selected metric definition, to be displayed on the emblem nameplate.",
	//       "type": "object"
	//     },
	//     "overrideStyleItemHash": {
	//       "description": "If populated, this is the hash of the item whose icon (and other secondary styles, but *not* the human readable strings) should override whatever icons/styles are on the item being sold.\r\nIf you don't do this, certain items whose styles are being overridden by socketed items - such as the \"Recycle Shader\" item - would show whatever their default icon/style is, and it wouldn't be pretty or look accurate.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "quantity": {
	//       "description": "The quantity of the item in this stack. Note that Instanced items cannot stack. If an instanced item, this value will always be 1 (as the stack has exactly one item in it)",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "state": {
	//       "description": "A flags enumeration indicating the transient/custom states of the item that affect how it is rendered: whether it's tracked or locked for example, or whether it has a masterwork plug inserted.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.ItemState"
	//       }
	//     },
	//     "tooltipNotificationIndexes": {
	//       "description": "If this is populated, it is a list of indexes into DestinyInventoryItemDefinition.tooltipNotifications for any special tooltip messages that need to be shown for this item.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "transferStatus": {
	//       "description": "If there is a known error state that would cause this item to not be transferable, this Flags enum will indicate all of those error states. Otherwise, it will be 0 (CanTransfer).",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.TransferStatuses"
	//       }
	//     },
	//     "versionNumber": {
	//       "description": "The version of this item, used to index into the versions list in the item definition quality block.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// If the item is bound to a location, it will be specified in this enum.
	BindStatus ItemBindStatus `json:"bindStatus"`

	// The hash identifier for the specific inventory bucket in which the item is located.
	BucketHash Hash[InventoryBucketDefinition] `json:"bucketHash"`

	// If the item can expire, this is the date at which it will/did expire.
	ExpirationDate Nullable[Timestamp] `json:"expirationDate,omitempty"`

	// If this is true, the object is actually a "wrapper" of the object it's representing. This means that
	// it's not the actual item itself, but rather an item that must be "opened" in game before you have
	// and can use the item.
	//
	//	Wrappers are an evolution of "bundles", which give an easy way to let you preview the contents of
	//
	// what you purchased while still letting you get a refund before you "open" it.
	IsWrapper bool `json:"isWrapper"`

	// The identifier for the item's definition, which is where most of the useful static information for
	// the item can be found.
	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`

	// If the item is instanced, it will have an instance ID. Lack of an instance ID implies that the item
	// has no distinct local qualities aside from stack size.
	ItemInstanceID Nullable[Int64] `json:"itemInstanceId,omitempty"`

	// If available, a list that describes which item values (rewards) should be shown (true) or hidden
	// (false).
	ItemValueVisibility []bool `json:"itemValueVisibility"`

	// An easy reference for where the item is located. Redundant if you got the item from an Inventory,
	// but useful when making detail calls on specific items.
	Location ItemLocation `json:"location"`

	// If the item can be locked, this will indicate that state.
	Lockable bool `json:"lockable"`

	// The identifier for the currently-selected metric definition, to be displayed on the emblem
	// nameplate.
	MetricHash Nullable[Hash[MetricDefinition]] `json:"metricHash,omitempty"`

	// The objective progress for the currently-selected metric definition, to be displayed on the emblem
	// nameplate.
	MetricObjective ObjectiveProgress `json:"metricObjective"`

	// If populated, this is the hash of the item whose icon (and other secondary styles, but *not* the
	// human readable strings) should override whatever icons/styles are on the item being sold.
	// If you don't do this, certain items whose styles are being overridden by socketed items - such as
	// the "Recycle Shader" item - would show whatever their default icon/style is, and it wouldn't be
	// pretty or look accurate.
	OverrideStyleItemHash Nullable[Hash[InventoryItemDefinition]] `json:"overrideStyleItemHash,omitempty"`

	// The quantity of the item in this stack. Note that Instanced items cannot stack. If an instanced
	// item, this value will always be 1 (as the stack has exactly one item in it)
	Quantity int32 `json:"quantity"`

	// A flags enumeration indicating the transient/custom states of the item that affect how it is
	// rendered: whether it's tracked or locked for example, or whether it has a masterwork plug inserted.
	State BitmaskSet[ItemState] `json:"state"`

	// If this is populated, it is a list of indexes into
	// DestinyInventoryItemDefinition.tooltipNotifications for any special tooltip messages that need to be
	// shown for this item.
	TooltipNotificationIndexes []int32 `json:"tooltipNotificationIndexes"`

	// If there is a known error state that would cause this item to not be transferable, this Flags enum
	// will indicate all of those error states. Otherwise, it will be 0 (CanTransfer).
	TransferStatus BitmaskSet[TransferStatuses] `json:"transferStatus"`

	// The version of this item, used to index into the versions list in the item definition quality block.
	VersionNumber Nullable[int32] `json:"versionNumber,omitempty"`
}

// Destiny.Entities.Items.DestinyItemInstanceComponent
//
// If an item is "instanced", this will contain information about the item's instance that doesn't fit
// easily into other components. One might say this is the "essential" instance data for the item.
// Items are instanced if they require information or state that can vary. For instance, weapons are
// Instanced: they are given a unique identifier, uniquely generated stats, and can have their
// properties altered. Non-instanced items have none of these things: for instance, Glimmer has no
// unique properties aside from how much of it you own.
// You can tell from an item's definition whether it will be instanced or not by looking at the
// DestinyInventoryItemDefinition's definition.inventory.isInstanceItem property.
type ItemInstanceComponent struct {
	// {
	//   "description": "If an item is \"instanced\", this will contain information about the item's instance that doesn't fit easily into other components. One might say this is the \"essential\" instance data for the item.\r\nItems are instanced if they require information or state that can vary. For instance, weapons are Instanced: they are given a unique identifier, uniquely generated stats, and can have their properties altered. Non-instanced items have none of these things: for instance, Glimmer has no unique properties aside from how much of it you own.\r\nYou can tell from an item's definition whether it will be instanced or not by looking at the DestinyInventoryItemDefinition's definition.inventory.isInstanceItem property.",
	//   "properties": {
	//     "breakerType": {
	//       "description": "If populated, this item has a breaker type corresponding to the given value. See DestinyBreakerTypeDefinition for more details.",
	//       "enum": [
	//         "0",
	//         "1",
	//         "2",
	//         "3"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "None",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "ShieldPiercing",
	//           "numericValue": "1"
	//         },
	//         {
	//           "identifier": "Disruption",
	//           "numericValue": "2"
	//         },
	//         {
	//           "identifier": "Stagger",
	//           "numericValue": "3"
	//         }
	//       ]
	//     },
	//     "breakerTypeHash": {
	//       "description": "If populated, this is the hash identifier for the item's breaker type. See DestinyBreakerTypeDefinition for more details.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.BreakerTypes.DestinyBreakerTypeDefinition"
	//       }
	//     },
	//     "canEquip": {
	//       "description": "If this is an equippable item, you can check it here. There are permanent as well as transitory reasons why an item might not be able to be equipped: check cannotEquipReason for details.",
	//       "type": "boolean"
	//     },
	//     "cannotEquipReason": {
	//       "description": "If you cannot equip the item, this is a flags enum that enumerates all of the reasons why you couldn't equip the item. You may need to refine your UI further by using unlockHashesRequiredToEquip and equipRequiredLevel.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.EquipFailureReason"
	//       }
	//     },
	//     "damageType": {
	//       "description": "If the item has a damage type, this is the item's current damage type.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DamageType"
	//       }
	//     },
	//     "damageTypeHash": {
	//       "description": "The current damage type's hash, so you can look up localized info and icons for it.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyDamageTypeDefinition"
	//       }
	//     },
	//     "energy": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Entities.Items.DestinyItemInstanceEnergy"
	//         }
	//       ],
	//       "description": "IF populated, this item supports Energy mechanics (i.e. Armor 2.0), and these are the current details of its energy type and available capacity to spend energy points.",
	//       "type": "object"
	//     },
	//     "equipRequiredLevel": {
	//       "description": "If the item cannot be equipped until you reach a certain level, that level will be reflected here.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "isEquipped": {
	//       "description": "Is the item currently equipped on the given character?",
	//       "type": "boolean"
	//     },
	//     "itemLevel": {
	//       "description": "The Item's \"Level\" has the most significant bearing on its stats, such as Light and Power.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "primaryStat": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.DestinyStat"
	//         }
	//       ],
	//       "description": "The item stat that we consider to be \"primary\" for the item. For instance, this would be \"Attack\" for Weapons or \"Defense\" for armor.",
	//       "type": "object"
	//     },
	//     "quality": {
	//       "description": "The \"Quality\" of the item has a lesser - but still impactful - bearing on stats like Light and Power.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "unlockHashesRequiredToEquip": {
	//       "description": "Sometimes, there are limitations to equipping that are represented by character-level flags called \"unlocks\".\r\nThis is a list of flags that they need in order to equip the item that the character has not met. Use these to look up the descriptions to show in your UI by looking up the relevant DestinyUnlockDefinitions for the hashes.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyUnlockDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "ItemInstances"
	// }

	// If populated, this item has a breaker type corresponding to the given value. See
	// DestinyBreakerTypeDefinition for more details.
	BreakerType Nullable[int32] `json:"breakerType,omitempty"`

	// If populated, this is the hash identifier for the item's breaker type. See
	// DestinyBreakerTypeDefinition for more details.
	BreakerTypeHash Nullable[Hash[BreakerTypeDefinition]] `json:"breakerTypeHash,omitempty"`

	// If this is an equippable item, you can check it here. There are permanent as well as transitory
	// reasons why an item might not be able to be equipped: check cannotEquipReason for details.
	CanEquip bool `json:"canEquip"`

	// If you cannot equip the item, this is a flags enum that enumerates all of the reasons why you
	// couldn't equip the item. You may need to refine your UI further by using unlockHashesRequiredToEquip
	// and equipRequiredLevel.
	CannotEquipReason BitmaskSet[EquipFailureReason] `json:"cannotEquipReason"`

	// If the item has a damage type, this is the item's current damage type.
	DamageType DamageType `json:"damageType"`

	// The current damage type's hash, so you can look up localized info and icons for it.
	DamageTypeHash Nullable[Hash[DamageTypeDefinition]] `json:"damageTypeHash,omitempty"`

	// IF populated, this item supports Energy mechanics (i.e. Armor 2.0), and these are the current
	// details of its energy type and available capacity to spend energy points.
	Energy ItemInstanceEnergy `json:"energy"`

	// If the item cannot be equipped until you reach a certain level, that level will be reflected here.
	EquipRequiredLevel int32 `json:"equipRequiredLevel"`

	// Is the item currently equipped on the given character?
	IsEquipped bool `json:"isEquipped"`

	// The Item's "Level" has the most significant bearing on its stats, such as Light and Power.
	ItemLevel int32 `json:"itemLevel"`

	// The item stat that we consider to be "primary" for the item. For instance, this would be "Attack"
	// for Weapons or "Defense" for armor.
	PrimaryStat Stat `json:"primaryStat"`

	// The "Quality" of the item has a lesser - but still impactful - bearing on stats like Light and
	// Power.
	Quality int32 `json:"quality"`

	// Sometimes, there are limitations to equipping that are represented by character-level flags called
	// "unlocks".
	// This is a list of flags that they need in order to equip the item that the character has not met.
	// Use these to look up the descriptions to show in your UI by looking up the relevant
	// DestinyUnlockDefinitions for the hashes.
	UnlockHashesRequiredToEquip []uint32 `json:"unlockHashesRequiredToEquip"`
}

// Destiny.Entities.Items.DestinyItemInstanceEnergy
type ItemInstanceEnergy struct {
	// {
	//   "properties": {
	//     "energyCapacity": {
	//       "description": "The total capacity of Energy that the item currently has, regardless of if it is currently being used.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "energyType": {
	//       "description": "This is the enum version of the Energy Type value, for convenience.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyEnergyType"
	//       }
	//     },
	//     "energyTypeHash": {
	//       "description": "The type of energy for this item. Plugs that require Energy can only be inserted if they have the \"Any\" Energy Type or the matching energy type of this item. This is a reference to the DestinyEnergyTypeDefinition for the energy type, where you can find extended info about it.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.EnergyTypes.DestinyEnergyTypeDefinition"
	//       }
	//     },
	//     "energyUnused": {
	//       "description": "The amount of energy still available for inserting new plugs.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "energyUsed": {
	//       "description": "The amount of Energy currently in use by inserted plugs.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// The total capacity of Energy that the item currently has, regardless of if it is currently being
	// used.
	EnergyCapacity int32 `json:"energyCapacity"`

	// This is the enum version of the Energy Type value, for convenience.
	EnergyType EnergyType `json:"energyType"`

	// The type of energy for this item. Plugs that require Energy can only be inserted if they have the
	// "Any" Energy Type or the matching energy type of this item. This is a reference to the
	// DestinyEnergyTypeDefinition for the energy type, where you can find extended info about it.
	EnergyTypeHash Hash[EnergyTypeDefinition] `json:"energyTypeHash"`

	// The amount of energy still available for inserting new plugs.
	EnergyUnused int32 `json:"energyUnused"`

	// The amount of Energy currently in use by inserted plugs.
	EnergyUsed int32 `json:"energyUsed"`
}

// Destiny.Entities.Items.DestinyItemObjectivesComponent
//
// Items can have objectives and progression. When you request this block, you will obtain information
// about any Objectives and progression tied to this item.
type ItemObjectivesComponent struct {
	// {
	//   "description": "Items can have objectives and progression. When you request this block, you will obtain information about any Objectives and progression tied to this item.",
	//   "properties": {
	//     "dateCompleted": {
	//       "description": "If we have any information on when these objectives were completed, this will be the date of that completion. This won't be on many items, but could be interesting for some items that do store this information.",
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "flavorObjective": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Quests.DestinyObjectiveProgress"
	//         }
	//       ],
	//       "description": "I may regret naming it this way - but this represents when an item has an objective that doesn't serve a beneficial purpose, but rather is used for \"flavor\" or additional information. For instance, when Emblems track specific stats, those stats are represented as Objectives on the item.",
	//       "type": "object"
	//     },
	//     "objectives": {
	//       "description": "If the item has a hard association with objectives, your progress on them will be defined here. \r\nObjectives are our standard way to describe a series of tasks that have to be completed for a reward.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Quests.DestinyObjectiveProgress"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "ItemObjectives"
	// }

	// If we have any information on when these objectives were completed, this will be the date of that
	// completion. This won't be on many items, but could be interesting for some items that do store this
	// information.
	DateCompleted Nullable[Timestamp] `json:"dateCompleted,omitempty"`

	// I may regret naming it this way - but this represents when an item has an objective that doesn't
	// serve a beneficial purpose, but rather is used for "flavor" or additional information. For instance,
	// when Emblems track specific stats, those stats are represented as Objectives on the item.
	FlavorObjective ObjectiveProgress `json:"flavorObjective"`

	// If the item has a hard association with objectives, your progress on them will be defined here.
	// Objectives are our standard way to describe a series of tasks that have to be completed for a
	// reward.
	Objectives []ObjectiveProgress `json:"objectives"`
}

// Destiny.Entities.Items.DestinyItemPerksComponent
//
// Instanced items can have perks: benefits that the item bestows.
// These are related to DestinySandboxPerkDefinition, and sometimes - but not always - have human
// readable info. When they do, they are the icons and text that you see in an item's tooltip.
// Talent Grids, Sockets, and the item itself can apply Perks, which are then summarized here for your
// convenience.
type ItemPerksComponent struct {
	// {
	//   "description": "Instanced items can have perks: benefits that the item bestows.\r\nThese are related to DestinySandboxPerkDefinition, and sometimes - but not always - have human readable info. When they do, they are the icons and text that you see in an item's tooltip.\r\nTalent Grids, Sockets, and the item itself can apply Perks, which are then summarized here for your convenience.",
	//   "properties": {
	//     "perks": {
	//       "description": "The list of perks to display in an item tooltip - and whether or not they have been activated.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Perks.DestinyPerkReference"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "ItemPerks"
	// }

	// The list of perks to display in an item tooltip - and whether or not they have been activated.
	Perks []PerkReference `json:"perks"`
}

// Destiny.Entities.Items.DestinyItemRenderComponent
//
// Many items can be rendered in 3D. When you request this block, you will obtain the custom data
// needed to render this specific instance of the item.
type ItemRenderComponent struct {
	// {
	//   "description": "Many items can be rendered in 3D. When you request this block, you will obtain the custom data needed to render this specific instance of the item.",
	//   "properties": {
	//     "artRegions": {
	//       "additionalProperties": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "description": "A dictionary for rendering gear components, with:\r\nkey = Art Arrangement Region Index\r\nvalue = The chosen Arrangement Index for the Region, based on the value of a stat on the item used for making the choice.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "int32",
	//         "type": "integer"
	//       }
	//     },
	//     "useCustomDyes": {
	//       "description": "If you should use custom dyes on this item, it will be indicated here.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "ItemRenderData"
	// }

	// A dictionary for rendering gear components, with:
	// key = Art Arrangement Region Index
	// value = The chosen Arrangement Index for the Region, based on the value of a stat on the item used
	// for making the choice.
	ArtRegions map[int32]int32 `json:"artRegions"`

	// If you should use custom dyes on this item, it will be indicated here.
	UseCustomDyes bool `json:"useCustomDyes"`
}

// Destiny.Entities.Items.DestinyItemSocketState
//
// The status of a given item's socket. (which plug is inserted, if any: whether it is enabled, what
// "reusable" plugs can be inserted, etc...)
// If I had it to do over, this would probably have a DestinyItemPlug representing the inserted item
// instead of most of these properties. :shrug:
type ItemSocketState struct {
	// {
	//   "description": "The status of a given item's socket. (which plug is inserted, if any: whether it is enabled, what \"reusable\" plugs can be inserted, etc...)\r\nIf I had it to do over, this would probably have a DestinyItemPlug representing the inserted item instead of most of these properties. :shrug:",
	//   "properties": {
	//     "enableFailIndexes": {
	//       "description": "If a plug is inserted but not enabled, this will be populated with indexes into the plug item definition's plug.enabledRules property, so that you can show the reasons why it is not enabled.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "isEnabled": {
	//       "description": "Even if a plug is inserted, it doesn't mean it's enabled.\r\nThis flag indicates whether the plug is active and providing its benefits.",
	//       "type": "boolean"
	//     },
	//     "isVisible": {
	//       "description": "A plug may theoretically provide benefits but not be visible - for instance, some older items use a plug's damage type perk to modify their own damage type. These, though they are not visible, still affect the item. This field indicates that state.\r\nAn invisible plug, while it provides benefits if it is Enabled, cannot be directly modified by the user.",
	//       "type": "boolean"
	//     },
	//     "plugHash": {
	//       "description": "The currently active plug, if any.\r\nNote that, because all plugs are statically defined, its effect on stats and perks can be statically determined using the plug item's definition. The stats and perks can be taken at face value on the plug item as the stats and perks it will provide to the user/item.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// If a plug is inserted but not enabled, this will be populated with indexes into the plug item
	// definition's plug.enabledRules property, so that you can show the reasons why it is not enabled.
	EnableFailIndexes []int32 `json:"enableFailIndexes"`

	// Even if a plug is inserted, it doesn't mean it's enabled.
	// This flag indicates whether the plug is active and providing its benefits.
	IsEnabled bool `json:"isEnabled"`

	// A plug may theoretically provide benefits but not be visible - for instance, some older items use a
	// plug's damage type perk to modify their own damage type. These, though they are not visible, still
	// affect the item. This field indicates that state.
	// An invisible plug, while it provides benefits if it is Enabled, cannot be directly modified by the
	// user.
	IsVisible bool `json:"isVisible"`

	// The currently active plug, if any.
	// Note that, because all plugs are statically defined, its effect on stats and perks can be statically
	// determined using the plug item's definition. The stats and perks can be taken at face value on the
	// plug item as the stats and perks it will provide to the user/item.
	PlugHash Nullable[Hash[InventoryItemDefinition]] `json:"plugHash,omitempty"`
}

// Destiny.Entities.Items.DestinyItemSocketsComponent
//
// Instanced items can have sockets, which are slots on the item where plugs can be inserted.
// Sockets are a bit complex: be sure to examine the documentation on the
// DestinyInventoryItemDefinition's "socket" block and elsewhere on these objects for more details.
type ItemSocketsComponent struct {
	// {
	//   "description": "Instanced items can have sockets, which are slots on the item where plugs can be inserted.\r\nSockets are a bit complex: be sure to examine the documentation on the DestinyInventoryItemDefinition's \"socket\" block and elsewhere on these objects for more details.",
	//   "properties": {
	//     "sockets": {
	//       "description": "The list of all sockets on the item, and their status information.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Entities.Items.DestinyItemSocketState"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "ItemSockets"
	// }

	// The list of all sockets on the item, and their status information.
	Sockets []ItemSocketState `json:"sockets"`
}

// Destiny.Entities.Items.DestinyItemStatsComponent
//
// If you want the stats on an item's instanced data, get this component.
// These are stats like Attack, Defense etc... and *not* historical stats.
// Note that some stats have additional computation in-game at runtime - for instance, Magazine Size -
// and thus these stats might not be 100% accurate compared to what you see in-game for some stats. I
// know, it sucks. I hate it too.
type ItemStatsComponent struct {
	// {
	//   "description": "If you want the stats on an item's instanced data, get this component.\r\nThese are stats like Attack, Defense etc... and *not* historical stats.\r\nNote that some stats have additional computation in-game at runtime - for instance, Magazine Size - and thus these stats might not be 100% accurate compared to what you see in-game for some stats. I know, it sucks. I hate it too.",
	//   "properties": {
	//     "stats": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.DestinyStat"
	//       },
	//       "description": "If the item has stats that it provides (damage, defense, etc...), it will be given here.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyStatDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "ItemStats"
	// }

	// If the item has stats that it provides (damage, defense, etc...), it will be given here.
	Stats map[Hash[StatDefinition]]Stat `json:"stats"`
}

// Destiny.Entities.Items.DestinyItemTalentGridComponent
//
// Well, we're here in Destiny 2, and Talent Grids are unfortunately still around.
// The good news is that they're pretty much only being used for certain base information on items and
// for Builds/Subclasses. The bad news is that they still suck. If you really want this information,
// grab this component.
// An important note is that talent grids are defined as such:
// A Grid has 1:M Nodes, which has 1:M Steps.
// Any given node can only have a single step active at one time, which represents the actual visual
// contents and effects of the Node (for instance, if you see a "Super Cool Bonus" node, the actual
// icon and text for the node is coming from the current Step of that node).
// Nodes can be grouped into exclusivity sets *and* as of D2, exclusivity groups (which are collections
// of exclusivity sets that affect each other).
// See DestinyTalentGridDefinition for more information. Brace yourself, the water's cold out there in
// the deep end.
type ItemTalentGridComponent struct {
	// {
	//   "description": "Well, we're here in Destiny 2, and Talent Grids are unfortunately still around.\r\nThe good news is that they're pretty much only being used for certain base information on items and for Builds/Subclasses. The bad news is that they still suck. If you really want this information, grab this component.\r\nAn important note is that talent grids are defined as such:\r\nA Grid has 1:M Nodes, which has 1:M Steps.\r\nAny given node can only have a single step active at one time, which represents the actual visual contents and effects of the Node (for instance, if you see a \"Super Cool Bonus\" node, the actual icon and text for the node is coming from the current Step of that node).\r\nNodes can be grouped into exclusivity sets *and* as of D2, exclusivity groups (which are collections of exclusivity sets that affect each other).\r\nSee DestinyTalentGridDefinition for more information. Brace yourself, the water's cold out there in the deep end.",
	//   "properties": {
	//     "gridProgression": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.DestinyProgression"
	//         }
	//       ],
	//       "description": "If the item has a progression, it will be detailed here. A progression means that the item can gain experience. Thresholds of experience are what determines whether and when a talent node can be activated.",
	//       "type": "object"
	//     },
	//     "isGridComplete": {
	//       "description": "Indicates whether the talent grid on this item is completed, and thus whether it should have a gold border around it.\r\nOnly will be true if the item actually *has* a talent grid, and only then if it is completed (i.e. every exclusive set has an activated node, and every non-exclusive set node has been activated)",
	//       "type": "boolean"
	//     },
	//     "nodes": {
	//       "description": "Detailed information about the individual nodes in the talent grid.\r\nA node represents a single visual \"pip\" in the talent grid or Build detail view, though each node may have multiple \"steps\" which indicate the actual bonuses and visual representation of that node.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyTalentNode"
	//       },
	//       "type": "array"
	//     },
	//     "talentGridHash": {
	//       "description": "Most items don't have useful talent grids anymore, but Builds in particular still do.\r\nYou can use this hash to lookup the DestinyTalentGridDefinition attached to this item, which will be crucial for understanding the node values on the item.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyTalentGridDefinition"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "ItemTalentGrids"
	// }

	// If the item has a progression, it will be detailed here. A progression means that the item can gain
	// experience. Thresholds of experience are what determines whether and when a talent node can be
	// activated.
	GridProgression Progression `json:"gridProgression"`

	// Indicates whether the talent grid on this item is completed, and thus whether it should have a gold
	// border around it.
	// Only will be true if the item actually *has* a talent grid, and only then if it is completed (i.e.
	// every exclusive set has an activated node, and every non-exclusive set node has been activated)
	IsGridComplete bool `json:"isGridComplete"`

	// Detailed information about the individual nodes in the talent grid.
	// A node represents a single visual "pip" in the talent grid or Build detail view, though each node
	// may have multiple "steps" which indicate the actual bonuses and visual representation of that node.
	Nodes []TalentNode `json:"nodes"`

	// Most items don't have useful talent grids anymore, but Builds in particular still do.
	// You can use this hash to lookup the DestinyTalentGridDefinition attached to this item, which will be
	// crucial for understanding the node values on the item.
	TalentGridHash Hash[TalentGridDefinition] `json:"talentGridHash"`
}

// Destiny.Entities.Profiles.DestinyProfileComponent
//
// The most essential summary information about a Profile (in Destiny 1, we called these "Accounts").
type ProfileComponent struct {
	// {
	//   "description": "The most essential summary information about a Profile (in Destiny 1, we called these \"Accounts\").",
	//   "properties": {
	//     "activeEventCardHash": {
	//       "description": "If populated, this is a reference to the event card that is currently active.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Seasons.DestinyEventCardDefinition"
	//       }
	//     },
	//     "characterIds": {
	//       "description": "A list of the character IDs, for further querying on your part.",
	//       "items": {
	//         "format": "int64",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "currentGuardianRank": {
	//       "description": "The 'current' Guardian Rank value, which starts at rank 1. This rank value will drop at the start of a new season to your 'renewed' rank from the previous season.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.GuardianRanks.DestinyGuardianRankDefinition"
	//       }
	//     },
	//     "currentSeasonHash": {
	//       "description": "If populated, this is a reference to the season that is currently active.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Seasons.DestinySeasonDefinition"
	//       }
	//     },
	//     "currentSeasonRewardPowerCap": {
	//       "description": "If populated, this is the reward power cap for the current season.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "dateLastPlayed": {
	//       "description": "The last time the user played with any character on this Profile.",
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "eventCardHashesOwned": {
	//       "description": "A list of hashes for event cards that a profile owns. Unlike most values in versionsOwned, these stay with the profile across all platforms.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Seasons.DestinyEventCardDefinition"
	//       }
	//     },
	//     "lifetimeHighestGuardianRank": {
	//       "description": "The 'lifetime highest' Guardian Rank value, which starts at rank 1. This rank value should never go down.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.GuardianRanks.DestinyGuardianRankDefinition"
	//       }
	//     },
	//     "renewedGuardianRank": {
	//       "description": "The seasonal 'renewed' Guardian Rank value. This rank value resets at the start of each new season to the highest-earned non-advanced rank.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.GuardianRanks.DestinyGuardianRankDefinition"
	//       }
	//     },
	//     "seasonHashes": {
	//       "description": "A list of seasons that this profile owns. Unlike versionsOwned, these stay with the profile across Platforms, and thus will be valid.\r\n It turns out that Stadia Pro subscriptions will give access to seasons but only while playing on Stadia and with an active subscription. So some users (users who have Stadia Pro but choose to play on some other platform) won't see these as available: it will be whatever seasons are available for the platform on which they last played.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Seasons.DestinySeasonDefinition"
	//       }
	//     },
	//     "userInfo": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/User.UserInfoCard"
	//         }
	//       ],
	//       "description": "If you need to render the Profile (their platform name, icon, etc...) somewhere, this property contains that information.",
	//       "type": "object"
	//     },
	//     "versionsOwned": {
	//       "description": "If you want to know what expansions they own, this will contain that data.\r\n IMPORTANT: This field may not return the data you're interested in for Cross-Saved users. It returns the last ownership data we saw for this account - which is to say, what they've purchased on the platform on which they last played, which now could be a different platform.\r\n If you don't care about per-platform ownership and only care about whatever platform it seems they are playing on most recently, then this should be \"good enough.\" Otherwise, this should be considered deprecated. We do not have a good alternative to provide at this time with platform specific ownership data for DLC.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyGameVersions"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "Profiles"
	// }

	// If populated, this is a reference to the event card that is currently active.
	ActiveEventCardHash Nullable[Hash[EventCardDefinition]] `json:"activeEventCardHash,omitempty"`

	// A list of the character IDs, for further querying on your part.
	CharacterIds []Int64 `json:"characterIds"`

	// The 'current' Guardian Rank value, which starts at rank 1. This rank value will drop at the start of
	// a new season to your 'renewed' rank from the previous season.
	CurrentGuardianRank Hash[GuardianRankDefinition] `json:"currentGuardianRank"`

	// If populated, this is a reference to the season that is currently active.
	CurrentSeasonHash Nullable[Hash[SeasonDefinition]] `json:"currentSeasonHash,omitempty"`

	// If populated, this is the reward power cap for the current season.
	CurrentSeasonRewardPowerCap Nullable[int32] `json:"currentSeasonRewardPowerCap,omitempty"`

	// The last time the user played with any character on this Profile.
	DateLastPlayed Timestamp `json:"dateLastPlayed"`

	// A list of hashes for event cards that a profile owns. Unlike most values in versionsOwned, these
	// stay with the profile across all platforms.
	EventCardHashesOwned []uint32 `json:"eventCardHashesOwned"`

	// The 'lifetime highest' Guardian Rank value, which starts at rank 1. This rank value should never go
	// down.
	LifetimeHighestGuardianRank Hash[GuardianRankDefinition] `json:"lifetimeHighestGuardianRank"`

	// The seasonal 'renewed' Guardian Rank value. This rank value resets at the start of each new season
	// to the highest-earned non-advanced rank.
	RenewedGuardianRank Hash[GuardianRankDefinition] `json:"renewedGuardianRank"`

	// A list of seasons that this profile owns. Unlike versionsOwned, these stay with the profile across
	// Platforms, and thus will be valid.
	//
	//	It turns out that Stadia Pro subscriptions will give access to seasons but only while playing on
	//
	// Stadia and with an active subscription. So some users (users who have Stadia Pro but choose to play
	// on some other platform) won't see these as available: it will be whatever seasons are available for
	// the platform on which they last played.
	SeasonHashes []uint32 `json:"seasonHashes"`

	// If you need to render the Profile (their platform name, icon, etc...) somewhere, this property
	// contains that information.
	UserInfo UserInfoCard `json:"userInfo"`

	// If you want to know what expansions they own, this will contain that data.
	//
	//	IMPORTANT: This field may not return the data you're interested in for Cross-Saved users. It
	//
	// returns the last ownership data we saw for this account - which is to say, what they've purchased on
	// the platform on which they last played, which now could be a different platform.
	//
	//	If you don't care about per-platform ownership and only care about whatever platform it seems they
	//
	// are playing on most recently, then this should be "good enough." Otherwise, this should be
	// considered deprecated. We do not have a good alternative to provide at this time with platform
	// specific ownership data for DLC.
	VersionsOwned BitmaskSet[GameVersions] `json:"versionsOwned"`
}

// Destiny.Entities.Profiles.DestinyVendorReceiptsComponent
//
// For now, this isn't used for much: it's a record of the recent refundable purchases that the user
// has made. In the future, it could be used for providing refunds/buyback via the API. Wouldn't that
// be fun?
type VendorReceiptsComponent struct {
	// {
	//   "description": "For now, this isn't used for much: it's a record of the recent refundable purchases that the user has made. In the future, it could be used for providing refunds/buyback via the API. Wouldn't that be fun?",
	//   "properties": {
	//     "receipts": {
	//       "description": "The receipts for refundable purchases made at a vendor.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Vendors.DestinyVendorReceipt"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "VendorReceipts"
	// }

	// The receipts for refundable purchases made at a vendor.
	Receipts []VendorReceipt `json:"receipts"`
}

// Destiny.Entities.Vendors.DestinyVendorCategoriesComponent
//
// A vendor can have many categories of items that they sell. This component will return the category
// information for available items, as well as the index into those items in the user's sale item list.
// Note that, since both the category and items are indexes, this data is Content Version dependent. Be
// sure to check that your content is up to date before using this data. This is an unfortunate, but
// permanent, limitation of Vendor data.
type VendorCategoriesComponent struct {
	// {
	//   "description": "A vendor can have many categories of items that they sell. This component will return the category information for available items, as well as the index into those items in the user's sale item list.\r\nNote that, since both the category and items are indexes, this data is Content Version dependent. Be sure to check that your content is up to date before using this data. This is an unfortunate, but permanent, limitation of Vendor data.",
	//   "properties": {
	//     "categories": {
	//       "description": "The list of categories for items that the vendor sells, in rendering order.\r\nThese categories each point to a \"display category\" in the displayCategories property of the DestinyVendorDefinition, as opposed to the other categories.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Entities.Vendors.DestinyVendorCategory"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "VendorCategories"
	// }

	// The list of categories for items that the vendor sells, in rendering order.
	// These categories each point to a "display category" in the displayCategories property of the
	// DestinyVendorDefinition, as opposed to the other categories.
	Categories []VendorCategory `json:"categories"`
}

// Destiny.Entities.Vendors.DestinyVendorCategory
//
// Information about the category and items currently sold in that category.
type VendorCategory struct {
	// {
	//   "description": "Information about the category and items currently sold in that category.",
	//   "properties": {
	//     "displayCategoryIndex": {
	//       "description": "An index into the DestinyVendorDefinition.displayCategories property, so you can grab the display data for this category.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "itemIndexes": {
	//       "description": "An ordered list of indexes into items being sold in this category (DestinyVendorDefinition.itemList) which will contain more information about the items being sold themselves. Can also be used to index into DestinyVendorSaleItemComponent data, if you asked for that data to be returned.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// An index into the DestinyVendorDefinition.displayCategories property, so you can grab the display
	// data for this category.
	DisplayCategoryIndex int32 `json:"displayCategoryIndex"`

	// An ordered list of indexes into items being sold in this category (DestinyVendorDefinition.itemList)
	// which will contain more information about the items being sold themselves. Can also be used to index
	// into DestinyVendorSaleItemComponent data, if you asked for that data to be returned.
	ItemIndexes []int32 `json:"itemIndexes"`
}

// Destiny.Entities.Vendors.DestinyVendorComponent
//
// This component contains essential/summary information about the vendor.
type VendorComponent struct {
	// {
	//   "description": "This component contains essential/summary information about the vendor.",
	//   "properties": {
	//     "canPurchase": {
	//       "description": "If True, you can purchase from the Vendor.",
	//       "type": "boolean"
	//     },
	//     "enabled": {
	//       "description": "If True, the Vendor is currently accessible. \r\nIf False, they may not actually be visible in the world at the moment.",
	//       "type": "boolean"
	//     },
	//     "nextRefreshDate": {
	//       "description": "The date when this vendor's inventory will next rotate/refresh.\r\nNote that this is distinct from the date ranges that the vendor is visible/available in-game: this field indicates the specific time when the vendor's available items refresh and rotate, regardless of whether the vendor is actually available at that time. Unfortunately, these two values may be (and are, for the case of important vendors like Xur) different.\r\nIssue https://github.com/Bungie-net/api/issues/353 is tracking a fix to start providing visibility date ranges where possible in addition to this refresh date, so that all important dates for vendors are available for use.",
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "progression": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.DestinyProgression"
	//         }
	//       ],
	//       "description": "If the Vendor has a related Reputation, this is the Progression data that represents the character's Reputation level with this Vendor.",
	//       "type": "object"
	//     },
	//     "seasonalRank": {
	//       "description": "If this vendor has a seasonal rank, this will be the calculated value of that rank. How nice is that? I mean, that's pretty sweeet. It's a whole 32 bit integer.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "vendorHash": {
	//       "description": "The unique identifier for the vendor. Use it to look up their DestinyVendorDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     },
	//     "vendorLocationIndex": {
	//       "description": "An index into the vendor definition's \"locations\" property array, indicating which location they are at currently. If -1, then the vendor has no known location (and you may choose not to show them in your UI as a result. I mean, it's your bag honey)",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "Vendors"
	// }

	// If True, you can purchase from the Vendor.
	CanPurchase bool `json:"canPurchase"`

	// If True, the Vendor is currently accessible.
	// If False, they may not actually be visible in the world at the moment.
	Enabled bool `json:"enabled"`

	// The date when this vendor's inventory will next rotate/refresh.
	// Note that this is distinct from the date ranges that the vendor is visible/available in-game: this
	// field indicates the specific time when the vendor's available items refresh and rotate, regardless
	// of whether the vendor is actually available at that time. Unfortunately, these two values may be
	// (and are, for the case of important vendors like Xur) different.
	// Issue https://github.com/Bungie-net/api/issues/353 is tracking a fix to start providing visibility
	// date ranges where possible in addition to this refresh date, so that all important dates for vendors
	// are available for use.
	NextRefreshDate Timestamp `json:"nextRefreshDate"`

	// If the Vendor has a related Reputation, this is the Progression data that represents the character's
	// Reputation level with this Vendor.
	Progression Progression `json:"progression"`

	// If this vendor has a seasonal rank, this will be the calculated value of that rank. How nice is
	// that? I mean, that's pretty sweeet. It's a whole 32 bit integer.
	SeasonalRank Nullable[int32] `json:"seasonalRank,omitempty"`

	// The unique identifier for the vendor. Use it to look up their DestinyVendorDefinition.
	VendorHash Hash[VendorDefinition] `json:"vendorHash"`

	// An index into the vendor definition's "locations" property array, indicating which location they are
	// at currently. If -1, then the vendor has no known location (and you may choose not to show them in
	// your UI as a result. I mean, it's your bag honey)
	VendorLocationIndex int32 `json:"vendorLocationIndex"`
}

// Destiny.Entities.Vendors.DestinyVendorSaleItemComponent
//
// Request this component if you want the details about an item being sold in relation to the character
// making the request: whether the character can buy it, whether they can afford it, and other data
// related to purchasing the item.
// Note that if you want instance, stats, etc... data for the item, you'll have to request additional
// components such as ItemInstances, ItemPerks etc... and acquire them from the DestinyVendorResponse's
// "items" property.
type VendorSaleItemComponent struct {
	// {
	//   "description": "Request this component if you want the details about an item being sold in relation to the character making the request: whether the character can buy it, whether they can afford it, and other data related to purchasing the item.\r\nNote that if you want instance, stats, etc... data for the item, you'll have to request additional components such as ItemInstances, ItemPerks etc... and acquire them from the DestinyVendorResponse's \"items\" property.",
	//   "properties": {
	//     "apiPurchasable": {
	//       "description": "If true, this item can be purchased through the Bungie.net API.",
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "augments": {
	//       "description": "A flags enumeration value representing the current state of any \"state modifiers\" on the item being sold. These are meant to correspond with some sort of visual indicator as to the augmentation: for instance, if an item is on sale or if you already own the item in question.\r\nDetermining how you want to represent these in your own app (or if you even want to) is an exercise left for the reader.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyVendorItemState"
	//       }
	//     },
	//     "costs": {
	//       "description": "A summary of the current costs of the item.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemQuantity"
	//       },
	//       "type": "array"
	//     },
	//     "failureIndexes": {
	//       "description": "Indexes in to the \"failureStrings\" lookup table in DestinyVendorDefinition for the given Vendor. Gives some more reliable failure information for why you can't purchase an item.\r\nIt is preferred to use these over requiredUnlocks and unlockStatuses: the latter are provided mostly in case someone can do something interesting with it that I didn't anticipate.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "itemHash": {
	//       "description": "The hash of the item being sold, as a quick shortcut for looking up the DestinyInventoryItemDefinition of the sale item.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "itemValueVisibility": {
	//       "description": "If available, a list that describes which item values (rewards) should be shown (true) or hidden (false).",
	//       "items": {
	//         "type": "boolean"
	//       },
	//       "type": "array"
	//     },
	//     "overrideNextRefreshDate": {
	//       "description": "If this item has its own custom date where it may be removed from the Vendor's rotation, this is that date.\r\nNote that there's not actually any guarantee that it will go away: it could be chosen again and end up still being in the Vendor's sale items! But this is the next date where that test will occur, and is also the date that the game shows for availability on things like Bounties being sold. So it's the best we can give.",
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "overrideStyleItemHash": {
	//       "description": "If populated, this is the hash of the item whose icon (and other secondary styles, but *not* the human readable strings) should override whatever icons/styles are on the item being sold.\r\nIf you don't do this, certain items whose styles are being overridden by socketed items - such as the \"Recycle Shader\" item - would show whatever their default icon/style is, and it wouldn't be pretty or look accurate.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "quantity": {
	//       "description": "How much of the item you'll be getting.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "requiredUnlocks": {
	//       "description": "If you can't buy the item due to a complex character state, these will be hashes for DestinyUnlockDefinitions that you can check to see messages regarding the failure (if the unlocks have human readable information: it is not guaranteed that Unlocks will have human readable strings, and your application will have to handle that)\r\nPrefer using failureIndexes instead. These are provided for informational purposes, but have largely been supplanted by failureIndexes.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyUnlockDefinition"
	//       }
	//     },
	//     "saleStatus": {
	//       "description": "A flag indicating whether the requesting character can buy the item, and if not the reasons why the character can't buy it.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.VendorItemStatus"
	//       }
	//     },
	//     "unlockStatuses": {
	//       "description": "If any complex unlock states are checked in determining purchasability, these will be returned here along with the status of the unlock check.\r\nPrefer using failureIndexes instead. These are provided for informational purposes, but have largely been supplanted by failureIndexes.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyUnlockStatus"
	//       },
	//       "type": "array"
	//     },
	//     "vendorItemIndex": {
	//       "description": "The index into the DestinyVendorDefinition.itemList property. Note that this means Vendor data *is* Content Version dependent: make sure you have the latest content before you use Vendor data, or these indexes may mismatch. \r\nMost systems avoid this problem, but Vendors is one area where we are unable to reasonably avoid content dependency at the moment.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "VendorSales"
	// }

	// If true, this item can be purchased through the Bungie.net API.
	ApiPurchasable Nullable[bool] `json:"apiPurchasable,omitempty"`

	// A flags enumeration value representing the current state of any "state modifiers" on the item being
	// sold. These are meant to correspond with some sort of visual indicator as to the augmentation: for
	// instance, if an item is on sale or if you already own the item in question.
	// Determining how you want to represent these in your own app (or if you even want to) is an exercise
	// left for the reader.
	Augments BitmaskSet[VendorItemState] `json:"augments"`

	// A summary of the current costs of the item.
	Costs []ItemQuantity `json:"costs"`

	// Indexes in to the "failureStrings" lookup table in DestinyVendorDefinition for the given Vendor.
	// Gives some more reliable failure information for why you can't purchase an item.
	// It is preferred to use these over requiredUnlocks and unlockStatuses: the latter are provided mostly
	// in case someone can do something interesting with it that I didn't anticipate.
	FailureIndexes []int32 `json:"failureIndexes"`

	// The hash of the item being sold, as a quick shortcut for looking up the
	// DestinyInventoryItemDefinition of the sale item.
	ItemHash Hash[InventoryItemDefinition] `json:"itemHash"`

	// If available, a list that describes which item values (rewards) should be shown (true) or hidden
	// (false).
	ItemValueVisibility []bool `json:"itemValueVisibility"`

	// If this item has its own custom date where it may be removed from the Vendor's rotation, this is
	// that date.
	// Note that there's not actually any guarantee that it will go away: it could be chosen again and end
	// up still being in the Vendor's sale items! But this is the next date where that test will occur, and
	// is also the date that the game shows for availability on things like Bounties being sold. So it's
	// the best we can give.
	OverrideNextRefreshDate Nullable[Timestamp] `json:"overrideNextRefreshDate,omitempty"`

	// If populated, this is the hash of the item whose icon (and other secondary styles, but *not* the
	// human readable strings) should override whatever icons/styles are on the item being sold.
	// If you don't do this, certain items whose styles are being overridden by socketed items - such as
	// the "Recycle Shader" item - would show whatever their default icon/style is, and it wouldn't be
	// pretty or look accurate.
	OverrideStyleItemHash Nullable[Hash[InventoryItemDefinition]] `json:"overrideStyleItemHash,omitempty"`

	// How much of the item you'll be getting.
	Quantity int32 `json:"quantity"`

	// If you can't buy the item due to a complex character state, these will be hashes for
	// DestinyUnlockDefinitions that you can check to see messages regarding the failure (if the unlocks
	// have human readable information: it is not guaranteed that Unlocks will have human readable strings,
	// and your application will have to handle that)
	// Prefer using failureIndexes instead. These are provided for informational purposes, but have largely
	// been supplanted by failureIndexes.
	RequiredUnlocks []uint32 `json:"requiredUnlocks"`

	// A flag indicating whether the requesting character can buy the item, and if not the reasons why the
	// character can't buy it.
	SaleStatus BitmaskSet[VendorItemStatus] `json:"saleStatus"`

	// If any complex unlock states are checked in determining purchasability, these will be returned here
	// along with the status of the unlock check.
	// Prefer using failureIndexes instead. These are provided for informational purposes, but have largely
	// been supplanted by failureIndexes.
	UnlockStatuses []UnlockStatus `json:"unlockStatuses"`

	// The index into the DestinyVendorDefinition.itemList property. Note that this means Vendor data *is*
	// Content Version dependent: make sure you have the latest content before you use Vendor data, or
	// these indexes may mismatch.
	// Most systems avoid this problem, but Vendors is one area where we are unable to reasonably avoid
	// content dependency at the moment.
	VendorItemIndex int32 `json:"vendorItemIndex"`
}

// Destiny.EquipFailureReason
//
// The reasons why an item cannot be equipped, if any. Many flags can be set, or "None" if
type EquipFailureReason int32

const (
	EquipFailureReason_None                         = EquipFailureReason(0)
	EquipFailureReason_ItemUnequippable             = EquipFailureReason(1)
	EquipFailureReason_ItemUniqueEquipRestricted    = EquipFailureReason(2)
	EquipFailureReason_ItemFailedUnlockCheck        = EquipFailureReason(4)
	EquipFailureReason_ItemFailedLevelCheck         = EquipFailureReason(8)
	EquipFailureReason_ItemWrapped                  = EquipFailureReason(16)
	EquipFailureReason_ItemNotLoaded                = EquipFailureReason(32)
	EquipFailureReason_ItemEquipBlocklisted         = EquipFailureReason(64)
	EquipFailureReason_ItemLoadoutRequirementNotMet = EquipFailureReason(128)
)

// Destiny.EquippingItemBlockAttributes
type EquippingItemBlockAttributes int32

const (
	EquippingItemBlockAttributes_None           = EquippingItemBlockAttributes(0)
	EquippingItemBlockAttributes_EquipOnAcquire = EquippingItemBlockAttributes(1)
)

// Destiny.FireteamFinderCodeOptionType
type FireteamFinderCodeOptionType int32

const (
	FireteamFinderCodeOptionType_None                = FireteamFinderCodeOptionType(0)
	FireteamFinderCodeOptionType_ApplicationOnly     = FireteamFinderCodeOptionType(1)
	FireteamFinderCodeOptionType_OnlineOnly          = FireteamFinderCodeOptionType(2)
	FireteamFinderCodeOptionType_PlayerCount         = FireteamFinderCodeOptionType(3)
	FireteamFinderCodeOptionType_Title               = FireteamFinderCodeOptionType(4)
	FireteamFinderCodeOptionType_Tags                = FireteamFinderCodeOptionType(5)
	FireteamFinderCodeOptionType_FinderActivityGraph = FireteamFinderCodeOptionType(6)
	FireteamFinderCodeOptionType_MicrophoneRequired  = FireteamFinderCodeOptionType(7)
)

// Destiny.FireteamFinderLabelFieldType
type FireteamFinderLabelFieldType int32

const (
	FireteamFinderLabelFieldType_Title = FireteamFinderLabelFieldType(0)
	FireteamFinderLabelFieldType_Label = FireteamFinderLabelFieldType(1)
)

// Destiny.FireteamFinderOptionAvailability
type FireteamFinderOptionAvailability int32

const (
	FireteamFinderOptionAvailability_None                 = FireteamFinderOptionAvailability(0)
	FireteamFinderOptionAvailability_CreateListingBuilder = FireteamFinderOptionAvailability(1)
	FireteamFinderOptionAvailability_SearchListingBuilder = FireteamFinderOptionAvailability(2)
	FireteamFinderOptionAvailability_ListingViewer        = FireteamFinderOptionAvailability(4)
	FireteamFinderOptionAvailability_LobbyViewer          = FireteamFinderOptionAvailability(8)
)

// Destiny.FireteamFinderOptionControlType
type FireteamFinderOptionControlType int32

const (
	FireteamFinderOptionControlType_None            = FireteamFinderOptionControlType(0)
	FireteamFinderOptionControlType_ValueCollection = FireteamFinderOptionControlType(1)
	FireteamFinderOptionControlType_RadioButton     = FireteamFinderOptionControlType(2)
)

// Destiny.FireteamFinderOptionDisplayFormat
type FireteamFinderOptionDisplayFormat int32

const (
	FireteamFinderOptionDisplayFormat_Text         = FireteamFinderOptionDisplayFormat(0)
	FireteamFinderOptionDisplayFormat_Integer      = FireteamFinderOptionDisplayFormat(1)
	FireteamFinderOptionDisplayFormat_Bool         = FireteamFinderOptionDisplayFormat(2)
	FireteamFinderOptionDisplayFormat_FormatString = FireteamFinderOptionDisplayFormat(3)
)

// Destiny.FireteamFinderOptionSearchFilterType
type FireteamFinderOptionSearchFilterType int32

const (
	FireteamFinderOptionSearchFilterType_None                 = FireteamFinderOptionSearchFilterType(0)
	FireteamFinderOptionSearchFilterType_All                  = FireteamFinderOptionSearchFilterType(1)
	FireteamFinderOptionSearchFilterType_Any                  = FireteamFinderOptionSearchFilterType(2)
	FireteamFinderOptionSearchFilterType_InRangeInclusive     = FireteamFinderOptionSearchFilterType(3)
	FireteamFinderOptionSearchFilterType_InRangeExclusive     = FireteamFinderOptionSearchFilterType(4)
	FireteamFinderOptionSearchFilterType_GreaterThan          = FireteamFinderOptionSearchFilterType(5)
	FireteamFinderOptionSearchFilterType_GreaterThanOrEqualTo = FireteamFinderOptionSearchFilterType(6)
	FireteamFinderOptionSearchFilterType_LessThan             = FireteamFinderOptionSearchFilterType(7)
	FireteamFinderOptionSearchFilterType_LessThanOrEqualTo    = FireteamFinderOptionSearchFilterType(8)
)

// Destiny.FireteamFinderOptionValueFlags
type FireteamFinderOptionValueFlags int32

const (
	FireteamFinderOptionValueFlags_None                      = FireteamFinderOptionValueFlags(0)
	FireteamFinderOptionValueFlags_CreateListingDefaultValue = FireteamFinderOptionValueFlags(1)
	FireteamFinderOptionValueFlags_SearchFilterDefaultValue  = FireteamFinderOptionValueFlags(2)
)

// Destiny.FireteamFinderOptionValueProviderType
type FireteamFinderOptionValueProviderType int32

const (
	FireteamFinderOptionValueProviderType_None                        = FireteamFinderOptionValueProviderType(0)
	FireteamFinderOptionValueProviderType_Values                      = FireteamFinderOptionValueProviderType(1)
	FireteamFinderOptionValueProviderType_PlayerCount                 = FireteamFinderOptionValueProviderType(2)
	FireteamFinderOptionValueProviderType_FireteamFinderLabels        = FireteamFinderOptionValueProviderType(3)
	FireteamFinderOptionValueProviderType_FireteamFinderActivityGraph = FireteamFinderOptionValueProviderType(4)
)

// Destiny.FireteamFinderOptionVisibility
type FireteamFinderOptionVisibility int32

const (
	FireteamFinderOptionVisibility_Always                     = FireteamFinderOptionVisibility(0)
	FireteamFinderOptionVisibility_ShowWhenChangedFromDefault = FireteamFinderOptionVisibility(1)
)

// Destiny.HistoricalStats.Definitions.DestinyActivityModeType
//
// For historical reasons, this list will have both D1 and D2-relevant Activity Modes in it. Please
// don't take this to mean that some D1-only feature is coming back!
type ActivityModeType int32

const (
	ActivityModeType_None                    = ActivityModeType(0)
	ActivityModeType_Story                   = ActivityModeType(2)
	ActivityModeType_Strike                  = ActivityModeType(3)
	ActivityModeType_Raid                    = ActivityModeType(4)
	ActivityModeType_AllPvP                  = ActivityModeType(5)
	ActivityModeType_Patrol                  = ActivityModeType(6)
	ActivityModeType_AllPvE                  = ActivityModeType(7)
	ActivityModeType_Reserved9               = ActivityModeType(9)
	ActivityModeType_Control                 = ActivityModeType(10)
	ActivityModeType_Reserved11              = ActivityModeType(11)
	ActivityModeType_Clash                   = ActivityModeType(12)
	ActivityModeType_Reserved13              = ActivityModeType(13)
	ActivityModeType_CrimsonDoubles          = ActivityModeType(15)
	ActivityModeType_Nightfall               = ActivityModeType(16)
	ActivityModeType_HeroicNightfall         = ActivityModeType(17)
	ActivityModeType_AllStrikes              = ActivityModeType(18)
	ActivityModeType_IronBanner              = ActivityModeType(19)
	ActivityModeType_Reserved20              = ActivityModeType(20)
	ActivityModeType_Reserved21              = ActivityModeType(21)
	ActivityModeType_Reserved22              = ActivityModeType(22)
	ActivityModeType_Reserved24              = ActivityModeType(24)
	ActivityModeType_AllMayhem               = ActivityModeType(25)
	ActivityModeType_Reserved26              = ActivityModeType(26)
	ActivityModeType_Reserved27              = ActivityModeType(27)
	ActivityModeType_Reserved28              = ActivityModeType(28)
	ActivityModeType_Reserved29              = ActivityModeType(29)
	ActivityModeType_Reserved30              = ActivityModeType(30)
	ActivityModeType_Supremacy               = ActivityModeType(31)
	ActivityModeType_PrivateMatchesAll       = ActivityModeType(32)
	ActivityModeType_Survival                = ActivityModeType(37)
	ActivityModeType_Countdown               = ActivityModeType(38)
	ActivityModeType_TrialsOfTheNine         = ActivityModeType(39)
	ActivityModeType_Social                  = ActivityModeType(40)
	ActivityModeType_TrialsCountdown         = ActivityModeType(41)
	ActivityModeType_TrialsSurvival          = ActivityModeType(42)
	ActivityModeType_IronBannerControl       = ActivityModeType(43)
	ActivityModeType_IronBannerClash         = ActivityModeType(44)
	ActivityModeType_IronBannerSupremacy     = ActivityModeType(45)
	ActivityModeType_ScoredNightfall         = ActivityModeType(46)
	ActivityModeType_ScoredHeroicNightfall   = ActivityModeType(47)
	ActivityModeType_Rumble                  = ActivityModeType(48)
	ActivityModeType_AllDoubles              = ActivityModeType(49)
	ActivityModeType_Doubles                 = ActivityModeType(50)
	ActivityModeType_PrivateMatchesClash     = ActivityModeType(51)
	ActivityModeType_PrivateMatchesControl   = ActivityModeType(52)
	ActivityModeType_PrivateMatchesSupremacy = ActivityModeType(53)
	ActivityModeType_PrivateMatchesCountdown = ActivityModeType(54)
	ActivityModeType_PrivateMatchesSurvival  = ActivityModeType(55)
	ActivityModeType_PrivateMatchesMayhem    = ActivityModeType(56)
	ActivityModeType_PrivateMatchesRumble    = ActivityModeType(57)
	ActivityModeType_HeroicAdventure         = ActivityModeType(58)
	ActivityModeType_Showdown                = ActivityModeType(59)
	ActivityModeType_Lockdown                = ActivityModeType(60)
	ActivityModeType_Scorched                = ActivityModeType(61)
	ActivityModeType_ScorchedTeam            = ActivityModeType(62)
	ActivityModeType_Gambit                  = ActivityModeType(63)
	ActivityModeType_AllPvECompetitive       = ActivityModeType(64)
	ActivityModeType_Breakthrough            = ActivityModeType(65)
	ActivityModeType_BlackArmoryRun          = ActivityModeType(66)
	ActivityModeType_Salvage                 = ActivityModeType(67)
	ActivityModeType_IronBannerSalvage       = ActivityModeType(68)
	ActivityModeType_PvPCompetitive          = ActivityModeType(69)
	ActivityModeType_PvPQuickplay            = ActivityModeType(70)
	ActivityModeType_ClashQuickplay          = ActivityModeType(71)
	ActivityModeType_ClashCompetitive        = ActivityModeType(72)
	ActivityModeType_ControlQuickplay        = ActivityModeType(73)
	ActivityModeType_ControlCompetitive      = ActivityModeType(74)
	ActivityModeType_GambitPrime             = ActivityModeType(75)
	ActivityModeType_Reckoning               = ActivityModeType(76)
	ActivityModeType_Menagerie               = ActivityModeType(77)
	ActivityModeType_VexOffensive            = ActivityModeType(78)
	ActivityModeType_NightmareHunt           = ActivityModeType(79)
	ActivityModeType_Elimination             = ActivityModeType(80)
	ActivityModeType_Momentum                = ActivityModeType(81)
	ActivityModeType_Dungeon                 = ActivityModeType(82)
	ActivityModeType_Sundial                 = ActivityModeType(83)
	ActivityModeType_TrialsOfOsiris          = ActivityModeType(84)
	ActivityModeType_Dares                   = ActivityModeType(85)
	ActivityModeType_Offensive               = ActivityModeType(86)
	ActivityModeType_LostSector              = ActivityModeType(87)
	ActivityModeType_Rift                    = ActivityModeType(88)
	ActivityModeType_ZoneControl             = ActivityModeType(89)
	ActivityModeType_IronBannerRift          = ActivityModeType(90)
	ActivityModeType_IronBannerZoneControl   = ActivityModeType(91)
	ActivityModeType_Relic                   = ActivityModeType(92)
)

// Destiny.HistoricalStats.Definitions.DestinyActivityModeType[]
//
//

// Destiny.HistoricalStats.Definitions.DestinyHistoricalStatsDefinition
type HistoricalStatsDefinition struct {
	// {
	//   "properties": {
	//     "category": {
	//       "description": "Category for the stat.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.DestinyStatsCategoryType"
	//       }
	//     },
	//     "group": {
	//       "description": "Statistic group",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.DestinyStatsGroupType"
	//       }
	//     },
	//     "iconImage": {
	//       "description": "Optional URI to an icon for the statistic",
	//       "type": "string"
	//     },
	//     "medalTierHash": {
	//       "description": "The tier associated with this medal - be it implicitly or explicitly.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyMedalTierDefinition"
	//       }
	//     },
	//     "mergeMethod": {
	//       "description": "Optional icon for the statistic",
	//       "enum": [
	//         "0",
	//         "1",
	//         "2"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "description": "When collapsing multiple instances of the stat together, add the values.",
	//           "identifier": "Add",
	//           "numericValue": "0"
	//         },
	//         {
	//           "description": "When collapsing multiple instances of the stat together, take the lower value.",
	//           "identifier": "Min",
	//           "numericValue": "1"
	//         },
	//         {
	//           "description": "When collapsing multiple instances of the stat together, take the higher value.",
	//           "identifier": "Max",
	//           "numericValue": "2"
	//         }
	//       ]
	//     },
	//     "modes": {
	//       "description": "Game modes where this statistic can be reported.",
	//       "items": {
	//         "description": "For historical reasons, this list will have both D1 and D2-relevant Activity Modes in it. Please don't take this to mean that some D1-only feature is coming back!",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.DestinyActivityModeType"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "periodTypes": {
	//       "description": "Time periods the statistic covers",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.PeriodType"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "statDescription": {
	//       "description": "Description of a stat if applicable.",
	//       "type": "string"
	//     },
	//     "statId": {
	//       "description": "Unique programmer friendly ID for this stat",
	//       "type": "string"
	//     },
	//     "statName": {
	//       "description": "Display name",
	//       "type": "string"
	//     },
	//     "statNameAbbr": {
	//       "description": "Display name abbreviated",
	//       "type": "string"
	//     },
	//     "unitLabel": {
	//       "description": "Localized Unit Name for the stat.",
	//       "type": "string"
	//     },
	//     "unitType": {
	//       "description": "Unit, if any, for the statistic",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.UnitType"
	//       }
	//     },
	//     "weight": {
	//       "description": "Weight assigned to this stat indicating its relative impressiveness.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object",
	//   "x-mobile-manifest-name": "HistoricalStats"
	// }

	// Category for the stat.
	Category StatsCategoryType `json:"category"`

	// Statistic group
	Group StatsGroupType `json:"group"`

	// Optional URI to an icon for the statistic
	IconImage string `json:"iconImage"`

	// The tier associated with this medal - be it implicitly or explicitly.
	MedalTierHash Nullable[Hash[MedalTierDefinition]] `json:"medalTierHash,omitempty"`

	// Optional icon for the statistic
	MergeMethod Nullable[int32] `json:"mergeMethod,omitempty"`

	// Game modes where this statistic can be reported.
	Modes []ActivityModeType `json:"modes"`

	// Time periods the statistic covers
	PeriodTypes []PeriodType `json:"periodTypes"`

	// Description of a stat if applicable.
	StatDescription string `json:"statDescription"`

	// Unique programmer friendly ID for this stat
	StatID string `json:"statId"`

	// Display name
	StatName string `json:"statName"`

	// Display name abbreviated
	StatNameAbbr string `json:"statNameAbbr"`

	// Localized Unit Name for the stat.
	UnitLabel string `json:"unitLabel"`

	// Unit, if any, for the statistic
	UnitType UnitType `json:"unitType"`

	// Weight assigned to this stat indicating its relative impressiveness.
	Weight int32 `json:"weight"`
}

// Destiny.HistoricalStats.Definitions.DestinyStatsCategoryType
type StatsCategoryType int32

const (
	StatsCategoryType_None              = StatsCategoryType(0)
	StatsCategoryType_Kills             = StatsCategoryType(1)
	StatsCategoryType_Assists           = StatsCategoryType(2)
	StatsCategoryType_Deaths            = StatsCategoryType(3)
	StatsCategoryType_Criticals         = StatsCategoryType(4)
	StatsCategoryType_KDa               = StatsCategoryType(5)
	StatsCategoryType_KD                = StatsCategoryType(6)
	StatsCategoryType_Score             = StatsCategoryType(7)
	StatsCategoryType_Entered           = StatsCategoryType(8)
	StatsCategoryType_TimePlayed        = StatsCategoryType(9)
	StatsCategoryType_MedalWins         = StatsCategoryType(10)
	StatsCategoryType_MedalGame         = StatsCategoryType(11)
	StatsCategoryType_MedalSpecialKills = StatsCategoryType(12)
	StatsCategoryType_MedalSprees       = StatsCategoryType(13)
	StatsCategoryType_MedalMultiKills   = StatsCategoryType(14)
	StatsCategoryType_MedalAbilities    = StatsCategoryType(15)
)

// Destiny.HistoricalStats.Definitions.DestinyStatsGroupType
//
// If the enum value is > 100, it is a "special" group that cannot be queried for directly (special
// cases apply to when they are returned, and are not relevant in general cases)
type StatsGroupType int32

const (
	StatsGroupType_None           = StatsGroupType(0)
	StatsGroupType_General        = StatsGroupType(1)
	StatsGroupType_Weapons        = StatsGroupType(2)
	StatsGroupType_Medals         = StatsGroupType(3)
	StatsGroupType_ReservedGroups = StatsGroupType(100)
	StatsGroupType_Leaderboard    = StatsGroupType(101)
	StatsGroupType_Activity       = StatsGroupType(102)
	StatsGroupType_UniqueWeapon   = StatsGroupType(103)
	StatsGroupType_Internal       = StatsGroupType(104)
)

// Destiny.HistoricalStats.Definitions.DestinyStatsMergeMethod
type StatsMergeMethod int32

const (
	StatsMergeMethod_Add = StatsMergeMethod(0)
	StatsMergeMethod_Min = StatsMergeMethod(1)
	StatsMergeMethod_Max = StatsMergeMethod(2)
)

// Destiny.HistoricalStats.Definitions.PeriodType
type PeriodType int32

const (
	PeriodType_None     = PeriodType(0)
	PeriodType_Daily    = PeriodType(1)
	PeriodType_AllTime  = PeriodType(2)
	PeriodType_Activity = PeriodType(3)
)

// Destiny.HistoricalStats.Definitions.PeriodType[]
//
//

// Destiny.HistoricalStats.Definitions.UnitType
type UnitType int32

const (
	UnitType_None             = UnitType(0)
	UnitType_Count            = UnitType(1)
	UnitType_PerGame          = UnitType(2)
	UnitType_Seconds          = UnitType(3)
	UnitType_Points           = UnitType(4)
	UnitType_Team             = UnitType(5)
	UnitType_Distance         = UnitType(6)
	UnitType_Percent          = UnitType(7)
	UnitType_Ratio            = UnitType(8)
	UnitType_Boolean          = UnitType(9)
	UnitType_WeaponType       = UnitType(10)
	UnitType_Standing         = UnitType(11)
	UnitType_Milliseconds     = UnitType(12)
	UnitType_CompletionReason = UnitType(13)
)

// Destiny.HistoricalStats.DestinyActivityHistoryResults
type ActivityHistoryResults struct {
	// {
	//   "properties": {
	//     "activities": {
	//       "description": "List of activities, the most recent activity first.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsPeriodGroup"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// List of activities, the most recent activity first.
	Activities []HistoricalStatsPeriodGroup `json:"activities"`
}

// Destiny.HistoricalStats.DestinyAggregateActivityResults
type AggregateActivityResults struct {
	// {
	//   "properties": {
	//     "activities": {
	//       "description": "List of all activities the player has participated in.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyAggregateActivityStats"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// List of all activities the player has participated in.
	Activities []AggregateActivityStats `json:"activities"`
}

// Destiny.HistoricalStats.DestinyAggregateActivityStats
type AggregateActivityStats struct {
	// {
	//   "properties": {
	//     "activityHash": {
	//       "description": "Hash ID that can be looked up in the DestinyActivityTable.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "values": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValue"
	//       },
	//       "description": "Collection of stats for the player in this activity.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// Hash ID that can be looked up in the DestinyActivityTable.
	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`

	// Collection of stats for the player in this activity.
	Values map[string]HistoricalStatsValue `json:"values"`
}

// Destiny.HistoricalStats.DestinyClanAggregateStat
type ClanAggregateStat struct {
	// {
	//   "properties": {
	//     "mode": {
	//       "description": "The id of the mode of stats (allPvp, allPvE, etc)",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.DestinyActivityModeType"
	//       }
	//     },
	//     "statId": {
	//       "description": "The id of the stat",
	//       "type": "string"
	//     },
	//     "value": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValue"
	//         }
	//       ],
	//       "description": "Value of the stat for this player",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object"
	// }

	// The id of the mode of stats (allPvp, allPvE, etc)
	Mode ActivityModeType `json:"mode"`

	// The id of the stat
	StatID string `json:"statId"`

	// Value of the stat for this player
	Value HistoricalStatsValue `json:"value"`
}

// Destiny.HistoricalStats.DestinyHistoricalStatsAccountResult
type HistoricalStatsAccountResult struct {
	// {
	//   "properties": {
	//     "characters": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsPerCharacter"
	//       },
	//       "type": "array"
	//     },
	//     "mergedAllCharacters": {
	//       "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsWithMerged"
	//     },
	//     "mergedDeletedCharacters": {
	//       "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsWithMerged"
	//     }
	//   },
	//   "type": "object"
	// }

	Characters []HistoricalStatsPerCharacter `json:"characters"`

	MergedAllCharacters HistoricalStatsWithMerged `json:"mergedAllCharacters"`

	MergedDeletedCharacters HistoricalStatsWithMerged `json:"mergedDeletedCharacters"`
}

// Destiny.HistoricalStats.DestinyHistoricalStatsActivity
//
// Summary information about the activity that was played.
type HistoricalStatsActivity struct {
	// {
	//   "description": "Summary information about the activity that was played.",
	//   "properties": {
	//     "directorActivityHash": {
	//       "description": "The unique hash identifier of the DestinyActivityDefinition that was played.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "instanceId": {
	//       "description": "The unique identifier for this *specific* match that was played.\r\nThis value can be used to get additional data about this activity such as who else was playing via the GetPostGameCarnageReport endpoint.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "isPrivate": {
	//       "description": "Whether or not the match was a private match.",
	//       "type": "boolean"
	//     },
	//     "membershipType": {
	//       "description": "The Membership Type indicating the platform on which this match was played.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "mode": {
	//       "description": "Indicates the most specific game mode of the activity that we could find.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.DestinyActivityModeType"
	//       }
	//     },
	//     "modes": {
	//       "description": "The list of all Activity Modes to which this activity applies, including aggregates. This will let you see, for example, whether the activity was both Clash and part of the Trials of the Nine event.",
	//       "items": {
	//         "description": "For historical reasons, this list will have both D1 and D2-relevant Activity Modes in it. Please don't take this to mean that some D1-only feature is coming back!",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.Definitions.DestinyActivityModeType"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "referenceId": {
	//       "description": "The unique hash identifier of the DestinyActivityDefinition that was played. If I had this to do over, it'd be named activityHash. Too late now.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The unique hash identifier of the DestinyActivityDefinition that was played.
	DirectorActivityHash Hash[ActivityDefinition] `json:"directorActivityHash"`

	// The unique identifier for this *specific* match that was played.
	// This value can be used to get additional data about this activity such as who else was playing via
	// the GetPostGameCarnageReport endpoint.
	InstanceID Int64 `json:"instanceId"`

	// Whether or not the match was a private match.
	IsPrivate bool `json:"isPrivate"`

	// The Membership Type indicating the platform on which this match was played.
	MembershipType BungieMembershipType `json:"membershipType"`

	// Indicates the most specific game mode of the activity that we could find.
	Mode ActivityModeType `json:"mode"`

	// The list of all Activity Modes to which this activity applies, including aggregates. This will let
	// you see, for example, whether the activity was both Clash and part of the Trials of the Nine event.
	Modes []ActivityModeType `json:"modes"`

	// The unique hash identifier of the DestinyActivityDefinition that was played. If I had this to do
	// over, it'd be named activityHash. Too late now.
	ReferenceID Hash[ActivityDefinition] `json:"referenceId"`
}

// Destiny.HistoricalStats.DestinyHistoricalStatsByPeriod
type HistoricalStatsByPeriod struct {
	// {
	//   "properties": {
	//     "allTime": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValue"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "allTimeTier1": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValue"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "allTimeTier2": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValue"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "allTimeTier3": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValue"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "daily": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsPeriodGroup"
	//       },
	//       "type": "array"
	//     },
	//     "monthly": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsPeriodGroup"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	AllTime map[string]HistoricalStatsValue `json:"allTime"`

	AllTimeTier1 map[string]HistoricalStatsValue `json:"allTimeTier1"`

	AllTimeTier2 map[string]HistoricalStatsValue `json:"allTimeTier2"`

	AllTimeTier3 map[string]HistoricalStatsValue `json:"allTimeTier3"`

	Daily []HistoricalStatsPeriodGroup `json:"daily"`

	Monthly []HistoricalStatsPeriodGroup `json:"monthly"`
}

// Destiny.HistoricalStats.DestinyHistoricalStatsPerCharacter
type HistoricalStatsPerCharacter struct {
	// {
	//   "properties": {
	//     "characterId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "deleted": {
	//       "type": "boolean"
	//     },
	//     "merged": {
	//       "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsByPeriod"
	//     },
	//     "results": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsByPeriod"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	CharacterID Int64 `json:"characterId"`

	Deleted bool `json:"deleted"`

	Merged HistoricalStatsByPeriod `json:"merged"`

	Results map[string]HistoricalStatsByPeriod `json:"results"`
}

// Destiny.HistoricalStats.DestinyHistoricalStatsPeriodGroup
type HistoricalStatsPeriodGroup struct {
	// {
	//   "properties": {
	//     "activityDetails": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsActivity"
	//         }
	//       ],
	//       "description": "If the period group is for a specific activity, this property will be set.",
	//       "type": "object"
	//     },
	//     "period": {
	//       "description": "Period for the group. If the stat periodType is day, then this will have a specific day. If the type is monthly, then this value will be the first day of the applicable month. This value is not set when the periodType is 'all time'.",
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "values": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValue"
	//       },
	//       "description": "Collection of stats for the period.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// If the period group is for a specific activity, this property will be set.
	ActivityDetails HistoricalStatsActivity `json:"activityDetails"`

	// Period for the group. If the stat periodType is day, then this will have a specific day. If the type
	// is monthly, then this value will be the first day of the applicable month. This value is not set
	// when the periodType is 'all time'.
	Period Timestamp `json:"period"`

	// Collection of stats for the period.
	Values map[string]HistoricalStatsValue `json:"values"`
}

// Destiny.HistoricalStats.DestinyHistoricalStatsResults
type HistoricalStatsResults map[string]any

//	{
//	  "additionalProperties": {
//	    "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsByPeriod"
//	  },
//	  "type": "object",
//	  "x-dictionary-key": {
//	    "type": "string"
//	  }
//	}
//
// Destiny.HistoricalStats.DestinyHistoricalStatsValue
type HistoricalStatsValue struct {
	// {
	//   "properties": {
	//     "activityId": {
	//       "description": "When a stat represents the best, most, longest, fastest or some other personal best, the actual activity ID where that personal best was established is available on this property.",
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "basic": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValuePair"
	//         }
	//       ],
	//       "description": "Basic stat value.",
	//       "type": "object"
	//     },
	//     "pga": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValuePair"
	//         }
	//       ],
	//       "description": "Per game average for the statistic, if applicable",
	//       "type": "object"
	//     },
	//     "statId": {
	//       "description": "Unique ID for this stat",
	//       "type": "string"
	//     },
	//     "weighted": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValuePair"
	//         }
	//       ],
	//       "description": "Weighted value of the stat if a weight greater than 1 has been assigned.",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object"
	// }

	// When a stat represents the best, most, longest, fastest or some other personal best, the actual
	// activity ID where that personal best was established is available on this property.
	ActivityID Nullable[Int64] `json:"activityId,omitempty"`

	// Basic stat value.
	Basic HistoricalStatsValuePair `json:"basic"`

	// Per game average for the statistic, if applicable
	Pga HistoricalStatsValuePair `json:"pga"`

	// Unique ID for this stat
	StatID string `json:"statId"`

	// Weighted value of the stat if a weight greater than 1 has been assigned.
	Weighted HistoricalStatsValuePair `json:"weighted"`
}

// Destiny.HistoricalStats.DestinyHistoricalStatsValuePair
type HistoricalStatsValuePair struct {
	// {
	//   "properties": {
	//     "displayValue": {
	//       "description": "Localized formated version of the value.",
	//       "type": "string"
	//     },
	//     "value": {
	//       "description": "Raw value of the statistic",
	//       "format": "double",
	//       "type": "number"
	//     }
	//   },
	//   "type": "object"
	// }

	// Localized formated version of the value.
	DisplayValue string `json:"displayValue"`

	// Raw value of the statistic
	Value float64 `json:"value"`
}

// Destiny.HistoricalStats.DestinyHistoricalStatsWithMerged
type HistoricalStatsWithMerged struct {
	// {
	//   "properties": {
	//     "merged": {
	//       "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsByPeriod"
	//     },
	//     "results": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsByPeriod"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	Merged HistoricalStatsByPeriod `json:"merged"`

	Results map[string]HistoricalStatsByPeriod `json:"results"`
}

// Destiny.HistoricalStats.DestinyHistoricalWeaponStats
type HistoricalWeaponStats struct {
	// {
	//   "properties": {
	//     "referenceId": {
	//       "description": "The hash ID of the item definition that describes the weapon.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "values": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValue"
	//       },
	//       "description": "Collection of stats for the period.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash ID of the item definition that describes the weapon.
	ReferenceID Hash[InventoryItemDefinition] `json:"referenceId"`

	// Collection of stats for the period.
	Values map[string]HistoricalStatsValue `json:"values"`
}

// Destiny.HistoricalStats.DestinyHistoricalWeaponStatsData
type HistoricalWeaponStatsData struct {
	// {
	//   "properties": {
	//     "weapons": {
	//       "description": "List of weapons and their perspective values.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalWeaponStats"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// List of weapons and their perspective values.
	Weapons []HistoricalWeaponStats `json:"weapons"`
}

// Destiny.HistoricalStats.DestinyLeaderboard
type Leaderboard struct {
	// {
	//   "properties": {
	//     "entries": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyLeaderboardEntry"
	//       },
	//       "type": "array"
	//     },
	//     "statId": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Entries []LeaderboardEntry `json:"entries"`

	StatID string `json:"statId"`
}

// Destiny.HistoricalStats.DestinyLeaderboardEntry
type LeaderboardEntry struct {
	// {
	//   "properties": {
	//     "characterId": {
	//       "description": "ID of the player's best character for the reported stat.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "player": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyPlayer"
	//         }
	//       ],
	//       "description": "Identity details of the player",
	//       "type": "object"
	//     },
	//     "rank": {
	//       "description": "Where this player ranks on the leaderboard. A value of 1 is the top rank.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "value": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValue"
	//         }
	//       ],
	//       "description": "Value of the stat for this player",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object"
	// }

	// ID of the player's best character for the reported stat.
	CharacterID Int64 `json:"characterId"`

	// Identity details of the player
	Player Player `json:"player"`

	// Where this player ranks on the leaderboard. A value of 1 is the top rank.
	Rank int32 `json:"rank"`

	// Value of the stat for this player
	Value HistoricalStatsValue `json:"value"`
}

// Destiny.HistoricalStats.DestinyLeaderboardResults
type LeaderboardResults struct {
	// {
	//   "additionalProperties": {
	//     "additionalProperties": {
	//       "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyLeaderboard"
	//     },
	//     "type": "object",
	//     "x-dictionary-key": {
	//       "type": "string"
	//     }
	//   },
	//   "properties": {
	//     "focusCharacterId": {
	//       "description": "Indicate the character ID of the character that is the focal point of the provided leaderboards. May be null, in which case any character from the focus membership can appear in the provided leaderboards.",
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "focusMembershipId": {
	//       "description": "Indicate the membership ID of the account that is the focal point of the provided leaderboards.",
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object",
	//   "x-dictionary-key": {
	//     "type": "string"
	//   }
	// }

	// Indicate the character ID of the character that is the focal point of the provided leaderboards. May
	// be null, in which case any character from the focus membership can appear in the provided
	// leaderboards.
	FocusCharacterID Nullable[Int64] `json:"focusCharacterId,omitempty"`

	// Indicate the membership ID of the account that is the focal point of the provided leaderboards.
	FocusMembershipID Nullable[Int64] `json:"focusMembershipId,omitempty"`
}

// Destiny.HistoricalStats.DestinyPlayer
type Player struct {
	// {
	//   "properties": {
	//     "bungieNetUserInfo": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/User.UserInfoCard"
	//         }
	//       ],
	//       "description": "Details about the player as they are known on BungieNet. This will be undefined if the player has marked their credential private, or does not have a BungieNet account.",
	//       "type": "object"
	//     },
	//     "characterClass": {
	//       "description": "Class of the character if applicable and available.",
	//       "type": "string"
	//     },
	//     "characterLevel": {
	//       "description": "Level of the character if available. Zero if it is not available.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "clanName": {
	//       "description": "Current clan name for the player. This value may be null or an empty string if the user does not have a clan.",
	//       "type": "string"
	//     },
	//     "clanTag": {
	//       "description": "Current clan tag for the player. This value may be null or an empty string if the user does not have a clan.",
	//       "type": "string"
	//     },
	//     "classHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyClassDefinition"
	//       }
	//     },
	//     "destinyUserInfo": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/User.UserInfoCard"
	//         }
	//       ],
	//       "description": "Details about the player as they are known in game (platform display name, Destiny emblem)",
	//       "type": "object"
	//     },
	//     "emblemHash": {
	//       "description": "If we know the emblem's hash, this can be used to look up the player's emblem at the time of a match when receiving PGCR data, or otherwise their currently equipped emblem (if we are able to obtain it).",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "genderHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyGenderDefinition"
	//       }
	//     },
	//     "lightLevel": {
	//       "description": "Light Level of the character if available. Zero if it is not available.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "raceHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyRaceDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// Details about the player as they are known on BungieNet. This will be undefined if the player has
	// marked their credential private, or does not have a BungieNet account.
	BungieNetUserInfo UserInfoCard `json:"bungieNetUserInfo"`

	// Class of the character if applicable and available.
	CharacterClass string `json:"characterClass"`

	// Level of the character if available. Zero if it is not available.
	CharacterLevel int32 `json:"characterLevel"`

	// Current clan name for the player. This value may be null or an empty string if the user does not
	// have a clan.
	ClanName string `json:"clanName"`

	// Current clan tag for the player. This value may be null or an empty string if the user does not have
	// a clan.
	ClanTag string `json:"clanTag"`

	ClassHash Hash[ClassDefinition] `json:"classHash"`

	// Details about the player as they are known in game (platform display name, Destiny emblem)
	DestinyUserInfo UserInfoCard `json:"destinyUserInfo"`

	// If we know the emblem's hash, this can be used to look up the player's emblem at the time of a match
	// when receiving PGCR data, or otherwise their currently equipped emblem (if we are able to obtain
	// it).
	EmblemHash Hash[InventoryItemDefinition] `json:"emblemHash"`

	GenderHash Hash[GenderDefinition] `json:"genderHash"`

	// Light Level of the character if available. Zero if it is not available.
	LightLevel int32 `json:"lightLevel"`

	RaceHash Hash[RaceDefinition] `json:"raceHash"`
}

// Destiny.HistoricalStats.DestinyPostGameCarnageReportData
type PostGameCarnageReportData struct {
	// {
	//   "properties": {
	//     "activityDetails": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsActivity"
	//         }
	//       ],
	//       "description": "Details about the activity.",
	//       "type": "object"
	//     },
	//     "activityWasStartedFromBeginning": {
	//       "description": "True if the activity was started from the beginning, if that information is available and the activity was played post Witch Queen release.",
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "entries": {
	//       "description": "Collection of players and their data for this activity.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyPostGameCarnageReportEntry"
	//       },
	//       "type": "array"
	//     },
	//     "period": {
	//       "description": "Date and time for the activity.",
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "startingPhaseIndex": {
	//       "description": "If this activity has \"phases\", this is the phase at which the activity was started. This value is only valid for activities before the Beyond Light expansion shipped. Subsequent activities will not have a valid value here.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "teams": {
	//       "description": "Collection of stats for the player in this activity.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyPostGameCarnageReportTeamEntry"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// Details about the activity.
	ActivityDetails HistoricalStatsActivity `json:"activityDetails"`

	// True if the activity was started from the beginning, if that information is available and the
	// activity was played post Witch Queen release.
	ActivityWasStartedFromBeginning Nullable[bool] `json:"activityWasStartedFromBeginning,omitempty"`

	// Collection of players and their data for this activity.
	Entries []PostGameCarnageReportEntry `json:"entries"`

	// Date and time for the activity.
	Period Timestamp `json:"period"`

	// If this activity has "phases", this is the phase at which the activity was started. This value is
	// only valid for activities before the Beyond Light expansion shipped. Subsequent activities will not
	// have a valid value here.
	StartingPhaseIndex Nullable[int32] `json:"startingPhaseIndex,omitempty"`

	// Collection of stats for the player in this activity.
	Teams []PostGameCarnageReportTeamEntry `json:"teams"`
}

// Destiny.HistoricalStats.DestinyPostGameCarnageReportEntry
type PostGameCarnageReportEntry struct {
	// {
	//   "properties": {
	//     "characterId": {
	//       "description": "ID of the player's character used in the activity.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "extended": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyPostGameCarnageReportExtendedData"
	//         }
	//       ],
	//       "description": "Extended data extracted from the activity blob.",
	//       "type": "object"
	//     },
	//     "player": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyPlayer"
	//         }
	//       ],
	//       "description": "Identity details of the player",
	//       "type": "object"
	//     },
	//     "score": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValue"
	//         }
	//       ],
	//       "description": "Score of the player if available",
	//       "type": "object"
	//     },
	//     "standing": {
	//       "description": "Standing of the player",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "values": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValue"
	//       },
	//       "description": "Collection of stats for the player in this activity.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// ID of the player's character used in the activity.
	CharacterID Int64 `json:"characterId"`

	// Extended data extracted from the activity blob.
	Extended PostGameCarnageReportExtendedData `json:"extended"`

	// Identity details of the player
	Player Player `json:"player"`

	// Score of the player if available
	Score HistoricalStatsValue `json:"score"`

	// Standing of the player
	Standing int32 `json:"standing"`

	// Collection of stats for the player in this activity.
	Values map[string]HistoricalStatsValue `json:"values"`
}

// Destiny.HistoricalStats.DestinyPostGameCarnageReportExtendedData
type PostGameCarnageReportExtendedData struct {
	// {
	//   "properties": {
	//     "values": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValue"
	//       },
	//       "description": "Collection of stats for the player in this activity.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "weapons": {
	//       "description": "List of weapons and their perspective values.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalWeaponStats"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// Collection of stats for the player in this activity.
	Values map[string]HistoricalStatsValue `json:"values"`

	// List of weapons and their perspective values.
	Weapons []HistoricalWeaponStats `json:"weapons"`
}

// Destiny.HistoricalStats.DestinyPostGameCarnageReportTeamEntry
type PostGameCarnageReportTeamEntry struct {
	// {
	//   "properties": {
	//     "score": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValue"
	//         }
	//       ],
	//       "description": "Score earned by the team",
	//       "type": "object"
	//     },
	//     "standing": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.HistoricalStats.DestinyHistoricalStatsValue"
	//         }
	//       ],
	//       "description": "Team's standing relative to other teams.",
	//       "type": "object"
	//     },
	//     "teamId": {
	//       "description": "Integer ID for the team.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "teamName": {
	//       "description": "Alpha or Bravo",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// Score earned by the team
	Score HistoricalStatsValue `json:"score"`

	// Team's standing relative to other teams.
	Standing HistoricalStatsValue `json:"standing"`

	// Integer ID for the team.
	TeamID int32 `json:"teamId"`

	// Alpha or Bravo
	TeamName string `json:"teamName"`
}

// Destiny.ItemBindStatus
type ItemBindStatus int32

const (
	ItemBindStatus_NotBound         = ItemBindStatus(0)
	ItemBindStatus_BoundToCharacter = ItemBindStatus(1)
	ItemBindStatus_BoundToAccount   = ItemBindStatus(2)
	ItemBindStatus_BoundToGuild     = ItemBindStatus(3)
)

// Destiny.ItemLocation
type ItemLocation int32

const (
	ItemLocation_Unknown    = ItemLocation(0)
	ItemLocation_Inventory  = ItemLocation(1)
	ItemLocation_Vault      = ItemLocation(2)
	ItemLocation_Vendor     = ItemLocation(3)
	ItemLocation_Postmaster = ItemLocation(4)
)

// Destiny.ItemPerkVisibility
//
// Indicates how a perk should be shown, or if it should be, in the game UI. Maybe useful for those of
// you trying to filter out internal-use-only perks (or for those of you trying to figure out what they
// do!)
type ItemPerkVisibility int32

const (
	ItemPerkVisibility_Visible  = ItemPerkVisibility(0)
	ItemPerkVisibility_Disabled = ItemPerkVisibility(1)
	ItemPerkVisibility_Hidden   = ItemPerkVisibility(2)
)

// Destiny.ItemState
//
// A flags enumeration/bitmask where each bit represents a different possible state that the item can
// be in that may effect how the item is displayed to the user and what actions can be performed
// against it.
type ItemState int32

const (
	ItemState_None                 = ItemState(0)
	ItemState_Locked               = ItemState(1)
	ItemState_Tracked              = ItemState(2)
	ItemState_Masterwork           = ItemState(4)
	ItemState_Crafted              = ItemState(8)
	ItemState_HighlightedObjective = ItemState(16)
)

// Destiny.Milestones.DestinyMilestone
//
// Represents a runtime instance of a user's milestone status. Live Milestone data should be combined
// with DestinyMilestoneDefinition data to show the user a picture of what is available for them to do
// in the game, and their status in regards to said "things to do." Consider it a big, wonky to-do
// list, or Advisors 3.0 for those who remember the Destiny 1 API.
type Milestone struct {
	// {
	//   "description": "Represents a runtime instance of a user's milestone status. Live Milestone data should be combined with DestinyMilestoneDefinition data to show the user a picture of what is available for them to do in the game, and their status in regards to said \"things to do.\" Consider it a big, wonky to-do list, or Advisors 3.0 for those who remember the Destiny 1 API.",
	//   "properties": {
	//     "activities": {
	//       "description": "The currently active Activities in this milestone, when the Milestone is driven by Challenges.\r\nNot all Milestones have Challenges, but when they do this will indicate the Activities and Challenges under those Activities related to this Milestone.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Milestones.DestinyMilestoneChallengeActivity"
	//       },
	//       "type": "array"
	//     },
	//     "availableQuests": {
	//       "description": "Indicates what quests are available for this Milestone. Usually this will be only a single Quest, but some quests have multiple available that you can choose from at any given time. All possible quests for a milestone can be found in the DestinyMilestoneDefinition, but they must be combined with this Live data to determine which one(s) are actually active right now. It is possible for Milestones to not have any quests.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Milestones.DestinyMilestoneQuest"
	//       },
	//       "type": "array"
	//     },
	//     "endDate": {
	//       "description": "If known, this is the date when the event will next end or repeat. It will only be populated for events with fixed and repeating start and end dates.",
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "milestoneHash": {
	//       "description": "The unique identifier for the Milestone. Use it to look up the DestinyMilestoneDefinition, so you can combine the other data in this contract with static definition data.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneDefinition"
	//       }
	//     },
	//     "order": {
	//       "description": "Used for ordering milestones in a display to match how we order them in BNet. May pull from static data, or possibly in the future from dynamic information.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "rewards": {
	//       "description": "If the entity to which this component is attached has known active Rewards for the player, this will detail information about those rewards, keyed by the RewardEntry Hash. (See DestinyMilestoneDefinition for more information about Reward Entries) Note that these rewards are not for the Quests related to the Milestone. Think of these as \"overview/checklist\" rewards that may be provided for Milestones that may provide rewards for performing a variety of tasks that aren't under a specific Quest.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Milestones.DestinyMilestoneRewardCategory"
	//       },
	//       "type": "array"
	//     },
	//     "startDate": {
	//       "description": "If known, this is the date when the event last began or refreshed. It will only be populated for events with fixed and repeating start and end dates.",
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "values": {
	//       "additionalProperties": {
	//         "format": "float",
	//         "type": "number"
	//       },
	//       "description": "Milestones may have arbitrary key/value pairs associated with them, for data that users will want to know about but that doesn't fit neatly into any of the common components such as Quests. A good example of this would be - if this existed in Destiny 1 - the number of wins you currently have on your Trials of Osiris ticket. Looking in the DestinyMilestoneDefinition, you can use the string identifier of this dictionary to look up more info about the value, including localized string content for displaying the value. The value in the dictionary is the floating point number. The definition will tell you how to format this number.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "vendorHashes": {
	//       "description": "A milestone may have one or more active vendors that are \"related\" to it (that provide rewards, or that are the initiators of the Milestone). I already regret this, even as I'm typing it. [I told you I'd regret this] You see, sometimes a milestone may be directly correlated with a set of vendors that provide varying tiers of rewards. The player may not be able to interact with one or more of those vendors. This will return the hashes of the Vendors that the player *can* interact with, allowing you to show their current inventory as rewards or related items to the Milestone or its activities.\r\nBefore we even use it, it's already deprecated! How much of a bummer is that? We need more data.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     },
	//     "vendors": {
	//       "description": "Replaces vendorHashes, which I knew was going to be trouble the day it walked in the door. This will return not only what Vendors are active and relevant to the activity (in an implied order that you can choose to ignore), but also other data - for example, if the Vendor is featuring a specific item relevant to this event that you should show with them.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Milestones.DestinyMilestoneVendor"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The currently active Activities in this milestone, when the Milestone is driven by Challenges.
	// Not all Milestones have Challenges, but when they do this will indicate the Activities and
	// Challenges under those Activities related to this Milestone.
	Activities []MilestoneChallengeActivity `json:"activities"`

	// Indicates what quests are available for this Milestone. Usually this will be only a single Quest,
	// but some quests have multiple available that you can choose from at any given time. All possible
	// quests for a milestone can be found in the DestinyMilestoneDefinition, but they must be combined
	// with this Live data to determine which one(s) are actually active right now. It is possible for
	// Milestones to not have any quests.
	AvailableQuests []MilestoneQuest `json:"availableQuests"`

	// If known, this is the date when the event will next end or repeat. It will only be populated for
	// events with fixed and repeating start and end dates.
	EndDate Nullable[Timestamp] `json:"endDate,omitempty"`

	// The unique identifier for the Milestone. Use it to look up the DestinyMilestoneDefinition, so you
	// can combine the other data in this contract with static definition data.
	MilestoneHash Hash[MilestoneDefinition] `json:"milestoneHash"`

	// Used for ordering milestones in a display to match how we order them in BNet. May pull from static
	// data, or possibly in the future from dynamic information.
	Order int32 `json:"order"`

	// If the entity to which this component is attached has known active Rewards for the player, this will
	// detail information about those rewards, keyed by the RewardEntry Hash. (See
	// DestinyMilestoneDefinition for more information about Reward Entries) Note that these rewards are
	// not for the Quests related to the Milestone. Think of these as "overview/checklist" rewards that may
	// be provided for Milestones that may provide rewards for performing a variety of tasks that aren't
	// under a specific Quest.
	Rewards []MilestoneRewardCategory `json:"rewards"`

	// If known, this is the date when the event last began or refreshed. It will only be populated for
	// events with fixed and repeating start and end dates.
	StartDate Nullable[Timestamp] `json:"startDate,omitempty"`

	// Milestones may have arbitrary key/value pairs associated with them, for data that users will want to
	// know about but that doesn't fit neatly into any of the common components such as Quests. A good
	// example of this would be - if this existed in Destiny 1 - the number of wins you currently have on
	// your Trials of Osiris ticket. Looking in the DestinyMilestoneDefinition, you can use the string
	// identifier of this dictionary to look up more info about the value, including localized string
	// content for displaying the value. The value in the dictionary is the floating point number. The
	// definition will tell you how to format this number.
	Values map[string]float64 `json:"values"`

	// A milestone may have one or more active vendors that are "related" to it (that provide rewards, or
	// that are the initiators of the Milestone). I already regret this, even as I'm typing it. [I told you
	// I'd regret this] You see, sometimes a milestone may be directly correlated with a set of vendors
	// that provide varying tiers of rewards. The player may not be able to interact with one or more of
	// those vendors. This will return the hashes of the Vendors that the player *can* interact with,
	// allowing you to show their current inventory as rewards or related items to the Milestone or its
	// activities.
	// Before we even use it, it's already deprecated! How much of a bummer is that? We need more data.
	VendorHashes []uint32 `json:"vendorHashes"`

	// Replaces vendorHashes, which I knew was going to be trouble the day it walked in the door. This will
	// return not only what Vendors are active and relevant to the activity (in an implied order that you
	// can choose to ignore), but also other data - for example, if the Vendor is featuring a specific item
	// relevant to this event that you should show with them.
	Vendors []MilestoneVendor `json:"vendors"`
}

// Destiny.Milestones.DestinyMilestoneActivity
//
// Sometimes, we know the specific activity that the Milestone wants you to play. This entity provides
// additional information about that Activity and all of its variants. (sometimes there's only one
// variant, but I think you get the point)
type MilestoneActivity struct {
	// {
	//   "description": "Sometimes, we know the specific activity that the Milestone wants you to play. This entity provides additional information about that Activity and all of its variants. (sometimes there's only one variant, but I think you get the point)",
	//   "properties": {
	//     "activityHash": {
	//       "description": "The hash of an arbitrarily chosen variant of this activity. We'll go ahead and call that the \"canonical\" activity, because if you're using this value you should only use it for properties that are common across the variants: things like the name of the activity, it's location, etc... Use this hash to look up the DestinyActivityDefinition of this activity for rendering data.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "activityModeHash": {
	//       "description": "The hash identifier of the most specific Activity Mode under which this activity is played. This is useful for situations where the activity in question is - for instance - a PVP map, but it's not clear what mode the PVP map is being played under. If it's a playlist, this will be less specific: but hopefully useful in some way.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityModeDefinition"
	//       }
	//     },
	//     "activityModeType": {
	//       "description": "The enumeration equivalent of the most specific Activity Mode under which this activity is played.",
	//       "enum": [
	//         "0",
	//         "2",
	//         "3",
	//         "4",
	//         "5",
	//         "6",
	//         "7",
	//         "9",
	//         "10",
	//         "11",
	//         "12",
	//         "13",
	//         "15",
	//         "16",
	//         "17",
	//         "18",
	//         "19",
	//         "20",
	//         "21",
	//         "22",
	//         "24",
	//         "25",
	//         "26",
	//         "27",
	//         "28",
	//         "29",
	//         "30",
	//         "31",
	//         "32",
	//         "37",
	//         "38",
	//         "39",
	//         "40",
	//         "41",
	//         "42",
	//         "43",
	//         "44",
	//         "45",
	//         "46",
	//         "47",
	//         "48",
	//         "49",
	//         "50",
	//         "51",
	//         "52",
	//         "53",
	//         "54",
	//         "55",
	//         "56",
	//         "57",
	//         "58",
	//         "59",
	//         "60",
	//         "61",
	//         "62",
	//         "63",
	//         "64",
	//         "65",
	//         "66",
	//         "67",
	//         "68",
	//         "69",
	//         "70",
	//         "71",
	//         "72",
	//         "73",
	//         "74",
	//         "75",
	//         "76",
	//         "77",
	//         "78",
	//         "79",
	//         "80",
	//         "81",
	//         "82",
	//         "83",
	//         "84",
	//         "85",
	//         "86",
	//         "87",
	//         "88",
	//         "89",
	//         "90",
	//         "91",
	//         "92"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "None",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Story",
	//           "numericValue": "2"
	//         },
	//         {
	//           "identifier": "Strike",
	//           "numericValue": "3"
	//         },
	//         {
	//           "identifier": "Raid",
	//           "numericValue": "4"
	//         },
	//         {
	//           "identifier": "AllPvP",
	//           "numericValue": "5"
	//         },
	//         {
	//           "identifier": "Patrol",
	//           "numericValue": "6"
	//         },
	//         {
	//           "identifier": "AllPvE",
	//           "numericValue": "7"
	//         },
	//         {
	//           "identifier": "Reserved9",
	//           "numericValue": "9"
	//         },
	//         {
	//           "identifier": "Control",
	//           "numericValue": "10"
	//         },
	//         {
	//           "identifier": "Reserved11",
	//           "numericValue": "11"
	//         },
	//         {
	//           "description": "Clash -\u003e Destiny's name for Team Deathmatch. 4v4 combat, the team with the highest kills at the end of time wins.",
	//           "identifier": "Clash",
	//           "numericValue": "12"
	//         },
	//         {
	//           "identifier": "Reserved13",
	//           "numericValue": "13"
	//         },
	//         {
	//           "identifier": "CrimsonDoubles",
	//           "numericValue": "15"
	//         },
	//         {
	//           "identifier": "Nightfall",
	//           "numericValue": "16"
	//         },
	//         {
	//           "identifier": "HeroicNightfall",
	//           "numericValue": "17"
	//         },
	//         {
	//           "identifier": "AllStrikes",
	//           "numericValue": "18"
	//         },
	//         {
	//           "identifier": "IronBanner",
	//           "numericValue": "19"
	//         },
	//         {
	//           "identifier": "Reserved20",
	//           "numericValue": "20"
	//         },
	//         {
	//           "identifier": "Reserved21",
	//           "numericValue": "21"
	//         },
	//         {
	//           "identifier": "Reserved22",
	//           "numericValue": "22"
	//         },
	//         {
	//           "identifier": "Reserved24",
	//           "numericValue": "24"
	//         },
	//         {
	//           "identifier": "AllMayhem",
	//           "numericValue": "25"
	//         },
	//         {
	//           "identifier": "Reserved26",
	//           "numericValue": "26"
	//         },
	//         {
	//           "identifier": "Reserved27",
	//           "numericValue": "27"
	//         },
	//         {
	//           "identifier": "Reserved28",
	//           "numericValue": "28"
	//         },
	//         {
	//           "identifier": "Reserved29",
	//           "numericValue": "29"
	//         },
	//         {
	//           "identifier": "Reserved30",
	//           "numericValue": "30"
	//         },
	//         {
	//           "identifier": "Supremacy",
	//           "numericValue": "31"
	//         },
	//         {
	//           "identifier": "PrivateMatchesAll",
	//           "numericValue": "32"
	//         },
	//         {
	//           "identifier": "Survival",
	//           "numericValue": "37"
	//         },
	//         {
	//           "identifier": "Countdown",
	//           "numericValue": "38"
	//         },
	//         {
	//           "identifier": "TrialsOfTheNine",
	//           "numericValue": "39"
	//         },
	//         {
	//           "identifier": "Social",
	//           "numericValue": "40"
	//         },
	//         {
	//           "identifier": "TrialsCountdown",
	//           "numericValue": "41"
	//         },
	//         {
	//           "identifier": "TrialsSurvival",
	//           "numericValue": "42"
	//         },
	//         {
	//           "identifier": "IronBannerControl",
	//           "numericValue": "43"
	//         },
	//         {
	//           "identifier": "IronBannerClash",
	//           "numericValue": "44"
	//         },
	//         {
	//           "identifier": "IronBannerSupremacy",
	//           "numericValue": "45"
	//         },
	//         {
	//           "identifier": "ScoredNightfall",
	//           "numericValue": "46"
	//         },
	//         {
	//           "identifier": "ScoredHeroicNightfall",
	//           "numericValue": "47"
	//         },
	//         {
	//           "identifier": "Rumble",
	//           "numericValue": "48"
	//         },
	//         {
	//           "identifier": "AllDoubles",
	//           "numericValue": "49"
	//         },
	//         {
	//           "identifier": "Doubles",
	//           "numericValue": "50"
	//         },
	//         {
	//           "identifier": "PrivateMatchesClash",
	//           "numericValue": "51"
	//         },
	//         {
	//           "identifier": "PrivateMatchesControl",
	//           "numericValue": "52"
	//         },
	//         {
	//           "identifier": "PrivateMatchesSupremacy",
	//           "numericValue": "53"
	//         },
	//         {
	//           "identifier": "PrivateMatchesCountdown",
	//           "numericValue": "54"
	//         },
	//         {
	//           "identifier": "PrivateMatchesSurvival",
	//           "numericValue": "55"
	//         },
	//         {
	//           "identifier": "PrivateMatchesMayhem",
	//           "numericValue": "56"
	//         },
	//         {
	//           "identifier": "PrivateMatchesRumble",
	//           "numericValue": "57"
	//         },
	//         {
	//           "identifier": "HeroicAdventure",
	//           "numericValue": "58"
	//         },
	//         {
	//           "identifier": "Showdown",
	//           "numericValue": "59"
	//         },
	//         {
	//           "identifier": "Lockdown",
	//           "numericValue": "60"
	//         },
	//         {
	//           "identifier": "Scorched",
	//           "numericValue": "61"
	//         },
	//         {
	//           "identifier": "ScorchedTeam",
	//           "numericValue": "62"
	//         },
	//         {
	//           "identifier": "Gambit",
	//           "numericValue": "63"
	//         },
	//         {
	//           "identifier": "AllPvECompetitive",
	//           "numericValue": "64"
	//         },
	//         {
	//           "identifier": "Breakthrough",
	//           "numericValue": "65"
	//         },
	//         {
	//           "identifier": "BlackArmoryRun",
	//           "numericValue": "66"
	//         },
	//         {
	//           "identifier": "Salvage",
	//           "numericValue": "67"
	//         },
	//         {
	//           "identifier": "IronBannerSalvage",
	//           "numericValue": "68"
	//         },
	//         {
	//           "identifier": "PvPCompetitive",
	//           "numericValue": "69"
	//         },
	//         {
	//           "identifier": "PvPQuickplay",
	//           "numericValue": "70"
	//         },
	//         {
	//           "identifier": "ClashQuickplay",
	//           "numericValue": "71"
	//         },
	//         {
	//           "identifier": "ClashCompetitive",
	//           "numericValue": "72"
	//         },
	//         {
	//           "identifier": "ControlQuickplay",
	//           "numericValue": "73"
	//         },
	//         {
	//           "identifier": "ControlCompetitive",
	//           "numericValue": "74"
	//         },
	//         {
	//           "identifier": "GambitPrime",
	//           "numericValue": "75"
	//         },
	//         {
	//           "identifier": "Reckoning",
	//           "numericValue": "76"
	//         },
	//         {
	//           "identifier": "Menagerie",
	//           "numericValue": "77"
	//         },
	//         {
	//           "identifier": "VexOffensive",
	//           "numericValue": "78"
	//         },
	//         {
	//           "identifier": "NightmareHunt",
	//           "numericValue": "79"
	//         },
	//         {
	//           "identifier": "Elimination",
	//           "numericValue": "80"
	//         },
	//         {
	//           "identifier": "Momentum",
	//           "numericValue": "81"
	//         },
	//         {
	//           "identifier": "Dungeon",
	//           "numericValue": "82"
	//         },
	//         {
	//           "identifier": "Sundial",
	//           "numericValue": "83"
	//         },
	//         {
	//           "identifier": "TrialsOfOsiris",
	//           "numericValue": "84"
	//         },
	//         {
	//           "identifier": "Dares",
	//           "numericValue": "85"
	//         },
	//         {
	//           "identifier": "Offensive",
	//           "numericValue": "86"
	//         },
	//         {
	//           "identifier": "LostSector",
	//           "numericValue": "87"
	//         },
	//         {
	//           "identifier": "Rift",
	//           "numericValue": "88"
	//         },
	//         {
	//           "identifier": "ZoneControl",
	//           "numericValue": "89"
	//         },
	//         {
	//           "identifier": "IronBannerRift",
	//           "numericValue": "90"
	//         },
	//         {
	//           "identifier": "IronBannerZoneControl",
	//           "numericValue": "91"
	//         },
	//         {
	//           "identifier": "Relic",
	//           "numericValue": "92"
	//         }
	//       ]
	//     },
	//     "modifierHashes": {
	//       "description": "If the activity has modifiers, this will be the list of modifiers that all variants have in common. Perform lookups against DestinyActivityModifierDefinition which defines the modifier being applied to get at the modifier data. Note that, in the DestiyActivityDefinition, you will see many more modifiers than this being referred to: those are all *possible* modifiers for the activity, not the active ones. Use only the active ones to match what's really live.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.ActivityModifiers.DestinyActivityModifierDefinition"
	//       }
	//     },
	//     "variants": {
	//       "description": "If you want more than just name/location/etc... you're going to have to dig into and show the variants of the conceptual activity. These will differ in seemingly arbitrary ways, like difficulty level and modifiers applied. Show it in whatever way tickles your fancy.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Milestones.DestinyMilestoneActivityVariant"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash of an arbitrarily chosen variant of this activity. We'll go ahead and call that the
	// "canonical" activity, because if you're using this value you should only use it for properties that
	// are common across the variants: things like the name of the activity, it's location, etc... Use this
	// hash to look up the DestinyActivityDefinition of this activity for rendering data.
	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`

	// The hash identifier of the most specific Activity Mode under which this activity is played. This is
	// useful for situations where the activity in question is - for instance - a PVP map, but it's not
	// clear what mode the PVP map is being played under. If it's a playlist, this will be less specific:
	// but hopefully useful in some way.
	ActivityModeHash Nullable[Hash[ActivityModeDefinition]] `json:"activityModeHash,omitempty"`

	// The enumeration equivalent of the most specific Activity Mode under which this activity is played.
	ActivityModeType Nullable[int32] `json:"activityModeType,omitempty"`

	// If the activity has modifiers, this will be the list of modifiers that all variants have in common.
	// Perform lookups against DestinyActivityModifierDefinition which defines the modifier being applied
	// to get at the modifier data. Note that, in the DestiyActivityDefinition, you will see many more
	// modifiers than this being referred to: those are all *possible* modifiers for the activity, not the
	// active ones. Use only the active ones to match what's really live.
	ModifierHashes []uint32 `json:"modifierHashes"`

	// If you want more than just name/location/etc... you're going to have to dig into and show the
	// variants of the conceptual activity. These will differ in seemingly arbitrary ways, like difficulty
	// level and modifiers applied. Show it in whatever way tickles your fancy.
	Variants []MilestoneActivityVariant `json:"variants"`
}

// Destiny.Milestones.DestinyMilestoneActivityCompletionStatus
//
// Represents this player's personal completion status for the Activity under a Milestone, if the
// activity has trackable completion and progress information. (most activities won't, or the concept
// won't apply. For instance, it makes sense to talk about a tier of a raid as being Completed or
// having progress, but it doesn't make sense to talk about a Crucible Playlist in those terms.
type MilestoneActivityCompletionStatus struct {
	// {
	//   "description": "Represents this player's personal completion status for the Activity under a Milestone, if the activity has trackable completion and progress information. (most activities won't, or the concept won't apply. For instance, it makes sense to talk about a tier of a raid as being Completed or having progress, but it doesn't make sense to talk about a Crucible Playlist in those terms.",
	//   "properties": {
	//     "completed": {
	//       "description": "If the activity has been \"completed\", that information will be returned here.",
	//       "type": "boolean"
	//     },
	//     "phases": {
	//       "description": "If the Activity has discrete \"phases\" that we can track, that info will be here. Otherwise, this value will be NULL. Note that this is a list and not a dictionary: the order implies the ascending order of phases or progression in this activity.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Milestones.DestinyMilestoneActivityPhase"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// If the activity has been "completed", that information will be returned here.
	Completed bool `json:"completed"`

	// If the Activity has discrete "phases" that we can track, that info will be here. Otherwise, this
	// value will be NULL. Note that this is a list and not a dictionary: the order implies the ascending
	// order of phases or progression in this activity.
	Phases []MilestoneActivityPhase `json:"phases"`
}

// Destiny.Milestones.DestinyMilestoneActivityPhase
//
// Represents whatever information we can return about an explicit phase in an activity. In the future,
// I hope we'll have more than just "guh, you done gone and did something," but for the forseeable
// future that's all we've got. I'm making it more than just a list of booleans out of that
// overly-optimistic hope.
type MilestoneActivityPhase struct {
	// {
	//   "description": "Represents whatever information we can return about an explicit phase in an activity. In the future, I hope we'll have more than just \"guh, you done gone and did something,\" but for the forseeable future that's all we've got. I'm making it more than just a list of booleans out of that overly-optimistic hope.",
	//   "properties": {
	//     "complete": {
	//       "description": "Indicates if the phase has been completed.",
	//       "type": "boolean"
	//     },
	//     "phaseHash": {
	//       "description": "In DestinyActivityDefinition, if the activity has phases, there will be a set of phases defined in the \"insertionPoints\" property. This is the hash that maps to that phase.",
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// Indicates if the phase has been completed.
	Complete bool `json:"complete"`

	// In DestinyActivityDefinition, if the activity has phases, there will be a set of phases defined in
	// the "insertionPoints" property. This is the hash that maps to that phase.
	PhaseHash uint32 `json:"phaseHash"`
}

// Destiny.Milestones.DestinyMilestoneActivityVariant
//
// Represents custom data that we know about an individual variant of an activity.
type MilestoneActivityVariant struct {
	// {
	//   "description": "Represents custom data that we know about an individual variant of an activity.",
	//   "properties": {
	//     "activityHash": {
	//       "description": "The hash for the specific variant of the activity related to this milestone. You can pull more detailed static info from the DestinyActivityDefinition, such as difficulty level.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "activityModeHash": {
	//       "description": "The hash identifier of the most specific Activity Mode under which this activity is played. This is useful for situations where the activity in question is - for instance - a PVP map, but it's not clear what mode the PVP map is being played under. If it's a playlist, this will be less specific: but hopefully useful in some way.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityModeDefinition"
	//       }
	//     },
	//     "activityModeType": {
	//       "description": "The enumeration equivalent of the most specific Activity Mode under which this activity is played.",
	//       "enum": [
	//         "0",
	//         "2",
	//         "3",
	//         "4",
	//         "5",
	//         "6",
	//         "7",
	//         "9",
	//         "10",
	//         "11",
	//         "12",
	//         "13",
	//         "15",
	//         "16",
	//         "17",
	//         "18",
	//         "19",
	//         "20",
	//         "21",
	//         "22",
	//         "24",
	//         "25",
	//         "26",
	//         "27",
	//         "28",
	//         "29",
	//         "30",
	//         "31",
	//         "32",
	//         "37",
	//         "38",
	//         "39",
	//         "40",
	//         "41",
	//         "42",
	//         "43",
	//         "44",
	//         "45",
	//         "46",
	//         "47",
	//         "48",
	//         "49",
	//         "50",
	//         "51",
	//         "52",
	//         "53",
	//         "54",
	//         "55",
	//         "56",
	//         "57",
	//         "58",
	//         "59",
	//         "60",
	//         "61",
	//         "62",
	//         "63",
	//         "64",
	//         "65",
	//         "66",
	//         "67",
	//         "68",
	//         "69",
	//         "70",
	//         "71",
	//         "72",
	//         "73",
	//         "74",
	//         "75",
	//         "76",
	//         "77",
	//         "78",
	//         "79",
	//         "80",
	//         "81",
	//         "82",
	//         "83",
	//         "84",
	//         "85",
	//         "86",
	//         "87",
	//         "88",
	//         "89",
	//         "90",
	//         "91",
	//         "92"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "None",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Story",
	//           "numericValue": "2"
	//         },
	//         {
	//           "identifier": "Strike",
	//           "numericValue": "3"
	//         },
	//         {
	//           "identifier": "Raid",
	//           "numericValue": "4"
	//         },
	//         {
	//           "identifier": "AllPvP",
	//           "numericValue": "5"
	//         },
	//         {
	//           "identifier": "Patrol",
	//           "numericValue": "6"
	//         },
	//         {
	//           "identifier": "AllPvE",
	//           "numericValue": "7"
	//         },
	//         {
	//           "identifier": "Reserved9",
	//           "numericValue": "9"
	//         },
	//         {
	//           "identifier": "Control",
	//           "numericValue": "10"
	//         },
	//         {
	//           "identifier": "Reserved11",
	//           "numericValue": "11"
	//         },
	//         {
	//           "description": "Clash -\u003e Destiny's name for Team Deathmatch. 4v4 combat, the team with the highest kills at the end of time wins.",
	//           "identifier": "Clash",
	//           "numericValue": "12"
	//         },
	//         {
	//           "identifier": "Reserved13",
	//           "numericValue": "13"
	//         },
	//         {
	//           "identifier": "CrimsonDoubles",
	//           "numericValue": "15"
	//         },
	//         {
	//           "identifier": "Nightfall",
	//           "numericValue": "16"
	//         },
	//         {
	//           "identifier": "HeroicNightfall",
	//           "numericValue": "17"
	//         },
	//         {
	//           "identifier": "AllStrikes",
	//           "numericValue": "18"
	//         },
	//         {
	//           "identifier": "IronBanner",
	//           "numericValue": "19"
	//         },
	//         {
	//           "identifier": "Reserved20",
	//           "numericValue": "20"
	//         },
	//         {
	//           "identifier": "Reserved21",
	//           "numericValue": "21"
	//         },
	//         {
	//           "identifier": "Reserved22",
	//           "numericValue": "22"
	//         },
	//         {
	//           "identifier": "Reserved24",
	//           "numericValue": "24"
	//         },
	//         {
	//           "identifier": "AllMayhem",
	//           "numericValue": "25"
	//         },
	//         {
	//           "identifier": "Reserved26",
	//           "numericValue": "26"
	//         },
	//         {
	//           "identifier": "Reserved27",
	//           "numericValue": "27"
	//         },
	//         {
	//           "identifier": "Reserved28",
	//           "numericValue": "28"
	//         },
	//         {
	//           "identifier": "Reserved29",
	//           "numericValue": "29"
	//         },
	//         {
	//           "identifier": "Reserved30",
	//           "numericValue": "30"
	//         },
	//         {
	//           "identifier": "Supremacy",
	//           "numericValue": "31"
	//         },
	//         {
	//           "identifier": "PrivateMatchesAll",
	//           "numericValue": "32"
	//         },
	//         {
	//           "identifier": "Survival",
	//           "numericValue": "37"
	//         },
	//         {
	//           "identifier": "Countdown",
	//           "numericValue": "38"
	//         },
	//         {
	//           "identifier": "TrialsOfTheNine",
	//           "numericValue": "39"
	//         },
	//         {
	//           "identifier": "Social",
	//           "numericValue": "40"
	//         },
	//         {
	//           "identifier": "TrialsCountdown",
	//           "numericValue": "41"
	//         },
	//         {
	//           "identifier": "TrialsSurvival",
	//           "numericValue": "42"
	//         },
	//         {
	//           "identifier": "IronBannerControl",
	//           "numericValue": "43"
	//         },
	//         {
	//           "identifier": "IronBannerClash",
	//           "numericValue": "44"
	//         },
	//         {
	//           "identifier": "IronBannerSupremacy",
	//           "numericValue": "45"
	//         },
	//         {
	//           "identifier": "ScoredNightfall",
	//           "numericValue": "46"
	//         },
	//         {
	//           "identifier": "ScoredHeroicNightfall",
	//           "numericValue": "47"
	//         },
	//         {
	//           "identifier": "Rumble",
	//           "numericValue": "48"
	//         },
	//         {
	//           "identifier": "AllDoubles",
	//           "numericValue": "49"
	//         },
	//         {
	//           "identifier": "Doubles",
	//           "numericValue": "50"
	//         },
	//         {
	//           "identifier": "PrivateMatchesClash",
	//           "numericValue": "51"
	//         },
	//         {
	//           "identifier": "PrivateMatchesControl",
	//           "numericValue": "52"
	//         },
	//         {
	//           "identifier": "PrivateMatchesSupremacy",
	//           "numericValue": "53"
	//         },
	//         {
	//           "identifier": "PrivateMatchesCountdown",
	//           "numericValue": "54"
	//         },
	//         {
	//           "identifier": "PrivateMatchesSurvival",
	//           "numericValue": "55"
	//         },
	//         {
	//           "identifier": "PrivateMatchesMayhem",
	//           "numericValue": "56"
	//         },
	//         {
	//           "identifier": "PrivateMatchesRumble",
	//           "numericValue": "57"
	//         },
	//         {
	//           "identifier": "HeroicAdventure",
	//           "numericValue": "58"
	//         },
	//         {
	//           "identifier": "Showdown",
	//           "numericValue": "59"
	//         },
	//         {
	//           "identifier": "Lockdown",
	//           "numericValue": "60"
	//         },
	//         {
	//           "identifier": "Scorched",
	//           "numericValue": "61"
	//         },
	//         {
	//           "identifier": "ScorchedTeam",
	//           "numericValue": "62"
	//         },
	//         {
	//           "identifier": "Gambit",
	//           "numericValue": "63"
	//         },
	//         {
	//           "identifier": "AllPvECompetitive",
	//           "numericValue": "64"
	//         },
	//         {
	//           "identifier": "Breakthrough",
	//           "numericValue": "65"
	//         },
	//         {
	//           "identifier": "BlackArmoryRun",
	//           "numericValue": "66"
	//         },
	//         {
	//           "identifier": "Salvage",
	//           "numericValue": "67"
	//         },
	//         {
	//           "identifier": "IronBannerSalvage",
	//           "numericValue": "68"
	//         },
	//         {
	//           "identifier": "PvPCompetitive",
	//           "numericValue": "69"
	//         },
	//         {
	//           "identifier": "PvPQuickplay",
	//           "numericValue": "70"
	//         },
	//         {
	//           "identifier": "ClashQuickplay",
	//           "numericValue": "71"
	//         },
	//         {
	//           "identifier": "ClashCompetitive",
	//           "numericValue": "72"
	//         },
	//         {
	//           "identifier": "ControlQuickplay",
	//           "numericValue": "73"
	//         },
	//         {
	//           "identifier": "ControlCompetitive",
	//           "numericValue": "74"
	//         },
	//         {
	//           "identifier": "GambitPrime",
	//           "numericValue": "75"
	//         },
	//         {
	//           "identifier": "Reckoning",
	//           "numericValue": "76"
	//         },
	//         {
	//           "identifier": "Menagerie",
	//           "numericValue": "77"
	//         },
	//         {
	//           "identifier": "VexOffensive",
	//           "numericValue": "78"
	//         },
	//         {
	//           "identifier": "NightmareHunt",
	//           "numericValue": "79"
	//         },
	//         {
	//           "identifier": "Elimination",
	//           "numericValue": "80"
	//         },
	//         {
	//           "identifier": "Momentum",
	//           "numericValue": "81"
	//         },
	//         {
	//           "identifier": "Dungeon",
	//           "numericValue": "82"
	//         },
	//         {
	//           "identifier": "Sundial",
	//           "numericValue": "83"
	//         },
	//         {
	//           "identifier": "TrialsOfOsiris",
	//           "numericValue": "84"
	//         },
	//         {
	//           "identifier": "Dares",
	//           "numericValue": "85"
	//         },
	//         {
	//           "identifier": "Offensive",
	//           "numericValue": "86"
	//         },
	//         {
	//           "identifier": "LostSector",
	//           "numericValue": "87"
	//         },
	//         {
	//           "identifier": "Rift",
	//           "numericValue": "88"
	//         },
	//         {
	//           "identifier": "ZoneControl",
	//           "numericValue": "89"
	//         },
	//         {
	//           "identifier": "IronBannerRift",
	//           "numericValue": "90"
	//         },
	//         {
	//           "identifier": "IronBannerZoneControl",
	//           "numericValue": "91"
	//         },
	//         {
	//           "identifier": "Relic",
	//           "numericValue": "92"
	//         }
	//       ]
	//     },
	//     "completionStatus": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Milestones.DestinyMilestoneActivityCompletionStatus"
	//         }
	//       ],
	//       "description": "An OPTIONAL component: if it makes sense to talk about this activity variant in terms of whether or not it has been completed or what progress you have made in it, this will be returned. Otherwise, this will be NULL.",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash for the specific variant of the activity related to this milestone. You can pull more
	// detailed static info from the DestinyActivityDefinition, such as difficulty level.
	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`

	// The hash identifier of the most specific Activity Mode under which this activity is played. This is
	// useful for situations where the activity in question is - for instance - a PVP map, but it's not
	// clear what mode the PVP map is being played under. If it's a playlist, this will be less specific:
	// but hopefully useful in some way.
	ActivityModeHash Nullable[Hash[ActivityModeDefinition]] `json:"activityModeHash,omitempty"`

	// The enumeration equivalent of the most specific Activity Mode under which this activity is played.
	ActivityModeType Nullable[int32] `json:"activityModeType,omitempty"`

	// An OPTIONAL component: if it makes sense to talk about this activity variant in terms of whether or
	// not it has been completed or what progress you have made in it, this will be returned. Otherwise,
	// this will be NULL.
	CompletionStatus MilestoneActivityCompletionStatus `json:"completionStatus"`
}

// Destiny.Milestones.DestinyMilestoneChallengeActivity
type MilestoneChallengeActivity struct {
	// {
	//   "properties": {
	//     "activityHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "booleanActivityOptions": {
	//       "additionalProperties": {
	//         "type": "boolean"
	//       },
	//       "description": "The set of activity options for this activity, keyed by an identifier that's unique for this activity (not guaranteed to be unique between or across all activities, though should be unique for every *variant* of a given *conceptual* activity: for instance, the original D2 Raid has many variant DestinyActivityDefinitions. While other activities could potentially have the same option hashes, for any given D2 base Raid variant the hash will be unique).\r\nAs a concrete example of this data, the hashes you get for Raids will correspond to the currently active \"Challenge Mode\".\r\nWe don't have any human readable information for these, but saavy 3rd party app users could manually associate the key (a hash identifier for the \"option\" that is enabled/disabled) and the value (whether it's enabled or disabled presently)\r\nOn our side, we don't necessarily even know what these are used for (the game designers know, but we don't), and we have no human readable data for them. In order to use them, you will have to do some experimentation.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "challenges": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Challenges.DestinyChallengeStatus"
	//       },
	//       "type": "array"
	//     },
	//     "loadoutRequirementIndex": {
	//       "description": "If returned, this is the index into the DestinyActivityDefinition's \"loadouts\" property, indicating the currently active loadout requirements.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "modifierHashes": {
	//       "description": "If the activity has modifiers, this will be the list of modifiers that all variants have in common. Perform lookups against DestinyActivityModifierDefinition which defines the modifier being applied to get at the modifier data.\r\nNote that, in the DestiyActivityDefinition, you will see many more modifiers than this being referred to: those are all *possible* modifiers for the activity, not the active ones. Use only the active ones to match what's really live.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.ActivityModifiers.DestinyActivityModifierDefinition"
	//       }
	//     },
	//     "phases": {
	//       "description": "If the Activity has discrete \"phases\" that we can track, that info will be here. Otherwise, this value will be NULL. Note that this is a list and not a dictionary: the order implies the ascending order of phases or progression in this activity.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Milestones.DestinyMilestoneActivityPhase"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`

	// The set of activity options for this activity, keyed by an identifier that's unique for this
	// activity (not guaranteed to be unique between or across all activities, though should be unique for
	// every *variant* of a given *conceptual* activity: for instance, the original D2 Raid has many
	// variant DestinyActivityDefinitions. While other activities could potentially have the same option
	// hashes, for any given D2 base Raid variant the hash will be unique).
	// As a concrete example of this data, the hashes you get for Raids will correspond to the currently
	// active "Challenge Mode".
	// We don't have any human readable information for these, but saavy 3rd party app users could manually
	// associate the key (a hash identifier for the "option" that is enabled/disabled) and the value
	// (whether it's enabled or disabled presently)
	// On our side, we don't necessarily even know what these are used for (the game designers know, but we
	// don't), and we have no human readable data for them. In order to use them, you will have to do some
	// experimentation.
	BooleanActivityOptions map[uint32]bool `json:"booleanActivityOptions"`

	Challenges []ChallengeStatus `json:"challenges"`

	// If returned, this is the index into the DestinyActivityDefinition's "loadouts" property, indicating
	// the currently active loadout requirements.
	LoadoutRequirementIndex Nullable[int32] `json:"loadoutRequirementIndex,omitempty"`

	// If the activity has modifiers, this will be the list of modifiers that all variants have in common.
	// Perform lookups against DestinyActivityModifierDefinition which defines the modifier being applied
	// to get at the modifier data.
	// Note that, in the DestiyActivityDefinition, you will see many more modifiers than this being
	// referred to: those are all *possible* modifiers for the activity, not the active ones. Use only the
	// active ones to match what's really live.
	ModifierHashes []uint32 `json:"modifierHashes"`

	// If the Activity has discrete "phases" that we can track, that info will be here. Otherwise, this
	// value will be NULL. Note that this is a list and not a dictionary: the order implies the ascending
	// order of phases or progression in this activity.
	Phases []MilestoneActivityPhase `json:"phases"`
}

// Destiny.Milestones.DestinyMilestoneContent
//
// Represents localized, extended content related to Milestones. This is intentionally returned by a
// separate endpoint and not with Character-level Milestone data because we do not put localized data
// into standard Destiny responses, both for brevity of response and for caching purposes. If you
// really need this data, hit the Milestone Content endpoint.
type MilestoneContent struct {
	// {
	//   "description": "Represents localized, extended content related to Milestones. This is intentionally returned by a separate endpoint and not with Character-level Milestone data because we do not put localized data into standard Destiny responses, both for brevity of response and for caching purposes. If you really need this data, hit the Milestone Content endpoint.",
	//   "properties": {
	//     "about": {
	//       "description": "The \"About this Milestone\" text from the Firehose.",
	//       "type": "string"
	//     },
	//     "itemCategories": {
	//       "description": "If DPS has defined items related to this Milestone, they can categorize those items in the Firehose. That data will then be returned as item categories here.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Milestones.DestinyMilestoneContentItemCategory"
	//       },
	//       "type": "array"
	//     },
	//     "status": {
	//       "description": "The Current Status of the Milestone, as driven by the Firehose.",
	//       "type": "string"
	//     },
	//     "tips": {
	//       "description": "A list of tips, provided by the Firehose.",
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The "About this Milestone" text from the Firehose.
	About string `json:"about"`

	// If DPS has defined items related to this Milestone, they can categorize those items in the Firehose.
	// That data will then be returned as item categories here.
	ItemCategories []MilestoneContentItemCategory `json:"itemCategories"`

	// The Current Status of the Milestone, as driven by the Firehose.
	Status string `json:"status"`

	// A list of tips, provided by the Firehose.
	Tips []string `json:"tips"`
}

// Destiny.Milestones.DestinyMilestoneContentItemCategory
//
// Part of our dynamic, localized Milestone content is arbitrary categories of items. These are built
// in our content management system, and thus aren't the same as programmatically generated rewards.
type MilestoneContentItemCategory struct {
	// {
	//   "description": "Part of our dynamic, localized Milestone content is arbitrary categories of items. These are built in our content management system, and thus aren't the same as programmatically generated rewards.",
	//   "properties": {
	//     "itemHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "title": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	ItemHashes []uint32 `json:"itemHashes"`

	Title string `json:"title"`
}

// Destiny.Milestones.DestinyMilestoneQuest
//
// If a Milestone has one or more Quests, this will contain the live information for the character's
// status with one of those quests.
type MilestoneQuest struct {
	// {
	//   "description": "If a Milestone has one or more Quests, this will contain the live information for the character's status with one of those quests.",
	//   "properties": {
	//     "activity": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Milestones.DestinyMilestoneActivity"
	//         }
	//       ],
	//       "description": "*IF* the Milestone has an active Activity that can give you greater details about what you need to do, it will be returned here. Remember to associate this with the DestinyMilestoneDefinition's activities to get details about the activity, including what specific quest it is related to if you have multiple quests to choose from.",
	//       "type": "object"
	//     },
	//     "challenges": {
	//       "description": "The activities referred to by this quest can have many associated challenges. They are all contained here, with activityHashes so that you can associate them with the specific activity variants in which they can be found. In retrospect, I probably should have put these under the specific Activity Variants, but it's too late to change it now. Theoretically, a quest without Activities can still have Challenges, which is why this is on a higher level than activity/variants, but it probably should have been in both places. That may come as a later revision.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Challenges.DestinyChallengeStatus"
	//       },
	//       "type": "array"
	//     },
	//     "questItemHash": {
	//       "description": "Quests are defined as Items in content. As such, this is the hash identifier of the DestinyInventoryItemDefinition that represents this quest. It will have pointers to all of the steps in the quest, and display information for the quest (title, description, icon etc) Individual steps will be referred to in the Quest item's DestinyInventoryItemDefinition.setData property, and themselves are Items with their own renderable data.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "status": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Quests.DestinyQuestStatus"
	//         }
	//       ],
	//       "description": "The current status of the quest for the character making the request.",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object"
	// }

	// *IF* the Milestone has an active Activity that can give you greater details about what you need to
	// do, it will be returned here. Remember to associate this with the DestinyMilestoneDefinition's
	// activities to get details about the activity, including what specific quest it is related to if you
	// have multiple quests to choose from.
	Activity MilestoneActivity `json:"activity"`

	// The activities referred to by this quest can have many associated challenges. They are all contained
	// here, with activityHashes so that you can associate them with the specific activity variants in
	// which they can be found. In retrospect, I probably should have put these under the specific Activity
	// Variants, but it's too late to change it now. Theoretically, a quest without Activities can still
	// have Challenges, which is why this is on a higher level than activity/variants, but it probably
	// should have been in both places. That may come as a later revision.
	Challenges []ChallengeStatus `json:"challenges"`

	// Quests are defined as Items in content. As such, this is the hash identifier of the
	// DestinyInventoryItemDefinition that represents this quest. It will have pointers to all of the steps
	// in the quest, and display information for the quest (title, description, icon etc) Individual steps
	// will be referred to in the Quest item's DestinyInventoryItemDefinition.setData property, and
	// themselves are Items with their own renderable data.
	QuestItemHash Hash[InventoryItemDefinition] `json:"questItemHash"`

	// The current status of the quest for the character making the request.
	Status QuestStatus `json:"status"`
}

// Destiny.Milestones.DestinyMilestoneRewardCategory
//
// Represents a category of "summary" rewards that can be earned for the Milestone regardless of
// specific quest rewards that can be earned.
type MilestoneRewardCategory struct {
	// {
	//   "description": "Represents a category of \"summary\" rewards that can be earned for the Milestone regardless of specific quest rewards that can be earned.",
	//   "properties": {
	//     "entries": {
	//       "description": "The individual reward entries for this category, and their status.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Milestones.DestinyMilestoneRewardEntry"
	//       },
	//       "type": "array"
	//     },
	//     "rewardCategoryHash": {
	//       "description": "Look up the relevant DestinyMilestoneDefinition, and then use rewardCategoryHash to look up the category info in DestinyMilestoneDefinition.rewards.",
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// The individual reward entries for this category, and their status.
	Entries []MilestoneRewardEntry `json:"entries"`

	// Look up the relevant DestinyMilestoneDefinition, and then use rewardCategoryHash to look up the
	// category info in DestinyMilestoneDefinition.rewards.
	RewardCategoryHash uint32 `json:"rewardCategoryHash"`
}

// Destiny.Milestones.DestinyMilestoneRewardEntry
//
// The character-specific data for a milestone's reward entry. See DestinyMilestoneDefinition for more
// information about Reward Entries.
type MilestoneRewardEntry struct {
	// {
	//   "description": "The character-specific data for a milestone's reward entry. See DestinyMilestoneDefinition for more information about Reward Entries.",
	//   "properties": {
	//     "earned": {
	//       "description": "If TRUE, the player has earned this reward.",
	//       "type": "boolean"
	//     },
	//     "redeemed": {
	//       "description": "If TRUE, the player has redeemed/picked up/obtained this reward. Feel free to alias this to \"gotTheShinyBauble\" in your own codebase.",
	//       "type": "boolean"
	//     },
	//     "rewardEntryHash": {
	//       "description": "The identifier for the reward entry in question. It is important to look up the related DestinyMilestoneRewardEntryDefinition to get the static details about the reward, which you can do by looking up the milestone's DestinyMilestoneDefinition and examining the DestinyMilestoneDefinition.rewards[rewardCategoryHash].rewardEntries[rewardEntryHash] data.",
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// If TRUE, the player has earned this reward.
	Earned bool `json:"earned"`

	// If TRUE, the player has redeemed/picked up/obtained this reward. Feel free to alias this to
	// "gotTheShinyBauble" in your own codebase.
	Redeemed bool `json:"redeemed"`

	// The identifier for the reward entry in question. It is important to look up the related
	// DestinyMilestoneRewardEntryDefinition to get the static details about the reward, which you can do
	// by looking up the milestone's DestinyMilestoneDefinition and examining the
	// DestinyMilestoneDefinition.rewards[rewardCategoryHash].rewardEntries[rewardEntryHash] data.
	RewardEntryHash uint32 `json:"rewardEntryHash"`
}

// Destiny.Milestones.DestinyMilestoneVendor
//
// If a Milestone has one or more Vendors that are relevant to it, this will contain information about
// that vendor that you can choose to show.
type MilestoneVendor struct {
	// {
	//   "description": "If a Milestone has one or more Vendors that are relevant to it, this will contain information about that vendor that you can choose to show.",
	//   "properties": {
	//     "previewItemHash": {
	//       "description": "If this vendor is featuring a specific item for this event, this will be the hash identifier of that item. I'm taking bets now on how long we go before this needs to be a list or some other, more complex representation instead and I deprecate this too. I'm going to go with 5 months. Calling it now, 2017-09-14 at 9:46pm PST.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "vendorHash": {
	//       "description": "The hash identifier of the Vendor related to this Milestone. You can show useful things from this, such as thier Faction icon or whatever you might care about.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// If this vendor is featuring a specific item for this event, this will be the hash identifier of that
	// item. I'm taking bets now on how long we go before this needs to be a list or some other, more
	// complex representation instead and I deprecate this too. I'm going to go with 5 months. Calling it
	// now, 2017-09-14 at 9:46pm PST.
	PreviewItemHash Nullable[Hash[InventoryItemDefinition]] `json:"previewItemHash,omitempty"`

	// The hash identifier of the Vendor related to this Milestone. You can show useful things from this,
	// such as thier Faction icon or whatever you might care about.
	VendorHash Hash[VendorDefinition] `json:"vendorHash"`
}

// Destiny.Milestones.DestinyPublicMilestone
//
// Information about milestones, presented in a character state-agnostic manner. Combine this data with
// DestinyMilestoneDefinition to get a full picture of the milestone, which is basically a checklist of
// things to do in the game. Think of this as GetPublicAdvisors 3.0, for those who used the Destiny 1
// API.
type PublicMilestone struct {
	// {
	//   "description": "Information about milestones, presented in a character state-agnostic manner. Combine this data with DestinyMilestoneDefinition to get a full picture of the milestone, which is basically a checklist of things to do in the game. Think of this as GetPublicAdvisors 3.0, for those who used the Destiny 1 API.",
	//   "properties": {
	//     "activities": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Milestones.DestinyPublicMilestoneChallengeActivity"
	//       },
	//       "type": "array"
	//     },
	//     "availableQuests": {
	//       "description": "A milestone not need have even a single quest, but if there are active quests they will be returned here.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Milestones.DestinyPublicMilestoneQuest"
	//       },
	//       "type": "array"
	//     },
	//     "endDate": {
	//       "description": "If known, this is the date when the Milestone will expire/recycle/end.",
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "milestoneHash": {
	//       "description": "The hash identifier for the milestone. Use it to look up the DestinyMilestoneDefinition for static data about the Milestone.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneDefinition"
	//       }
	//     },
	//     "order": {
	//       "description": "Used for ordering milestones in a display to match how we order them in BNet. May pull from static data, or possibly in the future from dynamic information.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "startDate": {
	//       "description": "If known, this is the date when the Milestone started/became active.",
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "vendorHashes": {
	//       "description": "Sometimes milestones - or activities active in milestones - will have relevant vendors. These are the vendors that are currently relevant.\r\nDeprecated, already, for the sake of the new \"vendors\" property that has more data. What was I thinking.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "vendors": {
	//       "description": "This is why we can't have nice things. This is the ordered list of vendors to be shown that relate to this milestone, potentially along with other interesting data.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Milestones.DestinyPublicMilestoneVendor"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	Activities []PublicMilestoneChallengeActivity `json:"activities"`

	// A milestone not need have even a single quest, but if there are active quests they will be returned
	// here.
	AvailableQuests []PublicMilestoneQuest `json:"availableQuests"`

	// If known, this is the date when the Milestone will expire/recycle/end.
	EndDate Nullable[Timestamp] `json:"endDate,omitempty"`

	// The hash identifier for the milestone. Use it to look up the DestinyMilestoneDefinition for static
	// data about the Milestone.
	MilestoneHash Hash[MilestoneDefinition] `json:"milestoneHash"`

	// Used for ordering milestones in a display to match how we order them in BNet. May pull from static
	// data, or possibly in the future from dynamic information.
	Order int32 `json:"order"`

	// If known, this is the date when the Milestone started/became active.
	StartDate Nullable[Timestamp] `json:"startDate,omitempty"`

	// Sometimes milestones - or activities active in milestones - will have relevant vendors. These are
	// the vendors that are currently relevant.
	// Deprecated, already, for the sake of the new "vendors" property that has more data. What was I
	// thinking.
	VendorHashes []uint32 `json:"vendorHashes"`

	// This is why we can't have nice things. This is the ordered list of vendors to be shown that relate
	// to this milestone, potentially along with other interesting data.
	Vendors []PublicMilestoneVendor `json:"vendors"`
}

// Destiny.Milestones.DestinyPublicMilestoneActivity
//
// A milestone may have one or more conceptual Activities associated with it, and each of those
// conceptual activities could have a variety of variants, modes, tiers, what-have-you. Our attempts to
// determine what qualifies as a conceptual activity are, unfortunately, janky. So if you see missing
// modes or modes that don't seem appropriate to you, let us know and I'll buy you a beer if we ever
// meet up in person.
type PublicMilestoneActivity struct {
	// {
	//   "description": "A milestone may have one or more conceptual Activities associated with it, and each of those conceptual activities could have a variety of variants, modes, tiers, what-have-you. Our attempts to determine what qualifies as a conceptual activity are, unfortunately, janky. So if you see missing modes or modes that don't seem appropriate to you, let us know and I'll buy you a beer if we ever meet up in person.",
	//   "properties": {
	//     "activityHash": {
	//       "description": "The hash identifier of the activity that's been chosen to be considered the canonical \"conceptual\" activity definition. This may have many variants, defined herein.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "activityModeHash": {
	//       "description": "The hash identifier of the most specific Activity Mode under which this activity is played. This is useful for situations where the activity in question is - for instance - a PVP map, but it's not clear what mode the PVP map is being played under. If it's a playlist, this will be less specific: but hopefully useful in some way.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityModeDefinition"
	//       }
	//     },
	//     "activityModeType": {
	//       "description": "The enumeration equivalent of the most specific Activity Mode under which this activity is played.",
	//       "enum": [
	//         "0",
	//         "2",
	//         "3",
	//         "4",
	//         "5",
	//         "6",
	//         "7",
	//         "9",
	//         "10",
	//         "11",
	//         "12",
	//         "13",
	//         "15",
	//         "16",
	//         "17",
	//         "18",
	//         "19",
	//         "20",
	//         "21",
	//         "22",
	//         "24",
	//         "25",
	//         "26",
	//         "27",
	//         "28",
	//         "29",
	//         "30",
	//         "31",
	//         "32",
	//         "37",
	//         "38",
	//         "39",
	//         "40",
	//         "41",
	//         "42",
	//         "43",
	//         "44",
	//         "45",
	//         "46",
	//         "47",
	//         "48",
	//         "49",
	//         "50",
	//         "51",
	//         "52",
	//         "53",
	//         "54",
	//         "55",
	//         "56",
	//         "57",
	//         "58",
	//         "59",
	//         "60",
	//         "61",
	//         "62",
	//         "63",
	//         "64",
	//         "65",
	//         "66",
	//         "67",
	//         "68",
	//         "69",
	//         "70",
	//         "71",
	//         "72",
	//         "73",
	//         "74",
	//         "75",
	//         "76",
	//         "77",
	//         "78",
	//         "79",
	//         "80",
	//         "81",
	//         "82",
	//         "83",
	//         "84",
	//         "85",
	//         "86",
	//         "87",
	//         "88",
	//         "89",
	//         "90",
	//         "91",
	//         "92"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "None",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Story",
	//           "numericValue": "2"
	//         },
	//         {
	//           "identifier": "Strike",
	//           "numericValue": "3"
	//         },
	//         {
	//           "identifier": "Raid",
	//           "numericValue": "4"
	//         },
	//         {
	//           "identifier": "AllPvP",
	//           "numericValue": "5"
	//         },
	//         {
	//           "identifier": "Patrol",
	//           "numericValue": "6"
	//         },
	//         {
	//           "identifier": "AllPvE",
	//           "numericValue": "7"
	//         },
	//         {
	//           "identifier": "Reserved9",
	//           "numericValue": "9"
	//         },
	//         {
	//           "identifier": "Control",
	//           "numericValue": "10"
	//         },
	//         {
	//           "identifier": "Reserved11",
	//           "numericValue": "11"
	//         },
	//         {
	//           "description": "Clash -\u003e Destiny's name for Team Deathmatch. 4v4 combat, the team with the highest kills at the end of time wins.",
	//           "identifier": "Clash",
	//           "numericValue": "12"
	//         },
	//         {
	//           "identifier": "Reserved13",
	//           "numericValue": "13"
	//         },
	//         {
	//           "identifier": "CrimsonDoubles",
	//           "numericValue": "15"
	//         },
	//         {
	//           "identifier": "Nightfall",
	//           "numericValue": "16"
	//         },
	//         {
	//           "identifier": "HeroicNightfall",
	//           "numericValue": "17"
	//         },
	//         {
	//           "identifier": "AllStrikes",
	//           "numericValue": "18"
	//         },
	//         {
	//           "identifier": "IronBanner",
	//           "numericValue": "19"
	//         },
	//         {
	//           "identifier": "Reserved20",
	//           "numericValue": "20"
	//         },
	//         {
	//           "identifier": "Reserved21",
	//           "numericValue": "21"
	//         },
	//         {
	//           "identifier": "Reserved22",
	//           "numericValue": "22"
	//         },
	//         {
	//           "identifier": "Reserved24",
	//           "numericValue": "24"
	//         },
	//         {
	//           "identifier": "AllMayhem",
	//           "numericValue": "25"
	//         },
	//         {
	//           "identifier": "Reserved26",
	//           "numericValue": "26"
	//         },
	//         {
	//           "identifier": "Reserved27",
	//           "numericValue": "27"
	//         },
	//         {
	//           "identifier": "Reserved28",
	//           "numericValue": "28"
	//         },
	//         {
	//           "identifier": "Reserved29",
	//           "numericValue": "29"
	//         },
	//         {
	//           "identifier": "Reserved30",
	//           "numericValue": "30"
	//         },
	//         {
	//           "identifier": "Supremacy",
	//           "numericValue": "31"
	//         },
	//         {
	//           "identifier": "PrivateMatchesAll",
	//           "numericValue": "32"
	//         },
	//         {
	//           "identifier": "Survival",
	//           "numericValue": "37"
	//         },
	//         {
	//           "identifier": "Countdown",
	//           "numericValue": "38"
	//         },
	//         {
	//           "identifier": "TrialsOfTheNine",
	//           "numericValue": "39"
	//         },
	//         {
	//           "identifier": "Social",
	//           "numericValue": "40"
	//         },
	//         {
	//           "identifier": "TrialsCountdown",
	//           "numericValue": "41"
	//         },
	//         {
	//           "identifier": "TrialsSurvival",
	//           "numericValue": "42"
	//         },
	//         {
	//           "identifier": "IronBannerControl",
	//           "numericValue": "43"
	//         },
	//         {
	//           "identifier": "IronBannerClash",
	//           "numericValue": "44"
	//         },
	//         {
	//           "identifier": "IronBannerSupremacy",
	//           "numericValue": "45"
	//         },
	//         {
	//           "identifier": "ScoredNightfall",
	//           "numericValue": "46"
	//         },
	//         {
	//           "identifier": "ScoredHeroicNightfall",
	//           "numericValue": "47"
	//         },
	//         {
	//           "identifier": "Rumble",
	//           "numericValue": "48"
	//         },
	//         {
	//           "identifier": "AllDoubles",
	//           "numericValue": "49"
	//         },
	//         {
	//           "identifier": "Doubles",
	//           "numericValue": "50"
	//         },
	//         {
	//           "identifier": "PrivateMatchesClash",
	//           "numericValue": "51"
	//         },
	//         {
	//           "identifier": "PrivateMatchesControl",
	//           "numericValue": "52"
	//         },
	//         {
	//           "identifier": "PrivateMatchesSupremacy",
	//           "numericValue": "53"
	//         },
	//         {
	//           "identifier": "PrivateMatchesCountdown",
	//           "numericValue": "54"
	//         },
	//         {
	//           "identifier": "PrivateMatchesSurvival",
	//           "numericValue": "55"
	//         },
	//         {
	//           "identifier": "PrivateMatchesMayhem",
	//           "numericValue": "56"
	//         },
	//         {
	//           "identifier": "PrivateMatchesRumble",
	//           "numericValue": "57"
	//         },
	//         {
	//           "identifier": "HeroicAdventure",
	//           "numericValue": "58"
	//         },
	//         {
	//           "identifier": "Showdown",
	//           "numericValue": "59"
	//         },
	//         {
	//           "identifier": "Lockdown",
	//           "numericValue": "60"
	//         },
	//         {
	//           "identifier": "Scorched",
	//           "numericValue": "61"
	//         },
	//         {
	//           "identifier": "ScorchedTeam",
	//           "numericValue": "62"
	//         },
	//         {
	//           "identifier": "Gambit",
	//           "numericValue": "63"
	//         },
	//         {
	//           "identifier": "AllPvECompetitive",
	//           "numericValue": "64"
	//         },
	//         {
	//           "identifier": "Breakthrough",
	//           "numericValue": "65"
	//         },
	//         {
	//           "identifier": "BlackArmoryRun",
	//           "numericValue": "66"
	//         },
	//         {
	//           "identifier": "Salvage",
	//           "numericValue": "67"
	//         },
	//         {
	//           "identifier": "IronBannerSalvage",
	//           "numericValue": "68"
	//         },
	//         {
	//           "identifier": "PvPCompetitive",
	//           "numericValue": "69"
	//         },
	//         {
	//           "identifier": "PvPQuickplay",
	//           "numericValue": "70"
	//         },
	//         {
	//           "identifier": "ClashQuickplay",
	//           "numericValue": "71"
	//         },
	//         {
	//           "identifier": "ClashCompetitive",
	//           "numericValue": "72"
	//         },
	//         {
	//           "identifier": "ControlQuickplay",
	//           "numericValue": "73"
	//         },
	//         {
	//           "identifier": "ControlCompetitive",
	//           "numericValue": "74"
	//         },
	//         {
	//           "identifier": "GambitPrime",
	//           "numericValue": "75"
	//         },
	//         {
	//           "identifier": "Reckoning",
	//           "numericValue": "76"
	//         },
	//         {
	//           "identifier": "Menagerie",
	//           "numericValue": "77"
	//         },
	//         {
	//           "identifier": "VexOffensive",
	//           "numericValue": "78"
	//         },
	//         {
	//           "identifier": "NightmareHunt",
	//           "numericValue": "79"
	//         },
	//         {
	//           "identifier": "Elimination",
	//           "numericValue": "80"
	//         },
	//         {
	//           "identifier": "Momentum",
	//           "numericValue": "81"
	//         },
	//         {
	//           "identifier": "Dungeon",
	//           "numericValue": "82"
	//         },
	//         {
	//           "identifier": "Sundial",
	//           "numericValue": "83"
	//         },
	//         {
	//           "identifier": "TrialsOfOsiris",
	//           "numericValue": "84"
	//         },
	//         {
	//           "identifier": "Dares",
	//           "numericValue": "85"
	//         },
	//         {
	//           "identifier": "Offensive",
	//           "numericValue": "86"
	//         },
	//         {
	//           "identifier": "LostSector",
	//           "numericValue": "87"
	//         },
	//         {
	//           "identifier": "Rift",
	//           "numericValue": "88"
	//         },
	//         {
	//           "identifier": "ZoneControl",
	//           "numericValue": "89"
	//         },
	//         {
	//           "identifier": "IronBannerRift",
	//           "numericValue": "90"
	//         },
	//         {
	//           "identifier": "IronBannerZoneControl",
	//           "numericValue": "91"
	//         },
	//         {
	//           "identifier": "Relic",
	//           "numericValue": "92"
	//         }
	//       ]
	//     },
	//     "modifierHashes": {
	//       "description": "The activity may have 0-to-many modifiers: if it does, this will contain the hashes to the DestinyActivityModifierDefinition that defines the modifier being applied.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.ActivityModifiers.DestinyActivityModifierDefinition"
	//       }
	//     },
	//     "variants": {
	//       "description": "Every relevant variation of this conceptual activity, including the conceptual activity itself, have variants defined here.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Milestones.DestinyPublicMilestoneActivityVariant"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash identifier of the activity that's been chosen to be considered the canonical "conceptual"
	// activity definition. This may have many variants, defined herein.
	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`

	// The hash identifier of the most specific Activity Mode under which this activity is played. This is
	// useful for situations where the activity in question is - for instance - a PVP map, but it's not
	// clear what mode the PVP map is being played under. If it's a playlist, this will be less specific:
	// but hopefully useful in some way.
	ActivityModeHash Nullable[Hash[ActivityModeDefinition]] `json:"activityModeHash,omitempty"`

	// The enumeration equivalent of the most specific Activity Mode under which this activity is played.
	ActivityModeType Nullable[int32] `json:"activityModeType,omitempty"`

	// The activity may have 0-to-many modifiers: if it does, this will contain the hashes to the
	// DestinyActivityModifierDefinition that defines the modifier being applied.
	ModifierHashes []uint32 `json:"modifierHashes"`

	// Every relevant variation of this conceptual activity, including the conceptual activity itself, have
	// variants defined here.
	Variants []PublicMilestoneActivityVariant `json:"variants"`
}

// Destiny.Milestones.DestinyPublicMilestoneActivityVariant
//
// Represents a variant of an activity that's relevant to a milestone.
type PublicMilestoneActivityVariant struct {
	// {
	//   "description": "Represents a variant of an activity that's relevant to a milestone.",
	//   "properties": {
	//     "activityHash": {
	//       "description": "The hash identifier of this activity variant. Examine the activity's definition in the Manifest database to determine what makes it a distinct variant. Usually it will be difficulty level or whether or not it is a guided game variant of the activity, but theoretically it could be distinguished in any arbitrary way.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "activityModeHash": {
	//       "description": "The hash identifier of the most specific Activity Mode under which this activity is played. This is useful for situations where the activity in question is - for instance - a PVP map, but it's not clear what mode the PVP map is being played under. If it's a playlist, this will be less specific: but hopefully useful in some way.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityModeDefinition"
	//       }
	//     },
	//     "activityModeType": {
	//       "description": "The enumeration equivalent of the most specific Activity Mode under which this activity is played.",
	//       "enum": [
	//         "0",
	//         "2",
	//         "3",
	//         "4",
	//         "5",
	//         "6",
	//         "7",
	//         "9",
	//         "10",
	//         "11",
	//         "12",
	//         "13",
	//         "15",
	//         "16",
	//         "17",
	//         "18",
	//         "19",
	//         "20",
	//         "21",
	//         "22",
	//         "24",
	//         "25",
	//         "26",
	//         "27",
	//         "28",
	//         "29",
	//         "30",
	//         "31",
	//         "32",
	//         "37",
	//         "38",
	//         "39",
	//         "40",
	//         "41",
	//         "42",
	//         "43",
	//         "44",
	//         "45",
	//         "46",
	//         "47",
	//         "48",
	//         "49",
	//         "50",
	//         "51",
	//         "52",
	//         "53",
	//         "54",
	//         "55",
	//         "56",
	//         "57",
	//         "58",
	//         "59",
	//         "60",
	//         "61",
	//         "62",
	//         "63",
	//         "64",
	//         "65",
	//         "66",
	//         "67",
	//         "68",
	//         "69",
	//         "70",
	//         "71",
	//         "72",
	//         "73",
	//         "74",
	//         "75",
	//         "76",
	//         "77",
	//         "78",
	//         "79",
	//         "80",
	//         "81",
	//         "82",
	//         "83",
	//         "84",
	//         "85",
	//         "86",
	//         "87",
	//         "88",
	//         "89",
	//         "90",
	//         "91",
	//         "92"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "None",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Story",
	//           "numericValue": "2"
	//         },
	//         {
	//           "identifier": "Strike",
	//           "numericValue": "3"
	//         },
	//         {
	//           "identifier": "Raid",
	//           "numericValue": "4"
	//         },
	//         {
	//           "identifier": "AllPvP",
	//           "numericValue": "5"
	//         },
	//         {
	//           "identifier": "Patrol",
	//           "numericValue": "6"
	//         },
	//         {
	//           "identifier": "AllPvE",
	//           "numericValue": "7"
	//         },
	//         {
	//           "identifier": "Reserved9",
	//           "numericValue": "9"
	//         },
	//         {
	//           "identifier": "Control",
	//           "numericValue": "10"
	//         },
	//         {
	//           "identifier": "Reserved11",
	//           "numericValue": "11"
	//         },
	//         {
	//           "description": "Clash -\u003e Destiny's name for Team Deathmatch. 4v4 combat, the team with the highest kills at the end of time wins.",
	//           "identifier": "Clash",
	//           "numericValue": "12"
	//         },
	//         {
	//           "identifier": "Reserved13",
	//           "numericValue": "13"
	//         },
	//         {
	//           "identifier": "CrimsonDoubles",
	//           "numericValue": "15"
	//         },
	//         {
	//           "identifier": "Nightfall",
	//           "numericValue": "16"
	//         },
	//         {
	//           "identifier": "HeroicNightfall",
	//           "numericValue": "17"
	//         },
	//         {
	//           "identifier": "AllStrikes",
	//           "numericValue": "18"
	//         },
	//         {
	//           "identifier": "IronBanner",
	//           "numericValue": "19"
	//         },
	//         {
	//           "identifier": "Reserved20",
	//           "numericValue": "20"
	//         },
	//         {
	//           "identifier": "Reserved21",
	//           "numericValue": "21"
	//         },
	//         {
	//           "identifier": "Reserved22",
	//           "numericValue": "22"
	//         },
	//         {
	//           "identifier": "Reserved24",
	//           "numericValue": "24"
	//         },
	//         {
	//           "identifier": "AllMayhem",
	//           "numericValue": "25"
	//         },
	//         {
	//           "identifier": "Reserved26",
	//           "numericValue": "26"
	//         },
	//         {
	//           "identifier": "Reserved27",
	//           "numericValue": "27"
	//         },
	//         {
	//           "identifier": "Reserved28",
	//           "numericValue": "28"
	//         },
	//         {
	//           "identifier": "Reserved29",
	//           "numericValue": "29"
	//         },
	//         {
	//           "identifier": "Reserved30",
	//           "numericValue": "30"
	//         },
	//         {
	//           "identifier": "Supremacy",
	//           "numericValue": "31"
	//         },
	//         {
	//           "identifier": "PrivateMatchesAll",
	//           "numericValue": "32"
	//         },
	//         {
	//           "identifier": "Survival",
	//           "numericValue": "37"
	//         },
	//         {
	//           "identifier": "Countdown",
	//           "numericValue": "38"
	//         },
	//         {
	//           "identifier": "TrialsOfTheNine",
	//           "numericValue": "39"
	//         },
	//         {
	//           "identifier": "Social",
	//           "numericValue": "40"
	//         },
	//         {
	//           "identifier": "TrialsCountdown",
	//           "numericValue": "41"
	//         },
	//         {
	//           "identifier": "TrialsSurvival",
	//           "numericValue": "42"
	//         },
	//         {
	//           "identifier": "IronBannerControl",
	//           "numericValue": "43"
	//         },
	//         {
	//           "identifier": "IronBannerClash",
	//           "numericValue": "44"
	//         },
	//         {
	//           "identifier": "IronBannerSupremacy",
	//           "numericValue": "45"
	//         },
	//         {
	//           "identifier": "ScoredNightfall",
	//           "numericValue": "46"
	//         },
	//         {
	//           "identifier": "ScoredHeroicNightfall",
	//           "numericValue": "47"
	//         },
	//         {
	//           "identifier": "Rumble",
	//           "numericValue": "48"
	//         },
	//         {
	//           "identifier": "AllDoubles",
	//           "numericValue": "49"
	//         },
	//         {
	//           "identifier": "Doubles",
	//           "numericValue": "50"
	//         },
	//         {
	//           "identifier": "PrivateMatchesClash",
	//           "numericValue": "51"
	//         },
	//         {
	//           "identifier": "PrivateMatchesControl",
	//           "numericValue": "52"
	//         },
	//         {
	//           "identifier": "PrivateMatchesSupremacy",
	//           "numericValue": "53"
	//         },
	//         {
	//           "identifier": "PrivateMatchesCountdown",
	//           "numericValue": "54"
	//         },
	//         {
	//           "identifier": "PrivateMatchesSurvival",
	//           "numericValue": "55"
	//         },
	//         {
	//           "identifier": "PrivateMatchesMayhem",
	//           "numericValue": "56"
	//         },
	//         {
	//           "identifier": "PrivateMatchesRumble",
	//           "numericValue": "57"
	//         },
	//         {
	//           "identifier": "HeroicAdventure",
	//           "numericValue": "58"
	//         },
	//         {
	//           "identifier": "Showdown",
	//           "numericValue": "59"
	//         },
	//         {
	//           "identifier": "Lockdown",
	//           "numericValue": "60"
	//         },
	//         {
	//           "identifier": "Scorched",
	//           "numericValue": "61"
	//         },
	//         {
	//           "identifier": "ScorchedTeam",
	//           "numericValue": "62"
	//         },
	//         {
	//           "identifier": "Gambit",
	//           "numericValue": "63"
	//         },
	//         {
	//           "identifier": "AllPvECompetitive",
	//           "numericValue": "64"
	//         },
	//         {
	//           "identifier": "Breakthrough",
	//           "numericValue": "65"
	//         },
	//         {
	//           "identifier": "BlackArmoryRun",
	//           "numericValue": "66"
	//         },
	//         {
	//           "identifier": "Salvage",
	//           "numericValue": "67"
	//         },
	//         {
	//           "identifier": "IronBannerSalvage",
	//           "numericValue": "68"
	//         },
	//         {
	//           "identifier": "PvPCompetitive",
	//           "numericValue": "69"
	//         },
	//         {
	//           "identifier": "PvPQuickplay",
	//           "numericValue": "70"
	//         },
	//         {
	//           "identifier": "ClashQuickplay",
	//           "numericValue": "71"
	//         },
	//         {
	//           "identifier": "ClashCompetitive",
	//           "numericValue": "72"
	//         },
	//         {
	//           "identifier": "ControlQuickplay",
	//           "numericValue": "73"
	//         },
	//         {
	//           "identifier": "ControlCompetitive",
	//           "numericValue": "74"
	//         },
	//         {
	//           "identifier": "GambitPrime",
	//           "numericValue": "75"
	//         },
	//         {
	//           "identifier": "Reckoning",
	//           "numericValue": "76"
	//         },
	//         {
	//           "identifier": "Menagerie",
	//           "numericValue": "77"
	//         },
	//         {
	//           "identifier": "VexOffensive",
	//           "numericValue": "78"
	//         },
	//         {
	//           "identifier": "NightmareHunt",
	//           "numericValue": "79"
	//         },
	//         {
	//           "identifier": "Elimination",
	//           "numericValue": "80"
	//         },
	//         {
	//           "identifier": "Momentum",
	//           "numericValue": "81"
	//         },
	//         {
	//           "identifier": "Dungeon",
	//           "numericValue": "82"
	//         },
	//         {
	//           "identifier": "Sundial",
	//           "numericValue": "83"
	//         },
	//         {
	//           "identifier": "TrialsOfOsiris",
	//           "numericValue": "84"
	//         },
	//         {
	//           "identifier": "Dares",
	//           "numericValue": "85"
	//         },
	//         {
	//           "identifier": "Offensive",
	//           "numericValue": "86"
	//         },
	//         {
	//           "identifier": "LostSector",
	//           "numericValue": "87"
	//         },
	//         {
	//           "identifier": "Rift",
	//           "numericValue": "88"
	//         },
	//         {
	//           "identifier": "ZoneControl",
	//           "numericValue": "89"
	//         },
	//         {
	//           "identifier": "IronBannerRift",
	//           "numericValue": "90"
	//         },
	//         {
	//           "identifier": "IronBannerZoneControl",
	//           "numericValue": "91"
	//         },
	//         {
	//           "identifier": "Relic",
	//           "numericValue": "92"
	//         }
	//       ]
	//     }
	//   },
	//   "type": "object"
	// }

	// The hash identifier of this activity variant. Examine the activity's definition in the Manifest
	// database to determine what makes it a distinct variant. Usually it will be difficulty level or
	// whether or not it is a guided game variant of the activity, but theoretically it could be
	// distinguished in any arbitrary way.
	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`

	// The hash identifier of the most specific Activity Mode under which this activity is played. This is
	// useful for situations where the activity in question is - for instance - a PVP map, but it's not
	// clear what mode the PVP map is being played under. If it's a playlist, this will be less specific:
	// but hopefully useful in some way.
	ActivityModeHash Nullable[Hash[ActivityModeDefinition]] `json:"activityModeHash,omitempty"`

	// The enumeration equivalent of the most specific Activity Mode under which this activity is played.
	ActivityModeType Nullable[int32] `json:"activityModeType,omitempty"`
}

// Destiny.Milestones.DestinyPublicMilestoneChallenge
//
// A Milestone can have many Challenges. Challenges are just extra Objectives that provide a fun way to
// mix-up play and provide extra rewards.
type PublicMilestoneChallenge struct {
	// {
	//   "description": "A Milestone can have many Challenges. Challenges are just extra Objectives that provide a fun way to mix-up play and provide extra rewards.",
	//   "properties": {
	//     "activityHash": {
	//       "description": "IF the Objective is related to a specific Activity, this will be that activity's hash. Use it to look up the DestinyActivityDefinition for additional data to show.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "objectiveHash": {
	//       "description": "The objective for the Challenge, which should have human-readable data about what needs to be done to accomplish the objective. Use this hash to look up the DestinyObjectiveDefinition.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectiveDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// IF the Objective is related to a specific Activity, this will be that activity's hash. Use it to
	// look up the DestinyActivityDefinition for additional data to show.
	ActivityHash Nullable[Hash[ActivityDefinition]] `json:"activityHash,omitempty"`

	// The objective for the Challenge, which should have human-readable data about what needs to be done
	// to accomplish the objective. Use this hash to look up the DestinyObjectiveDefinition.
	ObjectiveHash Hash[ObjectiveDefinition] `json:"objectiveHash"`
}

// Destiny.Milestones.DestinyPublicMilestoneChallengeActivity
type PublicMilestoneChallengeActivity struct {
	// {
	//   "properties": {
	//     "activityHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "booleanActivityOptions": {
	//       "additionalProperties": {
	//         "type": "boolean"
	//       },
	//       "description": "The set of activity options for this activity, keyed by an identifier that's unique for this activity (not guaranteed to be unique between or across all activities, though should be unique for every *variant* of a given *conceptual* activity: for instance, the original D2 Raid has many variant DestinyActivityDefinitions. While other activities could potentially have the same option hashes, for any given D2 base Raid variant the hash will be unique).\r\nAs a concrete example of this data, the hashes you get for Raids will correspond to the currently active \"Challenge Mode\".\r\nWe have no human readable information for this data, so it's up to you if you want to associate it with such info to show it.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "challengeObjectiveHashes": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "loadoutRequirementIndex": {
	//       "description": "If returned, this is the index into the DestinyActivityDefinition's \"loadouts\" property, indicating the currently active loadout requirements.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "modifierHashes": {
	//       "description": "If the activity has modifiers, this will be the list of modifiers that all variants have in common. Perform lookups against DestinyActivityModifierDefinition which defines the modifier being applied to get at the modifier data.\r\nNote that, in the DestiyActivityDefinition, you will see many more modifiers than this being referred to: those are all *possible* modifiers for the activity, not the active ones. Use only the active ones to match what's really live.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.ActivityModifiers.DestinyActivityModifierDefinition"
	//       }
	//     },
	//     "phaseHashes": {
	//       "description": "The ordered list of phases for this activity, if any. Note that we have no human readable info for phases, nor any entities to relate them to: relating these hashes to something human readable is up to you unfortunately.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`

	// The set of activity options for this activity, keyed by an identifier that's unique for this
	// activity (not guaranteed to be unique between or across all activities, though should be unique for
	// every *variant* of a given *conceptual* activity: for instance, the original D2 Raid has many
	// variant DestinyActivityDefinitions. While other activities could potentially have the same option
	// hashes, for any given D2 base Raid variant the hash will be unique).
	// As a concrete example of this data, the hashes you get for Raids will correspond to the currently
	// active "Challenge Mode".
	// We have no human readable information for this data, so it's up to you if you want to associate it
	// with such info to show it.
	BooleanActivityOptions map[uint32]bool `json:"booleanActivityOptions"`

	ChallengeObjectiveHashes []uint32 `json:"challengeObjectiveHashes"`

	// If returned, this is the index into the DestinyActivityDefinition's "loadouts" property, indicating
	// the currently active loadout requirements.
	LoadoutRequirementIndex Nullable[int32] `json:"loadoutRequirementIndex,omitempty"`

	// If the activity has modifiers, this will be the list of modifiers that all variants have in common.
	// Perform lookups against DestinyActivityModifierDefinition which defines the modifier being applied
	// to get at the modifier data.
	// Note that, in the DestiyActivityDefinition, you will see many more modifiers than this being
	// referred to: those are all *possible* modifiers for the activity, not the active ones. Use only the
	// active ones to match what's really live.
	ModifierHashes []uint32 `json:"modifierHashes"`

	// The ordered list of phases for this activity, if any. Note that we have no human readable info for
	// phases, nor any entities to relate them to: relating these hashes to something human readable is up
	// to you unfortunately.
	PhaseHashes []uint32 `json:"phaseHashes"`
}

// Destiny.Milestones.DestinyPublicMilestoneQuest
type PublicMilestoneQuest struct {
	// {
	//   "properties": {
	//     "activity": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Milestones.DestinyPublicMilestoneActivity"
	//         }
	//       ],
	//       "description": "A milestone need not have an active activity, but if there is one it will be returned here, along with any variant and additional information.",
	//       "type": "object"
	//     },
	//     "challenges": {
	//       "description": "For the given quest there could be 0-to-Many challenges: mini quests that you can perform in the course of doing this quest, that may grant you rewards and benefits.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Milestones.DestinyPublicMilestoneChallenge"
	//       },
	//       "type": "array"
	//     },
	//     "questItemHash": {
	//       "description": "Quests are defined as Items in content. As such, this is the hash identifier of the DestinyInventoryItemDefinition that represents this quest. It will have pointers to all of the steps in the quest, and display information for the quest (title, description, icon etc) Individual steps will be referred to in the Quest item's DestinyInventoryItemDefinition.setData property, and themselves are Items with their own renderable data.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Milestones.DestinyMilestoneDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// A milestone need not have an active activity, but if there is one it will be returned here, along
	// with any variant and additional information.
	Activity PublicMilestoneActivity `json:"activity"`

	// For the given quest there could be 0-to-Many challenges: mini quests that you can perform in the
	// course of doing this quest, that may grant you rewards and benefits.
	Challenges []PublicMilestoneChallenge `json:"challenges"`

	// Quests are defined as Items in content. As such, this is the hash identifier of the
	// DestinyInventoryItemDefinition that represents this quest. It will have pointers to all of the steps
	// in the quest, and display information for the quest (title, description, icon etc) Individual steps
	// will be referred to in the Quest item's DestinyInventoryItemDefinition.setData property, and
	// themselves are Items with their own renderable data.
	QuestItemHash Hash[MilestoneDefinition] `json:"questItemHash"`
}

// Destiny.Milestones.DestinyPublicMilestoneVendor
type PublicMilestoneVendor struct {
	// {
	//   "properties": {
	//     "previewItemHash": {
	//       "description": "If this vendor is featuring a specific item for this event, this will be the hash identifier of that item. I'm taking bets now on how long we go before this needs to be a list or some other, more complex representation instead and I deprecate this too. I'm going to go with 5 months. Calling it now, 2017-09-14 at 9:46pm PST.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "vendorHash": {
	//       "description": "The hash identifier of the Vendor related to this Milestone. You can show useful things from this, such as thier Faction icon or whatever you might care about.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyVendorDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// If this vendor is featuring a specific item for this event, this will be the hash identifier of that
	// item. I'm taking bets now on how long we go before this needs to be a list or some other, more
	// complex representation instead and I deprecate this too. I'm going to go with 5 months. Calling it
	// now, 2017-09-14 at 9:46pm PST.
	PreviewItemHash Nullable[Hash[InventoryItemDefinition]] `json:"previewItemHash,omitempty"`

	// The hash identifier of the Vendor related to this Milestone. You can show useful things from this,
	// such as thier Faction icon or whatever you might care about.
	VendorHash Hash[VendorDefinition] `json:"vendorHash"`
}

// Destiny.Misc.DestinyColor
//
// Represents a color whose RGBA values are all represented as values between 0 and 255.
type Color struct {
	// {
	//   "description": "Represents a color whose RGBA values are all represented as values between 0 and 255.",
	//   "properties": {
	//     "alpha": {
	//       "format": "byte",
	//       "type": "string"
	//     },
	//     "blue": {
	//       "format": "byte",
	//       "type": "string"
	//     },
	//     "green": {
	//       "format": "byte",
	//       "type": "string"
	//     },
	//     "red": {
	//       "format": "byte",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Alpha int `json:"alpha"`

	Blue int `json:"blue"`

	Green int `json:"green"`

	Red int `json:"red"`
}

// Destiny.Perks.DestinyPerkReference
//
// The list of perks to display in an item tooltip - and whether or not they have been activated.
// Perks apply a variety of effects to a character, and are generally either intrinsic to the item or
// provided in activated talent nodes or sockets.
type PerkReference struct {
	// {
	//   "description": "The list of perks to display in an item tooltip - and whether or not they have been activated.\r\nPerks apply a variety of effects to a character, and are generally either intrinsic to the item or provided in activated talent nodes or sockets.",
	//   "properties": {
	//     "iconPath": {
	//       "description": "The icon for the perk.",
	//       "type": "string"
	//     },
	//     "isActive": {
	//       "description": "Whether this perk is currently active. (We may return perks that you have not actually activated yet: these represent perks that you should show in the item's tooltip, but that the user has not yet activated.)",
	//       "type": "boolean"
	//     },
	//     "perkHash": {
	//       "description": "The hash identifier for the perk, which can be used to look up DestinySandboxPerkDefinition if it exists. Be warned, perks frequently do not have user-viewable information. You should examine whether you actually found a name/description in the perk's definition before you show it to the user.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinySandboxPerkDefinition"
	//       }
	//     },
	//     "visible": {
	//       "description": "Some perks provide benefits, but aren't visible in the UI. This value will let you know if this is perk should be shown in your UI.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	// The icon for the perk.
	IconPath string `json:"iconPath"`

	// Whether this perk is currently active. (We may return perks that you have not actually activated
	// yet: these represent perks that you should show in the item's tooltip, but that the user has not yet
	// activated.)
	IsActive bool `json:"isActive"`

	// The hash identifier for the perk, which can be used to look up DestinySandboxPerkDefinition if it
	// exists. Be warned, perks frequently do not have user-viewable information. You should examine
	// whether you actually found a name/description in the perk's definition before you show it to the
	// user.
	PerkHash Hash[SandboxPerkDefinition] `json:"perkHash"`

	// Some perks provide benefits, but aren't visible in the UI. This value will let you know if this is
	// perk should be shown in your UI.
	Visible bool `json:"visible"`
}

// Destiny.PlugAvailabilityMode
//
// This enum determines whether the plug is available to be inserted.
// - Normal means that all existing rules for plug insertion apply.
// - UnavailableIfSocketContainsMatchingPlugCategory means that the plug is only available if the
// socket does NOT match the plug category.
// - AvailableIfSocketContainsMatchingPlugCategory means that the plug is only available if the socket
// DOES match the plug category.
// For category matching, use the plug's "plugCategoryIdentifier" property, comparing it to
type PlugAvailabilityMode int32

const (
	PlugAvailabilityMode_Normal                                          = PlugAvailabilityMode(0)
	PlugAvailabilityMode_UnavailableIfSocketContainsMatchingPlugCategory = PlugAvailabilityMode(1)
	PlugAvailabilityMode_AvailableIfSocketContainsMatchingPlugCategory   = PlugAvailabilityMode(2)
)

// Destiny.PlugUiStyles
//
// If the plug has a specific custom style, this enumeration will represent that style/those styles.
type PlugUiStyles int32

const (
	PlugUiStyles_None       = PlugUiStyles(0)
	PlugUiStyles_Masterwork = PlugUiStyles(1)
)

// Destiny.Progression.DestinyFactionProgression
//
// Mostly for historical purposes, we segregate Faction progressions from other progressions. This is
// just a DestinyProgression with a shortcut for finding the DestinyFactionDefinition of the faction
// related to the progression.
type FactionProgression struct {
	// {
	//   "description": "Mostly for historical purposes, we segregate Faction progressions from other progressions. This is just a DestinyProgression with a shortcut for finding the DestinyFactionDefinition of the faction related to the progression.",
	//   "properties": {
	//     "currentProgress": {
	//       "description": "This is the total amount of progress obtained overall for this progression (for instance, the total amount of Character Level experience earned)",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "currentResetCount": {
	//       "description": "The number of resets of this progression you've executed this season, if applicable to this progression.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "dailyLimit": {
	//       "description": "If this progression has a daily limit, this is that limit.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "dailyProgress": {
	//       "description": "The amount of progress earned today for this progression.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "factionHash": {
	//       "description": "The hash identifier of the Faction related to this progression. Use it to look up the DestinyFactionDefinition for more rendering info.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyFactionDefinition"
	//       }
	//     },
	//     "factionVendorIndex": {
	//       "description": "The index of the Faction vendor that is currently available. Will be set to -1 if no vendors are available.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "level": {
	//       "description": "This is the level of the progression (for instance, the Character Level).",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "levelCap": {
	//       "description": "This is the maximum possible level you can achieve for this progression (for example, the maximum character level obtainable)",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "nextLevelAt": {
	//       "description": "The total amount of progression (i.e. \"Experience\") needed in order to reach the next level.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "progressToNextLevel": {
	//       "description": "The amount of progression (i.e. \"Experience\") needed to reach the next level of this Progression. Jeez, progression is such an overloaded word.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "progressionHash": {
	//       "description": "The hash identifier of the Progression in question. Use it to look up the DestinyProgressionDefinition in static data.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyProgressionDefinition"
	//       }
	//     },
	//     "rewardItemSocketOverrideStates": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.DestinyProgressionRewardItemSocketOverrideState"
	//       },
	//       "description": "Information about items stats and states that have socket overrides, if there is any data for it.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "int32",
	//         "type": "integer"
	//       }
	//     },
	//     "rewardItemStates": {
	//       "description": "Information about historical rewards for this progression, if there is any data for it.",
	//       "items": {
	//         "description": "Represents the different states a progression reward item can be in.",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": true,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/Destiny.DestinyProgressionRewardItemState"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "seasonResets": {
	//       "description": "Information about historical resets of this progression, if there is any data for it.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyProgressionResetEntry"
	//       },
	//       "type": "array"
	//     },
	//     "stepIndex": {
	//       "description": "Progressions define their levels in \"steps\". Since the last step may be repeatable, the user may be at a higher level than the actual Step achieved in the progression. Not necessarily useful, but potentially interesting for those cruising the API. Relate this to the \"steps\" property of the DestinyProgression to see which step the user is on, if you care about that. (Note that this is Content Version dependent since it refers to indexes.)",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "weeklyLimit": {
	//       "description": "If this progression has a weekly limit, this is that limit.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "weeklyProgress": {
	//       "description": "The amount of progress earned toward this progression in the current week.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// This is the total amount of progress obtained overall for this progression (for instance, the total
	// amount of Character Level experience earned)
	CurrentProgress int32 `json:"currentProgress"`

	// The number of resets of this progression you've executed this season, if applicable to this
	// progression.
	CurrentResetCount Nullable[int32] `json:"currentResetCount,omitempty"`

	// If this progression has a daily limit, this is that limit.
	DailyLimit int32 `json:"dailyLimit"`

	// The amount of progress earned today for this progression.
	DailyProgress int32 `json:"dailyProgress"`

	// The hash identifier of the Faction related to this progression. Use it to look up the
	// DestinyFactionDefinition for more rendering info.
	FactionHash Hash[FactionDefinition] `json:"factionHash"`

	// The index of the Faction vendor that is currently available. Will be set to -1 if no vendors are
	// available.
	FactionVendorIndex int32 `json:"factionVendorIndex"`

	// This is the level of the progression (for instance, the Character Level).
	Level int32 `json:"level"`

	// This is the maximum possible level you can achieve for this progression (for example, the maximum
	// character level obtainable)
	LevelCap int32 `json:"levelCap"`

	// The total amount of progression (i.e. "Experience") needed in order to reach the next level.
	NextLevelAt int32 `json:"nextLevelAt"`

	// The amount of progression (i.e. "Experience") needed to reach the next level of this Progression.
	// Jeez, progression is such an overloaded word.
	ProgressToNextLevel int32 `json:"progressToNextLevel"`

	// The hash identifier of the Progression in question. Use it to look up the
	// DestinyProgressionDefinition in static data.
	ProgressionHash Hash[ProgressionDefinition] `json:"progressionHash"`

	// Information about items stats and states that have socket overrides, if there is any data for it.
	RewardItemSocketOverrideStates map[int32]ProgressionRewardItemSocketOverrideState `json:"rewardItemSocketOverrideStates"`

	// Information about historical rewards for this progression, if there is any data for it.
	RewardItemStates []BitmaskSet[ProgressionRewardItemState] `json:"rewardItemStates"`

	// Information about historical resets of this progression, if there is any data for it.
	SeasonResets []ProgressionResetEntry `json:"seasonResets"`

	// Progressions define their levels in "steps". Since the last step may be repeatable, the user may be
	// at a higher level than the actual Step achieved in the progression. Not necessarily useful, but
	// potentially interesting for those cruising the API. Relate this to the "steps" property of the
	// DestinyProgression to see which step the user is on, if you care about that. (Note that this is
	// Content Version dependent since it refers to indexes.)
	StepIndex int32 `json:"stepIndex"`

	// If this progression has a weekly limit, this is that limit.
	WeeklyLimit int32 `json:"weeklyLimit"`

	// The amount of progress earned toward this progression in the current week.
	WeeklyProgress int32 `json:"weeklyProgress"`
}

// Destiny.Quests.DestinyObjectiveProgress
//
// Returns data about a character's status with a given Objective. Combine with
// DestinyObjectiveDefinition static data for display purposes.
type ObjectiveProgress struct {
	// {
	//   "description": "Returns data about a character's status with a given Objective. Combine with DestinyObjectiveDefinition static data for display purposes.",
	//   "properties": {
	//     "activityHash": {
	//       "description": "If the Objective has an Activity associated with it, this is the unique identifier of the Activity being referred to. Use to look up the DestinyActivityDefinition in static data. This will give localized data about *what* you should be playing for the objective to be achieved.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "complete": {
	//       "description": "Whether or not the Objective is completed.",
	//       "type": "boolean"
	//     },
	//     "completionValue": {
	//       "description": "As of Forsaken, objectives' completion value is determined dynamically at runtime.\r\nThis value represents the threshold of progress you need to surpass in order for this objective to be considered \"complete\".\r\nIf you were using objective data, switch from using the DestinyObjectiveDefinition's \"completionValue\" to this value.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "destinationHash": {
	//       "description": "If the Objective has a Destination associated with it, this is the unique identifier of the Destination being referred to. Use to look up the DestinyDestinationDefinition in static data. This will give localized data about *where* in the universe the objective should be achieved.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyDestinationDefinition"
	//       }
	//     },
	//     "objectiveHash": {
	//       "description": "The unique identifier of the Objective being referred to. Use to look up the DestinyObjectiveDefinition in static data.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyObjectiveDefinition"
	//       }
	//     },
	//     "progress": {
	//       "description": "If progress has been made, and the progress can be measured numerically, this will be the value of that progress. You can compare it to the DestinyObjectiveDefinition.completionValue property for current vs. upper bounds, and use DestinyObjectiveDefinition.inProgressValueStyle or completedValueStyle to determine how this should be rendered. Note that progress, in Destiny 2, need not be a literal numeric progression. It could be one of a number of possible values, even a Timestamp. Always examine DestinyObjectiveDefinition.inProgressValueStyle or completedValueStyle before rendering progress.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "visible": {
	//       "description": "If this is true, the objective is visible in-game. Otherwise, it's not yet visible to the player. Up to you if you want to honor this property.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	// If the Objective has an Activity associated with it, this is the unique identifier of the Activity
	// being referred to. Use to look up the DestinyActivityDefinition in static data. This will give
	// localized data about *what* you should be playing for the objective to be achieved.
	ActivityHash Nullable[Hash[ActivityDefinition]] `json:"activityHash,omitempty"`

	// Whether or not the Objective is completed.
	Complete bool `json:"complete"`

	// As of Forsaken, objectives' completion value is determined dynamically at runtime.
	// This value represents the threshold of progress you need to surpass in order for this objective to
	// be considered "complete".
	// If you were using objective data, switch from using the DestinyObjectiveDefinition's
	// "completionValue" to this value.
	CompletionValue int32 `json:"completionValue"`

	// If the Objective has a Destination associated with it, this is the unique identifier of the
	// Destination being referred to. Use to look up the DestinyDestinationDefinition in static data. This
	// will give localized data about *where* in the universe the objective should be achieved.
	DestinationHash Nullable[Hash[DestinationDefinition]] `json:"destinationHash,omitempty"`

	// The unique identifier of the Objective being referred to. Use to look up the
	// DestinyObjectiveDefinition in static data.
	ObjectiveHash Hash[ObjectiveDefinition] `json:"objectiveHash"`

	// If progress has been made, and the progress can be measured numerically, this will be the value of
	// that progress. You can compare it to the DestinyObjectiveDefinition.completionValue property for
	// current vs. upper bounds, and use DestinyObjectiveDefinition.inProgressValueStyle or
	// completedValueStyle to determine how this should be rendered. Note that progress, in Destiny 2, need
	// not be a literal numeric progression. It could be one of a number of possible values, even a
	// Timestamp. Always examine DestinyObjectiveDefinition.inProgressValueStyle or completedValueStyle
	// before rendering progress.
	Progress Nullable[int32] `json:"progress,omitempty"`

	// If this is true, the objective is visible in-game. Otherwise, it's not yet visible to the player. Up
	// to you if you want to honor this property.
	Visible bool `json:"visible"`
}

// Destiny.Quests.DestinyQuestStatus
//
// Data regarding the progress of a Quest for a specific character. Quests are composed of multiple
// steps, each with potentially multiple objectives: this QuestStatus will return Objective data for
// the *currently active* step in this quest.
type QuestStatus struct {
	// {
	//   "description": "Data regarding the progress of a Quest for a specific character. Quests are composed of multiple steps, each with potentially multiple objectives: this QuestStatus will return Objective data for the *currently active* step in this quest.",
	//   "properties": {
	//     "completed": {
	//       "description": "Whether or not the whole quest has been completed, regardless of whether or not you have redeemed the rewards for the quest.",
	//       "type": "boolean"
	//     },
	//     "itemInstanceId": {
	//       "description": "The current Quest Step will be an instanced item in the player's inventory. If you care about that, this is the instance ID of that item.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "questHash": {
	//       "description": "The hash identifier for the Quest Item. (Note: Quests are defined as Items, and thus you would use this to look up the quest's DestinyInventoryItemDefinition). For information on all steps in the quest, you can then examine its DestinyInventoryItemDefinition.setData property for Quest Steps (which are *also* items). You can use the Item Definition to display human readable data about the overall quest.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "redeemed": {
	//       "description": "Whether or not you have redeemed rewards for this quest.",
	//       "type": "boolean"
	//     },
	//     "started": {
	//       "description": "Whether or not you have started this quest.",
	//       "type": "boolean"
	//     },
	//     "stepHash": {
	//       "description": "The hash identifier of the current Quest Step, which is also a DestinyInventoryItemDefinition. You can use this to get human readable data about the current step and what to do in that step.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "stepObjectives": {
	//       "description": "A step can have multiple objectives. This will give you the progress for each objective in the current step, in the order in which they are rendered in-game.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Quests.DestinyObjectiveProgress"
	//       },
	//       "type": "array"
	//     },
	//     "tracked": {
	//       "description": "Whether or not the quest is tracked",
	//       "type": "boolean"
	//     },
	//     "vendorHash": {
	//       "description": "If the quest has a related Vendor that you should talk to in order to initiate the quest/earn rewards/continue the quest, this will be the hash identifier of that Vendor. Look it up its DestinyVendorDefinition.",
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// Whether or not the whole quest has been completed, regardless of whether or not you have redeemed
	// the rewards for the quest.
	Completed bool `json:"completed"`

	// The current Quest Step will be an instanced item in the player's inventory. If you care about that,
	// this is the instance ID of that item.
	ItemInstanceID Int64 `json:"itemInstanceId"`

	// The hash identifier for the Quest Item. (Note: Quests are defined as Items, and thus you would use
	// this to look up the quest's DestinyInventoryItemDefinition). For information on all steps in the
	// quest, you can then examine its DestinyInventoryItemDefinition.setData property for Quest Steps
	// (which are *also* items). You can use the Item Definition to display human readable data about the
	// overall quest.
	QuestHash Hash[InventoryItemDefinition] `json:"questHash"`

	// Whether or not you have redeemed rewards for this quest.
	Redeemed bool `json:"redeemed"`

	// Whether or not you have started this quest.
	Started bool `json:"started"`

	// The hash identifier of the current Quest Step, which is also a DestinyInventoryItemDefinition. You
	// can use this to get human readable data about the current step and what to do in that step.
	StepHash Hash[InventoryItemDefinition] `json:"stepHash"`

	// A step can have multiple objectives. This will give you the progress for each objective in the
	// current step, in the order in which they are rendered in-game.
	StepObjectives []ObjectiveProgress `json:"stepObjectives"`

	// Whether or not the quest is tracked
	Tracked bool `json:"tracked"`

	// If the quest has a related Vendor that you should talk to in order to initiate the quest/earn
	// rewards/continue the quest, this will be the hash identifier of that Vendor. Look it up its
	// DestinyVendorDefinition.
	VendorHash Nullable[uint32] `json:"vendorHash,omitempty"`
}

// Destiny.Reporting.Requests.DestinyReportOffensePgcrRequest
//
// If you want to report a player causing trouble in a game, this request will let you report that
// player and the specific PGCR in which the trouble was caused, along with why.
// Please don't do this just because you dislike the person! I mean, I know people will do it anyways,
// but can you like take a good walk, or put a curse on them or something? Do me a solid and
// reconsider.
// Note that this request object doesn't have the actual PGCR ID nor your Account/Character ID in it.
// We will infer that information from your authentication information and the PGCR ID that you pass
// into the URL of the reporting endpoint itself.
type ReportOffensePgcrRequestBody struct {
	// {
	//   "description": "If you want to report a player causing trouble in a game, this request will let you report that player and the specific PGCR in which the trouble was caused, along with why.\r\nPlease don't do this just because you dislike the person! I mean, I know people will do it anyways, but can you like take a good walk, or put a curse on them or something? Do me a solid and reconsider.\r\nNote that this request object doesn't have the actual PGCR ID nor your Account/Character ID in it. We will infer that information from your authentication information and the PGCR ID that you pass into the URL of the reporting endpoint itself.",
	//   "properties": {
	//     "offendingCharacterId": {
	//       "description": "Within the PGCR provided when calling the Reporting endpoint, this should be the character ID of the user that you thought was violating terms of use. They must exist in the PGCR provided.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "reasonCategoryHashes": {
	//       "description": "So you've decided to report someone instead of cursing them and their descendants. Well, okay then. This is the category or categorie(s) of infractions for which you are reporting the user. These are hash identifiers that map to DestinyReportReasonCategoryDefinition entries.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Reporting.DestinyReportReasonCategoryDefinition"
	//       }
	//     },
	//     "reasonHashes": {
	//       "description": "If applicable, provide a more specific reason(s) within the general category of problems provided by the reasonHash. This is also an identifier for a reason. All reasonHashes provided must be children of at least one the reasonCategoryHashes provided.",
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// Within the PGCR provided when calling the Reporting endpoint, this should be the character ID of the
	// user that you thought was violating terms of use. They must exist in the PGCR provided.
	OffendingCharacterID Int64 `json:"offendingCharacterId"`

	// So you've decided to report someone instead of cursing them and their descendants. Well, okay then.
	// This is the category or categorie(s) of infractions for which you are reporting the user. These are
	// hash identifiers that map to DestinyReportReasonCategoryDefinition entries.
	ReasonCategoryHashes []uint32 `json:"reasonCategoryHashes"`

	// If applicable, provide a more specific reason(s) within the general category of problems provided by
	// the reasonHash. This is also an identifier for a reason. All reasonHashes provided must be children
	// of at least one the reasonCategoryHashes provided.
	ReasonHashes []uint32 `json:"reasonHashes"`
}

// Destiny.Requests.Actions.DestinyActionRequest
type ActionRequestBody struct {
	// {
	//   "properties": {
	//     "membershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	MembershipType BungieMembershipType `json:"membershipType"`
}

// Destiny.Requests.Actions.DestinyCharacterActionRequest
type CharacterActionRequestBody struct {
	// {
	//   "properties": {
	//     "characterId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	CharacterID Int64 `json:"characterId"`

	MembershipType BungieMembershipType `json:"membershipType"`
}

// Destiny.Requests.Actions.DestinyInsertPlugsActionRequest
type InsertPlugsActionRequestBody struct {
	// {
	//   "properties": {
	//     "actionToken": {
	//       "description": "Action token provided by the AwaGetActionToken API call.",
	//       "type": "string"
	//     },
	//     "characterId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "itemInstanceId": {
	//       "description": "The instance ID of the item having a plug inserted. Only instanced items can have sockets.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "plug": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Requests.Actions.DestinyInsertPlugsRequestEntry"
	//         }
	//       ],
	//       "description": "The plugs being inserted.",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object"
	// }

	// Action token provided by the AwaGetActionToken API call.
	ActionToken string `json:"actionToken"`

	CharacterID Int64 `json:"characterId"`

	// The instance ID of the item having a plug inserted. Only instanced items can have sockets.
	ItemInstanceID Int64 `json:"itemInstanceId"`

	MembershipType BungieMembershipType `json:"membershipType"`

	// The plugs being inserted.
	Plug InsertPlugsRequestEntry `json:"plug"`
}

// Destiny.Requests.Actions.DestinyInsertPlugsFreeActionRequest
type InsertPlugsFreeActionRequestBody struct {
	// {
	//   "properties": {
	//     "characterId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "itemId": {
	//       "description": "The instance ID of the item for this action request.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "plug": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Requests.Actions.DestinyInsertPlugsRequestEntry"
	//         }
	//       ],
	//       "description": "The plugs being inserted.",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object"
	// }

	CharacterID Int64 `json:"characterId"`

	// The instance ID of the item for this action request.
	ItemID Int64 `json:"itemId"`

	MembershipType BungieMembershipType `json:"membershipType"`

	// The plugs being inserted.
	Plug InsertPlugsRequestEntry `json:"plug"`
}

// Destiny.Requests.Actions.DestinyInsertPlugsRequestEntry
//
// Represents all of the data related to a single plug to be inserted.
// Note that, while you *can* point to a socket that represents infusion, you will receive an error if
// you attempt to do so. Come on guys, let's play nice.
type InsertPlugsRequestEntry struct {
	// {
	//   "description": "Represents all of the data related to a single plug to be inserted.\r\nNote that, while you *can* point to a socket that represents infusion, you will receive an error if you attempt to do so. Come on guys, let's play nice.",
	//   "properties": {
	//     "plugItemHash": {
	//       "description": "Plugs are never instanced (except in infusion). So with the hash alone, we should be able to: 1) Infer whether the player actually needs to have the item, or if it's a reusable plug 2) Perform any operation needed to use the Plug, including removing the plug item and running reward sheets.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "socketArrayType": {
	//       "description": "This property, combined with the socketIndex, tells us which socket we are referring to (since operations can be performed on both Intrinsic and \"default\" sockets, and they occupy different arrays in the Inventory Item Definition). I know, I know. Don't give me that look.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.Requests.Actions.DestinySocketArrayType"
	//       }
	//     },
	//     "socketIndex": {
	//       "description": "The index into the socket array, which identifies the specific socket being operated on. We also need to know the socketArrayType in order to uniquely identify the socket.\r\nDon't point to or try to insert a plug into an infusion socket. It won't work.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// Plugs are never instanced (except in infusion). So with the hash alone, we should be able to: 1)
	// Infer whether the player actually needs to have the item, or if it's a reusable plug 2) Perform any
	// operation needed to use the Plug, including removing the plug item and running reward sheets.
	PlugItemHash uint32 `json:"plugItemHash"`

	// This property, combined with the socketIndex, tells us which socket we are referring to (since
	// operations can be performed on both Intrinsic and "default" sockets, and they occupy different
	// arrays in the Inventory Item Definition). I know, I know. Don't give me that look.
	SocketArrayType SocketArrayType `json:"socketArrayType"`

	// The index into the socket array, which identifies the specific socket being operated on. We also
	// need to know the socketArrayType in order to uniquely identify the socket.
	// Don't point to or try to insert a plug into an infusion socket. It won't work.
	SocketIndex int32 `json:"socketIndex"`
}

// Destiny.Requests.Actions.DestinyItemActionRequest
type ItemActionRequestBody struct {
	// {
	//   "properties": {
	//     "characterId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "itemId": {
	//       "description": "The instance ID of the item for this action request.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	CharacterID Int64 `json:"characterId"`

	// The instance ID of the item for this action request.
	ItemID Int64 `json:"itemId"`

	MembershipType BungieMembershipType `json:"membershipType"`
}

// Destiny.Requests.Actions.DestinyItemSetActionRequest
type ItemSetActionRequestBody struct {
	// {
	//   "properties": {
	//     "characterId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "itemIds": {
	//       "items": {
	//         "format": "int64",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "membershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	CharacterID Int64 `json:"characterId"`

	ItemIds []Int64 `json:"itemIds"`

	MembershipType BungieMembershipType `json:"membershipType"`
}

// Destiny.Requests.Actions.DestinyItemStateRequest
type ItemStateRequestBody struct {
	// {
	//   "properties": {
	//     "characterId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "itemId": {
	//       "description": "The instance ID of the item for this action request.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "state": {
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	CharacterID Int64 `json:"characterId"`

	// The instance ID of the item for this action request.
	ItemID Int64 `json:"itemId"`

	MembershipType BungieMembershipType `json:"membershipType"`

	State bool `json:"state"`
}

// Destiny.Requests.Actions.DestinyLoadoutActionRequest
type LoadoutActionRequestBody struct {
	// {
	//   "properties": {
	//     "characterId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "loadoutIndex": {
	//       "description": "The index of the loadout for this action request.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	CharacterID Int64 `json:"characterId"`

	// The index of the loadout for this action request.
	LoadoutIndex int32 `json:"loadoutIndex"`

	MembershipType BungieMembershipType `json:"membershipType"`
}

// Destiny.Requests.Actions.DestinyLoadoutUpdateActionRequest
type LoadoutUpdateActionRequestBody struct {
	// {
	//   "properties": {
	//     "characterId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "colorHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "iconHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "loadoutIndex": {
	//       "description": "The index of the loadout for this action request.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "nameHash": {
	//       "format": "uint32",
	//       "nullable": true,
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	CharacterID Int64 `json:"characterId"`

	ColorHash Nullable[uint32] `json:"colorHash,omitempty"`

	IconHash Nullable[uint32] `json:"iconHash,omitempty"`

	// The index of the loadout for this action request.
	LoadoutIndex int32 `json:"loadoutIndex"`

	MembershipType BungieMembershipType `json:"membershipType"`

	NameHash Nullable[uint32] `json:"nameHash,omitempty"`
}

// Destiny.Requests.Actions.DestinyPostmasterTransferRequest
type PostmasterTransferRequestBody struct {
	// {
	//   "properties": {
	//     "characterId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "itemId": {
	//       "description": "The instance ID of the item for this action request.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "itemReferenceHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "membershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "stackSize": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	CharacterID Int64 `json:"characterId"`

	// The instance ID of the item for this action request.
	ItemID Int64 `json:"itemId"`

	ItemReferenceHash Hash[InventoryItemDefinition] `json:"itemReferenceHash"`

	MembershipType BungieMembershipType `json:"membershipType"`

	StackSize int32 `json:"stackSize"`
}

// Destiny.Requests.Actions.DestinySocketArrayType
//
// If you look in the DestinyInventoryItemDefinition's "sockets" property, you'll see that there are
// two types of sockets: intrinsic, and "socketEntry."
// Unfortunately, because Intrinsic sockets are a whole separate array, it is no longer sufficient to
// know the index into that array to know which socket we're talking about. You have to know whether
// it's in the default "socketEntries" or if it's in the "intrinsic" list.
type SocketArrayType int32

const (
	SocketArrayType_Default   = SocketArrayType(0)
	SocketArrayType_Intrinsic = SocketArrayType(1)
)

// Destiny.Requests.DestinyItemTransferRequest
type ItemTransferRequestBody struct {
	// {
	//   "properties": {
	//     "characterId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "itemId": {
	//       "description": "The instance ID of the item for this action request.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "itemReferenceHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "membershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "stackSize": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "transferToVault": {
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	CharacterID Int64 `json:"characterId"`

	// The instance ID of the item for this action request.
	ItemID Int64 `json:"itemId"`

	ItemReferenceHash Hash[InventoryItemDefinition] `json:"itemReferenceHash"`

	MembershipType BungieMembershipType `json:"membershipType"`

	StackSize int32 `json:"stackSize"`

	TransferToVault bool `json:"transferToVault"`
}

// Destiny.Responses.DestinyCharacterResponse
//
// The response contract for GetDestinyCharacter, with components that can be returned for character
// and item-level data.
type CharacterResponse struct {
	// {
	//   "description": "The response contract for GetDestinyCharacter, with components that can be returned for character and item-level data.",
	//   "properties": {
	//     "activities": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyCharacterActivitiesComponent"
	//         }
	//       ],
	//       "description": "Activity data - info about current activities available to the player.\r\nCOMPONENT TYPE: CharacterActivities",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CharacterActivities"
	//     },
	//     "character": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyCharacterComponent"
	//         }
	//       ],
	//       "description": "Base information about the character in question.\r\nCOMPONENT TYPE: Characters",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Characters"
	//     },
	//     "collectibles": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyCollectiblesComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: Collectibles",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Collectibles"
	//     },
	//     "currencyLookups": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyCurrenciesComponent"
	//         }
	//       ],
	//       "description": "A \"lookup\" convenience component that can be used to quickly check if the character has access to items that can be used for purchasing.\r\nCOMPONENT TYPE: CurrencyLookups",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CurrencyLookups"
	//     },
	//     "equipment": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyInventoryComponent"
	//         }
	//       ],
	//       "description": "Equipped items on the character.\r\nCOMPONENT TYPE: CharacterEquipment",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CharacterEquipment"
	//     },
	//     "inventory": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyInventoryComponent"
	//         }
	//       ],
	//       "description": "The character-level non-equipped inventory items.\r\nCOMPONENT TYPE: CharacterInventories",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CharacterInventories"
	//     },
	//     "itemComponents": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DestinyItemComponentSetOfint64"
	//         }
	//       ],
	//       "description": "The set of components belonging to the player's instanced items.\r\nCOMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component types.]",
	//       "type": "object"
	//     },
	//     "kiosks": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyKiosksComponent"
	//         }
	//       ],
	//       "description": "Items available from Kiosks that are available to this specific character. \r\nCOMPONENT TYPE: Kiosks",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Kiosks"
	//     },
	//     "loadouts": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyLoadoutsComponent"
	//         }
	//       ],
	//       "description": "The loadouts available to the character.\r\nCOMPONENT TYPE: CharacterLoadouts",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CharacterLoadouts"
	//     },
	//     "plugSets": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyPlugSetsComponent"
	//         }
	//       ],
	//       "description": "When sockets refer to reusable Plug Sets (see DestinyPlugSetDefinition for more info), this is the set of plugs and their states that are scoped to this character.\r\nThis comes back with ItemSockets, as it is needed for a complete picture of the sockets on requested items.\r\nCOMPONENT TYPE: ItemSockets",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ItemSockets"
	//     },
	//     "presentationNodes": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyPresentationNodesComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: PresentationNodes",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "PresentationNodes"
	//     },
	//     "progressions": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyCharacterProgressionComponent"
	//         }
	//       ],
	//       "description": "Character progression data, including Milestones.\r\nCOMPONENT TYPE: CharacterProgressions",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CharacterProgressions"
	//     },
	//     "records": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyCharacterRecordsComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: Records",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Records"
	//     },
	//     "renderData": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyCharacterRenderComponent"
	//         }
	//       ],
	//       "description": "Character rendering data - a minimal set of information about equipment and dyes used for rendering.\r\nCOMPONENT TYPE: CharacterRenderData",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CharacterRenderData"
	//     },
	//     "uninstancedItemComponents": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DestinyBaseItemComponentSetOfuint32"
	//         }
	//       ],
	//       "description": "The set of components belonging to the player's UNinstanced items. Because apparently now those too can have information relevant to the character's state.\r\nCOMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component types.]",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object"
	// }

	// Activity data - info about current activities available to the player.
	// COMPONENT TYPE: CharacterActivities
	Activities ComponentResponse[CharacterActivitiesComponent] `json:"activities"`

	// Base information about the character in question.
	// COMPONENT TYPE: Characters
	Character ComponentResponse[CharacterComponent] `json:"character"`

	// COMPONENT TYPE: Collectibles
	Collectibles ComponentResponse[CollectiblesComponent] `json:"collectibles"`

	// A "lookup" convenience component that can be used to quickly check if the character has access to
	// items that can be used for purchasing.
	// COMPONENT TYPE: CurrencyLookups
	CurrencyLookups ComponentResponse[CurrenciesComponent] `json:"currencyLookups"`

	// Equipped items on the character.
	// COMPONENT TYPE: CharacterEquipment
	Equipment ComponentResponse[InventoryComponent] `json:"equipment"`

	// The character-level non-equipped inventory items.
	// COMPONENT TYPE: CharacterInventories
	Inventory ComponentResponse[InventoryComponent] `json:"inventory"`

	// The set of components belonging to the player's instanced items.
	// COMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component types.]
	ItemComponents ItemComponentSet[int64] `json:"itemComponents"`

	// Items available from Kiosks that are available to this specific character.
	// COMPONENT TYPE: Kiosks
	Kiosks ComponentResponse[KiosksComponent] `json:"kiosks"`

	// The loadouts available to the character.
	// COMPONENT TYPE: CharacterLoadouts
	Loadouts ComponentResponse[LoadoutsComponent] `json:"loadouts"`

	// When sockets refer to reusable Plug Sets (see DestinyPlugSetDefinition for more info), this is the
	// set of plugs and their states that are scoped to this character.
	// This comes back with ItemSockets, as it is needed for a complete picture of the sockets on requested
	// items.
	// COMPONENT TYPE: ItemSockets
	PlugSets ComponentResponse[PlugSetsComponent] `json:"plugSets"`

	// COMPONENT TYPE: PresentationNodes
	PresentationNodes ComponentResponse[PresentationNodesComponent] `json:"presentationNodes"`

	// Character progression data, including Milestones.
	// COMPONENT TYPE: CharacterProgressions
	Progressions ComponentResponse[CharacterProgressionComponent] `json:"progressions"`

	// COMPONENT TYPE: Records
	Records ComponentResponse[CharacterRecordsComponent] `json:"records"`

	// Character rendering data - a minimal set of information about equipment and dyes used for rendering.
	// COMPONENT TYPE: CharacterRenderData
	RenderData ComponentResponse[CharacterRenderComponent] `json:"renderData"`

	// The set of components belonging to the player's UNinstanced items. Because apparently now those too
	// can have information relevant to the character's state.
	// COMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component types.]
	UninstancedItemComponents BaseItemComponentSet[uint32] `json:"uninstancedItemComponents"`
}

// Destiny.Responses.DestinyCollectibleNodeDetailResponse
//
// Returns the detailed information about a Collectible Presentation Node and any Collectibles that are
// direct descendants.
type CollectibleNodeDetailResponse struct {
	// {
	//   "description": "Returns the detailed information about a Collectible Presentation Node and any Collectibles that are direct descendants.",
	//   "properties": {
	//     "collectibleItemComponents": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DestinyItemComponentSetOfuint32"
	//         }
	//       ],
	//       "description": "Item components, keyed by the item hash of the items pointed at collectibles found under the requested Presentation Node.\r\nNOTE: I had a lot of hemming and hawing about whether these should be keyed by collectible hash or item hash... but ultimately having it be keyed by item hash meant that UI that already uses DestinyItemComponentSet data wouldn't have to have a special override to do the collectible -\u003e item lookup once you delve into an item's details, and it also meant that you didn't have to remember that the Hash being used as the key for plugSets was different from the Hash being used for the other Dictionaries. As a result, using the Item Hash felt like the least crappy solution.\r\nWe may all come to regret this decision. We will see.\r\nCOMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component types.]",
	//       "type": "object"
	//     },
	//     "collectibles": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyCollectiblesComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: Collectibles",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Collectibles"
	//     }
	//   },
	//   "type": "object"
	// }

	// Item components, keyed by the item hash of the items pointed at collectibles found under the
	// requested Presentation Node.
	// NOTE: I had a lot of hemming and hawing about whether these should be keyed by collectible hash or
	// item hash... but ultimately having it be keyed by item hash meant that UI that already uses
	// DestinyItemComponentSet data wouldn't have to have a special override to do the collectible -> item
	// lookup once you delve into an item's details, and it also meant that you didn't have to remember
	// that the Hash being used as the key for plugSets was different from the Hash being used for the
	// other Dictionaries. As a result, using the Item Hash felt like the least crappy solution.
	// We may all come to regret this decision. We will see.
	// COMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component types.]
	CollectibleItemComponents ItemComponentSet[uint32] `json:"collectibleItemComponents"`

	// COMPONENT TYPE: Collectibles
	Collectibles ComponentResponse[CollectiblesComponent] `json:"collectibles"`
}

// Destiny.Responses.DestinyErrorProfile
//
// If a Destiny Profile can't be returned, but we're pretty certain it's a valid Destiny account, this
// will contain as much info as we can get about the profile for your use.
// Assume that the most you'll get is the Error Code, the Membership Type and the Membership ID.
type ErrorProfile struct {
	// {
	//   "description": "If a Destiny Profile can't be returned, but we're pretty certain it's a valid Destiny account, this will contain as much info as we can get about the profile for your use.\r\nAssume that the most you'll get is the Error Code, the Membership Type and the Membership ID.",
	//   "properties": {
	//     "errorCode": {
	//       "description": "The error that we encountered. You should be able to look up localized text to show to the user for these failures.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Exceptions.PlatformErrorCodes"
	//       }
	//     },
	//     "infoCard": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/User.UserInfoCard"
	//         }
	//       ],
	//       "description": "Basic info about the account that failed. Don't expect anything other than membership ID, Membership Type, and displayName to be populated.",
	//       "type": "object"
	//     }
	//   },
	//   "type": "object"
	// }

	// The error that we encountered. You should be able to look up localized text to show to the user for
	// these failures.
	ErrorCode PlatformErrorCodes `json:"errorCode"`

	// Basic info about the account that failed. Don't expect anything other than membership ID, Membership
	// Type, and displayName to be populated.
	InfoCard UserInfoCard `json:"infoCard"`
}

// Destiny.Responses.DestinyItemChangeResponse
type ItemChangeResponse struct {
	// {
	//   "properties": {
	//     "addedInventoryItems": {
	//       "description": "Items that appeared in the inventory possibly as a result of an action.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Entities.Items.DestinyItemComponent"
	//       },
	//       "type": "array"
	//     },
	//     "item": {
	//       "$ref": "#/components/schemas/Destiny.Responses.DestinyItemResponse"
	//     },
	//     "removedInventoryItems": {
	//       "description": "Items that disappeared from the inventory possibly as a result of an action.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Entities.Items.DestinyItemComponent"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// Items that appeared in the inventory possibly as a result of an action.
	AddedInventoryItems []ItemComponent `json:"addedInventoryItems"`

	Item ItemResponse `json:"item"`

	// Items that disappeared from the inventory possibly as a result of an action.
	RemovedInventoryItems []ItemComponent `json:"removedInventoryItems"`
}

// Destiny.Responses.DestinyItemResponse
//
// The response object for retrieving an individual instanced item. None of these components are
// relevant for an item that doesn't have an "itemInstanceId": for those, get your information from the
// DestinyInventoryDefinition.
type ItemResponse struct {
	// {
	//   "description": "The response object for retrieving an individual instanced item. None of these components are relevant for an item that doesn't have an \"itemInstanceId\": for those, get your information from the DestinyInventoryDefinition.",
	//   "properties": {
	//     "characterId": {
	//       "description": "If the item is on a character, this will return the ID of the character that is holding the item.",
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "instance": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyItemInstanceComponent"
	//         }
	//       ],
	//       "description": "Basic instance data for the item.\r\nCOMPONENT TYPE: ItemInstances",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ItemInstances"
	//     },
	//     "item": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyItemComponent"
	//         }
	//       ],
	//       "description": "Common data for the item relevant to its non-instanced properties.\r\nCOMPONENT TYPE: ItemCommonData",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ItemCommonData"
	//     },
	//     "objectives": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyItemObjectivesComponent"
	//         }
	//       ],
	//       "description": "Information specifically about the item's objectives.\r\nCOMPONENT TYPE: ItemObjectives",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ItemObjectives"
	//     },
	//     "perks": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyItemPerksComponent"
	//         }
	//       ],
	//       "description": "Information specifically about the perks currently active on the item.\r\nCOMPONENT TYPE: ItemPerks",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ItemPerks"
	//     },
	//     "plugObjectives": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyItemPlugObjectivesComponent"
	//         }
	//       ],
	//       "description": "Information about objectives on Plugs for a given item. See the component's documentation for more info.\r\nCOMPONENT TYPE: ItemPlugObjectives",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ItemPlugObjectives"
	//     },
	//     "renderData": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyItemRenderComponent"
	//         }
	//       ],
	//       "description": "Information about how to render the item in 3D.\r\nCOMPONENT TYPE: ItemRenderData",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ItemRenderData"
	//     },
	//     "reusablePlugs": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyItemReusablePlugsComponent"
	//         }
	//       ],
	//       "description": "Information about the Reusable Plugs for sockets on an item. These are plugs that you can insert into the given socket regardless of if you actually own an instance of that plug: they are logic-driven plugs rather than inventory-driven.\r\n These may need to be combined with Plug Set component data to get a full picture of available plugs on a given socket.\r\n COMPONENT TYPE: ItemReusablePlugs",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ItemReusablePlugs"
	//     },
	//     "sockets": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyItemSocketsComponent"
	//         }
	//       ],
	//       "description": "Information about the sockets of the item: which are currently active, what potential sockets you could have and the stats/abilities/perks you can gain from them.\r\nCOMPONENT TYPE: ItemSockets",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ItemSockets"
	//     },
	//     "stats": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyItemStatsComponent"
	//         }
	//       ],
	//       "description": "Information about the computed stats of the item: power, defense, etc...\r\nCOMPONENT TYPE: ItemStats",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ItemStats"
	//     },
	//     "talentGrid": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyItemTalentGridComponent"
	//         }
	//       ],
	//       "description": "Information about the talent grid attached to the item. Talent nodes can provide a variety of benefits and abilities, and in Destiny 2 are used almost exclusively for the character's \"Builds\".\r\nCOMPONENT TYPE: ItemTalentGrids",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ItemTalentGrids"
	//     }
	//   },
	//   "type": "object"
	// }

	// If the item is on a character, this will return the ID of the character that is holding the item.
	CharacterID Nullable[Int64] `json:"characterId,omitempty"`

	// Basic instance data for the item.
	// COMPONENT TYPE: ItemInstances
	Instance ComponentResponse[ItemInstanceComponent] `json:"instance"`

	// Common data for the item relevant to its non-instanced properties.
	// COMPONENT TYPE: ItemCommonData
	Item ComponentResponse[ItemComponent] `json:"item"`

	// Information specifically about the item's objectives.
	// COMPONENT TYPE: ItemObjectives
	Objectives ComponentResponse[ItemObjectivesComponent] `json:"objectives"`

	// Information specifically about the perks currently active on the item.
	// COMPONENT TYPE: ItemPerks
	Perks ComponentResponse[ItemPerksComponent] `json:"perks"`

	// Information about objectives on Plugs for a given item. See the component's documentation for more
	// info.
	// COMPONENT TYPE: ItemPlugObjectives
	PlugObjectives ComponentResponse[ItemPlugObjectivesComponent] `json:"plugObjectives"`

	// Information about how to render the item in 3D.
	// COMPONENT TYPE: ItemRenderData
	RenderData ComponentResponse[ItemRenderComponent] `json:"renderData"`

	// Information about the Reusable Plugs for sockets on an item. These are plugs that you can insert
	// into the given socket regardless of if you actually own an instance of that plug: they are
	// logic-driven plugs rather than inventory-driven.
	//
	//	These may need to be combined with Plug Set component data to get a full picture of available plugs
	//
	// on a given socket.
	//
	//	COMPONENT TYPE: ItemReusablePlugs
	ReusablePlugs ComponentResponse[ItemReusablePlugsComponent] `json:"reusablePlugs"`

	// Information about the sockets of the item: which are currently active, what potential sockets you
	// could have and the stats/abilities/perks you can gain from them.
	// COMPONENT TYPE: ItemSockets
	Sockets ComponentResponse[ItemSocketsComponent] `json:"sockets"`

	// Information about the computed stats of the item: power, defense, etc...
	// COMPONENT TYPE: ItemStats
	Stats ComponentResponse[ItemStatsComponent] `json:"stats"`

	// Information about the talent grid attached to the item. Talent nodes can provide a variety of
	// benefits and abilities, and in Destiny 2 are used almost exclusively for the character's "Builds".
	// COMPONENT TYPE: ItemTalentGrids
	TalentGrid ComponentResponse[ItemTalentGridComponent] `json:"talentGrid"`
}

// Destiny.Responses.DestinyLinkedProfilesResponse
//
// I know what you seek. You seek linked accounts. Found them, you have.
// This contract returns a minimal amount of data about Destiny Accounts that are linked through your
// Bungie.Net account. We will not return accounts in this response whose
type LinkedProfilesResponse struct {
	// {
	//   "description": "I know what you seek. You seek linked accounts. Found them, you have.\r\nThis contract returns a minimal amount of data about Destiny Accounts that are linked through your Bungie.Net account. We will not return accounts in this response whose",
	//   "properties": {
	//     "bnetMembership": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/User.UserInfoCard"
	//         }
	//       ],
	//       "description": "If the requested membership had a linked Bungie.Net membership ID, this is the basic information about that BNet account.\r\nI know, Tetron; I know this is mixing UserServices concerns with DestinyServices concerns. But it's so damn convenient! https://www.youtube.com/watch?v=X5R-bB-gKVI",
	//       "type": "object"
	//     },
	//     "profiles": {
	//       "description": "Any Destiny account for whom we could successfully pull characters will be returned here, as the Platform-level summary of user data. (no character data, no Destiny account data other than the Membership ID and Type so you can make further queries)",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Responses.DestinyProfileUserInfoCard"
	//       },
	//       "type": "array"
	//     },
	//     "profilesWithErrors": {
	//       "description": "This is brief summary info for profiles that we believe have valid Destiny info, but who failed to return data for some other reason and thus we know that subsequent calls for their info will also fail.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Responses.DestinyErrorProfile"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// If the requested membership had a linked Bungie.Net membership ID, this is the basic information
	// about that BNet account.
	// I know, Tetron; I know this is mixing UserServices concerns with DestinyServices concerns. But it's
	// so damn convenient! https://www.youtube.com/watch?v=X5R-bB-gKVI
	BnetMembership UserInfoCard `json:"bnetMembership"`

	// Any Destiny account for whom we could successfully pull characters will be returned here, as the
	// Platform-level summary of user data. (no character data, no Destiny account data other than the
	// Membership ID and Type so you can make further queries)
	Profiles []ProfileUserInfoCard `json:"profiles"`

	// This is brief summary info for profiles that we believe have valid Destiny info, but who failed to
	// return data for some other reason and thus we know that subsequent calls for their info will also
	// fail.
	ProfilesWithErrors []ErrorProfile `json:"profilesWithErrors"`
}

// Destiny.Responses.DestinyProfileResponse
//
// The response for GetDestinyProfile, with components for character and item-level data.
type ProfileResponse struct {
	// {
	//   "description": "The response for GetDestinyProfile, with components for character and item-level data.",
	//   "properties": {
	//     "characterActivities": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint64AndDestinyCharacterActivitiesComponent"
	//         }
	//       ],
	//       "description": "Character activity data - the activities available to this character and its status, keyed by the Character's Id.\r\nCOMPONENT TYPE: CharacterActivities",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CharacterActivities"
	//     },
	//     "characterCollectibles": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint64AndDestinyCollectiblesComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: Collectibles",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Collectibles"
	//     },
	//     "characterCraftables": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint64AndDestinyCraftablesComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: Craftables",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Craftables"
	//     },
	//     "characterCurrencyLookups": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint64AndDestinyCurrenciesComponent"
	//         }
	//       ],
	//       "description": "A \"lookup\" convenience component that can be used to quickly check if the character has access to items that can be used for purchasing.\r\nCOMPONENT TYPE: CurrencyLookups",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CurrencyLookups"
	//     },
	//     "characterEquipment": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint64AndDestinyInventoryComponent"
	//         }
	//       ],
	//       "description": "The character's equipped items, keyed by the Character's Id.\r\nCOMPONENT TYPE: CharacterEquipment",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CharacterEquipment"
	//     },
	//     "characterInventories": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint64AndDestinyInventoryComponent"
	//         }
	//       ],
	//       "description": "The character-level non-equipped inventory items, keyed by the Character's Id.\r\nCOMPONENT TYPE: CharacterInventories",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CharacterInventories"
	//     },
	//     "characterKiosks": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint64AndDestinyKiosksComponent"
	//         }
	//       ],
	//       "description": "Items available from Kiosks that are available to a specific character as opposed to the account as a whole. It must be combined with data from the profileKiosks property to get a full picture of the character's available items to check out of a kiosk.\r\nThis component returns information about what Kiosk items are available to you on a *Character* level. Usually, kiosk items will be earned for the entire Profile (all characters) at once. To find those, look in the profileKiosks property.\r\nCOMPONENT TYPE: Kiosks",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Kiosks"
	//     },
	//     "characterLoadouts": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint64AndDestinyLoadoutsComponent"
	//         }
	//       ],
	//       "description": "The character loadouts, keyed by the Character's Id.\r\nCOMPONENT TYPE: CharacterLoadouts",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CharacterLoadouts"
	//     },
	//     "characterPlugSets": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint64AndDestinyPlugSetsComponent"
	//         }
	//       ],
	//       "description": "When sockets refer to reusable Plug Sets (see DestinyPlugSetDefinition for more info), this is the set of plugs and their states, per character, that are character-scoped.\r\nThis comes back with ItemSockets, as it is needed for a complete picture of the sockets on requested items.\r\nCOMPONENT TYPE: ItemSockets",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ItemSockets"
	//     },
	//     "characterPresentationNodes": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint64AndDestinyPresentationNodesComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: PresentationNodes",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "PresentationNodes"
	//     },
	//     "characterProgressions": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint64AndDestinyCharacterProgressionComponent"
	//         }
	//       ],
	//       "description": "Character-level progression data, keyed by the Character's Id.\r\nCOMPONENT TYPE: CharacterProgressions",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CharacterProgressions"
	//     },
	//     "characterRecords": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint64AndDestinyCharacterRecordsComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: Records",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Records"
	//     },
	//     "characterRenderData": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint64AndDestinyCharacterRenderComponent"
	//         }
	//       ],
	//       "description": "Character rendering data - a minimal set of info needed to render a character in 3D - keyed by the Character's Id.\r\nCOMPONENT TYPE: CharacterRenderData",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CharacterRenderData"
	//     },
	//     "characterStringVariables": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint64AndDestinyStringVariablesComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: StringVariables",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "StringVariables"
	//     },
	//     "characterUninstancedItemComponents": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/DestinyBaseItemComponentSetOfuint32"
	//       },
	//       "description": "Do you ever get the feeling that a system was designed *too* flexibly? That it can be used in so many different ways that you end up being unable to provide an easy to use abstraction for the mess that's happening under the surface?\r\nLet's talk about character-specific data that might be related to items without instances. These two statements are totally unrelated, I promise.\r\nAt some point during D2, it was decided that items - such as Bounties - could be given to characters and *not* have instance data, but that *could* display and even use relevant state information on your account and character.\r\nUp to now, any item that had meaningful dependencies on character or account state had to be instanced, and thus \"itemComponents\" was all that you needed: it was keyed by item's instance IDs and provided the stateful information you needed inside.\r\nUnfortunately, we don't live in such a magical world anymore. This is information held on a per-character basis about non-instanced items that the characters have in their inventory - or that reference character-specific state information even if it's in Account-level inventory - and the values related to that item's state in relation to the given character.\r\nTo give a concrete example, look at a Moments of Triumph bounty. They exist in a character's inventory, and show/care about a character's progression toward completing the bounty. But the bounty itself is a non-instanced item, like a mod or a currency. This returns that data for the characters who have the bounty in their inventory.\r\nI'm not crying, you're crying Okay we're both crying but it's going to be okay I promise Actually I shouldn't promise that, I don't know if it's going to be okay",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "int64",
	//         "type": "integer"
	//       }
	//     },
	//     "characters": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint64AndDestinyCharacterComponent"
	//         }
	//       ],
	//       "description": "Basic information about each character, keyed by the CharacterId.\r\nCOMPONENT TYPE: Characters",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Characters"
	//     },
	//     "itemComponents": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DestinyItemComponentSetOfint64"
	//         }
	//       ],
	//       "description": "Information about instanced items across all returned characters, keyed by the item's instance ID.\r\nCOMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component types.]",
	//       "type": "object"
	//     },
	//     "metrics": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyMetricsComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: Metrics",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Metrics"
	//     },
	//     "platformSilver": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyPlatformSilverComponent"
	//         }
	//       ],
	//       "description": "Silver quantities for any platform on which this Profile plays destiny.\r\n COMPONENT TYPE: PlatformSilver",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "PlatformSilver"
	//     },
	//     "profile": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyProfileComponent"
	//         }
	//       ],
	//       "description": "The basic information about the Destiny Profile (formerly \"Account\").\r\nCOMPONENT TYPE: Profiles",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Profiles"
	//     },
	//     "profileCollectibles": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyProfileCollectiblesComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: Collectibles",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Collectibles"
	//     },
	//     "profileCommendations": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinySocialCommendationsComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: SocialCommendations",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "SocialCommendations"
	//     },
	//     "profileCurrencies": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyInventoryComponent"
	//         }
	//       ],
	//       "description": "The profile-level currencies owned by the Destiny Profile.\r\nCOMPONENT TYPE: ProfileCurrencies",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ProfileCurrencies"
	//     },
	//     "profileInventory": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyInventoryComponent"
	//         }
	//       ],
	//       "description": "The profile-level inventory of the Destiny Profile.\r\nCOMPONENT TYPE: ProfileInventories",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ProfileInventories"
	//     },
	//     "profileKiosks": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyKiosksComponent"
	//         }
	//       ],
	//       "description": "Items available from Kiosks that are available Profile-wide (i.e. across all characters)\r\nThis component returns information about what Kiosk items are available to you on a *Profile* level. It is theoretically possible for Kiosks to have items gated by specific Character as well. If you ever have those, you will find them on the characterKiosks property.\r\nCOMPONENT TYPE: Kiosks",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Kiosks"
	//     },
	//     "profilePlugSets": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyPlugSetsComponent"
	//         }
	//       ],
	//       "description": "When sockets refer to reusable Plug Sets (see DestinyPlugSetDefinition for more info), this is the set of plugs and their states that are profile-scoped.\r\nThis comes back with ItemSockets, as it is needed for a complete picture of the sockets on requested items.\r\nCOMPONENT TYPE: ItemSockets",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ItemSockets"
	//     },
	//     "profilePresentationNodes": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyPresentationNodesComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: PresentationNodes",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "PresentationNodes"
	//     },
	//     "profileProgression": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyProfileProgressionComponent"
	//         }
	//       ],
	//       "description": "When we have progression information - such as Checklists - that may apply profile-wide, it will be returned here rather than in the per-character progression data.\r\nCOMPONENT TYPE: ProfileProgression",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "ProfileProgression"
	//     },
	//     "profileRecords": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyProfileRecordsComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: Records",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Records"
	//     },
	//     "profileStringVariables": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyStringVariablesComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: StringVariables",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "StringVariables"
	//     },
	//     "profileTransitoryData": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyProfileTransitoryComponent"
	//         }
	//       ],
	//       "description": "COMPONENT TYPE: Transitory",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Transitory"
	//     },
	//     "responseMintedTimestamp": {
	//       "description": "Records the timestamp of when most components were last generated from the world server source. Unless the component type is specified in the documentation for secondaryComponentsMintedTimestamp, this value is sufficient to do data freshness.",
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "secondaryComponentsMintedTimestamp": {
	//       "description": "Some secondary components are not tracked in the primary response timestamp and have their timestamp tracked here. If your component is any of the following, this field is where you will find your timestamp value:\r\n PresentationNodes, Records, Collectibles, Metrics, StringVariables, Craftables, Transitory\r\n All other component types may use the primary timestamp property.",
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "vendorReceipts": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyVendorReceiptsComponent"
	//         }
	//       ],
	//       "description": "Recent, refundable purchases you have made from vendors. When will you use it? Couldn't say...\r\nCOMPONENT TYPE: VendorReceipts",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "VendorReceipts"
	//     }
	//   },
	//   "type": "object"
	// }

	// Character activity data - the activities available to this character and its status, keyed by the
	// Character's Id.
	// COMPONENT TYPE: CharacterActivities
	CharacterActivities ComponentResponse[map[Int64]CharacterActivitiesComponent] `json:"characterActivities"`

	// COMPONENT TYPE: Collectibles
	CharacterCollectibles ComponentResponse[map[Int64]CollectiblesComponent] `json:"characterCollectibles"`

	// COMPONENT TYPE: Craftables
	CharacterCraftables ComponentResponse[map[Int64]CraftablesComponent] `json:"characterCraftables"`

	// A "lookup" convenience component that can be used to quickly check if the character has access to
	// items that can be used for purchasing.
	// COMPONENT TYPE: CurrencyLookups
	CharacterCurrencyLookups ComponentResponse[map[Int64]CurrenciesComponent] `json:"characterCurrencyLookups"`

	// The character's equipped items, keyed by the Character's Id.
	// COMPONENT TYPE: CharacterEquipment
	CharacterEquipment ComponentResponse[map[Int64]InventoryComponent] `json:"characterEquipment"`

	// The character-level non-equipped inventory items, keyed by the Character's Id.
	// COMPONENT TYPE: CharacterInventories
	CharacterInventories ComponentResponse[map[Int64]InventoryComponent] `json:"characterInventories"`

	// Items available from Kiosks that are available to a specific character as opposed to the account as
	// a whole. It must be combined with data from the profileKiosks property to get a full picture of the
	// character's available items to check out of a kiosk.
	// This component returns information about what Kiosk items are available to you on a *Character*
	// level. Usually, kiosk items will be earned for the entire Profile (all characters) at once. To find
	// those, look in the profileKiosks property.
	// COMPONENT TYPE: Kiosks
	CharacterKiosks ComponentResponse[map[Int64]KiosksComponent] `json:"characterKiosks"`

	// The character loadouts, keyed by the Character's Id.
	// COMPONENT TYPE: CharacterLoadouts
	CharacterLoadouts ComponentResponse[map[Int64]LoadoutsComponent] `json:"characterLoadouts"`

	// When sockets refer to reusable Plug Sets (see DestinyPlugSetDefinition for more info), this is the
	// set of plugs and their states, per character, that are character-scoped.
	// This comes back with ItemSockets, as it is needed for a complete picture of the sockets on requested
	// items.
	// COMPONENT TYPE: ItemSockets
	CharacterPlugSets ComponentResponse[map[Int64]PlugSetsComponent] `json:"characterPlugSets"`

	// COMPONENT TYPE: PresentationNodes
	CharacterPresentationNodes ComponentResponse[map[Int64]PresentationNodesComponent] `json:"characterPresentationNodes"`

	// Character-level progression data, keyed by the Character's Id.
	// COMPONENT TYPE: CharacterProgressions
	CharacterProgressions ComponentResponse[map[Int64]CharacterProgressionComponent] `json:"characterProgressions"`

	// COMPONENT TYPE: Records
	CharacterRecords ComponentResponse[map[Int64]CharacterRecordsComponent] `json:"characterRecords"`

	// Character rendering data - a minimal set of info needed to render a character in 3D - keyed by the
	// Character's Id.
	// COMPONENT TYPE: CharacterRenderData
	CharacterRenderData ComponentResponse[map[Int64]CharacterRenderComponent] `json:"characterRenderData"`

	// COMPONENT TYPE: StringVariables
	CharacterStringVariables ComponentResponse[map[Int64]StringVariablesComponent] `json:"characterStringVariables"`

	// Do you ever get the feeling that a system was designed *too* flexibly? That it can be used in so
	// many different ways that you end up being unable to provide an easy to use abstraction for the mess
	// that's happening under the surface?
	// Let's talk about character-specific data that might be related to items without instances. These two
	// statements are totally unrelated, I promise.
	// At some point during D2, it was decided that items - such as Bounties - could be given to characters
	// and *not* have instance data, but that *could* display and even use relevant state information on
	// your account and character.
	// Up to now, any item that had meaningful dependencies on character or account state had to be
	// instanced, and thus "itemComponents" was all that you needed: it was keyed by item's instance IDs
	// and provided the stateful information you needed inside.
	// Unfortunately, we don't live in such a magical world anymore. This is information held on a
	// per-character basis about non-instanced items that the characters have in their inventory - or that
	// reference character-specific state information even if it's in Account-level inventory - and the
	// values related to that item's state in relation to the given character.
	// To give a concrete example, look at a Moments of Triumph bounty. They exist in a character's
	// inventory, and show/care about a character's progression toward completing the bounty. But the
	// bounty itself is a non-instanced item, like a mod or a currency. This returns that data for the
	// characters who have the bounty in their inventory.
	// I'm not crying, you're crying Okay we're both crying but it's going to be okay I promise Actually I
	// shouldn't promise that, I don't know if it's going to be okay
	CharacterUninstancedItemComponents map[Int64]BaseItemComponentSet[uint32] `json:"characterUninstancedItemComponents"`

	// Basic information about each character, keyed by the CharacterId.
	// COMPONENT TYPE: Characters
	Characters ComponentResponse[map[Int64]CharacterComponent] `json:"characters"`

	// Information about instanced items across all returned characters, keyed by the item's instance ID.
	// COMPONENT TYPE: [See inside the DestinyItemComponentSet contract for component types.]
	ItemComponents ItemComponentSet[int64] `json:"itemComponents"`

	// COMPONENT TYPE: Metrics
	Metrics ComponentResponse[MetricsComponent] `json:"metrics"`

	// Silver quantities for any platform on which this Profile plays destiny.
	//
	//	COMPONENT TYPE: PlatformSilver
	PlatformSilver ComponentResponse[PlatformSilverComponent] `json:"platformSilver"`

	// The basic information about the Destiny Profile (formerly "Account").
	// COMPONENT TYPE: Profiles
	Profile ComponentResponse[ProfileComponent] `json:"profile"`

	// COMPONENT TYPE: Collectibles
	ProfileCollectibles ComponentResponse[ProfileCollectiblesComponent] `json:"profileCollectibles"`

	// COMPONENT TYPE: SocialCommendations
	ProfileCommendations ComponentResponse[SocialCommendationsComponent] `json:"profileCommendations"`

	// The profile-level currencies owned by the Destiny Profile.
	// COMPONENT TYPE: ProfileCurrencies
	ProfileCurrencies ComponentResponse[InventoryComponent] `json:"profileCurrencies"`

	// The profile-level inventory of the Destiny Profile.
	// COMPONENT TYPE: ProfileInventories
	ProfileInventory ComponentResponse[InventoryComponent] `json:"profileInventory"`

	// Items available from Kiosks that are available Profile-wide (i.e. across all characters)
	// This component returns information about what Kiosk items are available to you on a *Profile* level.
	// It is theoretically possible for Kiosks to have items gated by specific Character as well. If you
	// ever have those, you will find them on the characterKiosks property.
	// COMPONENT TYPE: Kiosks
	ProfileKiosks ComponentResponse[KiosksComponent] `json:"profileKiosks"`

	// When sockets refer to reusable Plug Sets (see DestinyPlugSetDefinition for more info), this is the
	// set of plugs and their states that are profile-scoped.
	// This comes back with ItemSockets, as it is needed for a complete picture of the sockets on requested
	// items.
	// COMPONENT TYPE: ItemSockets
	ProfilePlugSets ComponentResponse[PlugSetsComponent] `json:"profilePlugSets"`

	// COMPONENT TYPE: PresentationNodes
	ProfilePresentationNodes ComponentResponse[PresentationNodesComponent] `json:"profilePresentationNodes"`

	// When we have progression information - such as Checklists - that may apply profile-wide, it will be
	// returned here rather than in the per-character progression data.
	// COMPONENT TYPE: ProfileProgression
	ProfileProgression ComponentResponse[ProfileProgressionComponent] `json:"profileProgression"`

	// COMPONENT TYPE: Records
	ProfileRecords ComponentResponse[ProfileRecordsComponent] `json:"profileRecords"`

	// COMPONENT TYPE: StringVariables
	ProfileStringVariables ComponentResponse[StringVariablesComponent] `json:"profileStringVariables"`

	// COMPONENT TYPE: Transitory
	ProfileTransitoryData ComponentResponse[ProfileTransitoryComponent] `json:"profileTransitoryData"`

	// Records the timestamp of when most components were last generated from the world server source.
	// Unless the component type is specified in the documentation for secondaryComponentsMintedTimestamp,
	// this value is sufficient to do data freshness.
	ResponseMintedTimestamp Timestamp `json:"responseMintedTimestamp"`

	// Some secondary components are not tracked in the primary response timestamp and have their timestamp
	// tracked here. If your component is any of the following, this field is where you will find your
	// timestamp value:
	//
	//	PresentationNodes, Records, Collectibles, Metrics, StringVariables, Craftables, Transitory
	//	All other component types may use the primary timestamp property.
	SecondaryComponentsMintedTimestamp Timestamp `json:"secondaryComponentsMintedTimestamp"`

	// Recent, refundable purchases you have made from vendors. When will you use it? Couldn't say...
	// COMPONENT TYPE: VendorReceipts
	VendorReceipts ComponentResponse[VendorReceiptsComponent] `json:"vendorReceipts"`
}

// Destiny.Responses.DestinyProfileUserInfoCard
type ProfileUserInfoCard struct {
	// {
	//   "properties": {
	//     "applicableMembershipTypes": {
	//       "description": "The list of Membership Types indicating the platforms on which this Membership can be used.\r\n Not in Cross Save = its original membership type. Cross Save Primary = Any membership types it is overridding, and its original membership type Cross Save Overridden = Empty list",
	//       "items": {
	//         "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/BungieMembershipType"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "bungieGlobalDisplayName": {
	//       "description": "The bungie global display name, if set.",
	//       "type": "string"
	//     },
	//     "bungieGlobalDisplayNameCode": {
	//       "description": "The bungie global display name code, if set.",
	//       "format": "int16",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "crossSaveOverride": {
	//       "description": "If there is a cross save override in effect, this value will tell you the type that is overridding this one.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "dateLastPlayed": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "displayName": {
	//       "description": "Display Name the player has chosen for themselves. The display name is optional when the data type is used as input to a platform API.",
	//       "type": "string"
	//     },
	//     "iconPath": {
	//       "description": "URL the Icon if available.",
	//       "type": "string"
	//     },
	//     "isCrossSavePrimary": {
	//       "description": "If true, this account is hooked up as the \"Primary\" cross save account for one or more platforms.",
	//       "type": "boolean"
	//     },
	//     "isOverridden": {
	//       "description": "If this profile is being overridden/obscured by Cross Save, this will be set to true. We will still return the profile for display purposes where users need to know the info: it is up to any given area of the app/site to determine if this profile should still be shown.",
	//       "type": "boolean"
	//     },
	//     "isPublic": {
	//       "description": "If True, this is a public user membership.",
	//       "type": "boolean"
	//     },
	//     "membershipId": {
	//       "description": "Membership ID as they user is known in the Accounts service",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "description": "Type of the membership. Not necessarily the native type.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "platformSilver": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Components.Inventory.DestinyPlatformSilverComponent"
	//         }
	//       ],
	//       "description": "This is the silver available on this Profile across any platforms on which they have purchased silver.\r\n This is only available if you are requesting yourself.",
	//       "type": "object"
	//     },
	//     "supplementalDisplayName": {
	//       "description": "A platform specific additional display name - ex: psn Real Name, bnet Unique Name, etc.",
	//       "type": "string"
	//     },
	//     "unpairedGameVersions": {
	//       "description": "If this profile is not in a cross save pairing, this will return the game versions that we believe this profile has access to.\r\n For the time being, we will not return this information for any membership that is in a cross save pairing. The gist is that, once the pairing occurs, we do not currently have a consistent way to get that information for the profile's original Platform, and thus gameVersions would be too inconsistent (based on the last platform they happened to play on) for the info to be useful.\r\n If we ever can get this data, this field will be deprecated and replaced with data on the DestinyLinkedProfileResponse itself, with game versions per linked Platform. But since we can't get that, we have this as a stop-gap measure for getting the data in the only situation that we currently need it.",
	//       "enum": [
	//         "0",
	//         "1",
	//         "2",
	//         "4",
	//         "8",
	//         "16",
	//         "32",
	//         "64",
	//         "128",
	//         "256",
	//         "512",
	//         "1024"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-values": [
	//         {
	//           "identifier": "None",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Destiny2",
	//           "numericValue": "1"
	//         },
	//         {
	//           "identifier": "DLC1",
	//           "numericValue": "2"
	//         },
	//         {
	//           "identifier": "DLC2",
	//           "numericValue": "4"
	//         },
	//         {
	//           "identifier": "Forsaken",
	//           "numericValue": "8"
	//         },
	//         {
	//           "identifier": "YearTwoAnnualPass",
	//           "numericValue": "16"
	//         },
	//         {
	//           "identifier": "Shadowkeep",
	//           "numericValue": "32"
	//         },
	//         {
	//           "identifier": "BeyondLight",
	//           "numericValue": "64"
	//         },
	//         {
	//           "identifier": "Anniversary30th",
	//           "numericValue": "128"
	//         },
	//         {
	//           "identifier": "TheWitchQueen",
	//           "numericValue": "256"
	//         },
	//         {
	//           "identifier": "Lightfall",
	//           "numericValue": "512"
	//         },
	//         {
	//           "identifier": "TheFinalShape",
	//           "numericValue": "1024"
	//         }
	//       ]
	//     }
	//   },
	//   "type": "object"
	// }

	// The list of Membership Types indicating the platforms on which this Membership can be used.
	//
	//	Not in Cross Save = its original membership type. Cross Save Primary = Any membership types it is
	//
	// overridding, and its original membership type Cross Save Overridden = Empty list
	ApplicableMembershipTypes []BungieMembershipType `json:"applicableMembershipTypes"`

	// The bungie global display name, if set.
	BungieGlobalDisplayName string `json:"bungieGlobalDisplayName"`

	// The bungie global display name code, if set.
	BungieGlobalDisplayNameCode Nullable[int16] `json:"bungieGlobalDisplayNameCode,omitempty"`

	// If there is a cross save override in effect, this value will tell you the type that is overridding
	// this one.
	CrossSaveOverride BungieMembershipType `json:"crossSaveOverride"`

	DateLastPlayed Timestamp `json:"dateLastPlayed"`

	// Display Name the player has chosen for themselves. The display name is optional when the data type
	// is used as input to a platform API.
	DisplayName string `json:"displayName"`

	// URL the Icon if available.
	IconPath string `json:"iconPath"`

	// If true, this account is hooked up as the "Primary" cross save account for one or more platforms.
	IsCrossSavePrimary bool `json:"isCrossSavePrimary"`

	// If this profile is being overridden/obscured by Cross Save, this will be set to true. We will still
	// return the profile for display purposes where users need to know the info: it is up to any given
	// area of the app/site to determine if this profile should still be shown.
	IsOverridden bool `json:"isOverridden"`

	// If True, this is a public user membership.
	IsPublic bool `json:"isPublic"`

	// Membership ID as they user is known in the Accounts service
	MembershipID Int64 `json:"membershipId"`

	// Type of the membership. Not necessarily the native type.
	MembershipType BungieMembershipType `json:"membershipType"`

	// This is the silver available on this Profile across any platforms on which they have purchased
	// silver.
	//
	//	This is only available if you are requesting yourself.
	PlatformSilver PlatformSilverComponent `json:"platformSilver"`

	// A platform specific additional display name - ex: psn Real Name, bnet Unique Name, etc.
	SupplementalDisplayName string `json:"supplementalDisplayName"`

	// If this profile is not in a cross save pairing, this will return the game versions that we believe
	// this profile has access to.
	//
	//	For the time being, we will not return this information for any membership that is in a cross save
	//
	// pairing. The gist is that, once the pairing occurs, we do not currently have a consistent way to get
	// that information for the profile's original Platform, and thus gameVersions would be too
	// inconsistent (based on the last platform they happened to play on) for the info to be useful.
	//
	//	If we ever can get this data, this field will be deprecated and replaced with data on the
	//
	// DestinyLinkedProfileResponse itself, with game versions per linked Platform. But since we can't get
	// that, we have this as a stop-gap measure for getting the data in the only situation that we
	// currently need it.
	UnpairedGameVersions Nullable[int32] `json:"unpairedGameVersions,omitempty"`
}

// Destiny.Responses.DestinyPublicVendorsResponse
//
// A response containing all valid components for the public Vendors endpoint.
//
//	It is a decisively smaller subset of data compared to what we can get when we know the specific
//
// user making the request.
//
//	If you want any of the other data - item details, whether or not you can buy it, etc... you'll have
//
// to call in the context of a character. I know, sad but true.
type PublicVendorsResponse struct {
	// {
	//   "description": "A response containing all valid components for the public Vendors endpoint.\r\n It is a decisively smaller subset of data compared to what we can get when we know the specific user making the request.\r\n If you want any of the other data - item details, whether or not you can buy it, etc... you'll have to call in the context of a character. I know, sad but true.",
	//   "properties": {
	//     "categories": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfuint32AndDestinyVendorCategoriesComponent"
	//         }
	//       ],
	//       "description": "Categories that the vendor has available, and references to the sales therein. These are keyed by the Vendor Hash, so you will get one Categories Component per vendor returned.\r\nCOMPONENT TYPE: VendorCategories",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "VendorCategories"
	//     },
	//     "sales": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfuint32AndPublicDestinyVendorSaleItemSetComponent"
	//         }
	//       ],
	//       "description": "Sales, keyed by the vendorItemIndex of the item being sold. These are keyed by the Vendor Hash, so you will get one Sale Item Set Component per vendor returned.\r\nNote that within the Sale Item Set component, the sales are themselves keyed by the vendorSaleIndex, so you can relate it to the corrent sale item definition within the Vendor's definition.\r\nCOMPONENT TYPE: VendorSales",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "VendorSales"
	//     },
	//     "stringVariables": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyStringVariablesComponent"
	//         }
	//       ],
	//       "description": "A set of string variable values by hash for a public vendors context.\r\nCOMPONENT TYPE: StringVariables",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "StringVariables"
	//     },
	//     "vendorGroups": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyVendorGroupComponent"
	//         }
	//       ],
	//       "description": "For Vendors being returned, this will give you the information you need to group them and order them in the same way that the Bungie Companion app performs grouping. It will automatically be returned if you request the Vendors component.\r\nCOMPONENT TYPE: Vendors",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Vendors"
	//     },
	//     "vendors": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfuint32AndDestinyPublicVendorComponent"
	//         }
	//       ],
	//       "description": "The base properties of the vendor. These are keyed by the Vendor Hash, so you will get one Vendor Component per vendor returned.\r\nCOMPONENT TYPE: Vendors",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Vendors"
	//     }
	//   },
	//   "type": "object"
	// }

	// Categories that the vendor has available, and references to the sales therein. These are keyed by
	// the Vendor Hash, so you will get one Categories Component per vendor returned.
	// COMPONENT TYPE: VendorCategories
	Categories ComponentResponse[map[uint32]VendorCategoriesComponent] `json:"categories"`

	// Sales, keyed by the vendorItemIndex of the item being sold. These are keyed by the Vendor Hash, so
	// you will get one Sale Item Set Component per vendor returned.
	// Note that within the Sale Item Set component, the sales are themselves keyed by the vendorSaleIndex,
	// so you can relate it to the corrent sale item definition within the Vendor's definition.
	// COMPONENT TYPE: VendorSales
	Sales ComponentResponse[map[uint32]PublicDestinyVendorSaleItemSetComponent] `json:"sales"`

	// A set of string variable values by hash for a public vendors context.
	// COMPONENT TYPE: StringVariables
	StringVariables ComponentResponse[StringVariablesComponent] `json:"stringVariables"`

	// For Vendors being returned, this will give you the information you need to group them and order them
	// in the same way that the Bungie Companion app performs grouping. It will automatically be returned
	// if you request the Vendors component.
	// COMPONENT TYPE: Vendors
	VendorGroups ComponentResponse[VendorGroupComponent] `json:"vendorGroups"`

	// The base properties of the vendor. These are keyed by the Vendor Hash, so you will get one Vendor
	// Component per vendor returned.
	// COMPONENT TYPE: Vendors
	Vendors ComponentResponse[map[uint32]PublicVendorComponent] `json:"vendors"`
}

// Destiny.Responses.DestinyVendorResponse
//
// A response containing all of the components for a vendor.
type VendorResponse struct {
	// {
	//   "description": "A response containing all of the components for a vendor.",
	//   "properties": {
	//     "categories": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyVendorCategoriesComponent"
	//         }
	//       ],
	//       "description": "Categories that the vendor has available, and references to the sales therein.\r\nCOMPONENT TYPE: VendorCategories",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "VendorCategories"
	//     },
	//     "currencyLookups": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyCurrenciesComponent"
	//         }
	//       ],
	//       "description": "A \"lookup\" convenience component that can be used to quickly check if the character has access to items that can be used for purchasing.\r\nCOMPONENT TYPE: CurrencyLookups",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CurrencyLookups"
	//     },
	//     "itemComponents": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DestinyVendorItemComponentSetOfint32"
	//         }
	//       ],
	//       "description": "Item components, keyed by the vendorItemIndex of the active sale items.\r\nCOMPONENT TYPE: [See inside the DestinyVendorItemComponentSet contract for component types.]",
	//       "type": "object"
	//     },
	//     "sales": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfint32AndDestinyVendorSaleItemComponent"
	//         }
	//       ],
	//       "description": "Sales, keyed by the vendorItemIndex of the item being sold.\r\nCOMPONENT TYPE: VendorSales",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "VendorSales"
	//     },
	//     "stringVariables": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyStringVariablesComponent"
	//         }
	//       ],
	//       "description": "A map of string variable values by hash for this character context.\r\nCOMPONENT TYPE: StringVariables",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "StringVariables"
	//     },
	//     "vendor": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyVendorComponent"
	//         }
	//       ],
	//       "description": "The base properties of the vendor.\r\nCOMPONENT TYPE: Vendors",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Vendors"
	//     }
	//   },
	//   "type": "object"
	// }

	// Categories that the vendor has available, and references to the sales therein.
	// COMPONENT TYPE: VendorCategories
	Categories ComponentResponse[VendorCategoriesComponent] `json:"categories"`

	// A "lookup" convenience component that can be used to quickly check if the character has access to
	// items that can be used for purchasing.
	// COMPONENT TYPE: CurrencyLookups
	CurrencyLookups ComponentResponse[CurrenciesComponent] `json:"currencyLookups"`

	// Item components, keyed by the vendorItemIndex of the active sale items.
	// COMPONENT TYPE: [See inside the DestinyVendorItemComponentSet contract for component types.]
	ItemComponents VendorItemComponentSetOfint32 `json:"itemComponents"`

	// Sales, keyed by the vendorItemIndex of the item being sold.
	// COMPONENT TYPE: VendorSales
	Sales ComponentResponse[map[int32]VendorSaleItemComponent] `json:"sales"`

	// A map of string variable values by hash for this character context.
	// COMPONENT TYPE: StringVariables
	StringVariables ComponentResponse[StringVariablesComponent] `json:"stringVariables"`

	// The base properties of the vendor.
	// COMPONENT TYPE: Vendors
	Vendor ComponentResponse[VendorComponent] `json:"vendor"`
}

// Destiny.Responses.DestinyVendorsResponse
//
// A response containing all of the components for all requested vendors.
type VendorsResponse struct {
	// {
	//   "description": "A response containing all of the components for all requested vendors.",
	//   "properties": {
	//     "categories": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfuint32AndDestinyVendorCategoriesComponent"
	//         }
	//       ],
	//       "description": "Categories that the vendor has available, and references to the sales therein. These are keyed by the Vendor Hash, so you will get one Categories Component per vendor returned.\r\nCOMPONENT TYPE: VendorCategories",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "VendorCategories"
	//     },
	//     "currencyLookups": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyCurrenciesComponent"
	//         }
	//       ],
	//       "description": "A \"lookup\" convenience component that can be used to quickly check if the character has access to items that can be used for purchasing.\r\nCOMPONENT TYPE: CurrencyLookups",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "CurrencyLookups"
	//     },
	//     "itemComponents": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/DestinyVendorItemComponentSetOfint32"
	//       },
	//       "description": "The set of item detail components, one set of item components per Vendor. These are keyed by the Vendor Hash, so you will get one Item Component Set per vendor returned.\r\nThe components contained inside are themselves keyed by the vendorSaleIndex, and will have whatever item-level components you requested (Sockets, Stats, Instance data etc...) per item being sold by the vendor.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     },
	//     "sales": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfuint32AndPersonalDestinyVendorSaleItemSetComponent"
	//         }
	//       ],
	//       "description": "Sales, keyed by the vendorItemIndex of the item being sold. These are keyed by the Vendor Hash, so you will get one Sale Item Set Component per vendor returned.\r\nNote that within the Sale Item Set component, the sales are themselves keyed by the vendorSaleIndex, so you can relate it to the current sale item definition within the Vendor's definition.\r\nCOMPONENT TYPE: VendorSales",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "VendorSales"
	//     },
	//     "stringVariables": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyStringVariablesComponent"
	//         }
	//       ],
	//       "description": "A map of string variable values by hash for this character context.\r\nCOMPONENT TYPE: StringVariables",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "StringVariables"
	//     },
	//     "vendorGroups": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/SingleComponentResponseOfDestinyVendorGroupComponent"
	//         }
	//       ],
	//       "description": "For Vendors being returned, this will give you the information you need to group them and order them in the same way that the Bungie Companion app performs grouping. It will automatically be returned if you request the Vendors component.\r\nCOMPONENT TYPE: Vendors",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Vendors"
	//     },
	//     "vendors": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/DictionaryComponentResponseOfuint32AndDestinyVendorComponent"
	//         }
	//       ],
	//       "description": "The base properties of the vendor. These are keyed by the Vendor Hash, so you will get one Vendor Component per vendor returned.\r\nCOMPONENT TYPE: Vendors",
	//       "type": "object",
	//       "x-destiny-component-type-dependency": "Vendors"
	//     }
	//   },
	//   "type": "object"
	// }

	// Categories that the vendor has available, and references to the sales therein. These are keyed by
	// the Vendor Hash, so you will get one Categories Component per vendor returned.
	// COMPONENT TYPE: VendorCategories
	Categories ComponentResponse[map[uint32]VendorCategoriesComponent] `json:"categories"`

	// A "lookup" convenience component that can be used to quickly check if the character has access to
	// items that can be used for purchasing.
	// COMPONENT TYPE: CurrencyLookups
	CurrencyLookups ComponentResponse[CurrenciesComponent] `json:"currencyLookups"`

	// The set of item detail components, one set of item components per Vendor. These are keyed by the
	// Vendor Hash, so you will get one Item Component Set per vendor returned.
	// The components contained inside are themselves keyed by the vendorSaleIndex, and will have whatever
	// item-level components you requested (Sockets, Stats, Instance data etc...) per item being sold by
	// the vendor.
	ItemComponents map[uint32]VendorItemComponentSetOfint32 `json:"itemComponents"`

	// Sales, keyed by the vendorItemIndex of the item being sold. These are keyed by the Vendor Hash, so
	// you will get one Sale Item Set Component per vendor returned.
	// Note that within the Sale Item Set component, the sales are themselves keyed by the vendorSaleIndex,
	// so you can relate it to the current sale item definition within the Vendor's definition.
	// COMPONENT TYPE: VendorSales
	Sales ComponentResponse[map[uint32]PersonalDestinyVendorSaleItemSetComponent] `json:"sales"`

	// A map of string variable values by hash for this character context.
	// COMPONENT TYPE: StringVariables
	StringVariables ComponentResponse[StringVariablesComponent] `json:"stringVariables"`

	// For Vendors being returned, this will give you the information you need to group them and order them
	// in the same way that the Bungie Companion app performs grouping. It will automatically be returned
	// if you request the Vendors component.
	// COMPONENT TYPE: Vendors
	VendorGroups ComponentResponse[VendorGroupComponent] `json:"vendorGroups"`

	// The base properties of the vendor. These are keyed by the Vendor Hash, so you will get one Vendor
	// Component per vendor returned.
	// COMPONENT TYPE: Vendors
	Vendors ComponentResponse[map[uint32]VendorComponent] `json:"vendors"`
}

// Destiny.Responses.InventoryChangedResponse
//
// A response containing all of the components for all requested vendors.
type InventoryChangedResponse struct {
	// {
	//   "description": "A response containing all of the components for all requested vendors.",
	//   "properties": {
	//     "addedInventoryItems": {
	//       "description": "Items that appeared in the inventory possibly as a result of an action.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Entities.Items.DestinyItemComponent"
	//       },
	//       "type": "array"
	//     },
	//     "removedInventoryItems": {
	//       "description": "Items that disappeared from the inventory possibly as a result of an action.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Entities.Items.DestinyItemComponent"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// Items that appeared in the inventory possibly as a result of an action.
	AddedInventoryItems []ItemComponent `json:"addedInventoryItems"`

	// Items that disappeared from the inventory possibly as a result of an action.
	RemovedInventoryItems []ItemComponent `json:"removedInventoryItems"`
}

// Destiny.Responses.PersonalDestinyVendorSaleItemSetComponent
type PersonalDestinyVendorSaleItemSetComponent struct {
	// {
	//   "properties": {
	//     "saleItems": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Entities.Vendors.DestinyVendorSaleItemComponent"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "int32",
	//         "type": "integer"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "VendorSales"
	// }

	SaleItems map[int32]VendorSaleItemComponent `json:"saleItems"`
}

// Destiny.Responses.PublicDestinyVendorSaleItemSetComponent
type PublicDestinyVendorSaleItemSetComponent struct {
	// {
	//   "properties": {
	//     "saleItems": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.Components.Vendors.DestinyPublicVendorSaleItemComponent"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "int32",
	//         "type": "integer"
	//       }
	//     }
	//   },
	//   "type": "object",
	//   "x-destiny-component-type-dependency": "VendorSales"
	// }

	SaleItems map[int32]PublicVendorSaleItemComponent `json:"saleItems"`
}

// Destiny.SocketPlugSources
//
// Indicates how a socket is populated, and where you should look for valid plug data.
//
//	This is a flags enumeration/bitmask field, as you may have to look in multiple sources across
//
// multiple components for valid plugs.
//
//	For instance, a socket could have plugs that are sourced from its own definition, as well as plugs
//
// that are sourced from Character-scoped AND profile-scoped Plug Sets. Only by combining plug data for
// every indicated source will you be able to know all of the plugs available for a socket.
type SocketPlugSources int32

const (
	SocketPlugSources_None              = SocketPlugSources(0)
	SocketPlugSources_InventorySourced  = SocketPlugSources(1)
	SocketPlugSources_ReusablePlugItems = SocketPlugSources(2)
	SocketPlugSources_ProfilePlugSet    = SocketPlugSources(4)
	SocketPlugSources_CharacterPlugSet  = SocketPlugSources(8)
)

// Destiny.SocketTypeActionType
//
// Indicates the type of actions that can be performed
type SocketTypeActionType int32

const (
	SocketTypeActionType_InsertPlug         = SocketTypeActionType(0)
	SocketTypeActionType_InfuseItem         = SocketTypeActionType(1)
	SocketTypeActionType_ReinitializeSocket = SocketTypeActionType(2)
)

// Destiny.Sockets.DestinyItemPlug
type ItemPlug struct {
	// {
	//   "properties": {
	//     "canInsert": {
	//       "description": "If true, this plug has met all of its insertion requirements. Big if true.",
	//       "type": "boolean"
	//     },
	//     "enableFailIndexes": {
	//       "description": "If a plug is not enabled, this will be populated with indexes into the plug item definition's plug.enabledRules property, so that you can show the reasons why it is not enabled.\r\nThis list will be empty if the plug is enabled.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "enabled": {
	//       "description": "If true, this plug will provide its benefits while inserted.",
	//       "type": "boolean"
	//     },
	//     "insertFailIndexes": {
	//       "description": "If the plug cannot be inserted for some reason, this will have the indexes into the plug item definition's plug.insertionRules property, so you can show the reasons why it can't be inserted.\r\nThis list will be empty if the plug can be inserted.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "maxStackSize": {
	//       "description": "If available, this is the maximum stack size to display for the socket plug item.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "plugItemHash": {
	//       "description": "The hash identifier of the DestinyInventoryItemDefinition that represents this plug.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "plugObjectives": {
	//       "description": "Sometimes, Plugs may have objectives: these are often used for flavor and display purposes, but they can be used for any arbitrary purpose (both fortunately and unfortunately). Recently (with Season 2) they were expanded in use to be used as the \"gating\" for whether the plug can be inserted at all. For instance, a Plug might be tracking the number of PVP kills you have made. It will use the parent item's data about that tracking status to determine what to show, and will generally show it using the DestinyObjectiveDefinition's progressDescription property. Refer to the plug's itemHash and objective property for more information if you would like to display even more data.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Quests.DestinyObjectiveProgress"
	//       },
	//       "type": "array"
	//     },
	//     "stackSize": {
	//       "description": "If available, this is the stack size to display for the socket plug item.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// If true, this plug has met all of its insertion requirements. Big if true.
	CanInsert bool `json:"canInsert"`

	// If a plug is not enabled, this will be populated with indexes into the plug item definition's
	// plug.enabledRules property, so that you can show the reasons why it is not enabled.
	// This list will be empty if the plug is enabled.
	EnableFailIndexes []int32 `json:"enableFailIndexes"`

	// If true, this plug will provide its benefits while inserted.
	Enabled bool `json:"enabled"`

	// If the plug cannot be inserted for some reason, this will have the indexes into the plug item
	// definition's plug.insertionRules property, so you can show the reasons why it can't be inserted.
	// This list will be empty if the plug can be inserted.
	InsertFailIndexes []int32 `json:"insertFailIndexes"`

	// If available, this is the maximum stack size to display for the socket plug item.
	MaxStackSize Nullable[int32] `json:"maxStackSize,omitempty"`

	// The hash identifier of the DestinyInventoryItemDefinition that represents this plug.
	PlugItemHash Hash[InventoryItemDefinition] `json:"plugItemHash"`

	// Sometimes, Plugs may have objectives: these are often used for flavor and display purposes, but they
	// can be used for any arbitrary purpose (both fortunately and unfortunately). Recently (with Season 2)
	// they were expanded in use to be used as the "gating" for whether the plug can be inserted at all.
	// For instance, a Plug might be tracking the number of PVP kills you have made. It will use the parent
	// item's data about that tracking status to determine what to show, and will generally show it using
	// the DestinyObjectiveDefinition's progressDescription property. Refer to the plug's itemHash and
	// objective property for more information if you would like to display even more data.
	PlugObjectives []ObjectiveProgress `json:"plugObjectives"`

	// If available, this is the stack size to display for the socket plug item.
	StackSize Nullable[int32] `json:"stackSize,omitempty"`
}

// Destiny.Sockets.DestinyItemPlugBase
type ItemPlugBase struct {
	// {
	//   "properties": {
	//     "canInsert": {
	//       "description": "If true, this plug has met all of its insertion requirements. Big if true.",
	//       "type": "boolean"
	//     },
	//     "enableFailIndexes": {
	//       "description": "If a plug is not enabled, this will be populated with indexes into the plug item definition's plug.enabledRules property, so that you can show the reasons why it is not enabled.\r\nThis list will be empty if the plug is enabled.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "enabled": {
	//       "description": "If true, this plug will provide its benefits while inserted.",
	//       "type": "boolean"
	//     },
	//     "insertFailIndexes": {
	//       "description": "If the plug cannot be inserted for some reason, this will have the indexes into the plug item definition's plug.insertionRules property, so you can show the reasons why it can't be inserted.\r\nThis list will be empty if the plug can be inserted.",
	//       "items": {
	//         "format": "int32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "maxStackSize": {
	//       "description": "If available, this is the maximum stack size to display for the socket plug item.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "plugItemHash": {
	//       "description": "The hash identifier of the DestinyInventoryItemDefinition that represents this plug.",
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//       }
	//     },
	//     "stackSize": {
	//       "description": "If available, this is the stack size to display for the socket plug item.",
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// If true, this plug has met all of its insertion requirements. Big if true.
	CanInsert bool `json:"canInsert"`

	// If a plug is not enabled, this will be populated with indexes into the plug item definition's
	// plug.enabledRules property, so that you can show the reasons why it is not enabled.
	// This list will be empty if the plug is enabled.
	EnableFailIndexes []int32 `json:"enableFailIndexes"`

	// If true, this plug will provide its benefits while inserted.
	Enabled bool `json:"enabled"`

	// If the plug cannot be inserted for some reason, this will have the indexes into the plug item
	// definition's plug.insertionRules property, so you can show the reasons why it can't be inserted.
	// This list will be empty if the plug can be inserted.
	InsertFailIndexes []int32 `json:"insertFailIndexes"`

	// If available, this is the maximum stack size to display for the socket plug item.
	MaxStackSize Nullable[int32] `json:"maxStackSize,omitempty"`

	// The hash identifier of the DestinyInventoryItemDefinition that represents this plug.
	PlugItemHash Hash[InventoryItemDefinition] `json:"plugItemHash"`

	// If available, this is the stack size to display for the socket plug item.
	StackSize Nullable[int32] `json:"stackSize,omitempty"`
}

// Destiny.SpecialItemType
//
// As you run into items that need to be classified for Milestone purposes in ways that we cannot infer
// via direct data, add a new classification here and use a string constant to represent it in the
// local item config file.
// NOTE: This is not all of the item types available, and some of these are holdovers from Destiny 1
// that may or may not still exist.
type SpecialItemType int32

const (
	SpecialItemType_None             = SpecialItemType(0)
	SpecialItemType_SpecialCurrency  = SpecialItemType(1)
	SpecialItemType_Armor            = SpecialItemType(8)
	SpecialItemType_Weapon           = SpecialItemType(9)
	SpecialItemType_Engram           = SpecialItemType(23)
	SpecialItemType_Consumable       = SpecialItemType(24)
	SpecialItemType_ExchangeMaterial = SpecialItemType(25)
	SpecialItemType_MissionReward    = SpecialItemType(27)
	SpecialItemType_Currency         = SpecialItemType(29)
)

// Destiny.TierType
type TierType int32

const (
	TierType_Unknown  = TierType(0)
	TierType_Currency = TierType(1)
	TierType_Basic    = TierType(2)
	TierType_Common   = TierType(3)
	TierType_Rare     = TierType(4)
	TierType_Superior = TierType(5)
	TierType_Exotic   = TierType(6)
)

// Destiny.TransferStatuses
//
// Whether you can transfer an item, and why not if you can't.
type TransferStatuses int32

const (
	TransferStatuses_CanTransfer         = TransferStatuses(0)
	TransferStatuses_ItemIsEquipped      = TransferStatuses(1)
	TransferStatuses_NotTransferrable    = TransferStatuses(2)
	TransferStatuses_NoRoomInDestination = TransferStatuses(4)
)

// Destiny.VendorDisplayCategorySortOrder
//
// Display categories can have custom sort orders. These are the possible options.
type VendorDisplayCategorySortOrder int32

const (
	VendorDisplayCategorySortOrder_Default    = VendorDisplayCategorySortOrder(0)
	VendorDisplayCategorySortOrder_SortByTier = VendorDisplayCategorySortOrder(1)
)

// Destiny.VendorInteractionType
//
// An enumeration of the known UI interactions for Vendors.
type VendorInteractionType int32

const (
	VendorInteractionType_Unknown           = VendorInteractionType(0)
	VendorInteractionType_Undefined         = VendorInteractionType(1)
	VendorInteractionType_QuestComplete     = VendorInteractionType(2)
	VendorInteractionType_QuestContinue     = VendorInteractionType(3)
	VendorInteractionType_ReputationPreview = VendorInteractionType(4)
	VendorInteractionType_RankUpReward      = VendorInteractionType(5)
	VendorInteractionType_TokenTurnIn       = VendorInteractionType(6)
	VendorInteractionType_QuestAccept       = VendorInteractionType(7)
	VendorInteractionType_ProgressTab       = VendorInteractionType(8)
	VendorInteractionType_End               = VendorInteractionType(9)
	VendorInteractionType_Start             = VendorInteractionType(10)
)

// Destiny.VendorItemStatus
type VendorItemStatus int32

const (
	VendorItemStatus_Success               = VendorItemStatus(0)
	VendorItemStatus_NoInventorySpace      = VendorItemStatus(1)
	VendorItemStatus_NoFunds               = VendorItemStatus(2)
	VendorItemStatus_NoProgression         = VendorItemStatus(4)
	VendorItemStatus_NoUnlock              = VendorItemStatus(8)
	VendorItemStatus_NoQuantity            = VendorItemStatus(16)
	VendorItemStatus_OutsidePurchaseWindow = VendorItemStatus(32)
	VendorItemStatus_NotAvailable          = VendorItemStatus(64)
	VendorItemStatus_UniquenessViolation   = VendorItemStatus(128)
	VendorItemStatus_UnknownError          = VendorItemStatus(256)
	VendorItemStatus_AlreadySelling        = VendorItemStatus(512)
	VendorItemStatus_Unsellable            = VendorItemStatus(1024)
	VendorItemStatus_SellingInhibited      = VendorItemStatus(2048)
	VendorItemStatus_AlreadyOwned          = VendorItemStatus(4096)
	VendorItemStatus_DisplayOnly           = VendorItemStatus(8192)
)

// Destiny.Vendors.DestinyVendorReceipt
//
// If a character purchased an item that is refundable, a Vendor Receipt will be created on the user's
// Destiny Profile. These expire after a configurable period of time, but until then can be used to get
// refunds on items. BNet does not provide the ability to refund a purchase *yet*, but you know.
type VendorReceipt struct {
	// {
	//   "description": "If a character purchased an item that is refundable, a Vendor Receipt will be created on the user's Destiny Profile. These expire after a configurable period of time, but until then can be used to get refunds on items. BNet does not provide the ability to refund a purchase *yet*, but you know.",
	//   "properties": {
	//     "currencyPaid": {
	//       "description": "The amount paid for the item, in terms of items that were consumed in the purchase and their quantity.",
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.DestinyItemQuantity"
	//       },
	//       "type": "array"
	//     },
	//     "expiresOn": {
	//       "description": "The date at which this receipt is rendered invalid.",
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "itemReceived": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.DestinyItemQuantity"
	//         }
	//       ],
	//       "description": "The item that was received, and its quantity.",
	//       "type": "object"
	//     },
	//     "licenseUnlockHash": {
	//       "description": "The unlock flag used to determine whether you still have the purchased item.",
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "purchasedByCharacterId": {
	//       "description": "The ID of the character who made the purchase.",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "refundPolicy": {
	//       "description": "Whether you can get a refund, and what happens in order for the refund to be received. See the DestinyVendorItemRefundPolicy enum for details.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Destiny.DestinyVendorItemRefundPolicy"
	//       }
	//     },
	//     "sequenceNumber": {
	//       "description": "The identifier of this receipt.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "timeToExpiration": {
	//       "description": "The seconds since epoch at which this receipt is rendered invalid.",
	//       "format": "int64",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// The amount paid for the item, in terms of items that were consumed in the purchase and their
	// quantity.
	CurrencyPaid []ItemQuantity `json:"currencyPaid"`

	// The date at which this receipt is rendered invalid.
	ExpiresOn Timestamp `json:"expiresOn"`

	// The item that was received, and its quantity.
	ItemReceived ItemQuantity `json:"itemReceived"`

	// The unlock flag used to determine whether you still have the purchased item.
	LicenseUnlockHash uint32 `json:"licenseUnlockHash"`

	// The ID of the character who made the purchase.
	PurchasedByCharacterID Int64 `json:"purchasedByCharacterId"`

	// Whether you can get a refund, and what happens in order for the refund to be received. See the
	// DestinyVendorItemRefundPolicy enum for details.
	RefundPolicy VendorItemRefundPolicy `json:"refundPolicy"`

	// The identifier of this receipt.
	SequenceNumber int32 `json:"sequenceNumber"`

	// The seconds since epoch at which this receipt is rendered invalid.
	TimeToExpiration Int64 `json:"timeToExpiration"`
}

// DestinyVendorItemComponentSetOfint32
type VendorItemComponentSetOfint32 struct {
	// {
	//   "properties": {
	//     "instances": {
	//       "$ref": "#/components/schemas/DictionaryComponentResponseOfint32AndDestinyItemInstanceComponent"
	//     },
	//     "itemComponents": {
	//       "$ref": "#/components/schemas/DictionaryComponentResponseOfint32AndDestinyItemComponent"
	//     },
	//     "objectives": {
	//       "$ref": "#/components/schemas/DictionaryComponentResponseOfint32AndDestinyItemObjectivesComponent"
	//     },
	//     "perks": {
	//       "$ref": "#/components/schemas/DictionaryComponentResponseOfint32AndDestinyItemPerksComponent"
	//     },
	//     "plugObjectives": {
	//       "$ref": "#/components/schemas/DictionaryComponentResponseOfint32AndDestinyItemPlugObjectivesComponent"
	//     },
	//     "plugStates": {
	//       "$ref": "#/components/schemas/DictionaryComponentResponseOfuint32AndDestinyItemPlugComponent"
	//     },
	//     "renderData": {
	//       "$ref": "#/components/schemas/DictionaryComponentResponseOfint32AndDestinyItemRenderComponent"
	//     },
	//     "reusablePlugs": {
	//       "$ref": "#/components/schemas/DictionaryComponentResponseOfint32AndDestinyItemReusablePlugsComponent"
	//     },
	//     "sockets": {
	//       "$ref": "#/components/schemas/DictionaryComponentResponseOfint32AndDestinyItemSocketsComponent"
	//     },
	//     "stats": {
	//       "$ref": "#/components/schemas/DictionaryComponentResponseOfint32AndDestinyItemStatsComponent"
	//     },
	//     "talentGrids": {
	//       "$ref": "#/components/schemas/DictionaryComponentResponseOfint32AndDestinyItemTalentGridComponent"
	//     }
	//   },
	//   "type": "object"
	// }

	Instances ComponentResponse[map[int32]ItemInstanceComponent] `json:"instances"`

	ItemComponents ComponentResponse[map[int32]ItemComponent] `json:"itemComponents"`

	Objectives ComponentResponse[map[int32]ItemObjectivesComponent] `json:"objectives"`

	Perks ComponentResponse[map[int32]ItemPerksComponent] `json:"perks"`

	PlugObjectives ComponentResponse[map[int32]ItemPlugObjectivesComponent] `json:"plugObjectives"`

	PlugStates ComponentResponse[map[uint32]ItemPlugComponent] `json:"plugStates"`

	RenderData ComponentResponse[map[int32]ItemRenderComponent] `json:"renderData"`

	ReusablePlugs ComponentResponse[map[int32]ItemReusablePlugsComponent] `json:"reusablePlugs"`

	Sockets ComponentResponse[map[int32]ItemSocketsComponent] `json:"sockets"`

	Stats ComponentResponse[map[int32]ItemStatsComponent] `json:"stats"`

	TalentGrids ComponentResponse[map[int32]ItemTalentGridComponent] `json:"talentGrids"`
}

// Entities.EntityActionResult
type EntityActionResult struct {
	// {
	//   "properties": {
	//     "entityId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "result": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Exceptions.PlatformErrorCodes"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	EntityID Int64 `json:"entityId"`

	Result PlatformErrorCodes `json:"result"`
}

// Exceptions.PlatformErrorCodes
type PlatformErrorCodes int32

const (
	PlatformErrorCodes_None                                                      = PlatformErrorCodes(0)
	PlatformErrorCodes_Success                                                   = PlatformErrorCodes(1)
	PlatformErrorCodes_TransportException                                        = PlatformErrorCodes(2)
	PlatformErrorCodes_UnhandledException                                        = PlatformErrorCodes(3)
	PlatformErrorCodes_NotImplemented                                            = PlatformErrorCodes(4)
	PlatformErrorCodes_SystemDisabled                                            = PlatformErrorCodes(5)
	PlatformErrorCodes_FailedToLoadAvailableLocalesConfiguration                 = PlatformErrorCodes(6)
	PlatformErrorCodes_ParameterParseFailure                                     = PlatformErrorCodes(7)
	PlatformErrorCodes_ParameterInvalidRange                                     = PlatformErrorCodes(8)
	PlatformErrorCodes_BadRequest                                                = PlatformErrorCodes(9)
	PlatformErrorCodes_AuthenticationInvalid                                     = PlatformErrorCodes(10)
	PlatformErrorCodes_DataNotFound                                              = PlatformErrorCodes(11)
	PlatformErrorCodes_InsufficientPrivileges                                    = PlatformErrorCodes(12)
	PlatformErrorCodes_Duplicate                                                 = PlatformErrorCodes(13)
	PlatformErrorCodes_UnknownSqlResult                                          = PlatformErrorCodes(14)
	PlatformErrorCodes_ValidationError                                           = PlatformErrorCodes(15)
	PlatformErrorCodes_ValidationMissingFieldError                               = PlatformErrorCodes(16)
	PlatformErrorCodes_ValidationInvalidInputError                               = PlatformErrorCodes(17)
	PlatformErrorCodes_InvalidParameters                                         = PlatformErrorCodes(18)
	PlatformErrorCodes_ParameterNotFound                                         = PlatformErrorCodes(19)
	PlatformErrorCodes_UnhandledHttpException                                    = PlatformErrorCodes(20)
	PlatformErrorCodes_NotFound                                                  = PlatformErrorCodes(21)
	PlatformErrorCodes_WebAuthModuleAsyncFailed                                  = PlatformErrorCodes(22)
	PlatformErrorCodes_InvalidReturnValue                                        = PlatformErrorCodes(23)
	PlatformErrorCodes_UserBanned                                                = PlatformErrorCodes(24)
	PlatformErrorCodes_InvalidPostBody                                           = PlatformErrorCodes(25)
	PlatformErrorCodes_MissingPostBody                                           = PlatformErrorCodes(26)
	PlatformErrorCodes_ExternalServiceTimeout                                    = PlatformErrorCodes(27)
	PlatformErrorCodes_ValidationLengthError                                     = PlatformErrorCodes(28)
	PlatformErrorCodes_ValidationRangeError                                      = PlatformErrorCodes(29)
	PlatformErrorCodes_JsonDeserializationError                                  = PlatformErrorCodes(30)
	PlatformErrorCodes_ThrottleLimitExceeded                                     = PlatformErrorCodes(31)
	PlatformErrorCodes_ValidationTagError                                        = PlatformErrorCodes(32)
	PlatformErrorCodes_ValidationProfanityError                                  = PlatformErrorCodes(33)
	PlatformErrorCodes_ValidationUrlFormatError                                  = PlatformErrorCodes(34)
	PlatformErrorCodes_ThrottleLimitExceededMinutes                              = PlatformErrorCodes(35)
	PlatformErrorCodes_ThrottleLimitExceededMomentarily                          = PlatformErrorCodes(36)
	PlatformErrorCodes_ThrottleLimitExceededSeconds                              = PlatformErrorCodes(37)
	PlatformErrorCodes_ExternalServiceUnknown                                    = PlatformErrorCodes(38)
	PlatformErrorCodes_ValidationWordLengthError                                 = PlatformErrorCodes(39)
	PlatformErrorCodes_ValidationInvisibleUnicode                                = PlatformErrorCodes(40)
	PlatformErrorCodes_ValidationBadNames                                        = PlatformErrorCodes(41)
	PlatformErrorCodes_ExternalServiceFailed                                     = PlatformErrorCodes(42)
	PlatformErrorCodes_ServiceRetired                                            = PlatformErrorCodes(43)
	PlatformErrorCodes_UnknownSqlException                                       = PlatformErrorCodes(44)
	PlatformErrorCodes_UnsupportedLocale                                         = PlatformErrorCodes(45)
	PlatformErrorCodes_InvalidPageNumber                                         = PlatformErrorCodes(46)
	PlatformErrorCodes_MaximumPageSizeExceeded                                   = PlatformErrorCodes(47)
	PlatformErrorCodes_ServiceUnsupported                                        = PlatformErrorCodes(48)
	PlatformErrorCodes_ValidationMaximumUnicodeCombiningCharacters               = PlatformErrorCodes(49)
	PlatformErrorCodes_ValidationMaximumSequentialCarriageReturns                = PlatformErrorCodes(50)
	PlatformErrorCodes_PerEndpointRequestThrottleExceeded                        = PlatformErrorCodes(51)
	PlatformErrorCodes_AuthContextCacheAssertion                                 = PlatformErrorCodes(52)
	PlatformErrorCodes_ExPlatformStringValidationError                           = PlatformErrorCodes(53)
	PlatformErrorCodes_PerApplicationThrottleExceeded                            = PlatformErrorCodes(54)
	PlatformErrorCodes_PerApplicationAnonymousThrottleExceeded                   = PlatformErrorCodes(55)
	PlatformErrorCodes_PerApplicationAuthenticatedThrottleExceeded               = PlatformErrorCodes(56)
	PlatformErrorCodes_PerUserThrottleExceeded                                   = PlatformErrorCodes(57)
	PlatformErrorCodes_PayloadSignatureVerificationFailure                       = PlatformErrorCodes(58)
	PlatformErrorCodes_InvalidServiceAuthContext                                 = PlatformErrorCodes(59)
	PlatformErrorCodes_FailedMinimumAgeCheck                                     = PlatformErrorCodes(60)
	PlatformErrorCodes_ObsoleteCredentialType                                    = PlatformErrorCodes(89)
	PlatformErrorCodes_UnableToUnPairMobileApp                                   = PlatformErrorCodes(90)
	PlatformErrorCodes_UnableToPairMobileApp                                     = PlatformErrorCodes(91)
	PlatformErrorCodes_CannotUseMobileAuthWithNonMobileProvider                  = PlatformErrorCodes(92)
	PlatformErrorCodes_MissingDeviceCookie                                       = PlatformErrorCodes(93)
	PlatformErrorCodes_FacebookTokenExpired                                      = PlatformErrorCodes(94)
	PlatformErrorCodes_AuthTicketRequired                                        = PlatformErrorCodes(95)
	PlatformErrorCodes_CookieContextRequired                                     = PlatformErrorCodes(96)
	PlatformErrorCodes_UnknownAuthenticationError                                = PlatformErrorCodes(97)
	PlatformErrorCodes_BungieNetAccountCreationRequired                          = PlatformErrorCodes(98)
	PlatformErrorCodes_WebAuthRequired                                           = PlatformErrorCodes(99)
	PlatformErrorCodes_ContentUnknownSqlResult                                   = PlatformErrorCodes(100)
	PlatformErrorCodes_ContentNeedUniquePath                                     = PlatformErrorCodes(101)
	PlatformErrorCodes_ContentSqlException                                       = PlatformErrorCodes(102)
	PlatformErrorCodes_ContentNotFound                                           = PlatformErrorCodes(103)
	PlatformErrorCodes_ContentSuccessWithTagAddFail                              = PlatformErrorCodes(104)
	PlatformErrorCodes_ContentSearchMissingParameters                            = PlatformErrorCodes(105)
	PlatformErrorCodes_ContentInvalidId                                          = PlatformErrorCodes(106)
	PlatformErrorCodes_ContentPhysicalFileDeletionError                          = PlatformErrorCodes(107)
	PlatformErrorCodes_ContentPhysicalFileCreationError                          = PlatformErrorCodes(108)
	PlatformErrorCodes_ContentPerforceSubmissionError                            = PlatformErrorCodes(109)
	PlatformErrorCodes_ContentPerforceInitializationError                        = PlatformErrorCodes(110)
	PlatformErrorCodes_ContentDeploymentPackageNotReadyError                     = PlatformErrorCodes(111)
	PlatformErrorCodes_ContentUploadFailed                                       = PlatformErrorCodes(112)
	PlatformErrorCodes_ContentTooManyResults                                     = PlatformErrorCodes(113)
	PlatformErrorCodes_ContentInvalidState                                       = PlatformErrorCodes(115)
	PlatformErrorCodes_ContentNavigationParentNotFound                           = PlatformErrorCodes(116)
	PlatformErrorCodes_ContentNavigationParentUpdateError                        = PlatformErrorCodes(117)
	PlatformErrorCodes_DeploymentPackageNotEditable                              = PlatformErrorCodes(118)
	PlatformErrorCodes_ContentValidationError                                    = PlatformErrorCodes(119)
	PlatformErrorCodes_ContentPropertiesValidationError                          = PlatformErrorCodes(120)
	PlatformErrorCodes_ContentTypeNotFound                                       = PlatformErrorCodes(121)
	PlatformErrorCodes_DeploymentPackageNotFound                                 = PlatformErrorCodes(122)
	PlatformErrorCodes_ContentSearchInvalidParameters                            = PlatformErrorCodes(123)
	PlatformErrorCodes_ContentItemPropertyAggregationError                       = PlatformErrorCodes(124)
	PlatformErrorCodes_DeploymentPackageFileNotFound                             = PlatformErrorCodes(125)
	PlatformErrorCodes_ContentPerforceFileHistoryNotFound                        = PlatformErrorCodes(126)
	PlatformErrorCodes_ContentAssetZipCreationFailure                            = PlatformErrorCodes(127)
	PlatformErrorCodes_ContentAssetZipCreationBusy                               = PlatformErrorCodes(128)
	PlatformErrorCodes_ContentProjectNotFound                                    = PlatformErrorCodes(129)
	PlatformErrorCodes_ContentFolderNotFound                                     = PlatformErrorCodes(130)
	PlatformErrorCodes_ContentPackagesInconsistent                               = PlatformErrorCodes(131)
	PlatformErrorCodes_ContentPackagesInvalidState                               = PlatformErrorCodes(132)
	PlatformErrorCodes_ContentPackagesInconsistentType                           = PlatformErrorCodes(133)
	PlatformErrorCodes_ContentCannotDeletePackage                                = PlatformErrorCodes(134)
	PlatformErrorCodes_ContentLockedForChanges                                   = PlatformErrorCodes(135)
	PlatformErrorCodes_ContentFileUploadFailed                                   = PlatformErrorCodes(136)
	PlatformErrorCodes_ContentNotReviewed                                        = PlatformErrorCodes(137)
	PlatformErrorCodes_ContentPermissionDenied                                   = PlatformErrorCodes(138)
	PlatformErrorCodes_ContentInvalidExternalUrl                                 = PlatformErrorCodes(139)
	PlatformErrorCodes_ContentExternalFileCannotBeImportedLocally                = PlatformErrorCodes(140)
	PlatformErrorCodes_ContentTagSaveFailure                                     = PlatformErrorCodes(141)
	PlatformErrorCodes_ContentPerforceUnmatchedFileError                         = PlatformErrorCodes(142)
	PlatformErrorCodes_ContentPerforceChangelistResultNotFound                   = PlatformErrorCodes(143)
	PlatformErrorCodes_ContentPerforceChangelistFileItemsNotFound                = PlatformErrorCodes(144)
	PlatformErrorCodes_ContentPerforceInvalidRevisionError                       = PlatformErrorCodes(145)
	PlatformErrorCodes_ContentUnloadedSaveResult                                 = PlatformErrorCodes(146)
	PlatformErrorCodes_ContentPropertyInvalidNumber                              = PlatformErrorCodes(147)
	PlatformErrorCodes_ContentPropertyInvalidUrl                                 = PlatformErrorCodes(148)
	PlatformErrorCodes_ContentPropertyInvalidDate                                = PlatformErrorCodes(149)
	PlatformErrorCodes_ContentPropertyInvalidSet                                 = PlatformErrorCodes(150)
	PlatformErrorCodes_ContentPropertyCannotDeserialize                          = PlatformErrorCodes(151)
	PlatformErrorCodes_ContentRegexValidationFailOnProperty                      = PlatformErrorCodes(152)
	PlatformErrorCodes_ContentMaxLengthFailOnProperty                            = PlatformErrorCodes(153)
	PlatformErrorCodes_ContentPropertyUnexpectedDeserializationError             = PlatformErrorCodes(154)
	PlatformErrorCodes_ContentPropertyRequired                                   = PlatformErrorCodes(155)
	PlatformErrorCodes_ContentCannotCreateFile                                   = PlatformErrorCodes(156)
	PlatformErrorCodes_ContentInvalidMigrationFile                               = PlatformErrorCodes(157)
	PlatformErrorCodes_ContentMigrationAlteringProcessedItem                     = PlatformErrorCodes(158)
	PlatformErrorCodes_ContentPropertyDefinitionNotFound                         = PlatformErrorCodes(159)
	PlatformErrorCodes_ContentReviewDataChanged                                  = PlatformErrorCodes(160)
	PlatformErrorCodes_ContentRollbackRevisionNotInPackage                       = PlatformErrorCodes(161)
	PlatformErrorCodes_ContentItemNotBasedOnLatestRevision                       = PlatformErrorCodes(162)
	PlatformErrorCodes_ContentUnauthorized                                       = PlatformErrorCodes(163)
	PlatformErrorCodes_ContentCannotCreateDeploymentPackage                      = PlatformErrorCodes(164)
	PlatformErrorCodes_ContentUserNotFound                                       = PlatformErrorCodes(165)
	PlatformErrorCodes_ContentLocalePermissionDenied                             = PlatformErrorCodes(166)
	PlatformErrorCodes_ContentInvalidLinkToInternalEnvironment                   = PlatformErrorCodes(167)
	PlatformErrorCodes_ContentInvalidBlacklistedContent                          = PlatformErrorCodes(168)
	PlatformErrorCodes_ContentMacroMalformedNoContentId                          = PlatformErrorCodes(169)
	PlatformErrorCodes_ContentMacroMalformedNoTemplateType                       = PlatformErrorCodes(170)
	PlatformErrorCodes_ContentIllegalBNetMembershipId                            = PlatformErrorCodes(171)
	PlatformErrorCodes_ContentLocaleDidNotMatchExpected                          = PlatformErrorCodes(172)
	PlatformErrorCodes_ContentBabelCallFailed                                    = PlatformErrorCodes(173)
	PlatformErrorCodes_ContentEnglishPostLiveForbidden                           = PlatformErrorCodes(174)
	PlatformErrorCodes_ContentLocaleEditPermissionDenied                         = PlatformErrorCodes(175)
	PlatformErrorCodes_ContentStackUnknownError                                  = PlatformErrorCodes(176)
	PlatformErrorCodes_ContentStackNotFound                                      = PlatformErrorCodes(177)
	PlatformErrorCodes_ContentStackRateLimited                                   = PlatformErrorCodes(178)
	PlatformErrorCodes_ContentStackTimeout                                       = PlatformErrorCodes(179)
	PlatformErrorCodes_ContentStackServiceError                                  = PlatformErrorCodes(180)
	PlatformErrorCodes_ContentStackDeserializationFailure                        = PlatformErrorCodes(181)
	PlatformErrorCodes_UserNonUniqueName                                         = PlatformErrorCodes(200)
	PlatformErrorCodes_UserManualLinkingStepRequired                             = PlatformErrorCodes(201)
	PlatformErrorCodes_UserCreateUnknownSqlResult                                = PlatformErrorCodes(202)
	PlatformErrorCodes_UserCreateUnknownSqlException                             = PlatformErrorCodes(203)
	PlatformErrorCodes_UserMalformedMembershipId                                 = PlatformErrorCodes(204)
	PlatformErrorCodes_UserCannotFindRequestedUser                               = PlatformErrorCodes(205)
	PlatformErrorCodes_UserCannotLoadAccountCredentialLinkInfo                   = PlatformErrorCodes(206)
	PlatformErrorCodes_UserInvalidMobileAppType                                  = PlatformErrorCodes(207)
	PlatformErrorCodes_UserMissingMobilePairingInfo                              = PlatformErrorCodes(208)
	PlatformErrorCodes_UserCannotGenerateMobileKeyWhileUsingMobileCredential     = PlatformErrorCodes(209)
	PlatformErrorCodes_UserGenerateMobileKeyExistingSlotCollision                = PlatformErrorCodes(210)
	PlatformErrorCodes_UserDisplayNameMissingOrInvalid                           = PlatformErrorCodes(211)
	PlatformErrorCodes_UserCannotLoadAccountProfileData                          = PlatformErrorCodes(212)
	PlatformErrorCodes_UserCannotSaveUserProfileData                             = PlatformErrorCodes(213)
	PlatformErrorCodes_UserEmailMissingOrInvalid                                 = PlatformErrorCodes(214)
	PlatformErrorCodes_UserTermsOfUseRequired                                    = PlatformErrorCodes(215)
	PlatformErrorCodes_UserCannotCreateNewAccountWhileLoggedIn                   = PlatformErrorCodes(216)
	PlatformErrorCodes_UserCannotResolveCentralAccount                           = PlatformErrorCodes(217)
	PlatformErrorCodes_UserInvalidAvatar                                         = PlatformErrorCodes(218)
	PlatformErrorCodes_UserMissingCreatedUserResult                              = PlatformErrorCodes(219)
	PlatformErrorCodes_UserCannotChangeUniqueNameYet                             = PlatformErrorCodes(220)
	PlatformErrorCodes_UserCannotChangeDisplayNameYet                            = PlatformErrorCodes(221)
	PlatformErrorCodes_UserCannotChangeEmail                                     = PlatformErrorCodes(222)
	PlatformErrorCodes_UserUniqueNameMustStartWithLetter                         = PlatformErrorCodes(223)
	PlatformErrorCodes_UserNoLinkedAccountsSupportFriendListings                 = PlatformErrorCodes(224)
	PlatformErrorCodes_UserAcknowledgmentTableFull                               = PlatformErrorCodes(225)
	PlatformErrorCodes_UserCreationDestinyMembershipRequired                     = PlatformErrorCodes(226)
	PlatformErrorCodes_UserFriendsTokenNeedsRefresh                              = PlatformErrorCodes(227)
	PlatformErrorCodes_UserEmailValidationUnknown                                = PlatformErrorCodes(228)
	PlatformErrorCodes_UserEmailValidationLimit                                  = PlatformErrorCodes(229)
	PlatformErrorCodes_TransactionEmailSendFailure                               = PlatformErrorCodes(230)
	PlatformErrorCodes_MailHookPermissionFailure                                 = PlatformErrorCodes(231)
	PlatformErrorCodes_MailServiceRateLimit                                      = PlatformErrorCodes(232)
	PlatformErrorCodes_UserEmailMustBeVerified                                   = PlatformErrorCodes(233)
	PlatformErrorCodes_UserMustAllowCustomerServiceEmails                        = PlatformErrorCodes(234)
	PlatformErrorCodes_NonTransactionalEmailSendFailure                          = PlatformErrorCodes(235)
	PlatformErrorCodes_UnknownErrorSettingGlobalDisplayName                      = PlatformErrorCodes(236)
	PlatformErrorCodes_DuplicateGlobalDisplayName                                = PlatformErrorCodes(237)
	PlatformErrorCodes_ErrorRunningNameValidationChecks                          = PlatformErrorCodes(238)
	PlatformErrorCodes_ErrorDatabaseGlobalName                                   = PlatformErrorCodes(239)
	PlatformErrorCodes_ErrorNoAvailableNameChanges                               = PlatformErrorCodes(240)
	PlatformErrorCodes_ErrorNameAlreadySetToInput                                = PlatformErrorCodes(241)
	PlatformErrorCodes_UserDisplayNameLessThanMinLength                          = PlatformErrorCodes(242)
	PlatformErrorCodes_UserDisplayNameGreaterThanMaxLength                       = PlatformErrorCodes(243)
	PlatformErrorCodes_UserDisplayNameContainsUnacceptableOrInvalidContent       = PlatformErrorCodes(244)
	PlatformErrorCodes_EmailValidationOffline                                    = PlatformErrorCodes(245)
	PlatformErrorCodes_EmailValidationFailOldCode                                = PlatformErrorCodes(246)
	PlatformErrorCodes_EmailValidationFailBadLink                                = PlatformErrorCodes(247)
	PlatformErrorCodes_EmailUnsubscribeFail                                      = PlatformErrorCodes(248)
	PlatformErrorCodes_EmailUnsubscribeFailNew                                   = PlatformErrorCodes(249)
	PlatformErrorCodes_MessagingUnknownError                                     = PlatformErrorCodes(300)
	PlatformErrorCodes_MessagingSelfError                                        = PlatformErrorCodes(301)
	PlatformErrorCodes_MessagingSendThrottle                                     = PlatformErrorCodes(302)
	PlatformErrorCodes_MessagingNoBody                                           = PlatformErrorCodes(303)
	PlatformErrorCodes_MessagingTooManyUsers                                     = PlatformErrorCodes(304)
	PlatformErrorCodes_MessagingCanNotLeaveConversation                          = PlatformErrorCodes(305)
	PlatformErrorCodes_MessagingUnableToSend                                     = PlatformErrorCodes(306)
	PlatformErrorCodes_MessagingDeletedUserForbidden                             = PlatformErrorCodes(307)
	PlatformErrorCodes_MessagingCannotDeleteExternalConversation                 = PlatformErrorCodes(308)
	PlatformErrorCodes_MessagingGroupChatDisabled                                = PlatformErrorCodes(309)
	PlatformErrorCodes_MessagingMustIncludeSelfInPrivateMessage                  = PlatformErrorCodes(310)
	PlatformErrorCodes_MessagingSenderIsBanned                                   = PlatformErrorCodes(311)
	PlatformErrorCodes_MessagingGroupOptionalChatExceededMaximum                 = PlatformErrorCodes(312)
	PlatformErrorCodes_PrivateMessagingRequiresDestinyMembership                 = PlatformErrorCodes(313)
	PlatformErrorCodes_MessagingSendDailyThrottle                                = PlatformErrorCodes(314)
	PlatformErrorCodes_AddSurveyAnswersUnknownSqlException                       = PlatformErrorCodes(400)
	PlatformErrorCodes_ForumBodyCannotBeEmpty                                    = PlatformErrorCodes(500)
	PlatformErrorCodes_ForumSubjectCannotBeEmptyOnTopicPost                      = PlatformErrorCodes(501)
	PlatformErrorCodes_ForumCannotLocateParentPost                               = PlatformErrorCodes(502)
	PlatformErrorCodes_ForumThreadLockedForReplies                               = PlatformErrorCodes(503)
	PlatformErrorCodes_ForumUnknownSqlResultDuringCreatePost                     = PlatformErrorCodes(504)
	PlatformErrorCodes_ForumUnknownTagCreationError                              = PlatformErrorCodes(505)
	PlatformErrorCodes_ForumUnknownSqlResultDuringTagItem                        = PlatformErrorCodes(506)
	PlatformErrorCodes_ForumUnknownExceptionCreatePost                           = PlatformErrorCodes(507)
	PlatformErrorCodes_ForumQuestionMustBeTopicPost                              = PlatformErrorCodes(508)
	PlatformErrorCodes_ForumExceptionDuringTagSearch                             = PlatformErrorCodes(509)
	PlatformErrorCodes_ForumExceptionDuringTopicRetrieval                        = PlatformErrorCodes(510)
	PlatformErrorCodes_ForumAliasedTagError                                      = PlatformErrorCodes(511)
	PlatformErrorCodes_ForumCannotLocateThread                                   = PlatformErrorCodes(512)
	PlatformErrorCodes_ForumUnknownExceptionEditPost                             = PlatformErrorCodes(513)
	PlatformErrorCodes_ForumCannotLocatePost                                     = PlatformErrorCodes(514)
	PlatformErrorCodes_ForumUnknownExceptionGetOrCreateTags                      = PlatformErrorCodes(515)
	PlatformErrorCodes_ForumEditPermissionDenied                                 = PlatformErrorCodes(516)
	PlatformErrorCodes_ForumUnknownSqlResultDuringTagIdRetrieval                 = PlatformErrorCodes(517)
	PlatformErrorCodes_ForumCannotGetRating                                      = PlatformErrorCodes(518)
	PlatformErrorCodes_ForumUnknownExceptionGetRating                            = PlatformErrorCodes(519)
	PlatformErrorCodes_ForumRatingsAccessError                                   = PlatformErrorCodes(520)
	PlatformErrorCodes_ForumRelatedPostAccessError                               = PlatformErrorCodes(521)
	PlatformErrorCodes_ForumLatestReplyAccessError                               = PlatformErrorCodes(522)
	PlatformErrorCodes_ForumUserStatusAccessError                                = PlatformErrorCodes(523)
	PlatformErrorCodes_ForumAuthorAccessError                                    = PlatformErrorCodes(524)
	PlatformErrorCodes_ForumGroupAccessError                                     = PlatformErrorCodes(525)
	PlatformErrorCodes_ForumUrlExpectedButMissing                                = PlatformErrorCodes(526)
	PlatformErrorCodes_ForumRepliesCannotBeEmpty                                 = PlatformErrorCodes(527)
	PlatformErrorCodes_ForumRepliesCannotBeInDifferentGroups                     = PlatformErrorCodes(528)
	PlatformErrorCodes_ForumSubTopicCannotBeCreatedAtThisThreadLevel             = PlatformErrorCodes(529)
	PlatformErrorCodes_ForumCannotCreateContentTopic                             = PlatformErrorCodes(530)
	PlatformErrorCodes_ForumTopicDoesNotExist                                    = PlatformErrorCodes(531)
	PlatformErrorCodes_ForumContentCommentsNotAllowed                            = PlatformErrorCodes(532)
	PlatformErrorCodes_ForumUnknownSqlResultDuringEditPost                       = PlatformErrorCodes(533)
	PlatformErrorCodes_ForumUnknownSqlResultDuringGetPost                        = PlatformErrorCodes(534)
	PlatformErrorCodes_ForumPostValidationBadUrl                                 = PlatformErrorCodes(535)
	PlatformErrorCodes_ForumBodyTooLong                                          = PlatformErrorCodes(536)
	PlatformErrorCodes_ForumSubjectTooLong                                       = PlatformErrorCodes(537)
	PlatformErrorCodes_ForumAnnouncementNotAllowed                               = PlatformErrorCodes(538)
	PlatformErrorCodes_ForumCannotShareOwnPost                                   = PlatformErrorCodes(539)
	PlatformErrorCodes_ForumEditNoOp                                             = PlatformErrorCodes(540)
	PlatformErrorCodes_ForumUnknownDatabaseErrorDuringGetPost                    = PlatformErrorCodes(541)
	PlatformErrorCodes_ForumExceeedMaximumRowLimit                               = PlatformErrorCodes(542)
	PlatformErrorCodes_ForumCannotSharePrivatePost                               = PlatformErrorCodes(543)
	PlatformErrorCodes_ForumCannotCrossPostBetweenGroups                         = PlatformErrorCodes(544)
	PlatformErrorCodes_ForumIncompatibleCategories                               = PlatformErrorCodes(555)
	PlatformErrorCodes_ForumCannotUseTheseCategoriesOnNonTopicPost               = PlatformErrorCodes(556)
	PlatformErrorCodes_ForumCanOnlyDeleteTopics                                  = PlatformErrorCodes(557)
	PlatformErrorCodes_ForumDeleteSqlException                                   = PlatformErrorCodes(558)
	PlatformErrorCodes_ForumDeleteSqlUnknownResult                               = PlatformErrorCodes(559)
	PlatformErrorCodes_ForumTooManyTags                                          = PlatformErrorCodes(560)
	PlatformErrorCodes_ForumCanOnlyRateTopics                                    = PlatformErrorCodes(561)
	PlatformErrorCodes_ForumBannedPostsCannotBeEdited                            = PlatformErrorCodes(562)
	PlatformErrorCodes_ForumThreadRootIsBanned                                   = PlatformErrorCodes(563)
	PlatformErrorCodes_ForumCannotUseOfficialTagCategoryAsTag                    = PlatformErrorCodes(564)
	PlatformErrorCodes_ForumAnswerCannotBeMadeOnCreatePost                       = PlatformErrorCodes(565)
	PlatformErrorCodes_ForumAnswerCannotBeMadeOnEditPost                         = PlatformErrorCodes(566)
	PlatformErrorCodes_ForumAnswerPostIdIsNotADirectReplyOfQuestion              = PlatformErrorCodes(567)
	PlatformErrorCodes_ForumAnswerTopicIdIsNotAQuestion                          = PlatformErrorCodes(568)
	PlatformErrorCodes_ForumUnknownExceptionDuringMarkAnswer                     = PlatformErrorCodes(569)
	PlatformErrorCodes_ForumUnknownSqlResultDuringMarkAnswer                     = PlatformErrorCodes(570)
	PlatformErrorCodes_ForumCannotRateYourOwnPosts                               = PlatformErrorCodes(571)
	PlatformErrorCodes_ForumPollsMustBeTheFirstPostInTopic                       = PlatformErrorCodes(572)
	PlatformErrorCodes_ForumInvalidPollInput                                     = PlatformErrorCodes(573)
	PlatformErrorCodes_ForumGroupAdminEditNonMember                              = PlatformErrorCodes(574)
	PlatformErrorCodes_ForumCannotEditModeratorEditedPost                        = PlatformErrorCodes(575)
	PlatformErrorCodes_ForumRequiresDestinyMembership                            = PlatformErrorCodes(576)
	PlatformErrorCodes_ForumUnexpectedError                                      = PlatformErrorCodes(577)
	PlatformErrorCodes_ForumAgeLock                                              = PlatformErrorCodes(578)
	PlatformErrorCodes_ForumMaxPages                                             = PlatformErrorCodes(579)
	PlatformErrorCodes_ForumMaxPagesOldestFirst                                  = PlatformErrorCodes(580)
	PlatformErrorCodes_ForumCannotApplyForumIdWithoutTags                        = PlatformErrorCodes(581)
	PlatformErrorCodes_ForumCannotApplyForumIdToNonTopics                        = PlatformErrorCodes(582)
	PlatformErrorCodes_ForumCannotDownvoteCommunityCreations                     = PlatformErrorCodes(583)
	PlatformErrorCodes_ForumTopicsMustHaveOfficialCategory                       = PlatformErrorCodes(584)
	PlatformErrorCodes_ForumRecruitmentTopicMalformed                            = PlatformErrorCodes(585)
	PlatformErrorCodes_ForumRecruitmentTopicNotFound                             = PlatformErrorCodes(586)
	PlatformErrorCodes_ForumRecruitmentTopicNoSlotsRemaining                     = PlatformErrorCodes(587)
	PlatformErrorCodes_ForumRecruitmentTopicKickBan                              = PlatformErrorCodes(588)
	PlatformErrorCodes_ForumRecruitmentTopicRequirementsNotMet                   = PlatformErrorCodes(589)
	PlatformErrorCodes_ForumRecruitmentTopicNoPlayers                            = PlatformErrorCodes(590)
	PlatformErrorCodes_ForumRecruitmentApproveFailMessageBan                     = PlatformErrorCodes(591)
	PlatformErrorCodes_ForumRecruitmentGlobalBan                                 = PlatformErrorCodes(592)
	PlatformErrorCodes_ForumUserBannedFromThisTopic                              = PlatformErrorCodes(593)
	PlatformErrorCodes_ForumRecruitmentFireteamMembersOnly                       = PlatformErrorCodes(594)
	PlatformErrorCodes_ForumRequiresDestiny2Progress                             = PlatformErrorCodes(595)
	PlatformErrorCodes_ForumRequiresDestiny2EntitlementPurchase                  = PlatformErrorCodes(596)
	PlatformErrorCodes_GroupMembershipApplicationAlreadyResolved                 = PlatformErrorCodes(601)
	PlatformErrorCodes_GroupMembershipAlreadyApplied                             = PlatformErrorCodes(602)
	PlatformErrorCodes_GroupMembershipInsufficientPrivileges                     = PlatformErrorCodes(603)
	PlatformErrorCodes_GroupIdNotReturnedFromCreation                            = PlatformErrorCodes(604)
	PlatformErrorCodes_GroupSearchInvalidParameters                              = PlatformErrorCodes(605)
	PlatformErrorCodes_GroupMembershipPendingApplicationNotFound                 = PlatformErrorCodes(606)
	PlatformErrorCodes_GroupInvalidId                                            = PlatformErrorCodes(607)
	PlatformErrorCodes_GroupInvalidMembershipId                                  = PlatformErrorCodes(608)
	PlatformErrorCodes_GroupInvalidMembershipType                                = PlatformErrorCodes(609)
	PlatformErrorCodes_GroupMissingTags                                          = PlatformErrorCodes(610)
	PlatformErrorCodes_GroupMembershipNotFound                                   = PlatformErrorCodes(611)
	PlatformErrorCodes_GroupInvalidRating                                        = PlatformErrorCodes(612)
	PlatformErrorCodes_GroupUserFollowingAccessError                             = PlatformErrorCodes(613)
	PlatformErrorCodes_GroupUserMembershipAccessError                            = PlatformErrorCodes(614)
	PlatformErrorCodes_GroupCreatorAccessError                                   = PlatformErrorCodes(615)
	PlatformErrorCodes_GroupAdminAccessError                                     = PlatformErrorCodes(616)
	PlatformErrorCodes_GroupPrivatePostNotViewable                               = PlatformErrorCodes(617)
	PlatformErrorCodes_GroupMembershipNotLoggedIn                                = PlatformErrorCodes(618)
	PlatformErrorCodes_GroupNotDeleted                                           = PlatformErrorCodes(619)
	PlatformErrorCodes_GroupUnknownErrorUndeletingGroup                          = PlatformErrorCodes(620)
	PlatformErrorCodes_GroupDeleted                                              = PlatformErrorCodes(621)
	PlatformErrorCodes_GroupNotFound                                             = PlatformErrorCodes(622)
	PlatformErrorCodes_GroupMemberBanned                                         = PlatformErrorCodes(623)
	PlatformErrorCodes_GroupMembershipClosed                                     = PlatformErrorCodes(624)
	PlatformErrorCodes_GroupPrivatePostOverrideError                             = PlatformErrorCodes(625)
	PlatformErrorCodes_GroupNameTaken                                            = PlatformErrorCodes(626)
	PlatformErrorCodes_GroupDeletionGracePeriodExpired                           = PlatformErrorCodes(627)
	PlatformErrorCodes_GroupCannotCheckBanStatus                                 = PlatformErrorCodes(628)
	PlatformErrorCodes_GroupMaximumMembershipCountReached                        = PlatformErrorCodes(629)
	PlatformErrorCodes_NoDestinyAccountForClanPlatform                           = PlatformErrorCodes(630)
	PlatformErrorCodes_AlreadyRequestingMembershipForClanPlatform                = PlatformErrorCodes(631)
	PlatformErrorCodes_AlreadyClanMemberOnPlatform                               = PlatformErrorCodes(632)
	PlatformErrorCodes_GroupJoinedCannotSetClanName                              = PlatformErrorCodes(633)
	PlatformErrorCodes_GroupLeftCannotClearClanName                              = PlatformErrorCodes(634)
	PlatformErrorCodes_GroupRelationshipRequestPending                           = PlatformErrorCodes(635)
	PlatformErrorCodes_GroupRelationshipRequestBlocked                           = PlatformErrorCodes(636)
	PlatformErrorCodes_GroupRelationshipRequestNotFound                          = PlatformErrorCodes(637)
	PlatformErrorCodes_GroupRelationshipBlockNotFound                            = PlatformErrorCodes(638)
	PlatformErrorCodes_GroupRelationshipNotFound                                 = PlatformErrorCodes(639)
	PlatformErrorCodes_GroupAlreadyAllied                                        = PlatformErrorCodes(641)
	PlatformErrorCodes_GroupAlreadyMember                                        = PlatformErrorCodes(642)
	PlatformErrorCodes_GroupRelationshipAlreadyExists                            = PlatformErrorCodes(643)
	PlatformErrorCodes_InvalidGroupTypesForRelationshipRequest                   = PlatformErrorCodes(644)
	PlatformErrorCodes_GroupAtMaximumAlliances                                   = PlatformErrorCodes(646)
	PlatformErrorCodes_GroupCannotSetClanOnlySettings                            = PlatformErrorCodes(647)
	PlatformErrorCodes_ClanCannotSetTwoDefaultPostTypes                          = PlatformErrorCodes(648)
	PlatformErrorCodes_GroupMemberInvalidMemberType                              = PlatformErrorCodes(649)
	PlatformErrorCodes_GroupInvalidPlatformType                                  = PlatformErrorCodes(650)
	PlatformErrorCodes_GroupMemberInvalidSort                                    = PlatformErrorCodes(651)
	PlatformErrorCodes_GroupInvalidResolveState                                  = PlatformErrorCodes(652)
	PlatformErrorCodes_ClanAlreadyEnabledForPlatform                             = PlatformErrorCodes(653)
	PlatformErrorCodes_ClanNotEnabledForPlatform                                 = PlatformErrorCodes(654)
	PlatformErrorCodes_ClanEnabledButCouldNotJoinNoAccount                       = PlatformErrorCodes(655)
	PlatformErrorCodes_ClanEnabledButCouldNotJoinAlreadyMember                   = PlatformErrorCodes(656)
	PlatformErrorCodes_ClanCannotJoinNoCredential                                = PlatformErrorCodes(657)
	PlatformErrorCodes_NoClanMembershipForPlatform                               = PlatformErrorCodes(658)
	PlatformErrorCodes_GroupToGroupFollowLimitReached                            = PlatformErrorCodes(659)
	PlatformErrorCodes_ChildGroupAlreadyInAlliance                               = PlatformErrorCodes(660)
	PlatformErrorCodes_OwnerGroupAlreadyInAlliance                               = PlatformErrorCodes(661)
	PlatformErrorCodes_AllianceOwnerCannotJoinAlliance                           = PlatformErrorCodes(662)
	PlatformErrorCodes_GroupNotInAlliance                                        = PlatformErrorCodes(663)
	PlatformErrorCodes_ChildGroupCannotInviteToAlliance                          = PlatformErrorCodes(664)
	PlatformErrorCodes_GroupToGroupAlreadyFollowed                               = PlatformErrorCodes(665)
	PlatformErrorCodes_GroupToGroupNotFollowing                                  = PlatformErrorCodes(666)
	PlatformErrorCodes_ClanMaximumMembershipReached                              = PlatformErrorCodes(667)
	PlatformErrorCodes_ClanNameNotValid                                          = PlatformErrorCodes(668)
	PlatformErrorCodes_ClanNameNotValidError                                     = PlatformErrorCodes(669)
	PlatformErrorCodes_AllianceOwnerNotDefined                                   = PlatformErrorCodes(670)
	PlatformErrorCodes_AllianceChildNotDefined                                   = PlatformErrorCodes(671)
	PlatformErrorCodes_ClanCultureIllegalCharacters                              = PlatformErrorCodes(672)
	PlatformErrorCodes_ClanTagIllegalCharacters                                  = PlatformErrorCodes(673)
	PlatformErrorCodes_ClanRequiresInvitation                                    = PlatformErrorCodes(674)
	PlatformErrorCodes_ClanMembershipClosed                                      = PlatformErrorCodes(675)
	PlatformErrorCodes_ClanInviteAlreadyMember                                   = PlatformErrorCodes(676)
	PlatformErrorCodes_GroupInviteAlreadyMember                                  = PlatformErrorCodes(677)
	PlatformErrorCodes_GroupJoinApprovalRequired                                 = PlatformErrorCodes(678)
	PlatformErrorCodes_ClanTagRequired                                           = PlatformErrorCodes(679)
	PlatformErrorCodes_GroupNameCannotStartOrEndWithWhiteSpace                   = PlatformErrorCodes(680)
	PlatformErrorCodes_ClanCallsignCannotStartOrEndWithWhiteSpace                = PlatformErrorCodes(681)
	PlatformErrorCodes_ClanMigrationFailed                                       = PlatformErrorCodes(682)
	PlatformErrorCodes_ClanNotEnabledAlreadyMemberOfAnotherClan                  = PlatformErrorCodes(683)
	PlatformErrorCodes_GroupModerationNotPermittedOnNonMembers                   = PlatformErrorCodes(684)
	PlatformErrorCodes_ClanCreationInWorldServerFailed                           = PlatformErrorCodes(685)
	PlatformErrorCodes_ClanNotFound                                              = PlatformErrorCodes(686)
	PlatformErrorCodes_ClanMembershipLevelDoesNotPermitThatAction                = PlatformErrorCodes(687)
	PlatformErrorCodes_ClanMemberNotFound                                        = PlatformErrorCodes(688)
	PlatformErrorCodes_ClanMissingMembershipApprovers                            = PlatformErrorCodes(689)
	PlatformErrorCodes_ClanInWrongStateForRequestedAction                        = PlatformErrorCodes(690)
	PlatformErrorCodes_ClanNameAlreadyUsed                                       = PlatformErrorCodes(691)
	PlatformErrorCodes_ClanTooFewMembers                                         = PlatformErrorCodes(692)
	PlatformErrorCodes_ClanInfoCannotBeWhitespace                                = PlatformErrorCodes(693)
	PlatformErrorCodes_GroupCultureThrottle                                      = PlatformErrorCodes(694)
	PlatformErrorCodes_ClanTargetDisallowsInvites                                = PlatformErrorCodes(695)
	PlatformErrorCodes_ClanInvalidOperation                                      = PlatformErrorCodes(696)
	PlatformErrorCodes_ClanFounderCannotLeaveWithoutAbdication                   = PlatformErrorCodes(697)
	PlatformErrorCodes_ClanNameReserved                                          = PlatformErrorCodes(698)
	PlatformErrorCodes_ClanApplicantInClanSoNowInvited                           = PlatformErrorCodes(699)
	PlatformErrorCodes_ActivitiesUnknownException                                = PlatformErrorCodes(701)
	PlatformErrorCodes_ActivitiesParameterNull                                   = PlatformErrorCodes(702)
	PlatformErrorCodes_ActivityCountsDiabled                                     = PlatformErrorCodes(703)
	PlatformErrorCodes_ActivitySearchInvalidParameters                           = PlatformErrorCodes(704)
	PlatformErrorCodes_ActivityPermissionDenied                                  = PlatformErrorCodes(705)
	PlatformErrorCodes_ShareAlreadyShared                                        = PlatformErrorCodes(706)
	PlatformErrorCodes_ActivityLoggingDisabled                                   = PlatformErrorCodes(707)
	PlatformErrorCodes_ClanRequiresExistingDestinyAccount                        = PlatformErrorCodes(750)
	PlatformErrorCodes_ClanNameRestricted                                        = PlatformErrorCodes(751)
	PlatformErrorCodes_ClanCreationBan                                           = PlatformErrorCodes(752)
	PlatformErrorCodes_ClanCreationTenureRequirementsNotMet                      = PlatformErrorCodes(753)
	PlatformErrorCodes_ClanFieldContainsReservedTerms                            = PlatformErrorCodes(754)
	PlatformErrorCodes_ClanFieldContainsInappropriateContent                     = PlatformErrorCodes(755)
	PlatformErrorCodes_ItemAlreadyFollowed                                       = PlatformErrorCodes(801)
	PlatformErrorCodes_ItemNotFollowed                                           = PlatformErrorCodes(802)
	PlatformErrorCodes_CannotFollowSelf                                          = PlatformErrorCodes(803)
	PlatformErrorCodes_GroupFollowLimitExceeded                                  = PlatformErrorCodes(804)
	PlatformErrorCodes_TagFollowLimitExceeded                                    = PlatformErrorCodes(805)
	PlatformErrorCodes_UserFollowLimitExceeded                                   = PlatformErrorCodes(806)
	PlatformErrorCodes_FollowUnsupportedEntityType                               = PlatformErrorCodes(807)
	PlatformErrorCodes_NoValidTagsInList                                         = PlatformErrorCodes(900)
	PlatformErrorCodes_BelowMinimumSuggestionLength                              = PlatformErrorCodes(901)
	PlatformErrorCodes_CannotGetSuggestionsOnMultipleTagsSimultaneously          = PlatformErrorCodes(902)
	PlatformErrorCodes_NotAValidPartialTag                                       = PlatformErrorCodes(903)
	PlatformErrorCodes_TagSuggestionsUnknownSqlResult                            = PlatformErrorCodes(904)
	PlatformErrorCodes_TagsUnableToLoadPopularTagsFromDatabase                   = PlatformErrorCodes(905)
	PlatformErrorCodes_TagInvalid                                                = PlatformErrorCodes(906)
	PlatformErrorCodes_TagNotFound                                               = PlatformErrorCodes(907)
	PlatformErrorCodes_SingleTagExpected                                         = PlatformErrorCodes(908)
	PlatformErrorCodes_TagsExceededMaximumPerItem                                = PlatformErrorCodes(909)
	PlatformErrorCodes_IgnoreInvalidParameters                                   = PlatformErrorCodes(1000)
	PlatformErrorCodes_IgnoreSqlException                                        = PlatformErrorCodes(1001)
	PlatformErrorCodes_IgnoreErrorRetrievingGroupPermissions                     = PlatformErrorCodes(1002)
	PlatformErrorCodes_IgnoreErrorInsufficientPermission                         = PlatformErrorCodes(1003)
	PlatformErrorCodes_IgnoreErrorRetrievingItem                                 = PlatformErrorCodes(1004)
	PlatformErrorCodes_IgnoreCannotIgnoreSelf                                    = PlatformErrorCodes(1005)
	PlatformErrorCodes_IgnoreIllegalType                                         = PlatformErrorCodes(1006)
	PlatformErrorCodes_IgnoreNotFound                                            = PlatformErrorCodes(1007)
	PlatformErrorCodes_IgnoreUserGloballyIgnored                                 = PlatformErrorCodes(1008)
	PlatformErrorCodes_IgnoreUserIgnored                                         = PlatformErrorCodes(1009)
	PlatformErrorCodes_TargetUserIgnored                                         = PlatformErrorCodes(1010)
	PlatformErrorCodes_NotificationSettingInvalid                                = PlatformErrorCodes(1100)
	PlatformErrorCodes_PsnApiExpiredAccessToken                                  = PlatformErrorCodes(1204)
	PlatformErrorCodes_PSNExForbidden                                            = PlatformErrorCodes(1205)
	PlatformErrorCodes_PSNExSystemDisabled                                       = PlatformErrorCodes(1218)
	PlatformErrorCodes_PsnApiErrorCodeUnknown                                    = PlatformErrorCodes(1223)
	PlatformErrorCodes_PsnApiErrorWebException                                   = PlatformErrorCodes(1224)
	PlatformErrorCodes_PsnApiBadRequest                                          = PlatformErrorCodes(1225)
	PlatformErrorCodes_PsnApiAccessTokenRequired                                 = PlatformErrorCodes(1226)
	PlatformErrorCodes_PsnApiInvalidAccessToken                                  = PlatformErrorCodes(1227)
	PlatformErrorCodes_PsnApiBannedUser                                          = PlatformErrorCodes(1229)
	PlatformErrorCodes_PsnApiAccountUpgradeRequired                              = PlatformErrorCodes(1230)
	PlatformErrorCodes_PsnApiServiceTemporarilyUnavailable                       = PlatformErrorCodes(1231)
	PlatformErrorCodes_PsnApiServerBusy                                          = PlatformErrorCodes(1232)
	PlatformErrorCodes_PsnApiUnderMaintenance                                    = PlatformErrorCodes(1233)
	PlatformErrorCodes_PsnApiProfileUserNotFound                                 = PlatformErrorCodes(1234)
	PlatformErrorCodes_PsnApiProfilePrivacyRestriction                           = PlatformErrorCodes(1235)
	PlatformErrorCodes_PsnApiProfileUnderMaintenance                             = PlatformErrorCodes(1236)
	PlatformErrorCodes_PsnApiAccountAttributeMissing                             = PlatformErrorCodes(1237)
	PlatformErrorCodes_PsnApiNoPermission                                        = PlatformErrorCodes(1238)
	PlatformErrorCodes_PsnApiTargetUserBlocked                                   = PlatformErrorCodes(1239)
	PlatformErrorCodes_PsnApiJwksMissing                                         = PlatformErrorCodes(1240)
	PlatformErrorCodes_PsnApiJwtMalformedHeader                                  = PlatformErrorCodes(1241)
	PlatformErrorCodes_PsnApiJwtMalformedPayload                                 = PlatformErrorCodes(1242)
	PlatformErrorCodes_XblExSystemDisabled                                       = PlatformErrorCodes(1300)
	PlatformErrorCodes_XblExUnknownError                                         = PlatformErrorCodes(1301)
	PlatformErrorCodes_XblApiErrorWebException                                   = PlatformErrorCodes(1302)
	PlatformErrorCodes_XblStsTokenInvalid                                        = PlatformErrorCodes(1303)
	PlatformErrorCodes_XblStsMissingToken                                        = PlatformErrorCodes(1304)
	PlatformErrorCodes_XblStsExpiredToken                                        = PlatformErrorCodes(1305)
	PlatformErrorCodes_XblAccessToTheSandboxDenied                               = PlatformErrorCodes(1306)
	PlatformErrorCodes_XblMsaResponseMissing                                     = PlatformErrorCodes(1307)
	PlatformErrorCodes_XblMsaAccessTokenExpired                                  = PlatformErrorCodes(1308)
	PlatformErrorCodes_XblMsaInvalidRequest                                      = PlatformErrorCodes(1309)
	PlatformErrorCodes_XblMsaFriendsRequireSignIn                                = PlatformErrorCodes(1310)
	PlatformErrorCodes_XblUserActionRequired                                     = PlatformErrorCodes(1311)
	PlatformErrorCodes_XblParentalControls                                       = PlatformErrorCodes(1312)
	PlatformErrorCodes_XblDeveloperAccount                                       = PlatformErrorCodes(1313)
	PlatformErrorCodes_XblUserTokenExpired                                       = PlatformErrorCodes(1314)
	PlatformErrorCodes_XblUserTokenInvalid                                       = PlatformErrorCodes(1315)
	PlatformErrorCodes_XblOffline                                                = PlatformErrorCodes(1316)
	PlatformErrorCodes_XblUnknownErrorCode                                       = PlatformErrorCodes(1317)
	PlatformErrorCodes_XblMsaInvalidGrant                                        = PlatformErrorCodes(1318)
	PlatformErrorCodes_ReportNotYetResolved                                      = PlatformErrorCodes(1400)
	PlatformErrorCodes_ReportOverturnDoesNotChangeDecision                       = PlatformErrorCodes(1401)
	PlatformErrorCodes_ReportNotFound                                            = PlatformErrorCodes(1402)
	PlatformErrorCodes_ReportAlreadyReported                                     = PlatformErrorCodes(1403)
	PlatformErrorCodes_ReportInvalidResolution                                   = PlatformErrorCodes(1404)
	PlatformErrorCodes_ReportNotAssignedToYou                                    = PlatformErrorCodes(1405)
	PlatformErrorCodes_LegacyGameStatsSystemDisabled                             = PlatformErrorCodes(1500)
	PlatformErrorCodes_LegacyGameStatsUnknownError                               = PlatformErrorCodes(1501)
	PlatformErrorCodes_LegacyGameStatsMalformedSneakerNetCode                    = PlatformErrorCodes(1502)
	PlatformErrorCodes_DestinyAccountAcquisitionFailure                          = PlatformErrorCodes(1600)
	PlatformErrorCodes_DestinyAccountNotFound                                    = PlatformErrorCodes(1601)
	PlatformErrorCodes_DestinyBuildStatsDatabaseError                            = PlatformErrorCodes(1602)
	PlatformErrorCodes_DestinyCharacterStatsDatabaseError                        = PlatformErrorCodes(1603)
	PlatformErrorCodes_DestinyPvPStatsDatabaseError                              = PlatformErrorCodes(1604)
	PlatformErrorCodes_DestinyPvEStatsDatabaseError                              = PlatformErrorCodes(1605)
	PlatformErrorCodes_DestinyGrimoireStatsDatabaseError                         = PlatformErrorCodes(1606)
	PlatformErrorCodes_DestinyStatsParameterMembershipTypeParseError             = PlatformErrorCodes(1607)
	PlatformErrorCodes_DestinyStatsParameterMembershipIdParseError               = PlatformErrorCodes(1608)
	PlatformErrorCodes_DestinyStatsParameterRangeParseError                      = PlatformErrorCodes(1609)
	PlatformErrorCodes_DestinyStringItemHashNotFound                             = PlatformErrorCodes(1610)
	PlatformErrorCodes_DestinyStringSetNotFound                                  = PlatformErrorCodes(1611)
	PlatformErrorCodes_DestinyContentLookupNotFoundForKey                        = PlatformErrorCodes(1612)
	PlatformErrorCodes_DestinyContentItemNotFound                                = PlatformErrorCodes(1613)
	PlatformErrorCodes_DestinyContentSectionNotFound                             = PlatformErrorCodes(1614)
	PlatformErrorCodes_DestinyContentPropertyNotFound                            = PlatformErrorCodes(1615)
	PlatformErrorCodes_DestinyContentConfigNotFound                              = PlatformErrorCodes(1616)
	PlatformErrorCodes_DestinyContentPropertyBucketValueNotFound                 = PlatformErrorCodes(1617)
	PlatformErrorCodes_DestinyUnexpectedError                                    = PlatformErrorCodes(1618)
	PlatformErrorCodes_DestinyInvalidAction                                      = PlatformErrorCodes(1619)
	PlatformErrorCodes_DestinyCharacterNotFound                                  = PlatformErrorCodes(1620)
	PlatformErrorCodes_DestinyInvalidFlag                                        = PlatformErrorCodes(1621)
	PlatformErrorCodes_DestinyInvalidRequest                                     = PlatformErrorCodes(1622)
	PlatformErrorCodes_DestinyItemNotFound                                       = PlatformErrorCodes(1623)
	PlatformErrorCodes_DestinyInvalidCustomizationChoices                        = PlatformErrorCodes(1624)
	PlatformErrorCodes_DestinyVendorItemNotFound                                 = PlatformErrorCodes(1625)
	PlatformErrorCodes_DestinyInternalError                                      = PlatformErrorCodes(1626)
	PlatformErrorCodes_DestinyVendorNotFound                                     = PlatformErrorCodes(1627)
	PlatformErrorCodes_DestinyRecentActivitiesDatabaseError                      = PlatformErrorCodes(1628)
	PlatformErrorCodes_DestinyItemBucketNotFound                                 = PlatformErrorCodes(1629)
	PlatformErrorCodes_DestinyInvalidMembershipType                              = PlatformErrorCodes(1630)
	PlatformErrorCodes_DestinyVersionIncompatibility                             = PlatformErrorCodes(1631)
	PlatformErrorCodes_DestinyItemAlreadyInInventory                             = PlatformErrorCodes(1632)
	PlatformErrorCodes_DestinyBucketNotFound                                     = PlatformErrorCodes(1633)
	PlatformErrorCodes_DestinyCharacterNotInTower                                = PlatformErrorCodes(1634)
	PlatformErrorCodes_DestinyCharacterNotLoggedIn                               = PlatformErrorCodes(1635)
	PlatformErrorCodes_DestinyDefinitionsNotLoaded                               = PlatformErrorCodes(1636)
	PlatformErrorCodes_DestinyInventoryFull                                      = PlatformErrorCodes(1637)
	PlatformErrorCodes_DestinyItemFailedLevelCheck                               = PlatformErrorCodes(1638)
	PlatformErrorCodes_DestinyItemFailedUnlockCheck                              = PlatformErrorCodes(1639)
	PlatformErrorCodes_DestinyItemUnequippable                                   = PlatformErrorCodes(1640)
	PlatformErrorCodes_DestinyItemUniqueEquipRestricted                          = PlatformErrorCodes(1641)
	PlatformErrorCodes_DestinyNoRoomInDestination                                = PlatformErrorCodes(1642)
	PlatformErrorCodes_DestinyServiceFailure                                     = PlatformErrorCodes(1643)
	PlatformErrorCodes_DestinyServiceRetired                                     = PlatformErrorCodes(1644)
	PlatformErrorCodes_DestinyTransferFailed                                     = PlatformErrorCodes(1645)
	PlatformErrorCodes_DestinyTransferNotFoundForSourceBucket                    = PlatformErrorCodes(1646)
	PlatformErrorCodes_DestinyUnexpectedResultInVendorTransferCheck              = PlatformErrorCodes(1647)
	PlatformErrorCodes_DestinyUniquenessViolation                                = PlatformErrorCodes(1648)
	PlatformErrorCodes_DestinyErrorDeserializationFailure                        = PlatformErrorCodes(1649)
	PlatformErrorCodes_DestinyValidAccountTicketRequired                         = PlatformErrorCodes(1650)
	PlatformErrorCodes_DestinyShardRelayClientTimeout                            = PlatformErrorCodes(1651)
	PlatformErrorCodes_DestinyShardRelayProxyTimeout                             = PlatformErrorCodes(1652)
	PlatformErrorCodes_DestinyPGCRNotFound                                       = PlatformErrorCodes(1653)
	PlatformErrorCodes_DestinyAccountMustBeOffline                               = PlatformErrorCodes(1654)
	PlatformErrorCodes_DestinyCanOnlyEquipInGame                                 = PlatformErrorCodes(1655)
	PlatformErrorCodes_DestinyCannotPerformActionOnEquippedItem                  = PlatformErrorCodes(1656)
	PlatformErrorCodes_DestinyQuestAlreadyCompleted                              = PlatformErrorCodes(1657)
	PlatformErrorCodes_DestinyQuestAlreadyTracked                                = PlatformErrorCodes(1658)
	PlatformErrorCodes_DestinyTrackableQuestsFull                                = PlatformErrorCodes(1659)
	PlatformErrorCodes_DestinyItemNotTransferrable                               = PlatformErrorCodes(1660)
	PlatformErrorCodes_DestinyVendorPurchaseNotAllowed                           = PlatformErrorCodes(1661)
	PlatformErrorCodes_DestinyContentVersionMismatch                             = PlatformErrorCodes(1662)
	PlatformErrorCodes_DestinyItemActionForbidden                                = PlatformErrorCodes(1663)
	PlatformErrorCodes_DestinyRefundInvalid                                      = PlatformErrorCodes(1664)
	PlatformErrorCodes_DestinyPrivacyRestriction                                 = PlatformErrorCodes(1665)
	PlatformErrorCodes_DestinyActionInsufficientPrivileges                       = PlatformErrorCodes(1666)
	PlatformErrorCodes_DestinyInvalidClaimException                              = PlatformErrorCodes(1667)
	PlatformErrorCodes_DestinyLegacyPlatformRestricted                           = PlatformErrorCodes(1668)
	PlatformErrorCodes_DestinyLegacyPlatformInUse                                = PlatformErrorCodes(1669)
	PlatformErrorCodes_DestinyLegacyPlatformInaccessible                         = PlatformErrorCodes(1670)
	PlatformErrorCodes_DestinyCannotPerformActionAtThisLocation                  = PlatformErrorCodes(1671)
	PlatformErrorCodes_DestinyThrottledByGameServer                              = PlatformErrorCodes(1672)
	PlatformErrorCodes_DestinyItemNotTransferrableHasSideEffects                 = PlatformErrorCodes(1673)
	PlatformErrorCodes_DestinyItemLocked                                         = PlatformErrorCodes(1674)
	PlatformErrorCodes_DestinyCannotAffordMaterialRequirements                   = PlatformErrorCodes(1675)
	PlatformErrorCodes_DestinyFailedPlugInsertionRules                           = PlatformErrorCodes(1676)
	PlatformErrorCodes_DestinySocketNotFound                                     = PlatformErrorCodes(1677)
	PlatformErrorCodes_DestinySocketActionNotAllowed                             = PlatformErrorCodes(1678)
	PlatformErrorCodes_DestinySocketAlreadyHasPlug                               = PlatformErrorCodes(1679)
	PlatformErrorCodes_DestinyPlugItemNotAvailable                               = PlatformErrorCodes(1680)
	PlatformErrorCodes_DestinyCharacterLoggedInNotAllowed                        = PlatformErrorCodes(1681)
	PlatformErrorCodes_DestinyPublicAccountNotAccessible                         = PlatformErrorCodes(1682)
	PlatformErrorCodes_DestinyClaimsItemAlreadyClaimed                           = PlatformErrorCodes(1683)
	PlatformErrorCodes_DestinyClaimsNoInventorySpace                             = PlatformErrorCodes(1684)
	PlatformErrorCodes_DestinyClaimsRequiredLevelNotMet                          = PlatformErrorCodes(1685)
	PlatformErrorCodes_DestinyClaimsInvalidState                                 = PlatformErrorCodes(1686)
	PlatformErrorCodes_DestinyNotEnoughRoomForMultipleRewards                    = PlatformErrorCodes(1687)
	PlatformErrorCodes_DestinyDirectBabelClientTimeout                           = PlatformErrorCodes(1688)
	PlatformErrorCodes_FbInvalidRequest                                          = PlatformErrorCodes(1800)
	PlatformErrorCodes_FbRedirectMismatch                                        = PlatformErrorCodes(1801)
	PlatformErrorCodes_FbAccessDenied                                            = PlatformErrorCodes(1802)
	PlatformErrorCodes_FbUnsupportedResponseType                                 = PlatformErrorCodes(1803)
	PlatformErrorCodes_FbInvalidScope                                            = PlatformErrorCodes(1804)
	PlatformErrorCodes_FbUnsupportedGrantType                                    = PlatformErrorCodes(1805)
	PlatformErrorCodes_FbInvalidGrant                                            = PlatformErrorCodes(1806)
	PlatformErrorCodes_InvitationExpired                                         = PlatformErrorCodes(1900)
	PlatformErrorCodes_InvitationUnknownType                                     = PlatformErrorCodes(1901)
	PlatformErrorCodes_InvitationInvalidResponseStatus                           = PlatformErrorCodes(1902)
	PlatformErrorCodes_InvitationInvalidType                                     = PlatformErrorCodes(1903)
	PlatformErrorCodes_InvitationAlreadyPending                                  = PlatformErrorCodes(1904)
	PlatformErrorCodes_InvitationInsufficientPermission                          = PlatformErrorCodes(1905)
	PlatformErrorCodes_InvitationInvalidCode                                     = PlatformErrorCodes(1906)
	PlatformErrorCodes_InvitationInvalidTargetState                              = PlatformErrorCodes(1907)
	PlatformErrorCodes_InvitationCannotBeReactivated                             = PlatformErrorCodes(1908)
	PlatformErrorCodes_InvitationNoRecipients                                    = PlatformErrorCodes(1910)
	PlatformErrorCodes_InvitationGroupCannotSendToSelf                           = PlatformErrorCodes(1911)
	PlatformErrorCodes_InvitationTooManyRecipients                               = PlatformErrorCodes(1912)
	PlatformErrorCodes_InvitationInvalid                                         = PlatformErrorCodes(1913)
	PlatformErrorCodes_InvitationNotFound                                        = PlatformErrorCodes(1914)
	PlatformErrorCodes_TokenInvalid                                              = PlatformErrorCodes(2000)
	PlatformErrorCodes_TokenBadFormat                                            = PlatformErrorCodes(2001)
	PlatformErrorCodes_TokenAlreadyClaimed                                       = PlatformErrorCodes(2002)
	PlatformErrorCodes_TokenAlreadyClaimedSelf                                   = PlatformErrorCodes(2003)
	PlatformErrorCodes_TokenThrottling                                           = PlatformErrorCodes(2004)
	PlatformErrorCodes_TokenUnknownRedemptionFailure                             = PlatformErrorCodes(2005)
	PlatformErrorCodes_TokenPurchaseClaimFailedAfterTokenClaimed                 = PlatformErrorCodes(2006)
	PlatformErrorCodes_TokenUserAlreadyOwnsOffer                                 = PlatformErrorCodes(2007)
	PlatformErrorCodes_TokenInvalidOfferKey                                      = PlatformErrorCodes(2008)
	PlatformErrorCodes_TokenEmailNotValidated                                    = PlatformErrorCodes(2009)
	PlatformErrorCodes_TokenProvisioningBadVendorOrOffer                         = PlatformErrorCodes(2010)
	PlatformErrorCodes_TokenPurchaseHistoryUnknownError                          = PlatformErrorCodes(2011)
	PlatformErrorCodes_TokenThrottleStateUnknownError                            = PlatformErrorCodes(2012)
	PlatformErrorCodes_TokenUserAgeNotVerified                                   = PlatformErrorCodes(2013)
	PlatformErrorCodes_TokenExceededOfferMaximum                                 = PlatformErrorCodes(2014)
	PlatformErrorCodes_TokenNoAvailableUnlocks                                   = PlatformErrorCodes(2015)
	PlatformErrorCodes_TokenMarketplaceInvalidPlatform                           = PlatformErrorCodes(2016)
	PlatformErrorCodes_TokenNoMarketplaceCodesFound                              = PlatformErrorCodes(2017)
	PlatformErrorCodes_TokenOfferNotAvailableForRedemption                       = PlatformErrorCodes(2018)
	PlatformErrorCodes_TokenUnlockPartialFailure                                 = PlatformErrorCodes(2019)
	PlatformErrorCodes_TokenMarketplaceInvalidRegion                             = PlatformErrorCodes(2020)
	PlatformErrorCodes_TokenOfferExpired                                         = PlatformErrorCodes(2021)
	PlatformErrorCodes_RAFExceededMaximumReferrals                               = PlatformErrorCodes(2022)
	PlatformErrorCodes_RAFDuplicateBond                                          = PlatformErrorCodes(2023)
	PlatformErrorCodes_RAFNoValidVeteranDestinyMembershipsFound                  = PlatformErrorCodes(2024)
	PlatformErrorCodes_RAFNotAValidVeteranUser                                   = PlatformErrorCodes(2025)
	PlatformErrorCodes_RAFCodeAlreadyClaimedOrNotFound                           = PlatformErrorCodes(2026)
	PlatformErrorCodes_RAFMismatchedDestinyMembershipType                        = PlatformErrorCodes(2027)
	PlatformErrorCodes_RAFUnableToAccessPurchaseHistory                          = PlatformErrorCodes(2028)
	PlatformErrorCodes_RAFUnableToCreateBond                                     = PlatformErrorCodes(2029)
	PlatformErrorCodes_RAFUnableToFindBond                                       = PlatformErrorCodes(2030)
	PlatformErrorCodes_RAFUnableToRemoveBond                                     = PlatformErrorCodes(2031)
	PlatformErrorCodes_RAFCannotBondToSelf                                       = PlatformErrorCodes(2032)
	PlatformErrorCodes_RAFInvalidPlatform                                        = PlatformErrorCodes(2033)
	PlatformErrorCodes_RAFGenerateThrottled                                      = PlatformErrorCodes(2034)
	PlatformErrorCodes_RAFUnableToCreateBondVersionMismatch                      = PlatformErrorCodes(2035)
	PlatformErrorCodes_RAFUnableToRemoveBondVersionMismatch                      = PlatformErrorCodes(2036)
	PlatformErrorCodes_RAFRedeemThrottled                                        = PlatformErrorCodes(2037)
	PlatformErrorCodes_NoAvailableDiscountCode                                   = PlatformErrorCodes(2038)
	PlatformErrorCodes_DiscountAlreadyClaimed                                    = PlatformErrorCodes(2039)
	PlatformErrorCodes_DiscountClaimFailure                                      = PlatformErrorCodes(2040)
	PlatformErrorCodes_DiscountConfigurationFailure                              = PlatformErrorCodes(2041)
	PlatformErrorCodes_DiscountGenerationFailure                                 = PlatformErrorCodes(2042)
	PlatformErrorCodes_DiscountAlreadyExists                                     = PlatformErrorCodes(2043)
	PlatformErrorCodes_TokenRequiresCredentialXuid                               = PlatformErrorCodes(2044)
	PlatformErrorCodes_TokenRequiresCredentialPsnid                              = PlatformErrorCodes(2045)
	PlatformErrorCodes_OfferRequired                                             = PlatformErrorCodes(2046)
	PlatformErrorCodes_UnknownEververseHistoryError                              = PlatformErrorCodes(2047)
	PlatformErrorCodes_MissingEververseHistoryError                              = PlatformErrorCodes(2048)
	PlatformErrorCodes_BungieRewardEmailStateInvalid                             = PlatformErrorCodes(2049)
	PlatformErrorCodes_BungieRewardNotYetClaimable                               = PlatformErrorCodes(2050)
	PlatformErrorCodes_MissingOfferConfig                                        = PlatformErrorCodes(2051)
	PlatformErrorCodes_RAFQuestEntitlementRequiresBnet                           = PlatformErrorCodes(2052)
	PlatformErrorCodes_RAFQuestEntitlementTransportFailure                       = PlatformErrorCodes(2053)
	PlatformErrorCodes_RAFQuestEntitlementUnknownFailure                         = PlatformErrorCodes(2054)
	PlatformErrorCodes_RAFVeteranRewardUnknownFailure                            = PlatformErrorCodes(2055)
	PlatformErrorCodes_RAFTooEarlyToCancelBond                                   = PlatformErrorCodes(2056)
	PlatformErrorCodes_LoyaltyRewardAlreadyRedeemed                              = PlatformErrorCodes(2057)
	PlatformErrorCodes_UnclaimedLoyaltyRewardEntryNotFound                       = PlatformErrorCodes(2058)
	PlatformErrorCodes_PartnerOfferPartialFailure                                = PlatformErrorCodes(2059)
	PlatformErrorCodes_PartnerOfferAlreadyClaimed                                = PlatformErrorCodes(2060)
	PlatformErrorCodes_PartnerOfferSkuNotFound                                   = PlatformErrorCodes(2061)
	PlatformErrorCodes_PartnerOfferSkuExpired                                    = PlatformErrorCodes(2062)
	PlatformErrorCodes_PartnerOfferPermissionFailure                             = PlatformErrorCodes(2063)
	PlatformErrorCodes_PartnerOfferNoDestinyAccount                              = PlatformErrorCodes(2064)
	PlatformErrorCodes_PartnerOfferApplyDataNotFound                             = PlatformErrorCodes(2065)
	PlatformErrorCodes_ApiExceededMaxKeys                                        = PlatformErrorCodes(2100)
	PlatformErrorCodes_ApiInvalidOrExpiredKey                                    = PlatformErrorCodes(2101)
	PlatformErrorCodes_ApiKeyMissingFromRequest                                  = PlatformErrorCodes(2102)
	PlatformErrorCodes_ApplicationDisabled                                       = PlatformErrorCodes(2103)
	PlatformErrorCodes_ApplicationExceededMax                                    = PlatformErrorCodes(2104)
	PlatformErrorCodes_ApplicationDisallowedByScope                              = PlatformErrorCodes(2105)
	PlatformErrorCodes_AuthorizationCodeInvalid                                  = PlatformErrorCodes(2106)
	PlatformErrorCodes_OriginHeaderDoesNotMatchKey                               = PlatformErrorCodes(2107)
	PlatformErrorCodes_AccessNotPermittedByApplicationScope                      = PlatformErrorCodes(2108)
	PlatformErrorCodes_ApplicationNameIsTaken                                    = PlatformErrorCodes(2109)
	PlatformErrorCodes_RefreshTokenNotYetValid                                   = PlatformErrorCodes(2110)
	PlatformErrorCodes_AccessTokenHasExpired                                     = PlatformErrorCodes(2111)
	PlatformErrorCodes_ApplicationTokenFormatNotValid                            = PlatformErrorCodes(2112)
	PlatformErrorCodes_ApplicationNotConfiguredForBungieAuth                     = PlatformErrorCodes(2113)
	PlatformErrorCodes_ApplicationNotConfiguredForOAuth                          = PlatformErrorCodes(2114)
	PlatformErrorCodes_OAuthAccessTokenExpired                                   = PlatformErrorCodes(2115)
	PlatformErrorCodes_ApplicationTokenKeyIdDoesNotExist                         = PlatformErrorCodes(2116)
	PlatformErrorCodes_ProvidedTokenNotValidRefreshToken                         = PlatformErrorCodes(2117)
	PlatformErrorCodes_RefreshTokenExpired                                       = PlatformErrorCodes(2118)
	PlatformErrorCodes_AuthorizationRecordInvalid                                = PlatformErrorCodes(2119)
	PlatformErrorCodes_TokenPreviouslyRevoked                                    = PlatformErrorCodes(2120)
	PlatformErrorCodes_TokenInvalidMembership                                    = PlatformErrorCodes(2121)
	PlatformErrorCodes_AuthorizationCodeStale                                    = PlatformErrorCodes(2122)
	PlatformErrorCodes_AuthorizationRecordExpired                                = PlatformErrorCodes(2123)
	PlatformErrorCodes_AuthorizationRecordRevoked                                = PlatformErrorCodes(2124)
	PlatformErrorCodes_AuthorizationRecordInactiveApiKey                         = PlatformErrorCodes(2125)
	PlatformErrorCodes_AuthorizationRecordApiKeyMatching                         = PlatformErrorCodes(2126)
	PlatformErrorCodes_PartnershipInvalidType                                    = PlatformErrorCodes(2200)
	PlatformErrorCodes_PartnershipValidationError                                = PlatformErrorCodes(2201)
	PlatformErrorCodes_PartnershipValidationTimeout                              = PlatformErrorCodes(2202)
	PlatformErrorCodes_PartnershipAccessFailure                                  = PlatformErrorCodes(2203)
	PlatformErrorCodes_PartnershipAccountInvalid                                 = PlatformErrorCodes(2204)
	PlatformErrorCodes_PartnershipGetAccountInfoFailure                          = PlatformErrorCodes(2205)
	PlatformErrorCodes_PartnershipDisabled                                       = PlatformErrorCodes(2206)
	PlatformErrorCodes_PartnershipAlreadyExists                                  = PlatformErrorCodes(2207)
	PlatformErrorCodes_CommunityStreamingUnavailable                             = PlatformErrorCodes(2300)
	PlatformErrorCodes_TwitchNotLinked                                           = PlatformErrorCodes(2500)
	PlatformErrorCodes_TwitchAccountNotFound                                     = PlatformErrorCodes(2501)
	PlatformErrorCodes_TwitchCouldNotLoadDestinyInfo                             = PlatformErrorCodes(2502)
	PlatformErrorCodes_TwitchCouldNotRegisterUser                                = PlatformErrorCodes(2503)
	PlatformErrorCodes_TwitchCouldNotUnregisterUser                              = PlatformErrorCodes(2504)
	PlatformErrorCodes_TwitchRequiresRelinking                                   = PlatformErrorCodes(2505)
	PlatformErrorCodes_TwitchNoPlatformChosen                                    = PlatformErrorCodes(2506)
	PlatformErrorCodes_TwitchDropHistoryPermissionFailure                        = PlatformErrorCodes(2507)
	PlatformErrorCodes_TwitchDropsRepairPartialFailure                           = PlatformErrorCodes(2508)
	PlatformErrorCodes_TwitchNotAuthorized                                       = PlatformErrorCodes(2509)
	PlatformErrorCodes_TwitchUnknownAuthorizationFailure                         = PlatformErrorCodes(2510)
	PlatformErrorCodes_TrendingCategoryNotFound                                  = PlatformErrorCodes(2600)
	PlatformErrorCodes_TrendingEntryTypeNotSupported                             = PlatformErrorCodes(2601)
	PlatformErrorCodes_ReportOffenderNotInPgcr                                   = PlatformErrorCodes(2700)
	PlatformErrorCodes_ReportRequestorNotInPgcr                                  = PlatformErrorCodes(2701)
	PlatformErrorCodes_ReportSubmissionFailed                                    = PlatformErrorCodes(2702)
	PlatformErrorCodes_ReportCannotReportSelf                                    = PlatformErrorCodes(2703)
	PlatformErrorCodes_AwaTypeDisabled                                           = PlatformErrorCodes(2800)
	PlatformErrorCodes_AwaTooManyPendingRequests                                 = PlatformErrorCodes(2801)
	PlatformErrorCodes_AwaTheFeatureRequiresARegisteredDevice                    = PlatformErrorCodes(2802)
	PlatformErrorCodes_AwaRequestWasUnansweredForTooLong                         = PlatformErrorCodes(2803)
	PlatformErrorCodes_AwaWriteRequestMissingOrInvalidToken                      = PlatformErrorCodes(2804)
	PlatformErrorCodes_AwaWriteRequestTokenExpired                               = PlatformErrorCodes(2805)
	PlatformErrorCodes_AwaWriteRequestTokenUsageLimitReached                     = PlatformErrorCodes(2806)
	PlatformErrorCodes_SteamWebApiError                                          = PlatformErrorCodes(2900)
	PlatformErrorCodes_SteamWebNullResponseError                                 = PlatformErrorCodes(2901)
	PlatformErrorCodes_SteamAccountRequired                                      = PlatformErrorCodes(2902)
	PlatformErrorCodes_SteamNotAuthorized                                        = PlatformErrorCodes(2903)
	PlatformErrorCodes_ClanFireteamNotFound                                      = PlatformErrorCodes(3000)
	PlatformErrorCodes_ClanFireteamAddNoAlternatesForImmediate                   = PlatformErrorCodes(3001)
	PlatformErrorCodes_ClanFireteamFull                                          = PlatformErrorCodes(3002)
	PlatformErrorCodes_ClanFireteamAltFull                                       = PlatformErrorCodes(3003)
	PlatformErrorCodes_ClanFireteamBlocked                                       = PlatformErrorCodes(3004)
	PlatformErrorCodes_ClanFireteamPlayerEntryNotFound                           = PlatformErrorCodes(3005)
	PlatformErrorCodes_ClanFireteamPermissions                                   = PlatformErrorCodes(3006)
	PlatformErrorCodes_ClanFireteamInvalidPlatform                               = PlatformErrorCodes(3007)
	PlatformErrorCodes_ClanFireteamCannotAdjustSlotCount                         = PlatformErrorCodes(3008)
	PlatformErrorCodes_ClanFireteamInvalidPlayerPlatform                         = PlatformErrorCodes(3009)
	PlatformErrorCodes_ClanFireteamNotReadyForInvitesNotEnoughPlayers            = PlatformErrorCodes(3010)
	PlatformErrorCodes_ClanFireteamGameInvitesNotSupportForPlatform              = PlatformErrorCodes(3011)
	PlatformErrorCodes_ClanFireteamPlatformInvitePreqFailure                     = PlatformErrorCodes(3012)
	PlatformErrorCodes_ClanFireteamInvalidAuthContext                            = PlatformErrorCodes(3013)
	PlatformErrorCodes_ClanFireteamInvalidAuthProviderPsn                        = PlatformErrorCodes(3014)
	PlatformErrorCodes_ClanFireteamPs4SessionFull                                = PlatformErrorCodes(3015)
	PlatformErrorCodes_ClanFireteamInvalidAuthToken                              = PlatformErrorCodes(3016)
	PlatformErrorCodes_ClanFireteamScheduledFireteamsDisabled                    = PlatformErrorCodes(3017)
	PlatformErrorCodes_ClanFireteamNotReadyForInvitesNotScheduledYet             = PlatformErrorCodes(3018)
	PlatformErrorCodes_ClanFireteamNotReadyForInvitesClosed                      = PlatformErrorCodes(3019)
	PlatformErrorCodes_ClanFireteamScheduledFireteamsRequireAdminPermissions     = PlatformErrorCodes(3020)
	PlatformErrorCodes_ClanFireteamNonPublicMustHaveClan                         = PlatformErrorCodes(3021)
	PlatformErrorCodes_ClanFireteamPublicCreationRestriction                     = PlatformErrorCodes(3022)
	PlatformErrorCodes_ClanFireteamAlreadyJoined                                 = PlatformErrorCodes(3023)
	PlatformErrorCodes_ClanFireteamScheduledFireteamsRange                       = PlatformErrorCodes(3024)
	PlatformErrorCodes_ClanFireteamPublicCreationRestrictionExtended             = PlatformErrorCodes(3025)
	PlatformErrorCodes_ClanFireteamExpired                                       = PlatformErrorCodes(3026)
	PlatformErrorCodes_ClanFireteamInvalidAuthProvider                           = PlatformErrorCodes(3027)
	PlatformErrorCodes_ClanFireteamInvalidAuthProviderXuid                       = PlatformErrorCodes(3028)
	PlatformErrorCodes_ClanFireteamThrottle                                      = PlatformErrorCodes(3029)
	PlatformErrorCodes_ClanFireteamTooManyOpenScheduledFireteams                 = PlatformErrorCodes(3030)
	PlatformErrorCodes_ClanFireteamCannotReopenScheduledFireteams                = PlatformErrorCodes(3031)
	PlatformErrorCodes_ClanFireteamJoinNoAccountSpecified                        = PlatformErrorCodes(3032)
	PlatformErrorCodes_ClanFireteamMinDestiny2ProgressForCreation                = PlatformErrorCodes(3033)
	PlatformErrorCodes_ClanFireteamMinDestiny2ProgressForJoin                    = PlatformErrorCodes(3034)
	PlatformErrorCodes_ClanFireteamSMSOrPurchaseRequiredCreate                   = PlatformErrorCodes(3035)
	PlatformErrorCodes_ClanFireteamPurchaseRequiredCreate                        = PlatformErrorCodes(3036)
	PlatformErrorCodes_ClanFireteamSMSOrPurchaseRequiredJoin                     = PlatformErrorCodes(3037)
	PlatformErrorCodes_ClanFireteamPurchaseRequiredJoin                          = PlatformErrorCodes(3038)
	PlatformErrorCodes_FireteamFinderInvalidMembershipType                       = PlatformErrorCodes(3100)
	PlatformErrorCodes_FireteamFinderInvalidMembershipId                         = PlatformErrorCodes(3101)
	PlatformErrorCodes_FireteamFinderInvalidCharacterId                          = PlatformErrorCodes(3102)
	PlatformErrorCodes_FireteamFinderInvalidListingOptions                       = PlatformErrorCodes(3103)
	PlatformErrorCodes_FireteamFinderInvalidRequestData                          = PlatformErrorCodes(3104)
	PlatformErrorCodes_FireteamFinderListingApplicationFailed                    = PlatformErrorCodes(3105)
	PlatformErrorCodes_FireteamFinderListingAutoJoinFailed                       = PlatformErrorCodes(3106)
	PlatformErrorCodes_FireteamFinderPlayerApplicationsParsingFailed             = PlatformErrorCodes(3107)
	PlatformErrorCodes_FireteamFinderJoinLobbyHostFailed                         = PlatformErrorCodes(3108)
	PlatformErrorCodes_FireteamFinderPlayerNotInGame                             = PlatformErrorCodes(3109)
	PlatformErrorCodes_FireteamFinderActivationFailed                            = PlatformErrorCodes(3110)
	PlatformErrorCodes_FireteamFinderApplicationNotFound                         = PlatformErrorCodes(3111)
	PlatformErrorCodes_FireteamFinderUserAlreadyAppliedToListing                 = PlatformErrorCodes(3112)
	PlatformErrorCodes_FireteamFinderApplicationClosedForUpdates                 = PlatformErrorCodes(3113)
	PlatformErrorCodes_FireteamFinderListingAtMaxOpenApplicationsLimit           = PlatformErrorCodes(3114)
	PlatformErrorCodes_FireteamFinderUserNotInApplication                        = PlatformErrorCodes(3115)
	PlatformErrorCodes_FireteamFinderApplicationUserAlreadyListingOwner          = PlatformErrorCodes(3116)
	PlatformErrorCodes_FireteamFinderOfferNotFound                               = PlatformErrorCodes(3117)
	PlatformErrorCodes_FireteamFinderOfferClosedForUpdates                       = PlatformErrorCodes(3118)
	PlatformErrorCodes_FireteamFinderOfferUserNotTarget                          = PlatformErrorCodes(3119)
	PlatformErrorCodes_FireteamFinderLobbyNotFound                               = PlatformErrorCodes(3120)
	PlatformErrorCodes_FireteamFinderListingNotFound                             = PlatformErrorCodes(3121)
	PlatformErrorCodes_FireteamFinderLobbyFull                                   = PlatformErrorCodes(3122)
	PlatformErrorCodes_FireteamFinderUserNotListingOwner                         = PlatformErrorCodes(3123)
	PlatformErrorCodes_FireteamFinderUserNotLobbyOwner                           = PlatformErrorCodes(3124)
	PlatformErrorCodes_FireteamFinderLobbyClosedForUpdates                       = PlatformErrorCodes(3125)
	PlatformErrorCodes_FireteamFinderUserNotInLobby                              = PlatformErrorCodes(3126)
	PlatformErrorCodes_FireteamFinderDisabledSettingsValue                       = PlatformErrorCodes(3127)
	PlatformErrorCodes_FireteamFinderOwnerInActiveLobby                          = PlatformErrorCodes(3128)
	PlatformErrorCodes_FireteamFinderApplicationClosedToOfflinePlayers           = PlatformErrorCodes(3129)
	PlatformErrorCodes_FireteamFinderUserNotApplicationOwner                     = PlatformErrorCodes(3130)
	PlatformErrorCodes_FireteamFinderInviteValidationFailed                      = PlatformErrorCodes(3131)
	PlatformErrorCodes_FireteamFinderOwnerNotInGame                              = PlatformErrorCodes(3132)
	PlatformErrorCodes_FireteamFinderPlayerAtMaxLobbyLimit                       = PlatformErrorCodes(3133)
	PlatformErrorCodes_FireteamFinderLobbyTooFarInTheFuture                      = PlatformErrorCodes(3134)
	PlatformErrorCodes_FireteamFinderApplicantNotInGame                          = PlatformErrorCodes(3135)
	PlatformErrorCodes_FireteamFinderResponseUndefined                           = PlatformErrorCodes(3150)
	PlatformErrorCodes_FireteamFinderResponseMoved                               = PlatformErrorCodes(3151)
	PlatformErrorCodes_FireteamFinderResponseLoggingIn                           = PlatformErrorCodes(3152)
	PlatformErrorCodes_FireteamFinderResponseBadRequest                          = PlatformErrorCodes(3153)
	PlatformErrorCodes_FireteamFinderResponseUnauthorized                        = PlatformErrorCodes(3154)
	PlatformErrorCodes_FireteamFinderResponseForbidden                           = PlatformErrorCodes(3155)
	PlatformErrorCodes_FireteamFinderResponseNotFound                            = PlatformErrorCodes(3156)
	PlatformErrorCodes_FireteamFinderInternalServerError                         = PlatformErrorCodes(3157)
	PlatformErrorCodes_FireteamFinderServiceUnavailable                          = PlatformErrorCodes(3158)
	PlatformErrorCodes_FireteamFinderInternalServerErrorNonFatal                 = PlatformErrorCodes(3159)
	PlatformErrorCodes_CrossSaveOverriddenAccountNotFound                        = PlatformErrorCodes(3200)
	PlatformErrorCodes_CrossSaveTooManyOverriddenPlatforms                       = PlatformErrorCodes(3201)
	PlatformErrorCodes_CrossSaveNoOverriddenPlatforms                            = PlatformErrorCodes(3202)
	PlatformErrorCodes_CrossSavePrimaryAccountNotFound                           = PlatformErrorCodes(3203)
	PlatformErrorCodes_CrossSaveRequestInvalid                                   = PlatformErrorCodes(3204)
	PlatformErrorCodes_CrossSaveBungieAccountValidationFailure                   = PlatformErrorCodes(3206)
	PlatformErrorCodes_CrossSaveOverriddenPlatformNotAllowed                     = PlatformErrorCodes(3207)
	PlatformErrorCodes_CrossSaveThresholdExceeded                                = PlatformErrorCodes(3208)
	PlatformErrorCodes_CrossSaveIncompatibleMembershipType                       = PlatformErrorCodes(3209)
	PlatformErrorCodes_CrossSaveCouldNotFindLinkedAccountForMembershipType       = PlatformErrorCodes(3210)
	PlatformErrorCodes_CrossSaveCouldNotCreateDestinyProfileForMembershipType    = PlatformErrorCodes(3211)
	PlatformErrorCodes_CrossSaveErrorCreatingDestinyProfileForMembershipType     = PlatformErrorCodes(3212)
	PlatformErrorCodes_CrossSaveCannotOverrideSelf                               = PlatformErrorCodes(3213)
	PlatformErrorCodes_CrossSaveRecentSilverPurchase                             = PlatformErrorCodes(3214)
	PlatformErrorCodes_CrossSaveSilverBalanceNegative                            = PlatformErrorCodes(3215)
	PlatformErrorCodes_CrossSaveAccountNotAuthenticated                          = PlatformErrorCodes(3216)
	PlatformErrorCodes_ErrorOneAccountAlreadyActive                              = PlatformErrorCodes(3217)
	PlatformErrorCodes_ErrorOneAccountDestinyRestriction                         = PlatformErrorCodes(3218)
	PlatformErrorCodes_CrossSaveMustMigrateToSteam                               = PlatformErrorCodes(3219)
	PlatformErrorCodes_CrossSaveSteamAlreadyPaired                               = PlatformErrorCodes(3220)
	PlatformErrorCodes_CrossSaveCannotPairJustSteamAndBlizzard                   = PlatformErrorCodes(3221)
	PlatformErrorCodes_CrossSaveCannotPairSteamAloneBeforeShadowkeep             = PlatformErrorCodes(3222)
	PlatformErrorCodes_AuthVerificationNotLinkedToAccount                        = PlatformErrorCodes(3300)
	PlatformErrorCodes_PCMigrationMissingBlizzard                                = PlatformErrorCodes(3400)
	PlatformErrorCodes_PCMigrationMissingSteam                                   = PlatformErrorCodes(3401)
	PlatformErrorCodes_PCMigrationInvalidBlizzard                                = PlatformErrorCodes(3402)
	PlatformErrorCodes_PCMigrationInvalidSteam                                   = PlatformErrorCodes(3403)
	PlatformErrorCodes_PCMigrationUnknownFailure                                 = PlatformErrorCodes(3404)
	PlatformErrorCodes_PCMigrationUnknownException                               = PlatformErrorCodes(3405)
	PlatformErrorCodes_PCMigrationNotLinked                                      = PlatformErrorCodes(3406)
	PlatformErrorCodes_PCMigrationAccountsAlreadyUsed                            = PlatformErrorCodes(3407)
	PlatformErrorCodes_PCMigrationStepFailed                                     = PlatformErrorCodes(3408)
	PlatformErrorCodes_PCMigrationInvalidBlizzardCrossSaveState                  = PlatformErrorCodes(3409)
	PlatformErrorCodes_PCMigrationDestinationBanned                              = PlatformErrorCodes(3410)
	PlatformErrorCodes_PCMigrationDestinyFailure                                 = PlatformErrorCodes(3411)
	PlatformErrorCodes_PCMigrationSilverTransferFailed                           = PlatformErrorCodes(3412)
	PlatformErrorCodes_PCMigrationEntitlementTransferFailed                      = PlatformErrorCodes(3413)
	PlatformErrorCodes_PCMigrationCannotStompClanFounder                         = PlatformErrorCodes(3414)
	PlatformErrorCodes_UnsupportedBrowser                                        = PlatformErrorCodes(3500)
	PlatformErrorCodes_StadiaAccountRequired                                     = PlatformErrorCodes(3600)
	PlatformErrorCodes_ErrorPhoneValidationTooManyUses                           = PlatformErrorCodes(3702)
	PlatformErrorCodes_ErrorPhoneValidationNoAssociatedPhone                     = PlatformErrorCodes(3703)
	PlatformErrorCodes_ErrorPhoneValidationCodeInvalid                           = PlatformErrorCodes(3705)
	PlatformErrorCodes_ErrorPhoneValidationBanned                                = PlatformErrorCodes(3706)
	PlatformErrorCodes_ErrorPhoneValidationCodeTooRecentlySent                   = PlatformErrorCodes(3707)
	PlatformErrorCodes_ErrorPhoneValidationCodeExpired                           = PlatformErrorCodes(3708)
	PlatformErrorCodes_ErrorPhoneValidationInvalidNumberType                     = PlatformErrorCodes(3709)
	PlatformErrorCodes_ErrorPhoneValidationCodeTooRecentlyChecked                = PlatformErrorCodes(3710)
	PlatformErrorCodes_ErrorPhoneValidationRecentlyPlayedDestiny2AccountRequired = PlatformErrorCodes(3711)
	PlatformErrorCodes_ApplePushErrorUnknown                                     = PlatformErrorCodes(3800)
	PlatformErrorCodes_ApplePushErrorNull                                        = PlatformErrorCodes(3801)
	PlatformErrorCodes_ApplePushErrorTimeout                                     = PlatformErrorCodes(3802)
	PlatformErrorCodes_ApplePushBadRequest                                       = PlatformErrorCodes(3803)
	PlatformErrorCodes_ApplePushFailedAuth                                       = PlatformErrorCodes(3804)
	PlatformErrorCodes_ApplePushThrottled                                        = PlatformErrorCodes(3805)
	PlatformErrorCodes_ApplePushServiceUnavailable                               = PlatformErrorCodes(3806)
	PlatformErrorCodes_NotAnImageOrVideo                                         = PlatformErrorCodes(3807)
	PlatformErrorCodes_ErrorBungieFriendsBlockFailed                             = PlatformErrorCodes(3900)
	PlatformErrorCodes_ErrorBungieFriendsAutoReject                              = PlatformErrorCodes(3901)
	PlatformErrorCodes_ErrorBungieFriendsNoRequestFound                          = PlatformErrorCodes(3902)
	PlatformErrorCodes_ErrorBungieFriendsAlreadyFriends                          = PlatformErrorCodes(3903)
	PlatformErrorCodes_ErrorBungieFriendsUnableToRemoveRequest                   = PlatformErrorCodes(3904)
	PlatformErrorCodes_ErrorBungieFriendsUnableToRemove                          = PlatformErrorCodes(3905)
	PlatformErrorCodes_ErrorBungieFriendsIdenticalSourceTarget                   = PlatformErrorCodes(3906)
	PlatformErrorCodes_ErrorBungieFriendsSelf                                    = PlatformErrorCodes(3907)
	PlatformErrorCodes_ErrorBungieBlockSelf                                      = PlatformErrorCodes(3908)
	PlatformErrorCodes_ErrorBungieFriendsListFull                                = PlatformErrorCodes(3910)
	PlatformErrorCodes_ErrorBungieBlockListFull                                  = PlatformErrorCodes(3911)
	PlatformErrorCodes_ErrorBungieFriendNotFound                                 = PlatformErrorCodes(3912)
	PlatformErrorCodes_ErrorBungieFriendInvalidMembershipType                    = PlatformErrorCodes(3913)
	PlatformErrorCodes_ErrorEgsUnknown                                           = PlatformErrorCodes(4000)
	PlatformErrorCodes_ErrorEgsBadRequest                                        = PlatformErrorCodes(4001)
	PlatformErrorCodes_ErrorEgsNotAuthorized                                     = PlatformErrorCodes(4002)
	PlatformErrorCodes_ErrorEgsForbidden                                         = PlatformErrorCodes(4003)
	PlatformErrorCodes_ErrorEgsAccountNotFound                                   = PlatformErrorCodes(4004)
	PlatformErrorCodes_ErrorEgsWebException                                      = PlatformErrorCodes(4005)
	PlatformErrorCodes_ErrorEgsUnavailable                                       = PlatformErrorCodes(4006)
	PlatformErrorCodes_ErrorEgsJwksMissing                                       = PlatformErrorCodes(4007)
	PlatformErrorCodes_ErrorEgsJwtMalformedHeader                                = PlatformErrorCodes(4008)
	PlatformErrorCodes_ErrorEgsJwtMalformedPayload                               = PlatformErrorCodes(4009)
)

// Fireteam.FireteamDateRange
type FireteamDateRange int

const (
	FireteamDateRange_All             = FireteamDateRange(0)
	FireteamDateRange_Now             = FireteamDateRange(1)
	FireteamDateRange_TwentyFourHours = FireteamDateRange(2)
	FireteamDateRange_FortyEightHours = FireteamDateRange(3)
	FireteamDateRange_ThisWeek        = FireteamDateRange(4)
)

// Fireteam.FireteamMember
type FireteamMember struct {
	// {
	//   "properties": {
	//     "bungieNetUserInfo": {
	//       "$ref": "#/components/schemas/User.UserInfoCard"
	//     },
	//     "characterId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "dateJoined": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "destinyUserInfo": {
	//       "$ref": "#/components/schemas/Fireteam.FireteamUserInfoCard"
	//     },
	//     "hasMicrophone": {
	//       "type": "boolean"
	//     },
	//     "lastPlatformInviteAttemptDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "lastPlatformInviteAttemptResult": {
	//       "format": "byte",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Fireteam.FireteamPlatformInviteResult"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	BungieNetUserInfo UserInfoCard `json:"bungieNetUserInfo"`

	CharacterID Int64 `json:"characterId"`

	DateJoined Timestamp `json:"dateJoined"`

	DestinyUserInfo FireteamUserInfoCard `json:"destinyUserInfo"`

	HasMicrophone bool `json:"hasMicrophone"`

	LastPlatformInviteAttemptDate Timestamp `json:"lastPlatformInviteAttemptDate"`

	LastPlatformInviteAttemptResult FireteamPlatformInviteResult `json:"lastPlatformInviteAttemptResult"`
}

// Fireteam.FireteamPlatform
type FireteamPlatform int

const (
	FireteamPlatform_Any          = FireteamPlatform(0)
	FireteamPlatform_Playstation4 = FireteamPlatform(1)
	FireteamPlatform_XboxOne      = FireteamPlatform(2)
	FireteamPlatform_Blizzard     = FireteamPlatform(3)
	FireteamPlatform_Steam        = FireteamPlatform(4)
	FireteamPlatform_Stadia       = FireteamPlatform(5)
	FireteamPlatform_Egs          = FireteamPlatform(6)
)

// Fireteam.FireteamPlatformInviteResult
type FireteamPlatformInviteResult int

const (
	FireteamPlatformInviteResult_None              = FireteamPlatformInviteResult(0)
	FireteamPlatformInviteResult_Success           = FireteamPlatformInviteResult(1)
	FireteamPlatformInviteResult_AlreadyInFireteam = FireteamPlatformInviteResult(2)
	FireteamPlatformInviteResult_Throttled         = FireteamPlatformInviteResult(3)
	FireteamPlatformInviteResult_ServiceError      = FireteamPlatformInviteResult(4)
)

// Fireteam.FireteamPublicSearchOption
type FireteamPublicSearchOption int

const (
	FireteamPublicSearchOption_PublicAndPrivate = FireteamPublicSearchOption(0)
	FireteamPublicSearchOption_PublicOnly       = FireteamPublicSearchOption(1)
	FireteamPublicSearchOption_PrivateOnly      = FireteamPublicSearchOption(2)
)

// Fireteam.FireteamResponse
type FireteamResponse struct {
	// {
	//   "properties": {
	//     "Alternates": {
	//       "items": {
	//         "$ref": "#/components/schemas/Fireteam.FireteamMember"
	//       },
	//       "type": "array"
	//     },
	//     "Members": {
	//       "items": {
	//         "$ref": "#/components/schemas/Fireteam.FireteamMember"
	//       },
	//       "type": "array"
	//     },
	//     "Summary": {
	//       "$ref": "#/components/schemas/Fireteam.FireteamSummary"
	//     }
	//   },
	//   "type": "object"
	// }

	Alternates []FireteamMember `json:"Alternates"`

	Members []FireteamMember `json:"Members"`

	Summary FireteamSummary `json:"Summary"`
}

// Fireteam.FireteamSlotSearch
type FireteamSlotSearch int

const (
	FireteamSlotSearch_NoSlotRestriction       = FireteamSlotSearch(0)
	FireteamSlotSearch_HasOpenPlayerSlots      = FireteamSlotSearch(1)
	FireteamSlotSearch_HasOpenPlayerOrAltSlots = FireteamSlotSearch(2)
)

// Fireteam.FireteamSummary
type FireteamSummary struct {
	// {
	//   "properties": {
	//     "activityType": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "alternateSlotCount": {
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "availableAlternateSlotCount": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "availablePlayerSlotCount": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "dateCreated": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "dateModified": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "datePlayerModified": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "fireteamId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "groupId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "isImmediate": {
	//       "type": "boolean"
	//     },
	//     "isPublic": {
	//       "type": "boolean"
	//     },
	//     "isValid": {
	//       "type": "boolean"
	//     },
	//     "locale": {
	//       "type": "string"
	//     },
	//     "ownerCurrentGuardianRankSnapshot": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.GuardianRanks.DestinyGuardianRankDefinition"
	//       }
	//     },
	//     "ownerHighestLifetimeGuardianRankSnapshot": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.GuardianRanks.DestinyGuardianRankDefinition"
	//       }
	//     },
	//     "ownerMembershipId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "ownerTotalCommendationScoreSnapshot": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "platform": {
	//       "format": "byte",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Fireteam.FireteamPlatform"
	//       }
	//     },
	//     "playerSlotCount": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "scheduledTime": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "title": {
	//       "type": "string"
	//     },
	//     "titleBeforeModeration": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	ActivityType int32 `json:"activityType"`

	AlternateSlotCount Nullable[int32] `json:"alternateSlotCount,omitempty"`

	AvailableAlternateSlotCount int32 `json:"availableAlternateSlotCount"`

	AvailablePlayerSlotCount int32 `json:"availablePlayerSlotCount"`

	DateCreated Timestamp `json:"dateCreated"`

	DateModified Nullable[Timestamp] `json:"dateModified,omitempty"`

	DatePlayerModified Timestamp `json:"datePlayerModified"`

	FireteamID Int64 `json:"fireteamId"`

	GroupID Int64 `json:"groupId"`

	IsImmediate bool `json:"isImmediate"`

	IsPublic bool `json:"isPublic"`

	IsValid bool `json:"isValid"`

	Locale string `json:"locale"`

	OwnerCurrentGuardianRankSnapshot Hash[GuardianRankDefinition] `json:"ownerCurrentGuardianRankSnapshot"`

	OwnerHighestLifetimeGuardianRankSnapshot Hash[GuardianRankDefinition] `json:"ownerHighestLifetimeGuardianRankSnapshot"`

	OwnerMembershipID Int64 `json:"ownerMembershipId"`

	OwnerTotalCommendationScoreSnapshot int32 `json:"ownerTotalCommendationScoreSnapshot"`

	Platform FireteamPlatform `json:"platform"`

	PlayerSlotCount int32 `json:"playerSlotCount"`

	ScheduledTime Nullable[Timestamp] `json:"scheduledTime,omitempty"`

	Title string `json:"title"`

	TitleBeforeModeration string `json:"titleBeforeModeration"`
}

// Fireteam.FireteamUserInfoCard
type FireteamUserInfoCard struct {
	// {
	//   "properties": {
	//     "FireteamDisplayName": {
	//       "type": "string"
	//     },
	//     "FireteamMembershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "applicableMembershipTypes": {
	//       "description": "The list of Membership Types indicating the platforms on which this Membership can be used.\r\n Not in Cross Save = its original membership type. Cross Save Primary = Any membership types it is overridding, and its original membership type Cross Save Overridden = Empty list",
	//       "items": {
	//         "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/BungieMembershipType"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "bungieGlobalDisplayName": {
	//       "description": "The bungie global display name, if set.",
	//       "type": "string"
	//     },
	//     "bungieGlobalDisplayNameCode": {
	//       "description": "The bungie global display name code, if set.",
	//       "format": "int16",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "crossSaveOverride": {
	//       "description": "If there is a cross save override in effect, this value will tell you the type that is overridding this one.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "displayName": {
	//       "description": "Display Name the player has chosen for themselves. The display name is optional when the data type is used as input to a platform API.",
	//       "type": "string"
	//     },
	//     "iconPath": {
	//       "description": "URL the Icon if available.",
	//       "type": "string"
	//     },
	//     "isPublic": {
	//       "description": "If True, this is a public user membership.",
	//       "type": "boolean"
	//     },
	//     "membershipId": {
	//       "description": "Membership ID as they user is known in the Accounts service",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "description": "Type of the membership. Not necessarily the native type.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "supplementalDisplayName": {
	//       "description": "A platform specific additional display name - ex: psn Real Name, bnet Unique Name, etc.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	FireteamDisplayName string `json:"FireteamDisplayName"`

	FireteamMembershipType BungieMembershipType `json:"FireteamMembershipType"`

	// The list of Membership Types indicating the platforms on which this Membership can be used.
	//
	//	Not in Cross Save = its original membership type. Cross Save Primary = Any membership types it is
	//
	// overridding, and its original membership type Cross Save Overridden = Empty list
	ApplicableMembershipTypes []BungieMembershipType `json:"applicableMembershipTypes"`

	// The bungie global display name, if set.
	BungieGlobalDisplayName string `json:"bungieGlobalDisplayName"`

	// The bungie global display name code, if set.
	BungieGlobalDisplayNameCode Nullable[int16] `json:"bungieGlobalDisplayNameCode,omitempty"`

	// If there is a cross save override in effect, this value will tell you the type that is overridding
	// this one.
	CrossSaveOverride BungieMembershipType `json:"crossSaveOverride"`

	// Display Name the player has chosen for themselves. The display name is optional when the data type
	// is used as input to a platform API.
	DisplayName string `json:"displayName"`

	// URL the Icon if available.
	IconPath string `json:"iconPath"`

	// If True, this is a public user membership.
	IsPublic bool `json:"isPublic"`

	// Membership ID as they user is known in the Accounts service
	MembershipID Int64 `json:"membershipId"`

	// Type of the membership. Not necessarily the native type.
	MembershipType BungieMembershipType `json:"membershipType"`

	// A platform specific additional display name - ex: psn Real Name, bnet Unique Name, etc.
	SupplementalDisplayName string `json:"supplementalDisplayName"`
}

// FireteamFinder.DestinyFireteamFinderActivityGraphState
type FireteamFinderActivityGraphState struct {
	// {
	//   "properties": {
	//     "isAvailable": {
	//       "description": "Indicates if this fireteam finder activity graph node is available to select for this character.",
	//       "type": "boolean"
	//     },
	//     "isVisible": {
	//       "description": "Indicates if this fireteam finder activity graph node is visible for this character.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	// Indicates if this fireteam finder activity graph node is available to select for this character.
	IsAvailable bool `json:"isAvailable"`

	// Indicates if this fireteam finder activity graph node is visible for this character.
	IsVisible bool `json:"isVisible"`
}

// FireteamFinder.DestinyFireteamFinderApplicant
type FireteamFinderApplicant map[string]any

//	{
//	  "type": "object"
//	}
//
// FireteamFinder.DestinyFireteamFinderApplicantSet
type FireteamFinderApplicantSet struct {
	// {
	//   "properties": {
	//     "applicants": {
	//       "items": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderApplicant"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	Applicants []FireteamFinderApplicant `json:"applicants"`
}

// FireteamFinder.DestinyFireteamFinderApplication
type FireteamFinderApplication struct {
	// {
	//   "properties": {
	//     "applicantSet": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderApplicantSet"
	//     },
	//     "applicationId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "applicationType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderApplicationType"
	//       }
	//     },
	//     "createdDateTime": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "listingId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "referralToken": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "revision": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "state": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderApplicationState"
	//       }
	//     },
	//     "submitterId": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderPlayerId"
	//     }
	//   },
	//   "type": "object"
	// }

	ApplicantSet FireteamFinderApplicantSet `json:"applicantSet"`

	ApplicationID Int64 `json:"applicationId"`

	ApplicationType FireteamFinderApplicationType `json:"applicationType"`

	CreatedDateTime Timestamp `json:"createdDateTime"`

	ListingID Int64 `json:"listingId"`

	ReferralToken Int64 `json:"referralToken"`

	Revision int32 `json:"revision"`

	State FireteamFinderApplicationState `json:"state"`

	SubmitterID FireteamFinderPlayerId `json:"submitterId"`
}

// FireteamFinder.DestinyFireteamFinderApplicationState
type FireteamFinderApplicationState int32

const (
	FireteamFinderApplicationState_Unknown              = FireteamFinderApplicationState(0)
	FireteamFinderApplicationState_WaitingForApplicants = FireteamFinderApplicationState(1)
	FireteamFinderApplicationState_WaitingForLobbyOwner = FireteamFinderApplicationState(2)
	FireteamFinderApplicationState_Accepted             = FireteamFinderApplicationState(3)
	FireteamFinderApplicationState_Rejected             = FireteamFinderApplicationState(4)
	FireteamFinderApplicationState_Deleted              = FireteamFinderApplicationState(5)
	FireteamFinderApplicationState_Expired              = FireteamFinderApplicationState(6)
)

// FireteamFinder.DestinyFireteamFinderApplicationType
type FireteamFinderApplicationType int32

const (
	FireteamFinderApplicationType_Unknown   = FireteamFinderApplicationType(0)
	FireteamFinderApplicationType_Creator   = FireteamFinderApplicationType(1)
	FireteamFinderApplicationType_Search    = FireteamFinderApplicationType(2)
	FireteamFinderApplicationType_Invite    = FireteamFinderApplicationType(3)
	FireteamFinderApplicationType_Friend    = FireteamFinderApplicationType(4)
	FireteamFinderApplicationType_Encounter = FireteamFinderApplicationType(5)
	FireteamFinderApplicationType_Public    = FireteamFinderApplicationType(6)
)

// FireteamFinder.DestinyFireteamFinderApplyToListingResponse
type FireteamFinderApplyToListingResponse struct {
	// {
	//   "properties": {
	//     "application": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderApplication"
	//     },
	//     "isApplied": {
	//       "type": "boolean"
	//     },
	//     "listing": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderListing"
	//     }
	//   },
	//   "type": "object"
	// }

	Application FireteamFinderApplication `json:"application"`

	IsApplied bool `json:"isApplied"`

	Listing FireteamFinderListing `json:"listing"`
}

// FireteamFinder.DestinyFireteamFinderBulkGetListingStatusRequest
type FireteamFinderBulkGetListingStatusRequestBody map[string]any

//	{
//	  "type": "object"
//	}
//
// FireteamFinder.DestinyFireteamFinderBulkGetListingStatusResponse
type FireteamFinderBulkGetListingStatusResponse struct {
	// {
	//   "properties": {
	//     "listingStatus": {
	//       "items": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderListingStatus"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	ListingStatus []FireteamFinderListingStatus `json:"listingStatus"`
}

// FireteamFinder.DestinyFireteamFinderGetApplicationResponse
type FireteamFinderGetApplicationResponse struct {
	// {
	//   "properties": {
	//     "applicantSet": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderApplicantSet"
	//     },
	//     "applicationId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "applicationType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderApplicationType"
	//       }
	//     },
	//     "createdDateTime": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "listingId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "referralToken": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "revision": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "state": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderApplicationState"
	//       }
	//     },
	//     "submitterId": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderPlayerId"
	//     }
	//   },
	//   "type": "object"
	// }

	ApplicantSet FireteamFinderApplicantSet `json:"applicantSet"`

	ApplicationID Int64 `json:"applicationId"`

	ApplicationType FireteamFinderApplicationType `json:"applicationType"`

	CreatedDateTime Timestamp `json:"createdDateTime"`

	ListingID Int64 `json:"listingId"`

	ReferralToken Int64 `json:"referralToken"`

	Revision int32 `json:"revision"`

	State FireteamFinderApplicationState `json:"state"`

	SubmitterID FireteamFinderPlayerId `json:"submitterId"`
}

// FireteamFinder.DestinyFireteamFinderGetCharacterActivityAccessResponse
type FireteamFinderGetCharacterActivityAccessResponse struct {
	// {
	//   "properties": {
	//     "fireteamFinderActivityGraphStates": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderActivityGraphState"
	//       },
	//       "description": "A map of fireteam finder activity graph hashes to visibility and availability states.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderActivityGraphDefinition"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// A map of fireteam finder activity graph hashes to visibility and availability states.
	FireteamFinderActivityGraphStates map[Hash[FireteamFinderActivityGraphDefinition]]FireteamFinderActivityGraphState `json:"fireteamFinderActivityGraphStates"`
}

// FireteamFinder.DestinyFireteamFinderGetListingApplicationsResponse
type FireteamFinderGetListingApplicationsResponse struct {
	// {
	//   "properties": {
	//     "applications": {
	//       "items": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderApplication"
	//       },
	//       "type": "array"
	//     },
	//     "nextPageToken": {
	//       "type": "string"
	//     },
	//     "pageSize": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	Applications []FireteamFinderApplication `json:"applications"`

	NextPageToken string `json:"nextPageToken"`

	PageSize int32 `json:"pageSize"`
}

// FireteamFinder.DestinyFireteamFinderGetLobbyOffersResponse
type FireteamFinderGetLobbyOffersResponse struct {
	// {
	//   "properties": {
	//     "offers": {
	//       "items": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderOffer"
	//       },
	//       "type": "array"
	//     },
	//     "pageToken": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Offers []FireteamFinderOffer `json:"offers"`

	PageToken string `json:"pageToken"`
}

// FireteamFinder.DestinyFireteamFinderGetPlayerApplicationsResponse
type FireteamFinderGetPlayerApplicationsResponse struct {
	// {
	//   "properties": {
	//     "applications": {
	//       "description": "All applications that this player has sent.",
	//       "items": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderApplication"
	//       },
	//       "type": "array"
	//     },
	//     "nextPageToken": {
	//       "description": "String token to request next page of results.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// All applications that this player has sent.
	Applications []FireteamFinderApplication `json:"applications"`

	// String token to request next page of results.
	NextPageToken string `json:"nextPageToken"`
}

// FireteamFinder.DestinyFireteamFinderGetPlayerLobbiesResponse
type FireteamFinderGetPlayerLobbiesResponse struct {
	// {
	//   "properties": {
	//     "lobbies": {
	//       "description": "All available lobbies that this player has created or is a member of.",
	//       "items": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderLobbyResponse"
	//       },
	//       "type": "array"
	//     },
	//     "nextPageToken": {
	//       "description": "A string token required to get the next page of results. This will be null or empty if there are no more results.",
	//       "type": "string"
	//     },
	//     "pageSize": {
	//       "description": "The number of results requested.",
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// All available lobbies that this player has created or is a member of.
	Lobbies []FireteamFinderLobbyResponse `json:"lobbies"`

	// A string token required to get the next page of results. This will be null or empty if there are no
	// more results.
	NextPageToken string `json:"nextPageToken"`

	// The number of results requested.
	PageSize int32 `json:"pageSize"`
}

// FireteamFinder.DestinyFireteamFinderGetPlayerOffersResponse
type FireteamFinderGetPlayerOffersResponse struct {
	// {
	//   "properties": {
	//     "offers": {
	//       "description": "All offers that this player has recieved.",
	//       "items": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderOffer"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// All offers that this player has recieved.
	Offers []FireteamFinderOffer `json:"offers"`
}

// FireteamFinder.DestinyFireteamFinderHostLobbyRequest
type FireteamFinderHostLobbyRequestBody struct {
	// {
	//   "properties": {
	//     "activityGraphHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderActivityGraphDefinition"
	//       }
	//     },
	//     "activityHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "clanId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "listingValues": {
	//       "items": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderListingValue"
	//       },
	//       "type": "array"
	//     },
	//     "maxPlayerCount": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "onlinePlayersOnly": {
	//       "type": "boolean"
	//     },
	//     "privacyScope": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderLobbyPrivacyScope"
	//       }
	//     },
	//     "scheduledDateTime": {
	//       "format": "date-time",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	ActivityGraphHash Hash[FireteamFinderActivityGraphDefinition] `json:"activityGraphHash"`

	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`

	ClanID Int64 `json:"clanId"`

	ListingValues []FireteamFinderListingValue `json:"listingValues"`

	MaxPlayerCount int32 `json:"maxPlayerCount"`

	OnlinePlayersOnly bool `json:"onlinePlayersOnly"`

	PrivacyScope FireteamFinderLobbyPrivacyScope `json:"privacyScope"`

	ScheduledDateTime Timestamp `json:"scheduledDateTime"`
}

// FireteamFinder.DestinyFireteamFinderHostLobbyResponse
type FireteamFinderHostLobbyResponse struct {
	// {
	//   "properties": {
	//     "applicationId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "listingId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "lobbyId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "offerId": {
	//       "format": "int64",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	ApplicationID Int64 `json:"applicationId"`

	ListingID Int64 `json:"listingId"`

	LobbyID Int64 `json:"lobbyId"`

	OfferID Int64 `json:"offerId"`
}

// FireteamFinder.DestinyFireteamFinderJoinLobbyRequest
type FireteamFinderJoinLobbyRequestBody struct {
	// {
	//   "properties": {
	//     "lobbyId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "offerId": {
	//       "format": "int64",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	LobbyID Int64 `json:"lobbyId"`

	OfferID Int64 `json:"offerId"`
}

// FireteamFinder.DestinyFireteamFinderKickPlayerRequest
type FireteamFinderKickPlayerRequestBody struct {
	// {
	//   "properties": {
	//     "targetCharacterId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "targetMembershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	TargetCharacterID Int64 `json:"targetCharacterId"`

	TargetMembershipType BungieMembershipType `json:"targetMembershipType"`
}

// FireteamFinder.DestinyFireteamFinderListing
type FireteamFinderListing struct {
	// {
	//   "properties": {
	//     "availableSlots": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "createdDateTime": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "listingId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "lobbyId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "lobbyState": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderLobbyState"
	//       }
	//     },
	//     "ownerId": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderPlayerId"
	//     },
	//     "revision": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "settings": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderLobbySettings"
	//     }
	//   },
	//   "type": "object"
	// }

	AvailableSlots int32 `json:"availableSlots"`

	CreatedDateTime Timestamp `json:"createdDateTime"`

	ListingID Int64 `json:"listingId"`

	LobbyID Int64 `json:"lobbyId"`

	LobbyState FireteamFinderLobbyState `json:"lobbyState"`

	OwnerID FireteamFinderPlayerId `json:"ownerId"`

	Revision int32 `json:"revision"`

	Settings FireteamFinderLobbySettings `json:"settings"`
}

// FireteamFinder.DestinyFireteamFinderListingFilter
type FireteamFinderListingFilter struct {
	// {
	//   "properties": {
	//     "listingValue": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderListingValue"
	//     },
	//     "matchType": {
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderListingFilterMatchType"
	//       }
	//     },
	//     "rangeType": {
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderListingFilterRangeType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	ListingValue FireteamFinderListingValue `json:"listingValue"`

	MatchType FireteamFinderListingFilterMatchType `json:"matchType"`

	RangeType FireteamFinderListingFilterRangeType `json:"rangeType"`
}

// FireteamFinder.DestinyFireteamFinderListingFilterMatchType
type FireteamFinderListingFilterMatchType int

const (
	FireteamFinderListingFilterMatchType_Unknown = FireteamFinderListingFilterMatchType(0)
	FireteamFinderListingFilterMatchType_MustNot = FireteamFinderListingFilterMatchType(1)
	FireteamFinderListingFilterMatchType_Should  = FireteamFinderListingFilterMatchType(2)
	FireteamFinderListingFilterMatchType_Filter  = FireteamFinderListingFilterMatchType(3)
)

// FireteamFinder.DestinyFireteamFinderListingFilterRangeType
type FireteamFinderListingFilterRangeType int

const (
	FireteamFinderListingFilterRangeType_Unknown              = FireteamFinderListingFilterRangeType(0)
	FireteamFinderListingFilterRangeType_All                  = FireteamFinderListingFilterRangeType(1)
	FireteamFinderListingFilterRangeType_Any                  = FireteamFinderListingFilterRangeType(2)
	FireteamFinderListingFilterRangeType_InRangeInclusive     = FireteamFinderListingFilterRangeType(3)
	FireteamFinderListingFilterRangeType_InRangeExclusive     = FireteamFinderListingFilterRangeType(4)
	FireteamFinderListingFilterRangeType_GreaterThan          = FireteamFinderListingFilterRangeType(5)
	FireteamFinderListingFilterRangeType_GreaterThanOrEqualTo = FireteamFinderListingFilterRangeType(6)
	FireteamFinderListingFilterRangeType_LessThan             = FireteamFinderListingFilterRangeType(7)
	FireteamFinderListingFilterRangeType_LessThanOrEqualTo    = FireteamFinderListingFilterRangeType(8)
)

// FireteamFinder.DestinyFireteamFinderListingStatus
type FireteamFinderListingStatus struct {
	// {
	//   "properties": {
	//     "availableSlots": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "listingId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "listingRevision": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	AvailableSlots int32 `json:"availableSlots"`

	ListingID Int64 `json:"listingId"`

	ListingRevision int32 `json:"listingRevision"`
}

// FireteamFinder.DestinyFireteamFinderListingValue
type FireteamFinderListingValue struct {
	// {
	//   "properties": {
	//     "valueType": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "values": {
	//       "items": {
	//         "format": "uint32",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	ValueType uint32 `json:"valueType"`

	Values []uint32 `json:"values"`
}

// FireteamFinder.DestinyFireteamFinderLobbyListingReference
type FireteamFinderLobbyListingReference struct {
	// {
	//   "properties": {
	//     "listingId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "lobbyId": {
	//       "format": "int64",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	ListingID Int64 `json:"listingId"`

	LobbyID Int64 `json:"lobbyId"`
}

// FireteamFinder.DestinyFireteamFinderLobbyPlayer
type FireteamFinderLobbyPlayer struct {
	// {
	//   "properties": {
	//     "offerId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "playerId": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderPlayerId"
	//     },
	//     "referralToken": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "state": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderPlayerReadinessState"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	OfferID Int64 `json:"offerId"`

	PlayerID FireteamFinderPlayerId `json:"playerId"`

	ReferralToken Int64 `json:"referralToken"`

	State FireteamFinderPlayerReadinessState `json:"state"`
}

// FireteamFinder.DestinyFireteamFinderLobbyPrivacyScope
type FireteamFinderLobbyPrivacyScope int32

const (
	FireteamFinderLobbyPrivacyScope_Unknown      = FireteamFinderLobbyPrivacyScope(0)
	FireteamFinderLobbyPrivacyScope_Open         = FireteamFinderLobbyPrivacyScope(1)
	FireteamFinderLobbyPrivacyScope_Applications = FireteamFinderLobbyPrivacyScope(2)
	FireteamFinderLobbyPrivacyScope_Clan         = FireteamFinderLobbyPrivacyScope(3)
	FireteamFinderLobbyPrivacyScope_Friends      = FireteamFinderLobbyPrivacyScope(4)
)

// FireteamFinder.DestinyFireteamFinderLobbyResponse
type FireteamFinderLobbyResponse struct {
	// {
	//   "properties": {
	//     "createdDateTime": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "listingId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "lobbyId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "owner": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderPlayerId"
	//     },
	//     "players": {
	//       "items": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderLobbyPlayer"
	//       },
	//       "type": "array"
	//     },
	//     "revision": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "settings": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderLobbySettings"
	//     },
	//     "state": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderLobbyState"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	CreatedDateTime Timestamp `json:"createdDateTime"`

	ListingID Int64 `json:"listingId"`

	LobbyID Int64 `json:"lobbyId"`

	Owner FireteamFinderPlayerId `json:"owner"`

	Players []FireteamFinderLobbyPlayer `json:"players"`

	Revision int32 `json:"revision"`

	Settings FireteamFinderLobbySettings `json:"settings"`

	State FireteamFinderLobbyState `json:"state"`
}

// FireteamFinder.DestinyFireteamFinderLobbySettings
type FireteamFinderLobbySettings struct {
	// {
	//   "properties": {
	//     "activityGraphHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.FireteamFinder.DestinyFireteamFinderActivityGraphDefinition"
	//       }
	//     },
	//     "activityHash": {
	//       "format": "uint32",
	//       "type": "integer",
	//       "x-mapped-definition": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.DestinyActivityDefinition"
	//       }
	//     },
	//     "clanId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "listingValues": {
	//       "items": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderListingValue"
	//       },
	//       "type": "array"
	//     },
	//     "maxPlayerCount": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "onlinePlayersOnly": {
	//       "type": "boolean"
	//     },
	//     "privacyScope": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderLobbyPrivacyScope"
	//       }
	//     },
	//     "scheduledDateTime": {
	//       "format": "date-time",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	ActivityGraphHash Hash[FireteamFinderActivityGraphDefinition] `json:"activityGraphHash"`

	ActivityHash Hash[ActivityDefinition] `json:"activityHash"`

	ClanID Int64 `json:"clanId"`

	ListingValues []FireteamFinderListingValue `json:"listingValues"`

	MaxPlayerCount int32 `json:"maxPlayerCount"`

	OnlinePlayersOnly bool `json:"onlinePlayersOnly"`

	PrivacyScope FireteamFinderLobbyPrivacyScope `json:"privacyScope"`

	ScheduledDateTime Timestamp `json:"scheduledDateTime"`
}

// FireteamFinder.DestinyFireteamFinderLobbyState
type FireteamFinderLobbyState int32

const (
	FireteamFinderLobbyState_Unknown  = FireteamFinderLobbyState(0)
	FireteamFinderLobbyState_Inactive = FireteamFinderLobbyState(1)
	FireteamFinderLobbyState_Active   = FireteamFinderLobbyState(2)
	FireteamFinderLobbyState_Expired  = FireteamFinderLobbyState(3)
	FireteamFinderLobbyState_Closed   = FireteamFinderLobbyState(4)
	FireteamFinderLobbyState_Canceled = FireteamFinderLobbyState(5)
	FireteamFinderLobbyState_Deleted  = FireteamFinderLobbyState(6)
)

// FireteamFinder.DestinyFireteamFinderOffer
type FireteamFinderOffer struct {
	// {
	//   "properties": {
	//     "applicationId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "createdDateTime": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "lobbyId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "offerId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "revision": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "state": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderOfferState"
	//       }
	//     },
	//     "targetId": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderPlayerId"
	//     }
	//   },
	//   "type": "object"
	// }

	ApplicationID Int64 `json:"applicationId"`

	CreatedDateTime Timestamp `json:"createdDateTime"`

	LobbyID Int64 `json:"lobbyId"`

	OfferID Int64 `json:"offerId"`

	Revision int32 `json:"revision"`

	State FireteamFinderOfferState `json:"state"`

	TargetID FireteamFinderPlayerId `json:"targetId"`
}

// FireteamFinder.DestinyFireteamFinderOfferState
type FireteamFinderOfferState int32

const (
	FireteamFinderOfferState_Unknown  = FireteamFinderOfferState(0)
	FireteamFinderOfferState_Pending  = FireteamFinderOfferState(1)
	FireteamFinderOfferState_Accepted = FireteamFinderOfferState(2)
	FireteamFinderOfferState_Rejected = FireteamFinderOfferState(3)
	FireteamFinderOfferState_Deleted  = FireteamFinderOfferState(4)
	FireteamFinderOfferState_Expired  = FireteamFinderOfferState(5)
)

// FireteamFinder.DestinyFireteamFinderPlayerId
type FireteamFinderPlayerId struct {
	// {
	//   "properties": {
	//     "characterId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	CharacterID Int64 `json:"characterId"`

	MembershipID Int64 `json:"membershipId"`

	MembershipType BungieMembershipType `json:"membershipType"`
}

// FireteamFinder.DestinyFireteamFinderPlayerReadinessState
type FireteamFinderPlayerReadinessState int32

const (
	FireteamFinderPlayerReadinessState_Unknown        = FireteamFinderPlayerReadinessState(0)
	FireteamFinderPlayerReadinessState_Reserved       = FireteamFinderPlayerReadinessState(1)
	FireteamFinderPlayerReadinessState_Disconnected   = FireteamFinderPlayerReadinessState(2)
	FireteamFinderPlayerReadinessState_InLobbyUnready = FireteamFinderPlayerReadinessState(3)
	FireteamFinderPlayerReadinessState_InLobbyReady   = FireteamFinderPlayerReadinessState(4)
	FireteamFinderPlayerReadinessState_Summoned       = FireteamFinderPlayerReadinessState(5)
)

// FireteamFinder.DestinyFireteamFinderRespondToApplicationRequest
type FireteamFinderRespondToApplicationRequestBody struct {
	// {
	//   "properties": {
	//     "accepted": {
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	Accepted bool `json:"accepted"`
}

// FireteamFinder.DestinyFireteamFinderRespondToApplicationResponse
type FireteamFinderRespondToApplicationResponse struct {
	// {
	//   "properties": {
	//     "applicationId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "applicationRevision": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	ApplicationID Int64 `json:"applicationId"`

	ApplicationRevision int32 `json:"applicationRevision"`
}

// FireteamFinder.DestinyFireteamFinderRespondToAuthenticationRequest
type FireteamFinderRespondToAuthenticationRequestBody struct {
	// {
	//   "properties": {
	//     "confirmed": {
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	Confirmed bool `json:"confirmed"`
}

// FireteamFinder.DestinyFireteamFinderRespondToAuthenticationResponse
type FireteamFinderRespondToAuthenticationResponse struct {
	// {
	//   "properties": {
	//     "applicationId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "applicationRevision": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "listing": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderListing"
	//     },
	//     "offer": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderOffer"
	//     }
	//   },
	//   "type": "object"
	// }

	ApplicationID Int64 `json:"applicationId"`

	ApplicationRevision int32 `json:"applicationRevision"`

	Listing FireteamFinderListing `json:"listing"`

	Offer FireteamFinderOffer `json:"offer"`
}

// FireteamFinder.DestinyFireteamFinderRespondToOfferRequest
type FireteamFinderRespondToOfferRequestBody struct {
	// {
	//   "properties": {
	//     "accepted": {
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	Accepted bool `json:"accepted"`
}

// FireteamFinder.DestinyFireteamFinderRespondToOfferResponse
type FireteamFinderRespondToOfferResponse struct {
	// {
	//   "properties": {
	//     "offerId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "revision": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "state": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderOfferState"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	OfferID Int64 `json:"offerId"`

	Revision int32 `json:"revision"`

	State FireteamFinderOfferState `json:"state"`
}

// FireteamFinder.DestinyFireteamFinderSearchListingsByClanRequest
type FireteamFinderSearchListingsByClanRequestBody struct {
	// {
	//   "properties": {
	//     "lobbyState": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderLobbyState"
	//       }
	//     },
	//     "pageSize": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "pageToken": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	LobbyState FireteamFinderLobbyState `json:"lobbyState"`

	PageSize int32 `json:"pageSize"`

	PageToken string `json:"pageToken"`
}

// FireteamFinder.DestinyFireteamFinderSearchListingsByClanResponse
type FireteamFinderSearchListingsByClanResponse struct {
	// {
	//   "properties": {
	//     "listings": {
	//       "items": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderListing"
	//       },
	//       "type": "array"
	//     },
	//     "pageToken": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Listings []FireteamFinderListing `json:"listings"`

	PageToken string `json:"pageToken"`
}

// FireteamFinder.DestinyFireteamFinderSearchListingsByFiltersRequest
type FireteamFinderSearchListingsByFiltersRequestBody struct {
	// {
	//   "properties": {
	//     "filters": {
	//       "items": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderListingFilter"
	//       },
	//       "type": "array"
	//     },
	//     "lobbyState": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderLobbyState"
	//       }
	//     },
	//     "pageSize": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "pageToken": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Filters []FireteamFinderListingFilter `json:"filters"`

	LobbyState FireteamFinderLobbyState `json:"lobbyState"`

	PageSize int32 `json:"pageSize"`

	PageToken string `json:"pageToken"`
}

// FireteamFinder.DestinyFireteamFinderSearchListingsByFiltersResponse
type FireteamFinderSearchListingsByFiltersResponse struct {
	// {
	//   "properties": {
	//     "listings": {
	//       "items": {
	//         "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderListing"
	//       },
	//       "type": "array"
	//     },
	//     "pageToken": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Listings []FireteamFinderListing `json:"listings"`

	PageToken string `json:"pageToken"`
}

// FireteamFinder.DestinyFireteamFinderUpdateLobbySettingsRequest
type FireteamFinderUpdateLobbySettingsRequestBody struct {
	// {
	//   "properties": {
	//     "updatedSettings": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderLobbySettings"
	//     }
	//   },
	//   "type": "object"
	// }

	UpdatedSettings FireteamFinderLobbySettings `json:"updatedSettings"`
}

// FireteamFinder.DestinyFireteamFinderUpdateLobbySettingsResponse
type FireteamFinderUpdateLobbySettingsResponse struct {
	// {
	//   "properties": {
	//     "updatedListing": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderListing"
	//     },
	//     "updatedLobby": {
	//       "$ref": "#/components/schemas/FireteamFinder.DestinyFireteamFinderLobbyResponse"
	//     }
	//   },
	//   "type": "object"
	// }

	UpdatedListing FireteamFinderListing `json:"updatedListing"`

	UpdatedLobby FireteamFinderLobbyResponse `json:"updatedLobby"`
}

// Forum.CommunityContentSortMode
type CommunityContentSortMode int

const (
	CommunityContentSortMode_Trending     = CommunityContentSortMode(0)
	CommunityContentSortMode_Latest       = CommunityContentSortMode(1)
	CommunityContentSortMode_HighestRated = CommunityContentSortMode(2)
)

// Forum.ForumMediaType
type ForumMediaType int32

const (
	ForumMediaType_None    = ForumMediaType(0)
	ForumMediaType_Image   = ForumMediaType(1)
	ForumMediaType_Video   = ForumMediaType(2)
	ForumMediaType_Youtube = ForumMediaType(3)
)

// Forum.ForumPostPopularity
type ForumPostPopularity int32

const (
	ForumPostPopularity_Empty     = ForumPostPopularity(0)
	ForumPostPopularity_Default   = ForumPostPopularity(1)
	ForumPostPopularity_Discussed = ForumPostPopularity(2)
	ForumPostPopularity_CoolStory = ForumPostPopularity(3)
	ForumPostPopularity_HeatingUp = ForumPostPopularity(4)
	ForumPostPopularity_Hot       = ForumPostPopularity(5)
)

// Forum.ForumPostSortEnum
type ForumPostSort int32

const (
	ForumPostSort_Default     = ForumPostSort(0)
	ForumPostSort_OldestFirst = ForumPostSort(1)
)

// Forum.ForumRecruitmentDetail
type ForumRecruitmentDetail struct {
	// {
	//   "properties": {
	//     "Fireteam": {
	//       "items": {
	//         "$ref": "#/components/schemas/User.GeneralUser"
	//       },
	//       "type": "array"
	//     },
	//     "approved": {
	//       "type": "boolean"
	//     },
	//     "conversationId": {
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "intensity": {
	//       "format": "byte",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Forum.ForumRecruitmentIntensityLabel"
	//       }
	//     },
	//     "kickedPlayerIds": {
	//       "items": {
	//         "format": "int64",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "microphoneRequired": {
	//       "type": "boolean"
	//     },
	//     "playerSlotsRemaining": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "playerSlotsTotal": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "tone": {
	//       "format": "byte",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Forum.ForumRecruitmentToneLabel"
	//       }
	//     },
	//     "topicId": {
	//       "format": "int64",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	Fireteam []GeneralUser `json:"Fireteam"`

	Approved bool `json:"approved"`

	ConversationID Nullable[Int64] `json:"conversationId,omitempty"`

	Intensity ForumRecruitmentIntensityLabel `json:"intensity"`

	KickedPlayerIds []Int64 `json:"kickedPlayerIds"`

	MicrophoneRequired bool `json:"microphoneRequired"`

	PlayerSlotsRemaining int32 `json:"playerSlotsRemaining"`

	PlayerSlotsTotal int32 `json:"playerSlotsTotal"`

	Tone ForumRecruitmentToneLabel `json:"tone"`

	TopicID Int64 `json:"topicId"`
}

// Forum.ForumRecruitmentIntensityLabel
type ForumRecruitmentIntensityLabel int

const (
	ForumRecruitmentIntensityLabel_None         = ForumRecruitmentIntensityLabel(0)
	ForumRecruitmentIntensityLabel_Casual       = ForumRecruitmentIntensityLabel(1)
	ForumRecruitmentIntensityLabel_Professional = ForumRecruitmentIntensityLabel(2)
)

// Forum.ForumRecruitmentToneLabel
type ForumRecruitmentToneLabel int

const (
	ForumRecruitmentToneLabel_None           = ForumRecruitmentToneLabel(0)
	ForumRecruitmentToneLabel_FamilyFriendly = ForumRecruitmentToneLabel(1)
	ForumRecruitmentToneLabel_Rowdy          = ForumRecruitmentToneLabel(2)
)

// Forum.ForumTopicsCategoryFiltersEnum
type ForumTopicsCategoryFilters int32

const (
	ForumTopicsCategoryFilters_None              = ForumTopicsCategoryFilters(0)
	ForumTopicsCategoryFilters_Links             = ForumTopicsCategoryFilters(1)
	ForumTopicsCategoryFilters_Questions         = ForumTopicsCategoryFilters(2)
	ForumTopicsCategoryFilters_AnsweredQuestions = ForumTopicsCategoryFilters(4)
	ForumTopicsCategoryFilters_Media             = ForumTopicsCategoryFilters(8)
	ForumTopicsCategoryFilters_TextOnly          = ForumTopicsCategoryFilters(16)
	ForumTopicsCategoryFilters_Announcement      = ForumTopicsCategoryFilters(32)
	ForumTopicsCategoryFilters_BungieOfficial    = ForumTopicsCategoryFilters(64)
	ForumTopicsCategoryFilters_Polls             = ForumTopicsCategoryFilters(128)
)

// Forum.ForumTopicsQuickDateEnum
type ForumTopicsQuickDate int32

const (
	ForumTopicsQuickDate_All       = ForumTopicsQuickDate(0)
	ForumTopicsQuickDate_LastYear  = ForumTopicsQuickDate(1)
	ForumTopicsQuickDate_LastMonth = ForumTopicsQuickDate(2)
	ForumTopicsQuickDate_LastWeek  = ForumTopicsQuickDate(3)
	ForumTopicsQuickDate_LastDay   = ForumTopicsQuickDate(4)
)

// Forum.ForumTopicsSortEnum
type ForumTopicsSort int

const (
	ForumTopicsSort_Default          = ForumTopicsSort(0)
	ForumTopicsSort_LastReplied      = ForumTopicsSort(1)
	ForumTopicsSort_MostReplied      = ForumTopicsSort(2)
	ForumTopicsSort_Popularity       = ForumTopicsSort(3)
	ForumTopicsSort_Controversiality = ForumTopicsSort(4)
	ForumTopicsSort_Liked            = ForumTopicsSort(5)
	ForumTopicsSort_HighestRated     = ForumTopicsSort(6)
	ForumTopicsSort_MostUpvoted      = ForumTopicsSort(7)
)

// Forum.PollResponse
type PollResponse struct {
	// {
	//   "properties": {
	//     "results": {
	//       "items": {
	//         "$ref": "#/components/schemas/Forum.PollResult"
	//       },
	//       "type": "array"
	//     },
	//     "topicId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "totalVotes": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	Results []PollResult `json:"results"`

	TopicID Int64 `json:"topicId"`

	TotalVotes int32 `json:"totalVotes"`
}

// Forum.PollResult
type PollResult struct {
	// {
	//   "properties": {
	//     "answerSlot": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "answerText": {
	//       "type": "string"
	//     },
	//     "lastVoteDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "requestingUserVoted": {
	//       "type": "boolean"
	//     },
	//     "votes": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	AnswerSlot int32 `json:"answerSlot"`

	AnswerText string `json:"answerText"`

	LastVoteDate Timestamp `json:"lastVoteDate"`

	RequestingUserVoted bool `json:"requestingUserVoted"`

	Votes int32 `json:"votes"`
}

// Forum.PostResponse
type PostResponse struct {
	// {
	//   "properties": {
	//     "IsPinned": {
	//       "type": "boolean"
	//     },
	//     "ignoreStatus": {
	//       "$ref": "#/components/schemas/Ignores.IgnoreResponse"
	//     },
	//     "isActive": {
	//       "type": "boolean"
	//     },
	//     "isAnnouncement": {
	//       "type": "boolean"
	//     },
	//     "lastReplyTimestamp": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "latestReplyAuthorId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "latestReplyPostId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "locale": {
	//       "type": "string"
	//     },
	//     "popularity": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Forum.ForumPostPopularity"
	//       }
	//     },
	//     "thumbnail": {
	//       "type": "string"
	//     },
	//     "urlMediaType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Forum.ForumMediaType"
	//       }
	//     },
	//     "userHasMutedPost": {
	//       "type": "boolean"
	//     },
	//     "userHasRated": {
	//       "type": "boolean"
	//     },
	//     "userRating": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	IsPinned bool `json:"IsPinned"`

	IgnoreStatus IgnoreResponse `json:"ignoreStatus"`

	IsActive bool `json:"isActive"`

	IsAnnouncement bool `json:"isAnnouncement"`

	LastReplyTimestamp Timestamp `json:"lastReplyTimestamp"`

	LatestReplyAuthorID Int64 `json:"latestReplyAuthorId"`

	LatestReplyPostID Int64 `json:"latestReplyPostId"`

	Locale string `json:"locale"`

	Popularity ForumPostPopularity `json:"popularity"`

	Thumbnail string `json:"thumbnail"`

	UrlMediaType ForumMediaType `json:"urlMediaType"`

	UserHasMutedPost bool `json:"userHasMutedPost"`

	UserHasRated bool `json:"userHasRated"`

	UserRating int32 `json:"userRating"`
}

// Forum.PostSearchResponse
type PostSearchResponse struct {
	// {
	//   "properties": {
	//     "authors": {
	//       "items": {
	//         "$ref": "#/components/schemas/User.GeneralUser"
	//       },
	//       "type": "array"
	//     },
	//     "availablePages": {
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "groups": {
	//       "items": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupResponse"
	//       },
	//       "type": "array"
	//     },
	//     "hasMore": {
	//       "type": "boolean"
	//     },
	//     "polls": {
	//       "items": {
	//         "$ref": "#/components/schemas/Forum.PollResponse"
	//       },
	//       "type": "array"
	//     },
	//     "query": {
	//       "$ref": "#/components/schemas/Queries.PagedQuery"
	//     },
	//     "recruitmentDetails": {
	//       "items": {
	//         "$ref": "#/components/schemas/Forum.ForumRecruitmentDetail"
	//       },
	//       "type": "array"
	//     },
	//     "relatedPosts": {
	//       "items": {
	//         "$ref": "#/components/schemas/Forum.PostResponse"
	//       },
	//       "type": "array"
	//     },
	//     "replacementContinuationToken": {
	//       "type": "string"
	//     },
	//     "results": {
	//       "items": {
	//         "$ref": "#/components/schemas/Forum.PostResponse"
	//       },
	//       "type": "array"
	//     },
	//     "searchedTags": {
	//       "items": {
	//         "$ref": "#/components/schemas/Tags.Models.Contracts.TagResponse"
	//       },
	//       "type": "array"
	//     },
	//     "totalResults": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "useTotalResults": {
	//       "description": "If useTotalResults is true, then totalResults represents an accurate count.\r\nIf False, it does not, and may be estimated/only the size of the current page.\r\nEither way, you should probably always only trust hasMore.\r\nThis is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	Authors []GeneralUser `json:"authors"`

	AvailablePages Nullable[int32] `json:"availablePages,omitempty"`

	Groups []GroupResponse `json:"groups"`

	HasMore bool `json:"hasMore"`

	Polls []PollResponse `json:"polls"`

	Query PagedQuery `json:"query"`

	RecruitmentDetails []ForumRecruitmentDetail `json:"recruitmentDetails"`

	RelatedPosts []PostResponse `json:"relatedPosts"`

	ReplacementContinuationToken string `json:"replacementContinuationToken"`

	Results []PostResponse `json:"results"`

	SearchedTags []TagResponse `json:"searchedTags"`

	TotalResults int32 `json:"totalResults"`

	// If useTotalResults is true, then totalResults represents an accurate count.
	// If False, it does not, and may be estimated/only the size of the current page.
	// Either way, you should probably always only trust hasMore.
	// This is a long-held historical throwback to when we used to do paging with known total results.
	// Those queries toasted our database, and we were left to hastily alter our endpoints and create
	// backward- compatible shims, of which useTotalResults is one.
	UseTotalResults bool `json:"useTotalResults"`
}

// Forums.ForumFlagsEnum
type ForumFlags int32

const (
	ForumFlags_None                       = ForumFlags(0)
	ForumFlags_BungieStaffPost            = ForumFlags(1)
	ForumFlags_ForumNinjaPost             = ForumFlags(2)
	ForumFlags_ForumMentorPost            = ForumFlags(4)
	ForumFlags_TopicBungieStaffPosted     = ForumFlags(8)
	ForumFlags_TopicBungieVolunteerPosted = ForumFlags(16)
	ForumFlags_QuestionAnsweredByBungie   = ForumFlags(32)
	ForumFlags_QuestionAnsweredByNinja    = ForumFlags(64)
	ForumFlags_CommunityContent           = ForumFlags(128)
)

// Forums.ForumPostCategoryEnums
type ForumPostCategory int32

const (
	ForumPostCategory_None           = ForumPostCategory(0)
	ForumPostCategory_TextOnly       = ForumPostCategory(1)
	ForumPostCategory_Media          = ForumPostCategory(2)
	ForumPostCategory_Link           = ForumPostCategory(4)
	ForumPostCategory_Poll           = ForumPostCategory(8)
	ForumPostCategory_Question       = ForumPostCategory(16)
	ForumPostCategory_Answered       = ForumPostCategory(32)
	ForumPostCategory_Announcement   = ForumPostCategory(64)
	ForumPostCategory_ContentComment = ForumPostCategory(128)
	ForumPostCategory_BungieOfficial = ForumPostCategory(256)
	ForumPostCategory_NinjaOfficial  = ForumPostCategory(512)
	ForumPostCategory_Recruitment    = ForumPostCategory(1024)
)

// GlobalAlert
type GlobalAlert struct {
	// {
	//   "properties": {
	//     "AlertHtml": {
	//       "type": "string"
	//     },
	//     "AlertKey": {
	//       "type": "string"
	//     },
	//     "AlertLevel": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GlobalAlertLevel"
	//       }
	//     },
	//     "AlertLink": {
	//       "type": "string"
	//     },
	//     "AlertTimestamp": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "AlertType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GlobalAlertType"
	//       }
	//     },
	//     "StreamInfo": {
	//       "$ref": "#/components/schemas/StreamInfo"
	//     }
	//   },
	//   "type": "object"
	// }

	AlertHtml string `json:"AlertHtml"`

	AlertKey string `json:"AlertKey"`

	AlertLevel GlobalAlertLevel `json:"AlertLevel"`

	AlertLink string `json:"AlertLink"`

	AlertTimestamp Timestamp `json:"AlertTimestamp"`

	AlertType GlobalAlertType `json:"AlertType"`

	StreamInfo StreamInfo `json:"StreamInfo"`
}

// GlobalAlertLevel
type GlobalAlertLevel int32

const (
	GlobalAlertLevel_Unknown = GlobalAlertLevel(0)
	GlobalAlertLevel_Blue    = GlobalAlertLevel(1)
	GlobalAlertLevel_Yellow  = GlobalAlertLevel(2)
	GlobalAlertLevel_Red     = GlobalAlertLevel(3)
)

// GlobalAlertType
type GlobalAlertType int32

const (
	GlobalAlertType_GlobalAlert    = GlobalAlertType(0)
	GlobalAlertType_StreamingAlert = GlobalAlertType(1)
)

// GroupsV2.Capabilities
type Capabilities int32

const (
	Capabilities_None                  = Capabilities(0)
	Capabilities_Leaderboards          = Capabilities(1)
	Capabilities_Callsign              = Capabilities(2)
	Capabilities_OptionalConversations = Capabilities(4)
	Capabilities_ClanBanner            = Capabilities(8)
	Capabilities_D2InvestmentData      = Capabilities(16)
	Capabilities_Tags                  = Capabilities(32)
	Capabilities_Alliances             = Capabilities(64)
)

// GroupsV2.ChatSecuritySetting
type ChatSecuritySetting int32

const (
	ChatSecuritySetting_Group  = ChatSecuritySetting(0)
	ChatSecuritySetting_Admins = ChatSecuritySetting(1)
)

// GroupsV2.ClanBanner
type ClanBanner struct {
	// {
	//   "properties": {
	//     "decalBackgroundColorId": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "decalColorId": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "decalId": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "gonfalonColorId": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "gonfalonDetailColorId": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "gonfalonDetailId": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "gonfalonId": {
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	DecalBackgroundColorID uint32 `json:"decalBackgroundColorId"`

	DecalColorID uint32 `json:"decalColorId"`

	DecalID uint32 `json:"decalId"`

	GonfalonColorID uint32 `json:"gonfalonColorId"`

	GonfalonDetailColorID uint32 `json:"gonfalonDetailColorId"`

	GonfalonDetailID uint32 `json:"gonfalonDetailId"`

	GonfalonID uint32 `json:"gonfalonId"`
}

// GroupsV2.GetGroupsForMemberResponse
type GetGroupsForMemberResponse struct {
	// {
	//   "properties": {
	//     "areAllMembershipsInactive": {
	//       "additionalProperties": {
	//         "type": "boolean"
	//       },
	//       "description": "A convenience property that indicates if every membership this user has that is a part of this group are part of an account that is considered inactive - for example, overridden accounts in Cross Save.\r\n The key is the Group ID for the group being checked, and the value is true if the users' memberships for that group are all inactive.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "int64",
	//         "type": "integer"
	//       }
	//     },
	//     "hasMore": {
	//       "type": "boolean"
	//     },
	//     "query": {
	//       "$ref": "#/components/schemas/Queries.PagedQuery"
	//     },
	//     "replacementContinuationToken": {
	//       "type": "string"
	//     },
	//     "results": {
	//       "items": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupMembership"
	//       },
	//       "type": "array"
	//     },
	//     "totalResults": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "useTotalResults": {
	//       "description": "If useTotalResults is true, then totalResults represents an accurate count.\r\nIf False, it does not, and may be estimated/only the size of the current page.\r\nEither way, you should probably always only trust hasMore.\r\nThis is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	// A convenience property that indicates if every membership this user has that is a part of this group
	// are part of an account that is considered inactive - for example, overridden accounts in Cross Save.
	//
	//	The key is the Group ID for the group being checked, and the value is true if the users'
	//
	// memberships for that group are all inactive.
	AreAllMembershipsInactive map[Int64]bool `json:"areAllMembershipsInactive"`

	HasMore bool `json:"hasMore"`

	Query PagedQuery `json:"query"`

	ReplacementContinuationToken string `json:"replacementContinuationToken"`

	Results []GroupMembership `json:"results"`

	TotalResults int32 `json:"totalResults"`

	// If useTotalResults is true, then totalResults represents an accurate count.
	// If False, it does not, and may be estimated/only the size of the current page.
	// Either way, you should probably always only trust hasMore.
	// This is a long-held historical throwback to when we used to do paging with known total results.
	// Those queries toasted our database, and we were left to hastily alter our endpoints and create
	// backward- compatible shims, of which useTotalResults is one.
	UseTotalResults bool `json:"useTotalResults"`
}

// GroupsV2.GroupAllianceStatus
type GroupAllianceStatus int32

const (
	GroupAllianceStatus_Unallied = GroupAllianceStatus(0)
	GroupAllianceStatus_Parent   = GroupAllianceStatus(1)
	GroupAllianceStatus_Child    = GroupAllianceStatus(2)
)

// GroupsV2.GroupApplicationListRequest
type GroupApplicationListRequestBody struct {
	// {
	//   "properties": {
	//     "memberships": {
	//       "items": {
	//         "$ref": "#/components/schemas/User.UserMembership"
	//       },
	//       "type": "array"
	//     },
	//     "message": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Memberships []UserMembership `json:"memberships"`

	Message string `json:"message"`
}

// GroupsV2.GroupApplicationRequest
type GroupApplicationRequestBody struct {
	// {
	//   "properties": {
	//     "message": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Message string `json:"message"`
}

// GroupsV2.GroupApplicationResolveState
type GroupApplicationResolveState int32

const (
	GroupApplicationResolveState_Unresolved = GroupApplicationResolveState(0)
	GroupApplicationResolveState_Accepted   = GroupApplicationResolveState(1)
	GroupApplicationResolveState_Denied     = GroupApplicationResolveState(2)
	GroupApplicationResolveState_Rescinded  = GroupApplicationResolveState(3)
)

// GroupsV2.GroupApplicationResponse
type GroupApplicationResponse struct {
	// {
	//   "properties": {
	//     "resolution": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupApplicationResolveState"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	Resolution GroupApplicationResolveState `json:"resolution"`
}

// GroupsV2.GroupBan
type GroupBan struct {
	// {
	//   "properties": {
	//     "bungieNetUserInfo": {
	//       "$ref": "#/components/schemas/User.UserInfoCard"
	//     },
	//     "comment": {
	//       "type": "string"
	//     },
	//     "createdBy": {
	//       "$ref": "#/components/schemas/User.UserInfoCard"
	//     },
	//     "dateBanned": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "dateExpires": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "destinyUserInfo": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupUserInfoCard"
	//     },
	//     "groupId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "lastModifiedBy": {
	//       "$ref": "#/components/schemas/User.UserInfoCard"
	//     }
	//   },
	//   "type": "object"
	// }

	BungieNetUserInfo UserInfoCard `json:"bungieNetUserInfo"`

	Comment string `json:"comment"`

	CreatedBy UserInfoCard `json:"createdBy"`

	DateBanned Timestamp `json:"dateBanned"`

	DateExpires Timestamp `json:"dateExpires"`

	DestinyUserInfo GroupUserInfoCard `json:"destinyUserInfo"`

	GroupID Int64 `json:"groupId"`

	LastModifiedBy UserInfoCard `json:"lastModifiedBy"`
}

// GroupsV2.GroupBanRequest
type GroupBanRequestBody struct {
	// {
	//   "properties": {
	//     "comment": {
	//       "type": "string"
	//     },
	//     "length": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Ignores.IgnoreLength"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	Comment string `json:"comment"`

	Length IgnoreLength `json:"length"`
}

// GroupsV2.GroupDateRange
type GroupDateRange int32

const (
	GroupDateRange_All       = GroupDateRange(0)
	GroupDateRange_PastDay   = GroupDateRange(1)
	GroupDateRange_PastWeek  = GroupDateRange(2)
	GroupDateRange_PastMonth = GroupDateRange(3)
	GroupDateRange_PastYear  = GroupDateRange(4)
)

// GroupsV2.GroupEditAction
type GroupEditAction struct {
	// {
	//   "properties": {
	//     "about": {
	//       "type": "string"
	//     },
	//     "allowChat": {
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "avatarImageIndex": {
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "callsign": {
	//       "type": "string"
	//     },
	//     "chatSecurity": {
	//       "enum": [
	//         "0",
	//         "1"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "Group",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Admins",
	//           "numericValue": "1"
	//         }
	//       ]
	//     },
	//     "defaultPublicity": {
	//       "enum": [
	//         "0",
	//         "1",
	//         "2"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "Public",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Alliance",
	//           "numericValue": "1"
	//         },
	//         {
	//           "identifier": "Private",
	//           "numericValue": "2"
	//         }
	//       ]
	//     },
	//     "enableInvitationMessagingForAdmins": {
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "homepage": {
	//       "enum": [
	//         "0",
	//         "1",
	//         "2"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "Wall",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Forum",
	//           "numericValue": "1"
	//         },
	//         {
	//           "identifier": "AllianceForum",
	//           "numericValue": "2"
	//         }
	//       ]
	//     },
	//     "isPublic": {
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "isPublicTopicAdminOnly": {
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "locale": {
	//       "type": "string"
	//     },
	//     "membershipOption": {
	//       "enum": [
	//         "0",
	//         "1",
	//         "2"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "Reviewed",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Open",
	//           "numericValue": "1"
	//         },
	//         {
	//           "identifier": "Closed",
	//           "numericValue": "2"
	//         }
	//       ]
	//     },
	//     "motto": {
	//       "type": "string"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "tags": {
	//       "type": "string"
	//     },
	//     "theme": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	About string `json:"about"`

	AllowChat Nullable[bool] `json:"allowChat,omitempty"`

	AvatarImageIndex Nullable[int32] `json:"avatarImageIndex,omitempty"`

	Callsign string `json:"callsign"`

	ChatSecurity Nullable[int32] `json:"chatSecurity,omitempty"`

	DefaultPublicity Nullable[int32] `json:"defaultPublicity,omitempty"`

	EnableInvitationMessagingForAdmins Nullable[bool] `json:"enableInvitationMessagingForAdmins,omitempty"`

	Homepage Nullable[int32] `json:"homepage,omitempty"`

	IsPublic Nullable[bool] `json:"isPublic,omitempty"`

	IsPublicTopicAdminOnly Nullable[bool] `json:"isPublicTopicAdminOnly,omitempty"`

	Locale string `json:"locale"`

	MembershipOption Nullable[int32] `json:"membershipOption,omitempty"`

	Motto string `json:"motto"`

	Name string `json:"name"`

	Tags string `json:"tags"`

	Theme string `json:"theme"`
}

// GroupsV2.GroupEditHistory
type GroupEditHistory struct {
	// {
	//   "properties": {
	//     "about": {
	//       "type": "string"
	//     },
	//     "aboutEditors": {
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "clanCallsign": {
	//       "type": "string"
	//     },
	//     "clanCallsignEditors": {
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "editDate": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "groupEditors": {
	//       "items": {
	//         "$ref": "#/components/schemas/User.UserInfoCard"
	//       },
	//       "type": "array"
	//     },
	//     "groupId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "motto": {
	//       "type": "string"
	//     },
	//     "mottoEditors": {
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "nameEditors": {
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	About string `json:"about"`

	AboutEditors Nullable[Int64] `json:"aboutEditors,omitempty"`

	ClanCallsign string `json:"clanCallsign"`

	ClanCallsignEditors Nullable[Int64] `json:"clanCallsignEditors,omitempty"`

	EditDate Nullable[Timestamp] `json:"editDate,omitempty"`

	GroupEditors []UserInfoCard `json:"groupEditors"`

	GroupID Int64 `json:"groupId"`

	Motto string `json:"motto"`

	MottoEditors Nullable[Int64] `json:"mottoEditors,omitempty"`

	Name string `json:"name"`

	NameEditors Nullable[Int64] `json:"nameEditors,omitempty"`
}

// GroupsV2.GroupFeatures
type GroupFeatures struct {
	// {
	//   "properties": {
	//     "capabilities": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.Capabilities"
	//       }
	//     },
	//     "hostGuidedGamePermissionOverride": {
	//       "description": "Minimum Member Level allowed to host guided games\r\nAlways Allowed: Founder, Acting Founder, Admin\r\nAllowed Overrides: None, Member, Beginner\r\nDefault is Member for clans, None for groups, although this means nothing for groups.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.HostGuidedGamesPermissionLevel"
	//       }
	//     },
	//     "invitePermissionOverride": {
	//       "description": "Minimum Member Level allowed to invite new members to group\r\nAlways Allowed: Founder, Acting Founder\r\nTrue means admins have this power, false means they don't\r\nDefault is false for clans, true for groups.",
	//       "type": "boolean"
	//     },
	//     "joinLevel": {
	//       "description": "Level to join a member at when accepting an invite, application, or joining an open clan\r\nDefault is Beginner.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.RuntimeGroupMemberType"
	//       }
	//     },
	//     "maximumMembers": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "maximumMembershipsOfGroupType": {
	//       "description": "Maximum number of groups of this type a typical membership may join. For example, a user may join about 50 General groups with their Bungie.net account. They may join one clan per Destiny membership.",
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "membershipTypes": {
	//       "items": {
	//         "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/BungieMembershipType"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "updateBannerPermissionOverride": {
	//       "description": "Minimum Member Level allowed to update banner\r\nAlways Allowed: Founder, Acting Founder\r\nTrue means admins have this power, false means they don't\r\nDefault is false for clans, true for groups.",
	//       "type": "boolean"
	//     },
	//     "updateCulturePermissionOverride": {
	//       "description": "Minimum Member Level allowed to update group culture\r\nAlways Allowed: Founder, Acting Founder\r\nTrue means admins have this power, false means they don't\r\nDefault is false for clans, true for groups.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	Capabilities BitmaskSet[Capabilities] `json:"capabilities"`

	// Minimum Member Level allowed to host guided games
	// Always Allowed: Founder, Acting Founder, Admin
	// Allowed Overrides: None, Member, Beginner
	// Default is Member for clans, None for groups, although this means nothing for groups.
	HostGuidedGamePermissionOverride HostGuidedGamesPermissionLevel `json:"hostGuidedGamePermissionOverride"`

	// Minimum Member Level allowed to invite new members to group
	// Always Allowed: Founder, Acting Founder
	// True means admins have this power, false means they don't
	// Default is false for clans, true for groups.
	InvitePermissionOverride bool `json:"invitePermissionOverride"`

	// Level to join a member at when accepting an invite, application, or joining an open clan
	// Default is Beginner.
	JoinLevel RuntimeGroupMemberType `json:"joinLevel"`

	MaximumMembers int32 `json:"maximumMembers"`

	// Maximum number of groups of this type a typical membership may join. For example, a user may join
	// about 50 General groups with their Bungie.net account. They may join one clan per Destiny
	// membership.
	MaximumMembershipsOfGroupType int32 `json:"maximumMembershipsOfGroupType"`

	MembershipTypes []BungieMembershipType `json:"membershipTypes"`

	// Minimum Member Level allowed to update banner
	// Always Allowed: Founder, Acting Founder
	// True means admins have this power, false means they don't
	// Default is false for clans, true for groups.
	UpdateBannerPermissionOverride bool `json:"updateBannerPermissionOverride"`

	// Minimum Member Level allowed to update group culture
	// Always Allowed: Founder, Acting Founder
	// True means admins have this power, false means they don't
	// Default is false for clans, true for groups.
	UpdateCulturePermissionOverride bool `json:"updateCulturePermissionOverride"`
}

// GroupsV2.GroupHomepage
type GroupHomepage int32

const (
	GroupHomepage_Wall          = GroupHomepage(0)
	GroupHomepage_Forum         = GroupHomepage(1)
	GroupHomepage_AllianceForum = GroupHomepage(2)
)

// GroupsV2.GroupMember
type GroupMember struct {
	// {
	//   "properties": {
	//     "bungieNetUserInfo": {
	//       "$ref": "#/components/schemas/User.UserInfoCard"
	//     },
	//     "destinyUserInfo": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupUserInfoCard"
	//     },
	//     "groupId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "isOnline": {
	//       "type": "boolean"
	//     },
	//     "joinDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "lastOnlineStatusChange": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "memberType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.RuntimeGroupMemberType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	BungieNetUserInfo UserInfoCard `json:"bungieNetUserInfo"`

	DestinyUserInfo GroupUserInfoCard `json:"destinyUserInfo"`

	GroupID Int64 `json:"groupId"`

	IsOnline bool `json:"isOnline"`

	JoinDate Timestamp `json:"joinDate"`

	LastOnlineStatusChange Int64 `json:"lastOnlineStatusChange"`

	MemberType RuntimeGroupMemberType `json:"memberType"`
}

// GroupsV2.GroupMemberApplication
type GroupMemberApplication struct {
	// {
	//   "properties": {
	//     "bungieNetUserInfo": {
	//       "$ref": "#/components/schemas/User.UserInfoCard"
	//     },
	//     "creationDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "destinyUserInfo": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupUserInfoCard"
	//     },
	//     "groupId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "requestMessage": {
	//       "type": "string"
	//     },
	//     "resolveDate": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "resolveMessage": {
	//       "type": "string"
	//     },
	//     "resolveState": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupApplicationResolveState"
	//       }
	//     },
	//     "resolvedByMembershipId": {
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	BungieNetUserInfo UserInfoCard `json:"bungieNetUserInfo"`

	CreationDate Timestamp `json:"creationDate"`

	DestinyUserInfo GroupUserInfoCard `json:"destinyUserInfo"`

	GroupID Int64 `json:"groupId"`

	RequestMessage string `json:"requestMessage"`

	ResolveDate Nullable[Timestamp] `json:"resolveDate,omitempty"`

	ResolveMessage string `json:"resolveMessage"`

	ResolveState GroupApplicationResolveState `json:"resolveState"`

	ResolvedByMembershipID Nullable[Int64] `json:"resolvedByMembershipId,omitempty"`
}

// GroupsV2.GroupMemberCountFilter
type GroupMemberCountFilter int32

const (
	GroupMemberCountFilter_All                   = GroupMemberCountFilter(0)
	GroupMemberCountFilter_OneToTen              = GroupMemberCountFilter(1)
	GroupMemberCountFilter_ElevenToOneHundred    = GroupMemberCountFilter(2)
	GroupMemberCountFilter_GreaterThanOneHundred = GroupMemberCountFilter(3)
)

// GroupsV2.GroupMemberLeaveResult
type GroupMemberLeaveResult struct {
	// {
	//   "properties": {
	//     "group": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupV2"
	//     },
	//     "groupDeleted": {
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	Group GroupV2 `json:"group"`

	GroupDeleted bool `json:"groupDeleted"`
}

// GroupsV2.GroupMembership
type GroupMembership struct {
	// {
	//   "properties": {
	//     "group": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupV2"
	//     },
	//     "member": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupMember"
	//     }
	//   },
	//   "type": "object"
	// }

	Group GroupV2 `json:"group"`

	Member GroupMember `json:"member"`
}

// GroupsV2.GroupMembershipBase
type GroupMembershipBase struct {
	// {
	//   "properties": {
	//     "group": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupV2"
	//     }
	//   },
	//   "type": "object"
	// }

	Group GroupV2 `json:"group"`
}

// GroupsV2.GroupMembershipSearchResponse
type GroupMembershipSearchResponse struct {
	// {
	//   "properties": {
	//     "hasMore": {
	//       "type": "boolean"
	//     },
	//     "query": {
	//       "$ref": "#/components/schemas/Queries.PagedQuery"
	//     },
	//     "replacementContinuationToken": {
	//       "type": "string"
	//     },
	//     "results": {
	//       "items": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupMembership"
	//       },
	//       "type": "array"
	//     },
	//     "totalResults": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "useTotalResults": {
	//       "description": "If useTotalResults is true, then totalResults represents an accurate count.\r\nIf False, it does not, and may be estimated/only the size of the current page.\r\nEither way, you should probably always only trust hasMore.\r\nThis is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	HasMore bool `json:"hasMore"`

	Query PagedQuery `json:"query"`

	ReplacementContinuationToken string `json:"replacementContinuationToken"`

	Results []GroupMembership `json:"results"`

	TotalResults int32 `json:"totalResults"`

	// If useTotalResults is true, then totalResults represents an accurate count.
	// If False, it does not, and may be estimated/only the size of the current page.
	// Either way, you should probably always only trust hasMore.
	// This is a long-held historical throwback to when we used to do paging with known total results.
	// Those queries toasted our database, and we were left to hastily alter our endpoints and create
	// backward- compatible shims, of which useTotalResults is one.
	UseTotalResults bool `json:"useTotalResults"`
}

// GroupsV2.GroupNameSearchRequest
type GroupNameSearchRequestBody struct {
	// {
	//   "properties": {
	//     "groupName": {
	//       "type": "string"
	//     },
	//     "groupType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	GroupName string `json:"groupName"`

	GroupType GroupType `json:"groupType"`
}

// GroupsV2.GroupOptionalConversation
type GroupOptionalConversation struct {
	// {
	//   "properties": {
	//     "chatEnabled": {
	//       "type": "boolean"
	//     },
	//     "chatName": {
	//       "type": "string"
	//     },
	//     "chatSecurity": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.ChatSecuritySetting"
	//       }
	//     },
	//     "conversationId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "groupId": {
	//       "format": "int64",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	ChatEnabled bool `json:"chatEnabled"`

	ChatName string `json:"chatName"`

	ChatSecurity ChatSecuritySetting `json:"chatSecurity"`

	ConversationID Int64 `json:"conversationId"`

	GroupID Int64 `json:"groupId"`
}

// GroupsV2.GroupOptionalConversationAddRequest
type GroupOptionalConversationAddRequestBody struct {
	// {
	//   "properties": {
	//     "chatName": {
	//       "type": "string"
	//     },
	//     "chatSecurity": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.ChatSecuritySetting"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	ChatName string `json:"chatName"`

	ChatSecurity ChatSecuritySetting `json:"chatSecurity"`
}

// GroupsV2.GroupOptionalConversationEditRequest
type GroupOptionalConversationEditRequestBody struct {
	// {
	//   "properties": {
	//     "chatEnabled": {
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "chatName": {
	//       "type": "string"
	//     },
	//     "chatSecurity": {
	//       "enum": [
	//         "0",
	//         "1"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "Group",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Admins",
	//           "numericValue": "1"
	//         }
	//       ]
	//     }
	//   },
	//   "type": "object"
	// }

	ChatEnabled Nullable[bool] `json:"chatEnabled,omitempty"`

	ChatName string `json:"chatName"`

	ChatSecurity Nullable[int32] `json:"chatSecurity,omitempty"`
}

// GroupsV2.GroupOptionsEditAction
type GroupOptionsEditAction struct {
	// {
	//   "properties": {
	//     "HostGuidedGamePermissionOverride": {
	//       "description": "Minimum Member Level allowed to host guided games\r\nAlways Allowed: Founder, Acting Founder, Admin\r\nAllowed Overrides: None, Member, Beginner\r\nDefault is Member for clans, None for groups, although this means nothing for groups.",
	//       "enum": [
	//         "0",
	//         "1",
	//         "2"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "None",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Beginner",
	//           "numericValue": "1"
	//         },
	//         {
	//           "identifier": "Member",
	//           "numericValue": "2"
	//         }
	//       ]
	//     },
	//     "InvitePermissionOverride": {
	//       "description": "Minimum Member Level allowed to invite new members to group\r\nAlways Allowed: Founder, Acting Founder\r\nTrue means admins have this power, false means they don't\r\nDefault is false for clans, true for groups.",
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "JoinLevel": {
	//       "description": "Level to join a member at when accepting an invite, application, or joining an open clan\r\nDefault is Beginner.",
	//       "enum": [
	//         "0",
	//         "1",
	//         "2",
	//         "3",
	//         "4",
	//         "5"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "None",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Beginner",
	//           "numericValue": "1"
	//         },
	//         {
	//           "identifier": "Member",
	//           "numericValue": "2"
	//         },
	//         {
	//           "identifier": "Admin",
	//           "numericValue": "3"
	//         },
	//         {
	//           "identifier": "ActingFounder",
	//           "numericValue": "4"
	//         },
	//         {
	//           "identifier": "Founder",
	//           "numericValue": "5"
	//         }
	//       ]
	//     },
	//     "UpdateBannerPermissionOverride": {
	//       "description": "Minimum Member Level allowed to update banner\r\nAlways Allowed: Founder, Acting Founder\r\nTrue means admins have this power, false means they don't\r\nDefault is false for clans, true for groups.",
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "UpdateCulturePermissionOverride": {
	//       "description": "Minimum Member Level allowed to update group culture\r\nAlways Allowed: Founder, Acting Founder\r\nTrue means admins have this power, false means they don't\r\nDefault is false for clans, true for groups.",
	//       "nullable": true,
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	// Minimum Member Level allowed to host guided games
	// Always Allowed: Founder, Acting Founder, Admin
	// Allowed Overrides: None, Member, Beginner
	// Default is Member for clans, None for groups, although this means nothing for groups.
	HostGuidedGamePermissionOverride Nullable[int32] `json:"HostGuidedGamePermissionOverride,omitempty"`

	// Minimum Member Level allowed to invite new members to group
	// Always Allowed: Founder, Acting Founder
	// True means admins have this power, false means they don't
	// Default is false for clans, true for groups.
	InvitePermissionOverride Nullable[bool] `json:"InvitePermissionOverride,omitempty"`

	// Level to join a member at when accepting an invite, application, or joining an open clan
	// Default is Beginner.
	JoinLevel Nullable[int32] `json:"JoinLevel,omitempty"`

	// Minimum Member Level allowed to update banner
	// Always Allowed: Founder, Acting Founder
	// True means admins have this power, false means they don't
	// Default is false for clans, true for groups.
	UpdateBannerPermissionOverride Nullable[bool] `json:"UpdateBannerPermissionOverride,omitempty"`

	// Minimum Member Level allowed to update group culture
	// Always Allowed: Founder, Acting Founder
	// True means admins have this power, false means they don't
	// Default is false for clans, true for groups.
	UpdateCulturePermissionOverride Nullable[bool] `json:"UpdateCulturePermissionOverride,omitempty"`
}

// GroupsV2.GroupPostPublicity
type GroupPostPublicity int32

const (
	GroupPostPublicity_Public   = GroupPostPublicity(0)
	GroupPostPublicity_Alliance = GroupPostPublicity(1)
	GroupPostPublicity_Private  = GroupPostPublicity(2)
)

// GroupsV2.GroupPotentialMember
type GroupPotentialMember struct {
	// {
	//   "properties": {
	//     "bungieNetUserInfo": {
	//       "$ref": "#/components/schemas/User.UserInfoCard"
	//     },
	//     "destinyUserInfo": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupUserInfoCard"
	//     },
	//     "groupId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "joinDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "potentialStatus": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupPotentialMemberStatus"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	BungieNetUserInfo UserInfoCard `json:"bungieNetUserInfo"`

	DestinyUserInfo GroupUserInfoCard `json:"destinyUserInfo"`

	GroupID Int64 `json:"groupId"`

	JoinDate Timestamp `json:"joinDate"`

	PotentialStatus GroupPotentialMemberStatus `json:"potentialStatus"`
}

// GroupsV2.GroupPotentialMemberStatus
type GroupPotentialMemberStatus int32

const (
	GroupPotentialMemberStatus_None      = GroupPotentialMemberStatus(0)
	GroupPotentialMemberStatus_Applicant = GroupPotentialMemberStatus(1)
	GroupPotentialMemberStatus_Invitee   = GroupPotentialMemberStatus(2)
)

// GroupsV2.GroupPotentialMembership
type GroupPotentialMembership struct {
	// {
	//   "properties": {
	//     "group": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupV2"
	//     },
	//     "member": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupPotentialMember"
	//     }
	//   },
	//   "type": "object"
	// }

	Group GroupV2 `json:"group"`

	Member GroupPotentialMember `json:"member"`
}

// GroupsV2.GroupPotentialMembershipSearchResponse
type GroupPotentialMembershipSearchResponse struct {
	// {
	//   "properties": {
	//     "hasMore": {
	//       "type": "boolean"
	//     },
	//     "query": {
	//       "$ref": "#/components/schemas/Queries.PagedQuery"
	//     },
	//     "replacementContinuationToken": {
	//       "type": "string"
	//     },
	//     "results": {
	//       "items": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupPotentialMembership"
	//       },
	//       "type": "array"
	//     },
	//     "totalResults": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "useTotalResults": {
	//       "description": "If useTotalResults is true, then totalResults represents an accurate count.\r\nIf False, it does not, and may be estimated/only the size of the current page.\r\nEither way, you should probably always only trust hasMore.\r\nThis is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	HasMore bool `json:"hasMore"`

	Query PagedQuery `json:"query"`

	ReplacementContinuationToken string `json:"replacementContinuationToken"`

	Results []GroupPotentialMembership `json:"results"`

	TotalResults int32 `json:"totalResults"`

	// If useTotalResults is true, then totalResults represents an accurate count.
	// If False, it does not, and may be estimated/only the size of the current page.
	// Either way, you should probably always only trust hasMore.
	// This is a long-held historical throwback to when we used to do paging with known total results.
	// Those queries toasted our database, and we were left to hastily alter our endpoints and create
	// backward- compatible shims, of which useTotalResults is one.
	UseTotalResults bool `json:"useTotalResults"`
}

// GroupsV2.GroupQuery
//
// NOTE: GroupQuery, as of Destiny 2, has essentially two totally different and incompatible "modes".
// If you are querying for a group, you can pass any of the properties below.
// If you are querying for a Clan, you MUST NOT pass any of the following properties (they must be null
// or undefined in your request, not just empty string/default values):
// - groupMemberCountFilter - localeFilter - tagText
// If you pass these, you will get a useless InvalidParameters error.
type GroupQuery struct {
	// {
	//   "description": "NOTE: GroupQuery, as of Destiny 2, has essentially two totally different and incompatible \"modes\".\r\nIf you are querying for a group, you can pass any of the properties below.\r\nIf you are querying for a Clan, you MUST NOT pass any of the following properties (they must be null or undefined in your request, not just empty string/default values):\r\n- groupMemberCountFilter - localeFilter - tagText\r\nIf you pass these, you will get a useless InvalidParameters error.",
	//   "properties": {
	//     "creationDate": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupDateRange"
	//       }
	//     },
	//     "currentPage": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "groupMemberCountFilter": {
	//       "enum": [
	//         "0",
	//         "1",
	//         "2",
	//         "3"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "All",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "OneToTen",
	//           "numericValue": "1"
	//         },
	//         {
	//           "identifier": "ElevenToOneHundred",
	//           "numericValue": "2"
	//         },
	//         {
	//           "identifier": "GreaterThanOneHundred",
	//           "numericValue": "3"
	//         }
	//       ]
	//     },
	//     "groupType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupType"
	//       }
	//     },
	//     "itemsPerPage": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "localeFilter": {
	//       "type": "string"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "requestContinuationToken": {
	//       "type": "string"
	//     },
	//     "sortBy": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupSortBy"
	//       }
	//     },
	//     "tagText": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	CreationDate GroupDateRange `json:"creationDate"`

	CurrentPage int32 `json:"currentPage"`

	GroupMemberCountFilter Nullable[int32] `json:"groupMemberCountFilter,omitempty"`

	GroupType GroupType `json:"groupType"`

	ItemsPerPage int32 `json:"itemsPerPage"`

	LocaleFilter string `json:"localeFilter"`

	Name string `json:"name"`

	RequestContinuationToken string `json:"requestContinuationToken"`

	SortBy GroupSortBy `json:"sortBy"`

	TagText string `json:"tagText"`
}

// GroupsV2.GroupResponse
type GroupResponse struct {
	// {
	//   "properties": {
	//     "allianceStatus": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupAllianceStatus"
	//       }
	//     },
	//     "alliedIds": {
	//       "items": {
	//         "format": "int64",
	//         "type": "integer"
	//       },
	//       "type": "array"
	//     },
	//     "currentUserMemberMap": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupMember"
	//       },
	//       "description": "This property will be populated if the authenticated user is a member of the group. Note that because of account linking, a user can sometimes be part of a clan more than once. As such, this returns the highest member type available.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/BungieMembershipType"
	//         }
	//       }
	//     },
	//     "currentUserMembershipsInactiveForDestiny": {
	//       "description": "A convenience property that indicates if every membership you (the current user) have that is a part of this group are part of an account that is considered inactive - for example, overridden accounts in Cross Save.",
	//       "type": "boolean"
	//     },
	//     "currentUserPotentialMemberMap": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupPotentialMember"
	//       },
	//       "description": "This property will be populated if the authenticated user is an applicant or has an outstanding invitation to join. Note that because of account linking, a user can sometimes be part of a clan more than once.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/BungieMembershipType"
	//         }
	//       }
	//     },
	//     "detail": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupV2"
	//     },
	//     "founder": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupMember"
	//     },
	//     "groupJoinInviteCount": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "parentGroup": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupV2"
	//     }
	//   },
	//   "type": "object"
	// }

	AllianceStatus GroupAllianceStatus `json:"allianceStatus"`

	AlliedIds []Int64 `json:"alliedIds"`

	// This property will be populated if the authenticated user is a member of the group. Note that
	// because of account linking, a user can sometimes be part of a clan more than once. As such, this
	// returns the highest member type available.
	CurrentUserMemberMap map[string]GroupMember `json:"currentUserMemberMap"`

	// A convenience property that indicates if every membership you (the current user) have that is a part
	// of this group are part of an account that is considered inactive - for example, overridden accounts
	// in Cross Save.
	CurrentUserMembershipsInactiveForDestiny bool `json:"currentUserMembershipsInactiveForDestiny"`

	// This property will be populated if the authenticated user is an applicant or has an outstanding
	// invitation to join. Note that because of account linking, a user can sometimes be part of a clan
	// more than once.
	CurrentUserPotentialMemberMap map[string]GroupPotentialMember `json:"currentUserPotentialMemberMap"`

	Detail GroupV2 `json:"detail"`

	Founder GroupMember `json:"founder"`

	GroupJoinInviteCount int32 `json:"groupJoinInviteCount"`

	ParentGroup GroupV2 `json:"parentGroup"`
}

// GroupsV2.GroupSearchResponse
type GroupSearchResponse struct {
	// {
	//   "properties": {
	//     "hasMore": {
	//       "type": "boolean"
	//     },
	//     "query": {
	//       "$ref": "#/components/schemas/Queries.PagedQuery"
	//     },
	//     "replacementContinuationToken": {
	//       "type": "string"
	//     },
	//     "results": {
	//       "items": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupV2Card"
	//       },
	//       "type": "array"
	//     },
	//     "totalResults": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "useTotalResults": {
	//       "description": "If useTotalResults is true, then totalResults represents an accurate count.\r\nIf False, it does not, and may be estimated/only the size of the current page.\r\nEither way, you should probably always only trust hasMore.\r\nThis is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	HasMore bool `json:"hasMore"`

	Query PagedQuery `json:"query"`

	ReplacementContinuationToken string `json:"replacementContinuationToken"`

	Results []GroupV2Card `json:"results"`

	TotalResults int32 `json:"totalResults"`

	// If useTotalResults is true, then totalResults represents an accurate count.
	// If False, it does not, and may be estimated/only the size of the current page.
	// Either way, you should probably always only trust hasMore.
	// This is a long-held historical throwback to when we used to do paging with known total results.
	// Those queries toasted our database, and we were left to hastily alter our endpoints and create
	// backward- compatible shims, of which useTotalResults is one.
	UseTotalResults bool `json:"useTotalResults"`
}

// GroupsV2.GroupSortBy
type GroupSortBy int32

const (
	GroupSortBy_Name       = GroupSortBy(0)
	GroupSortBy_Date       = GroupSortBy(1)
	GroupSortBy_Popularity = GroupSortBy(2)
	GroupSortBy_Id         = GroupSortBy(3)
)

// GroupsV2.GroupType
type GroupType int32

const (
	GroupType_General = GroupType(0)
	GroupType_Clan    = GroupType(1)
)

// GroupsV2.GroupUserBase
type GroupUserBase struct {
	// {
	//   "properties": {
	//     "bungieNetUserInfo": {
	//       "$ref": "#/components/schemas/User.UserInfoCard"
	//     },
	//     "destinyUserInfo": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupUserInfoCard"
	//     },
	//     "groupId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "joinDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	BungieNetUserInfo UserInfoCard `json:"bungieNetUserInfo"`

	DestinyUserInfo GroupUserInfoCard `json:"destinyUserInfo"`

	GroupID Int64 `json:"groupId"`

	JoinDate Timestamp `json:"joinDate"`
}

// GroupsV2.GroupUserInfoCard
type GroupUserInfoCard struct {
	// {
	//   "properties": {
	//     "LastSeenDisplayName": {
	//       "description": "This will be the display name the clan server last saw the user as. If the account is an active cross save override, this will be the display name to use. Otherwise, this will match the displayName property.",
	//       "type": "string"
	//     },
	//     "LastSeenDisplayNameType": {
	//       "description": "The platform of the LastSeenDisplayName",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "applicableMembershipTypes": {
	//       "description": "The list of Membership Types indicating the platforms on which this Membership can be used.\r\n Not in Cross Save = its original membership type. Cross Save Primary = Any membership types it is overridding, and its original membership type Cross Save Overridden = Empty list",
	//       "items": {
	//         "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/BungieMembershipType"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "bungieGlobalDisplayName": {
	//       "description": "The bungie global display name, if set.",
	//       "type": "string"
	//     },
	//     "bungieGlobalDisplayNameCode": {
	//       "description": "The bungie global display name code, if set.",
	//       "format": "int16",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "crossSaveOverride": {
	//       "description": "If there is a cross save override in effect, this value will tell you the type that is overridding this one.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "displayName": {
	//       "description": "Display Name the player has chosen for themselves. The display name is optional when the data type is used as input to a platform API.",
	//       "type": "string"
	//     },
	//     "iconPath": {
	//       "description": "URL the Icon if available.",
	//       "type": "string"
	//     },
	//     "isPublic": {
	//       "description": "If True, this is a public user membership.",
	//       "type": "boolean"
	//     },
	//     "membershipId": {
	//       "description": "Membership ID as they user is known in the Accounts service",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "description": "Type of the membership. Not necessarily the native type.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "supplementalDisplayName": {
	//       "description": "A platform specific additional display name - ex: psn Real Name, bnet Unique Name, etc.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// This will be the display name the clan server last saw the user as. If the account is an active
	// cross save override, this will be the display name to use. Otherwise, this will match the
	// displayName property.
	LastSeenDisplayName string `json:"LastSeenDisplayName"`

	// The platform of the LastSeenDisplayName
	LastSeenDisplayNameType BungieMembershipType `json:"LastSeenDisplayNameType"`

	// The list of Membership Types indicating the platforms on which this Membership can be used.
	//
	//	Not in Cross Save = its original membership type. Cross Save Primary = Any membership types it is
	//
	// overridding, and its original membership type Cross Save Overridden = Empty list
	ApplicableMembershipTypes []BungieMembershipType `json:"applicableMembershipTypes"`

	// The bungie global display name, if set.
	BungieGlobalDisplayName string `json:"bungieGlobalDisplayName"`

	// The bungie global display name code, if set.
	BungieGlobalDisplayNameCode Nullable[int16] `json:"bungieGlobalDisplayNameCode,omitempty"`

	// If there is a cross save override in effect, this value will tell you the type that is overridding
	// this one.
	CrossSaveOverride BungieMembershipType `json:"crossSaveOverride"`

	// Display Name the player has chosen for themselves. The display name is optional when the data type
	// is used as input to a platform API.
	DisplayName string `json:"displayName"`

	// URL the Icon if available.
	IconPath string `json:"iconPath"`

	// If True, this is a public user membership.
	IsPublic bool `json:"isPublic"`

	// Membership ID as they user is known in the Accounts service
	MembershipID Int64 `json:"membershipId"`

	// Type of the membership. Not necessarily the native type.
	MembershipType BungieMembershipType `json:"membershipType"`

	// A platform specific additional display name - ex: psn Real Name, bnet Unique Name, etc.
	SupplementalDisplayName string `json:"supplementalDisplayName"`
}

// GroupsV2.GroupV2
type GroupV2 struct {
	// {
	//   "properties": {
	//     "about": {
	//       "type": "string"
	//     },
	//     "allowChat": {
	//       "type": "boolean"
	//     },
	//     "avatarImageIndex": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "avatarPath": {
	//       "type": "string"
	//     },
	//     "banExpireDate": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "bannerPath": {
	//       "type": "string"
	//     },
	//     "chatSecurity": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.ChatSecuritySetting"
	//       }
	//     },
	//     "clanInfo": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupV2ClanInfoAndInvestment"
	//     },
	//     "conversationId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "creationDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "defaultPublicity": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupPostPublicity"
	//       }
	//     },
	//     "enableInvitationMessagingForAdmins": {
	//       "type": "boolean"
	//     },
	//     "features": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupFeatures"
	//     },
	//     "groupId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "groupType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupType"
	//       }
	//     },
	//     "homepage": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupHomepage"
	//       }
	//     },
	//     "isDefaultPostPublic": {
	//       "type": "boolean"
	//     },
	//     "isPublic": {
	//       "type": "boolean"
	//     },
	//     "isPublicTopicAdminOnly": {
	//       "type": "boolean"
	//     },
	//     "locale": {
	//       "type": "string"
	//     },
	//     "memberCount": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "membershipIdCreated": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipOption": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.MembershipOption"
	//       }
	//     },
	//     "modificationDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "motto": {
	//       "type": "string"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "remoteGroupId": {
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "tags": {
	//       "items": {
	//         "type": "string"
	//       },
	//       "type": "array"
	//     },
	//     "theme": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	About string `json:"about"`

	AllowChat bool `json:"allowChat"`

	AvatarImageIndex int32 `json:"avatarImageIndex"`

	AvatarPath string `json:"avatarPath"`

	BanExpireDate Nullable[Timestamp] `json:"banExpireDate,omitempty"`

	BannerPath string `json:"bannerPath"`

	ChatSecurity ChatSecuritySetting `json:"chatSecurity"`

	ClanInfo GroupV2ClanInfoAndInvestment `json:"clanInfo"`

	ConversationID Int64 `json:"conversationId"`

	CreationDate Timestamp `json:"creationDate"`

	DefaultPublicity GroupPostPublicity `json:"defaultPublicity"`

	EnableInvitationMessagingForAdmins bool `json:"enableInvitationMessagingForAdmins"`

	Features GroupFeatures `json:"features"`

	GroupID Int64 `json:"groupId"`

	GroupType GroupType `json:"groupType"`

	Homepage GroupHomepage `json:"homepage"`

	IsDefaultPostPublic bool `json:"isDefaultPostPublic"`

	IsPublic bool `json:"isPublic"`

	IsPublicTopicAdminOnly bool `json:"isPublicTopicAdminOnly"`

	Locale string `json:"locale"`

	MemberCount int32 `json:"memberCount"`

	MembershipIdCreated Int64 `json:"membershipIdCreated"`

	MembershipOption MembershipOption `json:"membershipOption"`

	ModificationDate Timestamp `json:"modificationDate"`

	Motto string `json:"motto"`

	Name string `json:"name"`

	RemoteGroupID Nullable[Int64] `json:"remoteGroupId,omitempty"`

	Tags []string `json:"tags"`

	Theme string `json:"theme"`
}

// GroupsV2.GroupV2Card
//
// A small infocard of group information, usually used for when a list of groups are returned
type GroupV2Card struct {
	// {
	//   "description": "A small infocard of group information, usually used for when a list of groups are returned",
	//   "properties": {
	//     "about": {
	//       "type": "string"
	//     },
	//     "avatarPath": {
	//       "type": "string"
	//     },
	//     "capabilities": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.Capabilities"
	//       }
	//     },
	//     "clanInfo": {
	//       "$ref": "#/components/schemas/GroupsV2.GroupV2ClanInfo"
	//     },
	//     "creationDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "groupId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "groupType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupType"
	//       }
	//     },
	//     "locale": {
	//       "type": "string"
	//     },
	//     "memberCount": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "membershipOption": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/GroupsV2.MembershipOption"
	//       }
	//     },
	//     "motto": {
	//       "type": "string"
	//     },
	//     "name": {
	//       "type": "string"
	//     },
	//     "remoteGroupId": {
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "theme": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	About string `json:"about"`

	AvatarPath string `json:"avatarPath"`

	Capabilities BitmaskSet[Capabilities] `json:"capabilities"`

	ClanInfo GroupV2ClanInfo `json:"clanInfo"`

	CreationDate Timestamp `json:"creationDate"`

	GroupID Int64 `json:"groupId"`

	GroupType GroupType `json:"groupType"`

	Locale string `json:"locale"`

	MemberCount int32 `json:"memberCount"`

	MembershipOption MembershipOption `json:"membershipOption"`

	Motto string `json:"motto"`

	Name string `json:"name"`

	RemoteGroupID Nullable[Int64] `json:"remoteGroupId,omitempty"`

	Theme string `json:"theme"`
}

// GroupsV2.GroupV2ClanInfo
//
// This contract contains clan-specific group information. It does not include any investment data.
type GroupV2ClanInfo struct {
	// {
	//   "description": "This contract contains clan-specific group information. It does not include any investment data.",
	//   "properties": {
	//     "clanBannerData": {
	//       "$ref": "#/components/schemas/GroupsV2.ClanBanner"
	//     },
	//     "clanCallsign": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	ClanBannerData ClanBanner `json:"clanBannerData"`

	ClanCallsign string `json:"clanCallsign"`
}

// GroupsV2.GroupV2ClanInfoAndInvestment
//
// The same as GroupV2ClanInfo, but includes any investment data.
type GroupV2ClanInfoAndInvestment struct {
	// {
	//   "description": "The same as GroupV2ClanInfo, but includes any investment data.",
	//   "properties": {
	//     "clanBannerData": {
	//       "$ref": "#/components/schemas/GroupsV2.ClanBanner"
	//     },
	//     "clanCallsign": {
	//       "type": "string"
	//     },
	//     "d2ClanProgressions": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/Destiny.DestinyProgression"
	//       },
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "format": "uint32",
	//         "type": "integer"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	ClanBannerData ClanBanner `json:"clanBannerData"`

	ClanCallsign string `json:"clanCallsign"`

	D2ClanProgressions map[uint32]Progression `json:"d2ClanProgressions"`
}

// GroupsV2.GroupsForMemberFilter
type GroupsForMemberFilter int32

const (
	GroupsForMemberFilter_All        = GroupsForMemberFilter(0)
	GroupsForMemberFilter_Founded    = GroupsForMemberFilter(1)
	GroupsForMemberFilter_NonFounded = GroupsForMemberFilter(2)
)

// GroupsV2.HostGuidedGamesPermissionLevel
//
// Used for setting the guided game permission level override (admins and founders can always host
// guided games).
type HostGuidedGamesPermissionLevel int32

const (
	HostGuidedGamesPermissionLevel_None     = HostGuidedGamesPermissionLevel(0)
	HostGuidedGamesPermissionLevel_Beginner = HostGuidedGamesPermissionLevel(1)
	HostGuidedGamesPermissionLevel_Member   = HostGuidedGamesPermissionLevel(2)
)

// GroupsV2.MembershipOption
type MembershipOption int32

const (
	MembershipOption_Reviewed = MembershipOption(0)
	MembershipOption_Open     = MembershipOption(1)
	MembershipOption_Closed   = MembershipOption(2)
)

// GroupsV2.RuntimeGroupMemberType
//
// The member levels used by all V2 Groups API. Individual group types use their own mappings in their
// native storage (general uses BnetDbGroupMemberType and D2 clans use ClanMemberLevel), but they are
// all translated to this in the runtime api. These runtime values should NEVER be stored anywhere, so
// the values can be changed as necessary.
type RuntimeGroupMemberType int32

const (
	RuntimeGroupMemberType_None          = RuntimeGroupMemberType(0)
	RuntimeGroupMemberType_Beginner      = RuntimeGroupMemberType(1)
	RuntimeGroupMemberType_Member        = RuntimeGroupMemberType(2)
	RuntimeGroupMemberType_Admin         = RuntimeGroupMemberType(3)
	RuntimeGroupMemberType_ActingFounder = RuntimeGroupMemberType(4)
	RuntimeGroupMemberType_Founder       = RuntimeGroupMemberType(5)
)

// Ignores.IgnoreLength
type IgnoreLength int32

const (
	IgnoreLength_None         = IgnoreLength(0)
	IgnoreLength_Week         = IgnoreLength(1)
	IgnoreLength_TwoWeeks     = IgnoreLength(2)
	IgnoreLength_ThreeWeeks   = IgnoreLength(3)
	IgnoreLength_Month        = IgnoreLength(4)
	IgnoreLength_ThreeMonths  = IgnoreLength(5)
	IgnoreLength_SixMonths    = IgnoreLength(6)
	IgnoreLength_Year         = IgnoreLength(7)
	IgnoreLength_Forever      = IgnoreLength(8)
	IgnoreLength_ThreeMinutes = IgnoreLength(9)
	IgnoreLength_Hour         = IgnoreLength(10)
	IgnoreLength_ThirtyDays   = IgnoreLength(11)
)

// Ignores.IgnoreResponse
type IgnoreResponse struct {
	// {
	//   "properties": {
	//     "ignoreFlags": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Ignores.IgnoreStatus"
	//       }
	//     },
	//     "isIgnored": {
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	IgnoreFlags BitmaskSet[IgnoreStatus] `json:"ignoreFlags"`

	IsIgnored bool `json:"isIgnored"`
}

// Ignores.IgnoreStatus
type IgnoreStatus int32

const (
	IgnoreStatus_NotIgnored     = IgnoreStatus(0)
	IgnoreStatus_IgnoredUser    = IgnoreStatus(1)
	IgnoreStatus_IgnoredGroup   = IgnoreStatus(2)
	IgnoreStatus_IgnoredByGroup = IgnoreStatus(4)
	IgnoreStatus_IgnoredPost    = IgnoreStatus(8)
	IgnoreStatus_IgnoredTag     = IgnoreStatus(16)
	IgnoreStatus_IgnoredGlobal  = IgnoreStatus(32)
)

// Interpolation.InterpolationPoint
type InterpolationPoint struct {
	// {
	//   "properties": {
	//     "value": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "weight": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	Value int32 `json:"value"`

	Weight int32 `json:"weight"`
}

// Interpolation.InterpolationPointFloat
type InterpolationPointFloat struct {
	// {
	//   "properties": {
	//     "value": {
	//       "format": "float",
	//       "type": "number"
	//     },
	//     "weight": {
	//       "format": "float",
	//       "type": "number"
	//     }
	//   },
	//   "type": "object"
	// }

	Value float64 `json:"value"`

	Weight float64 `json:"weight"`
}

// Links.HyperlinkReference
type HyperlinkReference struct {
	// {
	//   "properties": {
	//     "title": {
	//       "type": "string"
	//     },
	//     "url": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Title string `json:"title"`

	Url string `json:"url"`
}

// Queries.PagedQuery
type PagedQuery struct {
	// {
	//   "properties": {
	//     "currentPage": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "itemsPerPage": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "requestContinuationToken": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	CurrentPage int32 `json:"currentPage"`

	ItemsPerPage int32 `json:"itemsPerPage"`

	RequestContinuationToken string `json:"requestContinuationToken"`
}

// Queries.SearchResult
type SearchResult[T any] struct {
	Results []T `json:"results"`
	// {
	//   "properties": {
	//     "hasMore": {
	//       "type": "boolean"
	//     },
	//     "query": {
	//       "$ref": "#/components/schemas/Queries.PagedQuery"
	//     },
	//     "replacementContinuationToken": {
	//       "type": "string"
	//     },
	//     "totalResults": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "useTotalResults": {
	//       "description": "If useTotalResults is true, then totalResults represents an accurate count.\r\nIf False, it does not, and may be estimated/only the size of the current page.\r\nEither way, you should probably always only trust hasMore.\r\nThis is a long-held historical throwback to when we used to do paging with known total results. Those queries toasted our database, and we were left to hastily alter our endpoints and create backward- compatible shims, of which useTotalResults is one.",
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	HasMore bool `json:"hasMore"`

	Query PagedQuery `json:"query"`

	ReplacementContinuationToken string `json:"replacementContinuationToken"`

	TotalResults int32 `json:"totalResults"`

	// If useTotalResults is true, then totalResults represents an accurate count.
	// If False, it does not, and may be estimated/only the size of the current page.
	// Either way, you should probably always only trust hasMore.
	// This is a long-held historical throwback to when we used to do paging with known total results.
	// Those queries toasted our database, and we were left to hastily alter our endpoints and create
	// backward- compatible shims, of which useTotalResults is one.
	UseTotalResults bool `json:"useTotalResults"`
}

// Social.Friends.BungieFriend
type BungieFriend struct {
	// {
	//   "properties": {
	//     "bungieGlobalDisplayName": {
	//       "type": "string"
	//     },
	//     "bungieGlobalDisplayNameCode": {
	//       "format": "int16",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "bungieNetUser": {
	//       "$ref": "#/components/schemas/User.GeneralUser"
	//     },
	//     "lastSeenAsBungieMembershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "lastSeenAsMembershipId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "onlineStatus": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Social.Friends.PresenceStatus"
	//       }
	//     },
	//     "onlineTitle": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Social.Friends.PresenceOnlineStateFlags"
	//       }
	//     },
	//     "relationship": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Social.Friends.FriendRelationshipState"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	BungieGlobalDisplayName string `json:"bungieGlobalDisplayName"`

	BungieGlobalDisplayNameCode Nullable[int16] `json:"bungieGlobalDisplayNameCode,omitempty"`

	BungieNetUser GeneralUser `json:"bungieNetUser"`

	LastSeenAsBungieMembershipType BungieMembershipType `json:"lastSeenAsBungieMembershipType"`

	LastSeenAsMembershipID Int64 `json:"lastSeenAsMembershipId"`

	OnlineStatus PresenceStatus `json:"onlineStatus"`

	OnlineTitle BitmaskSet[PresenceOnlineStateFlags] `json:"onlineTitle"`

	Relationship FriendRelationshipState `json:"relationship"`
}

// Social.Friends.BungieFriendListResponse
type BungieFriendListResponse struct {
	// {
	//   "properties": {
	//     "friends": {
	//       "items": {
	//         "$ref": "#/components/schemas/Social.Friends.BungieFriend"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	Friends []BungieFriend `json:"friends"`
}

// Social.Friends.BungieFriendRequestListResponse
type BungieFriendRequestListResponse struct {
	// {
	//   "properties": {
	//     "incomingRequests": {
	//       "items": {
	//         "$ref": "#/components/schemas/Social.Friends.BungieFriend"
	//       },
	//       "type": "array"
	//     },
	//     "outgoingRequests": {
	//       "items": {
	//         "$ref": "#/components/schemas/Social.Friends.BungieFriend"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	IncomingRequests []BungieFriend `json:"incomingRequests"`

	OutgoingRequests []BungieFriend `json:"outgoingRequests"`
}

// Social.Friends.FriendRelationshipState
type FriendRelationshipState int32

const (
	FriendRelationshipState_Unknown         = FriendRelationshipState(0)
	FriendRelationshipState_Friend          = FriendRelationshipState(1)
	FriendRelationshipState_IncomingRequest = FriendRelationshipState(2)
	FriendRelationshipState_OutgoingRequest = FriendRelationshipState(3)
)

// Social.Friends.PlatformFriend
type PlatformFriend struct {
	// {
	//   "properties": {
	//     "bungieGlobalDisplayName": {
	//       "type": "string"
	//     },
	//     "bungieGlobalDisplayNameCode": {
	//       "format": "int16",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "bungieNetMembershipId": {
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "destinyMembershipId": {
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "destinyMembershipType": {
	//       "enum": [
	//         "0",
	//         "1",
	//         "2",
	//         "3",
	//         "4",
	//         "5",
	//         "6",
	//         "10",
	//         "254",
	//         "-1"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "None",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "TigerXbox",
	//           "numericValue": "1"
	//         },
	//         {
	//           "identifier": "TigerPsn",
	//           "numericValue": "2"
	//         },
	//         {
	//           "identifier": "TigerSteam",
	//           "numericValue": "3"
	//         },
	//         {
	//           "identifier": "TigerBlizzard",
	//           "numericValue": "4"
	//         },
	//         {
	//           "identifier": "TigerStadia",
	//           "numericValue": "5"
	//         },
	//         {
	//           "identifier": "TigerEgs",
	//           "numericValue": "6"
	//         },
	//         {
	//           "identifier": "TigerDemon",
	//           "numericValue": "10"
	//         },
	//         {
	//           "identifier": "BungieNext",
	//           "numericValue": "254"
	//         },
	//         {
	//           "description": "\"All\" is only valid for searching capabilities: you need to pass the actual matching BungieMembershipType for any query where you pass a known membershipId.",
	//           "identifier": "All",
	//           "numericValue": "-1"
	//         }
	//       ]
	//     },
	//     "friendPlatform": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Social.Friends.PlatformFriendType"
	//       }
	//     },
	//     "platformDisplayName": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	BungieGlobalDisplayName string `json:"bungieGlobalDisplayName"`

	BungieGlobalDisplayNameCode Nullable[int16] `json:"bungieGlobalDisplayNameCode,omitempty"`

	BungieNetMembershipID Nullable[Int64] `json:"bungieNetMembershipId,omitempty"`

	DestinyMembershipID Nullable[Int64] `json:"destinyMembershipId,omitempty"`

	DestinyMembershipType Nullable[int32] `json:"destinyMembershipType,omitempty"`

	FriendPlatform PlatformFriendType `json:"friendPlatform"`

	PlatformDisplayName string `json:"platformDisplayName"`
}

// Social.Friends.PlatformFriendResponse
type PlatformFriendResponse struct {
	// {
	//   "properties": {
	//     "currentPage": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "hasMore": {
	//       "type": "boolean"
	//     },
	//     "itemsPerPage": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "platformFriends": {
	//       "items": {
	//         "$ref": "#/components/schemas/Social.Friends.PlatformFriend"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	CurrentPage int32 `json:"currentPage"`

	HasMore bool `json:"hasMore"`

	ItemsPerPage int32 `json:"itemsPerPage"`

	PlatformFriends []PlatformFriend `json:"platformFriends"`
}

// Social.Friends.PlatformFriendType
type PlatformFriendType int32

const (
	PlatformFriendType_Unknown = PlatformFriendType(0)
	PlatformFriendType_Xbox    = PlatformFriendType(1)
	PlatformFriendType_PSN     = PlatformFriendType(2)
	PlatformFriendType_Steam   = PlatformFriendType(3)
	PlatformFriendType_Egs     = PlatformFriendType(4)
)

// Social.Friends.PresenceOnlineStateFlags
type PresenceOnlineStateFlags int32

const (
	PresenceOnlineStateFlags_None     = PresenceOnlineStateFlags(0)
	PresenceOnlineStateFlags_Destiny1 = PresenceOnlineStateFlags(1)
	PresenceOnlineStateFlags_Destiny2 = PresenceOnlineStateFlags(2)
)

// Social.Friends.PresenceStatus
type PresenceStatus int32

const (
	PresenceStatus_OfflineOrUnknown = PresenceStatus(0)
	PresenceStatus_Online           = PresenceStatus(1)
)

// StreamInfo
type StreamInfo struct {
	// {
	//   "properties": {
	//     "ChannelName": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	ChannelName string `json:"ChannelName"`
}

// Streaming.DropStateEnum
type DropState int

const (
	DropState_Claimed   = DropState(0)
	DropState_Applied   = DropState(1)
	DropState_Fulfilled = DropState(2)
)

// Tags.Models.Contracts.TagResponse
type TagResponse struct {
	// {
	//   "properties": {
	//     "ignoreStatus": {
	//       "$ref": "#/components/schemas/Ignores.IgnoreResponse"
	//     },
	//     "tagText": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	IgnoreStatus IgnoreResponse `json:"ignoreStatus"`

	TagText string `json:"tagText"`
}

// Tokens.BungieRewardDisplay
type BungieRewardDisplay struct {
	// {
	//   "properties": {
	//     "ObjectiveDisplayProperties": {
	//       "$ref": "#/components/schemas/Tokens.RewardDisplayProperties"
	//     },
	//     "RewardDisplayProperties": {
	//       "$ref": "#/components/schemas/Tokens.RewardDisplayProperties"
	//     },
	//     "UserRewardAvailabilityModel": {
	//       "$ref": "#/components/schemas/Tokens.UserRewardAvailabilityModel"
	//     }
	//   },
	//   "type": "object"
	// }

	ObjectiveDisplayProperties RewardDisplayProperties `json:"ObjectiveDisplayProperties"`

	RewardDisplayProperties RewardDisplayProperties `json:"RewardDisplayProperties"`

	UserRewardAvailabilityModel UserRewardAvailabilityModel `json:"UserRewardAvailabilityModel"`
}

// Tokens.CollectibleDefinitions
type CollectibleDefinitions struct {
	// {
	//   "properties": {
	//     "CollectibleDefinition": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.Collectibles.DestinyCollectibleDefinition"
	//     },
	//     "DestinyInventoryItemDefinition": {
	//       "$ref": "#/components/schemas/Destiny.Definitions.DestinyInventoryItemDefinition"
	//     }
	//   },
	//   "type": "object"
	// }

	CollectibleDefinition CollectibleDefinition `json:"CollectibleDefinition"`

	DestinyInventoryItemDefinition InventoryItemDefinition `json:"DestinyInventoryItemDefinition"`
}

// Tokens.PartnerOfferClaimRequest
type PartnerOfferClaimRequestBody struct {
	// {
	//   "properties": {
	//     "BungieNetMembershipId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "PartnerOfferId": {
	//       "type": "string"
	//     },
	//     "TransactionId": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	BungieNetMembershipID Int64 `json:"BungieNetMembershipId"`

	PartnerOfferID string `json:"PartnerOfferId"`

	TransactionID string `json:"TransactionId"`
}

// Tokens.PartnerOfferHistoryResponse
type PartnerOfferHistoryResponse struct {
	// {
	//   "properties": {
	//     "ApplyDate": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "IsConsumable": {
	//       "type": "boolean"
	//     },
	//     "LocalizedDescription": {
	//       "type": "string"
	//     },
	//     "LocalizedName": {
	//       "type": "string"
	//     },
	//     "MembershipId": {
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "MembershipType": {
	//       "enum": [
	//         "0",
	//         "1",
	//         "2",
	//         "3",
	//         "4",
	//         "5",
	//         "6",
	//         "10",
	//         "254",
	//         "-1"
	//       ],
	//       "format": "int32",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "None",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "TigerXbox",
	//           "numericValue": "1"
	//         },
	//         {
	//           "identifier": "TigerPsn",
	//           "numericValue": "2"
	//         },
	//         {
	//           "identifier": "TigerSteam",
	//           "numericValue": "3"
	//         },
	//         {
	//           "identifier": "TigerBlizzard",
	//           "numericValue": "4"
	//         },
	//         {
	//           "identifier": "TigerStadia",
	//           "numericValue": "5"
	//         },
	//         {
	//           "identifier": "TigerEgs",
	//           "numericValue": "6"
	//         },
	//         {
	//           "identifier": "TigerDemon",
	//           "numericValue": "10"
	//         },
	//         {
	//           "identifier": "BungieNext",
	//           "numericValue": "254"
	//         },
	//         {
	//           "description": "\"All\" is only valid for searching capabilities: you need to pass the actual matching BungieMembershipType for any query where you pass a known membershipId.",
	//           "identifier": "All",
	//           "numericValue": "-1"
	//         }
	//       ]
	//     },
	//     "PartnerOfferKey": {
	//       "type": "string"
	//     },
	//     "QuantityApplied": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	ApplyDate Nullable[Timestamp] `json:"ApplyDate,omitempty"`

	IsConsumable bool `json:"IsConsumable"`

	LocalizedDescription string `json:"LocalizedDescription"`

	LocalizedName string `json:"LocalizedName"`

	MembershipID Nullable[Int64] `json:"MembershipId,omitempty"`

	MembershipType Nullable[int32] `json:"MembershipType,omitempty"`

	PartnerOfferKey string `json:"PartnerOfferKey"`

	QuantityApplied int32 `json:"QuantityApplied"`
}

// Tokens.PartnerOfferSkuHistoryResponse
type PartnerOfferSkuHistoryResponse struct {
	// {
	//   "properties": {
	//     "AllOffersApplied": {
	//       "type": "boolean"
	//     },
	//     "ClaimDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "LocalizedDescription": {
	//       "type": "string"
	//     },
	//     "LocalizedName": {
	//       "type": "string"
	//     },
	//     "SkuIdentifier": {
	//       "type": "string"
	//     },
	//     "SkuOffers": {
	//       "items": {
	//         "$ref": "#/components/schemas/Tokens.PartnerOfferHistoryResponse"
	//       },
	//       "type": "array"
	//     },
	//     "TransactionId": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	AllOffersApplied bool `json:"AllOffersApplied"`

	ClaimDate Timestamp `json:"ClaimDate"`

	LocalizedDescription string `json:"LocalizedDescription"`

	LocalizedName string `json:"LocalizedName"`

	SkuIdentifier string `json:"SkuIdentifier"`

	SkuOffers []PartnerOfferHistoryResponse `json:"SkuOffers"`

	TransactionID string `json:"TransactionId"`
}

// Tokens.PartnerRewardHistoryResponse
type PartnerRewardHistoryResponse struct {
	// {
	//   "properties": {
	//     "PartnerOffers": {
	//       "items": {
	//         "$ref": "#/components/schemas/Tokens.PartnerOfferSkuHistoryResponse"
	//       },
	//       "type": "array"
	//     },
	//     "TwitchDrops": {
	//       "items": {
	//         "$ref": "#/components/schemas/Tokens.TwitchDropHistoryResponse"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	PartnerOffers []PartnerOfferSkuHistoryResponse `json:"PartnerOffers"`

	TwitchDrops []TwitchDropHistoryResponse `json:"TwitchDrops"`
}

// Tokens.RewardAvailabilityModel
type RewardAvailabilityModel struct {
	// {
	//   "properties": {
	//     "CollectibleDefinitions": {
	//       "items": {
	//         "$ref": "#/components/schemas/Tokens.CollectibleDefinitions"
	//       },
	//       "type": "array"
	//     },
	//     "DecryptedToken": {
	//       "type": "string"
	//     },
	//     "GameEarnByDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "HasExistingCode": {
	//       "type": "boolean"
	//     },
	//     "HasOffer": {
	//       "type": "boolean"
	//     },
	//     "IsLoyaltyReward": {
	//       "type": "boolean"
	//     },
	//     "IsOffer": {
	//       "type": "boolean"
	//     },
	//     "OfferApplied": {
	//       "type": "boolean"
	//     },
	//     "RecordDefinitions": {
	//       "items": {
	//         "$ref": "#/components/schemas/Destiny.Definitions.Records.DestinyRecordDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "RedemptionEndDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "ShopifyEndDate": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	CollectibleDefinitions []CollectibleDefinitions `json:"CollectibleDefinitions"`

	DecryptedToken string `json:"DecryptedToken"`

	GameEarnByDate Timestamp `json:"GameEarnByDate"`

	HasExistingCode bool `json:"HasExistingCode"`

	HasOffer bool `json:"HasOffer"`

	IsLoyaltyReward bool `json:"IsLoyaltyReward"`

	IsOffer bool `json:"IsOffer"`

	OfferApplied bool `json:"OfferApplied"`

	RecordDefinitions []RecordDefinition `json:"RecordDefinitions"`

	RedemptionEndDate Timestamp `json:"RedemptionEndDate"`

	ShopifyEndDate Nullable[Timestamp] `json:"ShopifyEndDate,omitempty"`
}

// Tokens.RewardDisplayProperties
type RewardDisplayProperties struct {
	// {
	//   "properties": {
	//     "Description": {
	//       "type": "string"
	//     },
	//     "ImagePath": {
	//       "type": "string"
	//     },
	//     "Name": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Description string `json:"Description"`

	ImagePath string `json:"ImagePath"`

	Name string `json:"Name"`
}

// Tokens.TwitchDropHistoryResponse
type TwitchDropHistoryResponse struct {
	// {
	//   "properties": {
	//     "ClaimState": {
	//       "enum": [
	//         "0",
	//         "1",
	//         "2"
	//       ],
	//       "format": "byte",
	//       "nullable": true,
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-values": [
	//         {
	//           "identifier": "Claimed",
	//           "numericValue": "0"
	//         },
	//         {
	//           "identifier": "Applied",
	//           "numericValue": "1"
	//         },
	//         {
	//           "identifier": "Fulfilled",
	//           "numericValue": "2"
	//         }
	//       ]
	//     },
	//     "CreatedAt": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "Description": {
	//       "type": "string"
	//     },
	//     "Title": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	ClaimState Nullable[int] `json:"ClaimState,omitempty"`

	CreatedAt Nullable[Timestamp] `json:"CreatedAt,omitempty"`

	Description string `json:"Description"`

	Title string `json:"Title"`
}

// Tokens.UserRewardAvailabilityModel
type UserRewardAvailabilityModel struct {
	// {
	//   "properties": {
	//     "AvailabilityModel": {
	//       "$ref": "#/components/schemas/Tokens.RewardAvailabilityModel"
	//     },
	//     "IsAvailableForUser": {
	//       "type": "boolean"
	//     },
	//     "IsUnlockedForUser": {
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	AvailabilityModel RewardAvailabilityModel `json:"AvailabilityModel"`

	IsAvailableForUser bool `json:"IsAvailableForUser"`

	IsUnlockedForUser bool `json:"IsUnlockedForUser"`
}

// Trending.TrendingCategories
type TrendingCategories struct {
	// {
	//   "properties": {
	//     "categories": {
	//       "items": {
	//         "$ref": "#/components/schemas/Trending.TrendingCategory"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	Categories []TrendingCategory `json:"categories"`
}

// Trending.TrendingCategory
type TrendingCategory struct {
	// {
	//   "properties": {
	//     "categoryId": {
	//       "type": "string"
	//     },
	//     "categoryName": {
	//       "type": "string"
	//     },
	//     "entries": {
	//       "$ref": "#/components/schemas/SearchResultOfTrendingEntry"
	//     }
	//   },
	//   "type": "object"
	// }

	CategoryID string `json:"categoryId"`

	CategoryName string `json:"categoryName"`

	Entries SearchResult[TrendingEntry] `json:"entries"`
}

// Trending.TrendingDetail
type TrendingDetail struct {
	// {
	//   "properties": {
	//     "creation": {
	//       "$ref": "#/components/schemas/Trending.TrendingEntryCommunityCreation"
	//     },
	//     "destinyActivity": {
	//       "$ref": "#/components/schemas/Trending.TrendingEntryDestinyActivity"
	//     },
	//     "destinyItem": {
	//       "$ref": "#/components/schemas/Trending.TrendingEntryDestinyItem"
	//     },
	//     "destinyRitual": {
	//       "$ref": "#/components/schemas/Trending.TrendingEntryDestinyRitual"
	//     },
	//     "entityType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Trending.TrendingEntryType"
	//       }
	//     },
	//     "identifier": {
	//       "type": "string"
	//     },
	//     "news": {
	//       "$ref": "#/components/schemas/Trending.TrendingEntryNews"
	//     },
	//     "support": {
	//       "$ref": "#/components/schemas/Trending.TrendingEntrySupportArticle"
	//     }
	//   },
	//   "type": "object"
	// }

	Creation TrendingEntryCommunityCreation `json:"creation"`

	DestinyActivity TrendingEntryDestinyActivity `json:"destinyActivity"`

	DestinyItem TrendingEntryDestinyItem `json:"destinyItem"`

	DestinyRitual TrendingEntryDestinyRitual `json:"destinyRitual"`

	EntityType TrendingEntryType `json:"entityType"`

	Identifier string `json:"identifier"`

	News TrendingEntryNews `json:"news"`

	Support TrendingEntrySupportArticle `json:"support"`
}

// Trending.TrendingEntry
//
// The list entry view for trending items. Returns just enough to show the item on the trending page.
type TrendingEntry struct {
	// {
	//   "description": "The list entry view for trending items. Returns just enough to show the item on the trending page.",
	//   "properties": {
	//     "creationDate": {
	//       "description": "If the entry has a date at which it was created, this is that date.",
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "displayName": {
	//       "description": "The localized \"display name/article title/'primary localized identifier'\" of the entity.",
	//       "type": "string"
	//     },
	//     "endDate": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "entityType": {
	//       "description": "An enum - unfortunately - dictating all of the possible kinds of trending items that you might get in your result set, in case you want to do custom rendering or call to get the details of the item.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/Trending.TrendingEntryType"
	//       }
	//     },
	//     "featureImage": {
	//       "description": "If isFeatured, this image will be populated with whatever the featured image is. Note that this will likely be a very large image, so don't use it all the time.",
	//       "type": "string"
	//     },
	//     "identifier": {
	//       "description": "We don't know whether the identifier will be a string, a uint, or a long... so we're going to cast it all to a string. But either way, we need any trending item created to have a single unique identifier for its type.",
	//       "type": "string"
	//     },
	//     "image": {
	//       "type": "string"
	//     },
	//     "isFeatured": {
	//       "type": "boolean"
	//     },
	//     "items": {
	//       "description": "If the item is of entityType TrendingEntryType.Container, it may have items - also Trending Entries - contained within it. This is the ordered list of those to display under the Container's header.",
	//       "items": {
	//         "$ref": "#/components/schemas/Trending.TrendingEntry"
	//       },
	//       "type": "array"
	//     },
	//     "link": {
	//       "type": "string"
	//     },
	//     "mp4Video": {
	//       "description": "If this is populated, the entry has a related MP4 video to show. I am 100% certain I am going to regret putting this directly on TrendingEntry, but it will work so yolo",
	//       "type": "string"
	//     },
	//     "startDate": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "tagline": {
	//       "description": "If the entity has a localized tagline/subtitle/motto/whatever, that is found here.",
	//       "type": "string"
	//     },
	//     "webmVideo": {
	//       "description": "If this is populated, the entry has a related WebM video to show. I am 100% certain I am going to regret putting this directly on TrendingEntry, but it will work so yolo",
	//       "type": "string"
	//     },
	//     "weight": {
	//       "description": "The weighted score of this trending item.",
	//       "format": "double",
	//       "type": "number"
	//     }
	//   },
	//   "type": "object"
	// }

	// If the entry has a date at which it was created, this is that date.
	CreationDate Nullable[Timestamp] `json:"creationDate,omitempty"`

	// The localized "display name/article title/'primary localized identifier'" of the entity.
	DisplayName string `json:"displayName"`

	EndDate Nullable[Timestamp] `json:"endDate,omitempty"`

	// An enum - unfortunately - dictating all of the possible kinds of trending items that you might get
	// in your result set, in case you want to do custom rendering or call to get the details of the item.
	EntityType TrendingEntryType `json:"entityType"`

	// If isFeatured, this image will be populated with whatever the featured image is. Note that this will
	// likely be a very large image, so don't use it all the time.
	FeatureImage string `json:"featureImage"`

	// We don't know whether the identifier will be a string, a uint, or a long... so we're going to cast
	// it all to a string. But either way, we need any trending item created to have a single unique
	// identifier for its type.
	Identifier string `json:"identifier"`

	Image string `json:"image"`

	IsFeatured bool `json:"isFeatured"`

	// If the item is of entityType TrendingEntryType.Container, it may have items - also Trending Entries
	// - contained within it. This is the ordered list of those to display under the Container's header.
	Items []TrendingEntry `json:"items"`

	Link string `json:"link"`

	// If this is populated, the entry has a related MP4 video to show. I am 100% certain I am going to
	// regret putting this directly on TrendingEntry, but it will work so yolo
	Mp4Video string `json:"mp4Video"`

	StartDate Nullable[Timestamp] `json:"startDate,omitempty"`

	// If the entity has a localized tagline/subtitle/motto/whatever, that is found here.
	Tagline string `json:"tagline"`

	// If this is populated, the entry has a related WebM video to show. I am 100% certain I am going to
	// regret putting this directly on TrendingEntry, but it will work so yolo
	WebmVideo string `json:"webmVideo"`

	// The weighted score of this trending item.
	Weight float64 `json:"weight"`
}

// Trending.TrendingEntryCommunityCreation
type TrendingEntryCommunityCreation struct {
	// {
	//   "properties": {
	//     "author": {
	//       "type": "string"
	//     },
	//     "authorMembershipId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "body": {
	//       "type": "string"
	//     },
	//     "media": {
	//       "type": "string"
	//     },
	//     "postId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "title": {
	//       "type": "string"
	//     },
	//     "upvotes": {
	//       "format": "int32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	Author string `json:"author"`

	AuthorMembershipID Int64 `json:"authorMembershipId"`

	Body string `json:"body"`

	Media string `json:"media"`

	PostID Int64 `json:"postId"`

	Title string `json:"title"`

	Upvotes int32 `json:"upvotes"`
}

// Trending.TrendingEntryDestinyActivity
type TrendingEntryDestinyActivity struct {
	// {
	//   "properties": {
	//     "activityHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     },
	//     "status": {
	//       "$ref": "#/components/schemas/Destiny.Activities.DestinyPublicActivityStatus"
	//     }
	//   },
	//   "type": "object"
	// }

	ActivityHash uint32 `json:"activityHash"`

	Status PublicActivityStatus `json:"status"`
}

// Trending.TrendingEntryDestinyItem
type TrendingEntryDestinyItem struct {
	// {
	//   "properties": {
	//     "itemHash": {
	//       "format": "uint32",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	ItemHash uint32 `json:"itemHash"`
}

// Trending.TrendingEntryDestinyRitual
type TrendingEntryDestinyRitual struct {
	// {
	//   "properties": {
	//     "dateEnd": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "dateStart": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "eventContent": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Milestones.DestinyMilestoneContent"
	//         }
	//       ],
	//       "description": "A destiny event will not necessarily have milestone \"custom content\", but if it does the details will be here.",
	//       "type": "object"
	//     },
	//     "icon": {
	//       "type": "string"
	//     },
	//     "image": {
	//       "type": "string"
	//     },
	//     "milestoneDetails": {
	//       "allOf": [
	//         {
	//           "$ref": "#/components/schemas/Destiny.Milestones.DestinyPublicMilestone"
	//         }
	//       ],
	//       "description": "A destiny event does not necessarily have a related Milestone, but if it does the details will be returned here.",
	//       "type": "object"
	//     },
	//     "subtitle": {
	//       "type": "string"
	//     },
	//     "title": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	DateEnd Nullable[Timestamp] `json:"dateEnd,omitempty"`

	DateStart Nullable[Timestamp] `json:"dateStart,omitempty"`

	// A destiny event will not necessarily have milestone "custom content", but if it does the details
	// will be here.
	EventContent MilestoneContent `json:"eventContent"`

	Icon string `json:"icon"`

	Image string `json:"image"`

	// A destiny event does not necessarily have a related Milestone, but if it does the details will be
	// returned here.
	MilestoneDetails PublicMilestone `json:"milestoneDetails"`

	Subtitle string `json:"subtitle"`

	Title string `json:"title"`
}

// Trending.TrendingEntryNews
type TrendingEntryNews struct {
	// {
	//   "properties": {
	//     "article": {
	//       "$ref": "#/components/schemas/Content.ContentItemPublicContract"
	//     }
	//   },
	//   "type": "object"
	// }

	Article ContentItemPublicContract `json:"article"`
}

// Trending.TrendingEntrySupportArticle
type TrendingEntrySupportArticle struct {
	// {
	//   "properties": {
	//     "article": {
	//       "$ref": "#/components/schemas/Content.ContentItemPublicContract"
	//     }
	//   },
	//   "type": "object"
	// }

	Article ContentItemPublicContract `json:"article"`
}

// Trending.TrendingEntryType
//
// The known entity types that you can have returned from Trending.
type TrendingEntryType int32

const (
	TrendingEntryType_News            = TrendingEntryType(0)
	TrendingEntryType_DestinyItem     = TrendingEntryType(1)
	TrendingEntryType_DestinyActivity = TrendingEntryType(2)
	TrendingEntryType_DestinyRitual   = TrendingEntryType(3)
	TrendingEntryType_SupportArticle  = TrendingEntryType(4)
	TrendingEntryType_Creation        = TrendingEntryType(5)
	TrendingEntryType_Stream          = TrendingEntryType(6)
	TrendingEntryType_Update          = TrendingEntryType(7)
	TrendingEntryType_Link            = TrendingEntryType(8)
	TrendingEntryType_ForumTag        = TrendingEntryType(9)
	TrendingEntryType_Container       = TrendingEntryType(10)
	TrendingEntryType_Release         = TrendingEntryType(11)
)

// User.CrossSaveUserMembership
//
// Very basic info about a user as returned by the Account server, but including CrossSave information.
// Do NOT use as a request contract.
type CrossSaveUserMembership struct {
	// {
	//   "description": "Very basic info about a user as returned by the Account server, but including CrossSave information. Do NOT use as a request contract.",
	//   "properties": {
	//     "applicableMembershipTypes": {
	//       "description": "The list of Membership Types indicating the platforms on which this Membership can be used.\r\n Not in Cross Save = its original membership type. Cross Save Primary = Any membership types it is overridding, and its original membership type Cross Save Overridden = Empty list",
	//       "items": {
	//         "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/BungieMembershipType"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "bungieGlobalDisplayName": {
	//       "description": "The bungie global display name, if set.",
	//       "type": "string"
	//     },
	//     "bungieGlobalDisplayNameCode": {
	//       "description": "The bungie global display name code, if set.",
	//       "format": "int16",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "crossSaveOverride": {
	//       "description": "If there is a cross save override in effect, this value will tell you the type that is overridding this one.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "displayName": {
	//       "description": "Display Name the player has chosen for themselves. The display name is optional when the data type is used as input to a platform API.",
	//       "type": "string"
	//     },
	//     "isPublic": {
	//       "description": "If True, this is a public user membership.",
	//       "type": "boolean"
	//     },
	//     "membershipId": {
	//       "description": "Membership ID as they user is known in the Accounts service",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "description": "Type of the membership. Not necessarily the native type.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The list of Membership Types indicating the platforms on which this Membership can be used.
	//
	//	Not in Cross Save = its original membership type. Cross Save Primary = Any membership types it is
	//
	// overridding, and its original membership type Cross Save Overridden = Empty list
	ApplicableMembershipTypes []BungieMembershipType `json:"applicableMembershipTypes"`

	// The bungie global display name, if set.
	BungieGlobalDisplayName string `json:"bungieGlobalDisplayName"`

	// The bungie global display name code, if set.
	BungieGlobalDisplayNameCode Nullable[int16] `json:"bungieGlobalDisplayNameCode,omitempty"`

	// If there is a cross save override in effect, this value will tell you the type that is overridding
	// this one.
	CrossSaveOverride BungieMembershipType `json:"crossSaveOverride"`

	// Display Name the player has chosen for themselves. The display name is optional when the data type
	// is used as input to a platform API.
	DisplayName string `json:"displayName"`

	// If True, this is a public user membership.
	IsPublic bool `json:"isPublic"`

	// Membership ID as they user is known in the Accounts service
	MembershipID Int64 `json:"membershipId"`

	// Type of the membership. Not necessarily the native type.
	MembershipType BungieMembershipType `json:"membershipType"`
}

// User.EMailSettingLocalization
//
// Localized text relevant to a given EMail setting in a given localization.
type EMailSettingLocalization struct {
	// {
	//   "description": "Localized text relevant to a given EMail setting in a given localization.",
	//   "properties": {
	//     "description": {
	//       "type": "string"
	//     },
	//     "title": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Description string `json:"description"`

	Title string `json:"title"`
}

// User.EMailSettingSubscriptionLocalization
//
// Localized text relevant to a given EMail setting in a given localization. Extra settings
// specifically for subscriptions.
type EMailSettingSubscriptionLocalization struct {
	// {
	//   "description": "Localized text relevant to a given EMail setting in a given localization. Extra settings specifically for subscriptions.",
	//   "properties": {
	//     "description": {
	//       "type": "string"
	//     },
	//     "knownUserActionText": {
	//       "type": "string"
	//     },
	//     "registeredUserDescription": {
	//       "type": "string"
	//     },
	//     "title": {
	//       "type": "string"
	//     },
	//     "unknownUserActionText": {
	//       "type": "string"
	//     },
	//     "unknownUserDescription": {
	//       "type": "string"
	//     },
	//     "unregisteredUserDescription": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	Description string `json:"description"`

	KnownUserActionText string `json:"knownUserActionText"`

	RegisteredUserDescription string `json:"registeredUserDescription"`

	Title string `json:"title"`

	UnknownUserActionText string `json:"unknownUserActionText"`

	UnknownUserDescription string `json:"unknownUserDescription"`

	UnregisteredUserDescription string `json:"unregisteredUserDescription"`
}

// User.EmailOptInDefinition
//
// Defines a single opt-in category: a wide-scoped permission to send emails for the subject related to
// the opt-in.
type EmailOptInDefinition struct {
	// {
	//   "description": "Defines a single opt-in category: a wide-scoped permission to send emails for the subject related to the opt-in.",
	//   "properties": {
	//     "dependentSubscriptions": {
	//       "description": "Information about the dependent subscriptions for this opt-in.",
	//       "items": {
	//         "$ref": "#/components/schemas/User.EmailSubscriptionDefinition"
	//       },
	//       "type": "array"
	//     },
	//     "name": {
	//       "description": "The unique identifier for this opt-in category.",
	//       "type": "string"
	//     },
	//     "setByDefault": {
	//       "description": "If true, this opt-in setting should be set by default in situations where accounts are created without explicit choices about what they're opting into.",
	//       "type": "boolean"
	//     },
	//     "value": {
	//       "description": "The flag value for this opt-in category. For historical reasons, this is defined as a flags enum.",
	//       "format": "int64",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/User.OptInFlags"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// Information about the dependent subscriptions for this opt-in.
	DependentSubscriptions []EmailSubscriptionDefinition `json:"dependentSubscriptions"`

	// The unique identifier for this opt-in category.
	Name string `json:"name"`

	// If true, this opt-in setting should be set by default in situations where accounts are created
	// without explicit choices about what they're opting into.
	SetByDefault bool `json:"setByDefault"`

	// The flag value for this opt-in category. For historical reasons, this is defined as a flags enum.
	Value BitmaskSet[OptInFlags] `json:"value"`
}

// User.EmailSettings
//
// The set of all email subscription/opt-in settings and definitions.
type EmailSettings struct {
	// {
	//   "description": "The set of all email subscription/opt-in settings and definitions.",
	//   "properties": {
	//     "optInDefinitions": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/User.EmailOptInDefinition"
	//       },
	//       "description": "Keyed by the name identifier of the opt-in definition.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "subscriptionDefinitions": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/User.EmailSubscriptionDefinition"
	//       },
	//       "description": "Keyed by the name identifier of the Subscription definition.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "views": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/User.EmailViewDefinition"
	//       },
	//       "description": "Keyed by the name identifier of the View definition.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// Keyed by the name identifier of the opt-in definition.
	OptInDefinitions map[string]EmailOptInDefinition `json:"optInDefinitions"`

	// Keyed by the name identifier of the Subscription definition.
	SubscriptionDefinitions map[string]EmailSubscriptionDefinition `json:"subscriptionDefinitions"`

	// Keyed by the name identifier of the View definition.
	Views map[string]EmailViewDefinition `json:"views"`
}

// User.EmailSubscriptionDefinition
//
// Defines a single subscription: permission to send emails for a specific, focused subject (generally
// timeboxed, such as for a specific release of a product or feature).
type EmailSubscriptionDefinition struct {
	// {
	//   "description": "Defines a single subscription: permission to send emails for a specific, focused subject (generally timeboxed, such as for a specific release of a product or feature).",
	//   "properties": {
	//     "localization": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/User.EMailSettingSubscriptionLocalization"
	//       },
	//       "description": "A dictionary of localized text for the EMail Opt-in setting, keyed by the locale.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "name": {
	//       "description": "The unique identifier for this subscription.",
	//       "type": "string"
	//     },
	//     "value": {
	//       "description": "The bitflag value for this subscription. Should be a unique power of two value.",
	//       "format": "int64",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	// A dictionary of localized text for the EMail Opt-in setting, keyed by the locale.
	Localization map[string]EMailSettingSubscriptionLocalization `json:"localization"`

	// The unique identifier for this subscription.
	Name string `json:"name"`

	// The bitflag value for this subscription. Should be a unique power of two value.
	Value Int64 `json:"value"`
}

// User.EmailViewDefinition
//
// Represents a data-driven view for Email settings. Web/Mobile UI can use this data to show new EMail
// settings consistently without further manual work.
type EmailViewDefinition struct {
	// {
	//   "description": "Represents a data-driven view for Email settings. Web/Mobile UI can use this data to show new EMail settings consistently without further manual work.",
	//   "properties": {
	//     "name": {
	//       "description": "The identifier for this view.",
	//       "type": "string"
	//     },
	//     "viewSettings": {
	//       "description": "The ordered list of settings to show in this view.",
	//       "items": {
	//         "$ref": "#/components/schemas/User.EmailViewDefinitionSetting"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// The identifier for this view.
	Name string `json:"name"`

	// The ordered list of settings to show in this view.
	ViewSettings []EmailViewDefinitionSetting `json:"viewSettings"`
}

// User.EmailViewDefinitionSetting
type EmailViewDefinitionSetting struct {
	// {
	//   "properties": {
	//     "localization": {
	//       "additionalProperties": {
	//         "$ref": "#/components/schemas/User.EMailSettingLocalization"
	//       },
	//       "description": "A dictionary of localized text for the EMail setting, keyed by the locale.",
	//       "type": "object",
	//       "x-dictionary-key": {
	//         "type": "string"
	//       }
	//     },
	//     "name": {
	//       "description": "The identifier for this UI Setting, which can be used to relate it to custom strings or other data as desired.",
	//       "type": "string"
	//     },
	//     "optInAggregateValue": {
	//       "description": "The OptInFlags value to set or clear if this setting is set or cleared in the UI. It is the aggregate of all underlying opt-in flags related to this setting.",
	//       "format": "int64",
	//       "type": "integer",
	//       "x-enum-is-bitmask": true,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/User.OptInFlags"
	//       }
	//     },
	//     "setByDefault": {
	//       "description": "If true, this setting should be set by default if the user hasn't chosen whether it's set or cleared yet.",
	//       "type": "boolean"
	//     },
	//     "subscriptions": {
	//       "description": "The subscriptions to show as children of this setting, if any.",
	//       "items": {
	//         "$ref": "#/components/schemas/User.EmailSubscriptionDefinition"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	// A dictionary of localized text for the EMail setting, keyed by the locale.
	Localization map[string]EMailSettingLocalization `json:"localization"`

	// The identifier for this UI Setting, which can be used to relate it to custom strings or other data
	// as desired.
	Name string `json:"name"`

	// The OptInFlags value to set or clear if this setting is set or cleared in the UI. It is the
	// aggregate of all underlying opt-in flags related to this setting.
	OptInAggregateValue BitmaskSet[OptInFlags] `json:"optInAggregateValue"`

	// If true, this setting should be set by default if the user hasn't chosen whether it's set or cleared
	// yet.
	SetByDefault bool `json:"setByDefault"`

	// The subscriptions to show as children of this setting, if any.
	Subscriptions []EmailSubscriptionDefinition `json:"subscriptions"`
}

// User.ExactSearchRequest
type ExactSearchRequestBody struct {
	// {
	//   "properties": {
	//     "displayName": {
	//       "type": "string"
	//     },
	//     "displayNameCode": {
	//       "format": "int16",
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	DisplayName string `json:"displayName"`

	DisplayNameCode int16 `json:"displayNameCode"`
}

// User.GeneralUser
type GeneralUser struct {
	// {
	//   "properties": {
	//     "about": {
	//       "type": "string"
	//     },
	//     "blizzardDisplayName": {
	//       "type": "string"
	//     },
	//     "cachedBungieGlobalDisplayName": {
	//       "type": "string"
	//     },
	//     "cachedBungieGlobalDisplayNameCode": {
	//       "format": "int16",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "context": {
	//       "$ref": "#/components/schemas/User.UserToUserContext"
	//     },
	//     "displayName": {
	//       "type": "string"
	//     },
	//     "egsDisplayName": {
	//       "type": "string"
	//     },
	//     "fbDisplayName": {
	//       "type": "string"
	//     },
	//     "firstAccess": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "isDeleted": {
	//       "type": "boolean"
	//     },
	//     "lastBanReportId": {
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "lastUpdate": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "legacyPortalUID": {
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "locale": {
	//       "type": "string"
	//     },
	//     "localeInheritDefault": {
	//       "type": "boolean"
	//     },
	//     "membershipId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "normalizedName": {
	//       "type": "string"
	//     },
	//     "profileBanExpire": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "profilePicture": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "profilePicturePath": {
	//       "type": "string"
	//     },
	//     "profilePictureWidePath": {
	//       "type": "string"
	//     },
	//     "profileTheme": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "profileThemeName": {
	//       "type": "string"
	//     },
	//     "psnDisplayName": {
	//       "type": "string"
	//     },
	//     "showActivity": {
	//       "nullable": true,
	//       "type": "boolean"
	//     },
	//     "showGroupMessaging": {
	//       "type": "boolean"
	//     },
	//     "stadiaDisplayName": {
	//       "type": "string"
	//     },
	//     "statusDate": {
	//       "format": "date-time",
	//       "type": "string"
	//     },
	//     "statusText": {
	//       "type": "string"
	//     },
	//     "steamDisplayName": {
	//       "type": "string"
	//     },
	//     "successMessageFlags": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "twitchDisplayName": {
	//       "type": "string"
	//     },
	//     "uniqueName": {
	//       "type": "string"
	//     },
	//     "userTitle": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "userTitleDisplay": {
	//       "type": "string"
	//     },
	//     "xboxDisplayName": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	About string `json:"about"`

	BlizzardDisplayName string `json:"blizzardDisplayName"`

	CachedBungieGlobalDisplayName string `json:"cachedBungieGlobalDisplayName"`

	CachedBungieGlobalDisplayNameCode Nullable[int16] `json:"cachedBungieGlobalDisplayNameCode,omitempty"`

	Context UserToUserContext `json:"context"`

	DisplayName string `json:"displayName"`

	EgsDisplayName string `json:"egsDisplayName"`

	FbDisplayName string `json:"fbDisplayName"`

	FirstAccess Nullable[Timestamp] `json:"firstAccess,omitempty"`

	IsDeleted bool `json:"isDeleted"`

	LastBanReportID Nullable[Int64] `json:"lastBanReportId,omitempty"`

	LastUpdate Nullable[Timestamp] `json:"lastUpdate,omitempty"`

	LegacyPortalUID Nullable[Int64] `json:"legacyPortalUID,omitempty"`

	Locale string `json:"locale"`

	LocaleInheritDefault bool `json:"localeInheritDefault"`

	MembershipID Int64 `json:"membershipId"`

	NormalizedName string `json:"normalizedName"`

	ProfileBanExpire Nullable[Timestamp] `json:"profileBanExpire,omitempty"`

	ProfilePicture int32 `json:"profilePicture"`

	ProfilePicturePath string `json:"profilePicturePath"`

	ProfilePictureWidePath string `json:"profilePictureWidePath"`

	ProfileTheme int32 `json:"profileTheme"`

	ProfileThemeName string `json:"profileThemeName"`

	PsnDisplayName string `json:"psnDisplayName"`

	ShowActivity Nullable[bool] `json:"showActivity,omitempty"`

	ShowGroupMessaging bool `json:"showGroupMessaging"`

	StadiaDisplayName string `json:"stadiaDisplayName"`

	StatusDate Timestamp `json:"statusDate"`

	StatusText string `json:"statusText"`

	SteamDisplayName string `json:"steamDisplayName"`

	SuccessMessageFlags Int64 `json:"successMessageFlags"`

	TwitchDisplayName string `json:"twitchDisplayName"`

	UniqueName string `json:"uniqueName"`

	UserTitle int32 `json:"userTitle"`

	UserTitleDisplay string `json:"userTitleDisplay"`

	XboxDisplayName string `json:"xboxDisplayName"`
}

// User.HardLinkedUserMembership
type HardLinkedUserMembership struct {
	// {
	//   "properties": {
	//     "CrossSaveOverriddenMembershipId": {
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "CrossSaveOverriddenType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "membershipId": {
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	CrossSaveOverriddenMembershipID Nullable[Int64] `json:"CrossSaveOverriddenMembershipId,omitempty"`

	CrossSaveOverriddenType BungieMembershipType `json:"CrossSaveOverriddenType"`

	MembershipID Int64 `json:"membershipId"`

	MembershipType BungieMembershipType `json:"membershipType"`
}

// User.Models.GetCredentialTypesForAccountResponse
type GetCredentialTypesForAccountResponse struct {
	// {
	//   "properties": {
	//     "credentialAsString": {
	//       "type": "string"
	//     },
	//     "credentialDisplayName": {
	//       "type": "string"
	//     },
	//     "credentialType": {
	//       "format": "byte",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieCredentialType"
	//       }
	//     },
	//     "isPublic": {
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	CredentialAsString string `json:"credentialAsString"`

	CredentialDisplayName string `json:"credentialDisplayName"`

	CredentialType BungieCredentialType `json:"credentialType"`

	IsPublic bool `json:"isPublic"`
}

// User.OptInFlags
type OptInFlags Int64

const (
	OptInFlags_None            = OptInFlags(0)
	OptInFlags_Newsletter      = OptInFlags(1)
	OptInFlags_System          = OptInFlags(2)
	OptInFlags_Marketing       = OptInFlags(4)
	OptInFlags_UserResearch    = OptInFlags(8)
	OptInFlags_CustomerService = OptInFlags(16)
	OptInFlags_Social          = OptInFlags(32)
	OptInFlags_PlayTests       = OptInFlags(64)
	OptInFlags_PlayTestsLocal  = OptInFlags(128)
	OptInFlags_Careers         = OptInFlags(256)
)

// User.UserInfoCard
//
// This contract supplies basic information commonly used to display a minimal amount of information
// about a user. Take care to not add more properties here unless the property applies in all (or at
// least the majority) of the situations where UserInfoCard is used. Avoid adding game specific or
// platform specific details here. In cases where UserInfoCard is a subset of the data needed in a
// contract, use UserInfoCard as a property of other contracts.
type UserInfoCard struct {
	// {
	//   "description": "This contract supplies basic information commonly used to display a minimal amount of information about a user. Take care to not add more properties here unless the property applies in all (or at least the majority) of the situations where UserInfoCard is used. Avoid adding game specific or platform specific details here. In cases where UserInfoCard is a subset of the data needed in a contract, use UserInfoCard as a property of other contracts.",
	//   "properties": {
	//     "applicableMembershipTypes": {
	//       "description": "The list of Membership Types indicating the platforms on which this Membership can be used.\r\n Not in Cross Save = its original membership type. Cross Save Primary = Any membership types it is overridding, and its original membership type Cross Save Overridden = Empty list",
	//       "items": {
	//         "description": "The types of membership the Accounts system supports. This is the external facing enum used in place of the internal-only Bungie.SharedDefinitions.MembershipType.",
	//         "format": "int32",
	//         "type": "integer",
	//         "x-enum-is-bitmask": false,
	//         "x-enum-reference": {
	//           "$ref": "#/components/schemas/BungieMembershipType"
	//         }
	//       },
	//       "type": "array"
	//     },
	//     "bungieGlobalDisplayName": {
	//       "description": "The bungie global display name, if set.",
	//       "type": "string"
	//     },
	//     "bungieGlobalDisplayNameCode": {
	//       "description": "The bungie global display name code, if set.",
	//       "format": "int16",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "crossSaveOverride": {
	//       "description": "If there is a cross save override in effect, this value will tell you the type that is overridding this one.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "displayName": {
	//       "description": "Display Name the player has chosen for themselves. The display name is optional when the data type is used as input to a platform API.",
	//       "type": "string"
	//     },
	//     "iconPath": {
	//       "description": "URL the Icon if available.",
	//       "type": "string"
	//     },
	//     "isPublic": {
	//       "description": "If True, this is a public user membership.",
	//       "type": "boolean"
	//     },
	//     "membershipId": {
	//       "description": "Membership ID as they user is known in the Accounts service",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "description": "Type of the membership. Not necessarily the native type.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     },
	//     "supplementalDisplayName": {
	//       "description": "A platform specific additional display name - ex: psn Real Name, bnet Unique Name, etc.",
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	// The list of Membership Types indicating the platforms on which this Membership can be used.
	//
	//	Not in Cross Save = its original membership type. Cross Save Primary = Any membership types it is
	//
	// overridding, and its original membership type Cross Save Overridden = Empty list
	ApplicableMembershipTypes []BungieMembershipType `json:"applicableMembershipTypes"`

	// The bungie global display name, if set.
	BungieGlobalDisplayName string `json:"bungieGlobalDisplayName"`

	// The bungie global display name code, if set.
	BungieGlobalDisplayNameCode Nullable[int16] `json:"bungieGlobalDisplayNameCode,omitempty"`

	// If there is a cross save override in effect, this value will tell you the type that is overridding
	// this one.
	CrossSaveOverride BungieMembershipType `json:"crossSaveOverride"`

	// Display Name the player has chosen for themselves. The display name is optional when the data type
	// is used as input to a platform API.
	DisplayName string `json:"displayName"`

	// URL the Icon if available.
	IconPath string `json:"iconPath"`

	// If True, this is a public user membership.
	IsPublic bool `json:"isPublic"`

	// Membership ID as they user is known in the Accounts service
	MembershipID Int64 `json:"membershipId"`

	// Type of the membership. Not necessarily the native type.
	MembershipType BungieMembershipType `json:"membershipType"`

	// A platform specific additional display name - ex: psn Real Name, bnet Unique Name, etc.
	SupplementalDisplayName string `json:"supplementalDisplayName"`
}

// User.UserMembership
//
// Very basic info about a user as returned by the Account server.
type UserMembership struct {
	// {
	//   "description": "Very basic info about a user as returned by the Account server.",
	//   "properties": {
	//     "bungieGlobalDisplayName": {
	//       "description": "The bungie global display name, if set.",
	//       "type": "string"
	//     },
	//     "bungieGlobalDisplayNameCode": {
	//       "description": "The bungie global display name code, if set.",
	//       "format": "int16",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "displayName": {
	//       "description": "Display Name the player has chosen for themselves. The display name is optional when the data type is used as input to a platform API.",
	//       "type": "string"
	//     },
	//     "membershipId": {
	//       "description": "Membership ID as they user is known in the Accounts service",
	//       "format": "int64",
	//       "type": "integer"
	//     },
	//     "membershipType": {
	//       "description": "Type of the membership. Not necessarily the native type.",
	//       "format": "int32",
	//       "type": "integer",
	//       "x-enum-is-bitmask": false,
	//       "x-enum-reference": {
	//         "$ref": "#/components/schemas/BungieMembershipType"
	//       }
	//     }
	//   },
	//   "type": "object"
	// }

	// The bungie global display name, if set.
	BungieGlobalDisplayName string `json:"bungieGlobalDisplayName"`

	// The bungie global display name code, if set.
	BungieGlobalDisplayNameCode Nullable[int16] `json:"bungieGlobalDisplayNameCode,omitempty"`

	// Display Name the player has chosen for themselves. The display name is optional when the data type
	// is used as input to a platform API.
	DisplayName string `json:"displayName"`

	// Membership ID as they user is known in the Accounts service
	MembershipID Int64 `json:"membershipId"`

	// Type of the membership. Not necessarily the native type.
	MembershipType BungieMembershipType `json:"membershipType"`
}

// User.UserMembershipData
type UserMembershipData struct {
	// {
	//   "properties": {
	//     "bungieNetUser": {
	//       "$ref": "#/components/schemas/User.GeneralUser"
	//     },
	//     "destinyMemberships": {
	//       "description": "this allows you to see destiny memberships that are visible and linked to this account (regardless of whether or not they have characters on the world server)",
	//       "items": {
	//         "$ref": "#/components/schemas/GroupsV2.GroupUserInfoCard"
	//       },
	//       "type": "array"
	//     },
	//     "primaryMembershipId": {
	//       "description": "If this property is populated, it will have the membership ID of the account considered to be \"primary\" in this user's cross save relationship.\r\n If null, this user has no cross save relationship, nor primary account.",
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     }
	//   },
	//   "type": "object"
	// }

	BungieNetUser GeneralUser `json:"bungieNetUser"`

	// this allows you to see destiny memberships that are visible and linked to this account (regardless
	// of whether or not they have characters on the world server)
	DestinyMemberships []GroupUserInfoCard `json:"destinyMemberships"`

	// If this property is populated, it will have the membership ID of the account considered to be
	// "primary" in this user's cross save relationship.
	//
	//	If null, this user has no cross save relationship, nor primary account.
	PrimaryMembershipID Nullable[Int64] `json:"primaryMembershipId,omitempty"`
}

// User.UserSearchPrefixRequest
type UserSearchPrefixRequestBody struct {
	// {
	//   "properties": {
	//     "displayNamePrefix": {
	//       "type": "string"
	//     }
	//   },
	//   "type": "object"
	// }

	DisplayNamePrefix string `json:"displayNamePrefix"`
}

// User.UserSearchResponse
type UserSearchResponse struct {
	// {
	//   "properties": {
	//     "hasMore": {
	//       "type": "boolean"
	//     },
	//     "page": {
	//       "format": "int32",
	//       "type": "integer"
	//     },
	//     "searchResults": {
	//       "items": {
	//         "$ref": "#/components/schemas/User.UserSearchResponseDetail"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	HasMore bool `json:"hasMore"`

	Page int32 `json:"page"`

	SearchResults []UserSearchResponseDetail `json:"searchResults"`
}

// User.UserSearchResponseDetail
type UserSearchResponseDetail struct {
	// {
	//   "properties": {
	//     "bungieGlobalDisplayName": {
	//       "type": "string"
	//     },
	//     "bungieGlobalDisplayNameCode": {
	//       "format": "int16",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "bungieNetMembershipId": {
	//       "format": "int64",
	//       "nullable": true,
	//       "type": "integer"
	//     },
	//     "destinyMemberships": {
	//       "items": {
	//         "$ref": "#/components/schemas/User.UserInfoCard"
	//       },
	//       "type": "array"
	//     }
	//   },
	//   "type": "object"
	// }

	BungieGlobalDisplayName string `json:"bungieGlobalDisplayName"`

	BungieGlobalDisplayNameCode Nullable[int16] `json:"bungieGlobalDisplayNameCode,omitempty"`

	BungieNetMembershipID Nullable[Int64] `json:"bungieNetMembershipId,omitempty"`

	DestinyMemberships []UserInfoCard `json:"destinyMemberships"`
}

// User.UserToUserContext
type UserToUserContext struct {
	// {
	//   "properties": {
	//     "globalIgnoreEndDate": {
	//       "format": "date-time",
	//       "nullable": true,
	//       "type": "string"
	//     },
	//     "ignoreStatus": {
	//       "$ref": "#/components/schemas/Ignores.IgnoreResponse"
	//     },
	//     "isFollowing": {
	//       "type": "boolean"
	//     }
	//   },
	//   "type": "object"
	// }

	GlobalIgnoreEndDate Nullable[Timestamp] `json:"globalIgnoreEndDate,omitempty"`

	IgnoreStatus IgnoreResponse `json:"ignoreStatus"`

	IsFollowing bool `json:"isFollowing"`
}

func (e ApplicationScopes) Enum() string {
	switch e {
	case ApplicationScopes_ReadBasicUserProfile:
		return "ReadBasicUserProfile"
	case ApplicationScopes_ReadGroups:
		return "ReadGroups"
	case ApplicationScopes_WriteGroups:
		return "WriteGroups"
	case ApplicationScopes_AdminGroups:
		return "AdminGroups"
	case ApplicationScopes_BnetWrite:
		return "BnetWrite"
	case ApplicationScopes_MoveEquipDestinyItems:
		return "MoveEquipDestinyItems"
	case ApplicationScopes_ReadDestinyInventoryAndVault:
		return "ReadDestinyInventoryAndVault"
	case ApplicationScopes_ReadUserData:
		return "ReadUserData"
	case ApplicationScopes_EditUserData:
		return "EditUserData"
	case ApplicationScopes_ReadDestinyVendorsAndAdvisors:
		return "ReadDestinyVendorsAndAdvisors"
	case ApplicationScopes_ReadAndApplyTokens:
		return "ReadAndApplyTokens"
	case ApplicationScopes_AdvancedWriteActions:
		return "AdvancedWriteActions"
	case ApplicationScopes_PartnerOfferGrant:
		return "PartnerOfferGrant"
	case ApplicationScopes_DestinyUnlockValueQuery:
		return "DestinyUnlockValueQuery"
	case ApplicationScopes_UserPiiRead:
		return "UserPiiRead"
	}
	return fmt.Sprintf("ApplicationScopes_%d", e)
}

func (e ApplicationStatus) Enum() string {
	switch e {
	case ApplicationStatus_None:
		return "None"
	case ApplicationStatus_Private:
		return "Private"
	case ApplicationStatus_Public:
		return "Public"
	case ApplicationStatus_Disabled:
		return "Disabled"
	case ApplicationStatus_Blocked:
		return "Blocked"
	}
	return fmt.Sprintf("ApplicationStatus_%d", e)
}

func (e DeveloperRole) Enum() string {
	switch e {
	case DeveloperRole_None:
		return "None"
	case DeveloperRole_Owner:
		return "Owner"
	case DeveloperRole_TeamMember:
		return "TeamMember"
	}
	return fmt.Sprintf("DeveloperRole_%d", e)
}

func (e OAuthApplicationType) Enum() string {
	switch e {
	case OAuthApplicationType_None:
		return "None"
	case OAuthApplicationType_Confidential:
		return "Confidential"
	case OAuthApplicationType_Public:
		return "Public"
	}
	return fmt.Sprintf("OAuthApplicationType_%d", e)
}

func (e BungieCredentialType) Enum() string {
	switch e {
	case BungieCredentialType_None:
		return "None"
	case BungieCredentialType_Xuid:
		return "Xuid"
	case BungieCredentialType_Psnid:
		return "Psnid"
	case BungieCredentialType_Wlid:
		return "Wlid"
	case BungieCredentialType_Fake:
		return "Fake"
	case BungieCredentialType_Facebook:
		return "Facebook"
	case BungieCredentialType_Google:
		return "Google"
	case BungieCredentialType_Windows:
		return "Windows"
	case BungieCredentialType_DemonId:
		return "DemonId"
	case BungieCredentialType_SteamId:
		return "SteamId"
	case BungieCredentialType_BattleNetId:
		return "BattleNetId"
	case BungieCredentialType_StadiaId:
		return "StadiaId"
	case BungieCredentialType_TwitchId:
		return "TwitchId"
	case BungieCredentialType_EgsId:
		return "EgsId"
	}
	return fmt.Sprintf("BungieCredentialType_%d", e)
}

func (e BungieMembershipType) Enum() string {
	switch e {
	case BungieMembershipType_None:
		return "None"
	case BungieMembershipType_TigerXbox:
		return "TigerXbox"
	case BungieMembershipType_TigerPsn:
		return "TigerPsn"
	case BungieMembershipType_TigerSteam:
		return "TigerSteam"
	case BungieMembershipType_TigerBlizzard:
		return "TigerBlizzard"
	case BungieMembershipType_TigerStadia:
		return "TigerStadia"
	case BungieMembershipType_TigerEgs:
		return "TigerEgs"
	case BungieMembershipType_TigerDemon:
		return "TigerDemon"
	case BungieMembershipType_BungieNext:
		return "BungieNext"
	case BungieMembershipType_All:
		return "All"
	}
	return fmt.Sprintf("BungieMembershipType_%d", e)
}

func (e ComponentPrivacySetting) Enum() string {
	switch e {
	case ComponentPrivacySetting_None:
		return "None"
	case ComponentPrivacySetting_Public:
		return "Public"
	case ComponentPrivacySetting_Private:
		return "Private"
	}
	return fmt.Sprintf("ComponentPrivacySetting_%d", e)
}

func (e ContentPropertyDataType) Enum() string {
	switch e {
	case ContentPropertyDataType_None:
		return "None"
	case ContentPropertyDataType_Plaintext:
		return "Plaintext"
	case ContentPropertyDataType_Html:
		return "Html"
	case ContentPropertyDataType_Dropdown:
		return "Dropdown"
	case ContentPropertyDataType_List:
		return "List"
	case ContentPropertyDataType_Json:
		return "Json"
	case ContentPropertyDataType_Content:
		return "Content"
	case ContentPropertyDataType_Representation:
		return "Representation"
	case ContentPropertyDataType_Set:
		return "Set"
	case ContentPropertyDataType_File:
		return "File"
	case ContentPropertyDataType_FolderSet:
		return "FolderSet"
	case ContentPropertyDataType_Date:
		return "Date"
	case ContentPropertyDataType_MultilinePlaintext:
		return "MultilinePlaintext"
	case ContentPropertyDataType_DestinyContent:
		return "DestinyContent"
	case ContentPropertyDataType_Color:
		return "Color"
	}
	return fmt.Sprintf("ContentPropertyDataType_%d", e)
}

func (e ActivityGraphNodeHighlightType) Enum() string {
	switch e {
	case ActivityGraphNodeHighlightType_None:
		return "None"
	case ActivityGraphNodeHighlightType_Normal:
		return "Normal"
	case ActivityGraphNodeHighlightType_Hyper:
		return "Hyper"
	case ActivityGraphNodeHighlightType_Comet:
		return "Comet"
	case ActivityGraphNodeHighlightType_RiseOfIron:
		return "RiseOfIron"
	}
	return fmt.Sprintf("ActivityGraphNodeHighlightType_%d", e)
}

func (e AwaResponseReason) Enum() string {
	switch e {
	case AwaResponseReason_None:
		return "None"
	case AwaResponseReason_Answered:
		return "Answered"
	case AwaResponseReason_TimedOut:
		return "TimedOut"
	case AwaResponseReason_Replaced:
		return "Replaced"
	}
	return fmt.Sprintf("AwaResponseReason_%d", e)
}

func (e AwaType) Enum() string {
	switch e {
	case AwaType_None:
		return "None"
	case AwaType_InsertPlugs:
		return "InsertPlugs"
	}
	return fmt.Sprintf("AwaType_%d", e)
}

func (e AwaUserSelection) Enum() string {
	switch e {
	case AwaUserSelection_None:
		return "None"
	case AwaUserSelection_Rejected:
		return "Rejected"
	case AwaUserSelection_Approved:
		return "Approved"
	}
	return fmt.Sprintf("AwaUserSelection_%d", e)
}

func (e BucketCategory) Enum() string {
	switch e {
	case BucketCategory_Invisible:
		return "Invisible"
	case BucketCategory_Item:
		return "Item"
	case BucketCategory_Currency:
		return "Currency"
	case BucketCategory_Equippable:
		return "Equippable"
	case BucketCategory_Ignored:
		return "Ignored"
	}
	return fmt.Sprintf("BucketCategory_%d", e)
}

func (e BucketScope) Enum() string {
	switch e {
	case BucketScope_Character:
		return "Character"
	case BucketScope_Account:
		return "Account"
	}
	return fmt.Sprintf("BucketScope_%d", e)
}

func (e DamageType) Enum() string {
	switch e {
	case DamageType_None:
		return "None"
	case DamageType_Kinetic:
		return "Kinetic"
	case DamageType_Arc:
		return "Arc"
	case DamageType_Thermal:
		return "Thermal"
	case DamageType_Void:
		return "Void"
	case DamageType_Raid:
		return "Raid"
	case DamageType_Stasis:
		return "Stasis"
	case DamageType_Strand:
		return "Strand"
	}
	return fmt.Sprintf("DamageType_%d", e)
}
func (d ActivityInteractableDefinition) DefinitionTable() string {
	return "DestinyActivityInteractableDefinition"
}
func (d ActivityInteractableEntryDefinition) DefinitionTable() string {
	return "DestinyActivityInteractableEntryDefinition"
}
func (d ActivityModifierDefinition) DefinitionTable() string {
	return "DestinyActivityModifierDefinition"
}
func (d AnimationReference) DefinitionTable() string {
	return "DestinyAnimationReference"
}
func (d ArtifactDefinition) DefinitionTable() string {
	return "DestinyArtifactDefinition"
}
func (d ArtifactTierDefinition) DefinitionTable() string {
	return "DestinyArtifactTierDefinition"
}
func (d ArtifactTierItemDefinition) DefinitionTable() string {
	return "DestinyArtifactTierItemDefinition"
}
func (d BreakerTypeDefinition) DefinitionTable() string {
	return "DestinyBreakerTypeDefinition"
}
func (d ChecklistDefinition) DefinitionTable() string {
	return "DestinyChecklistDefinition"
}
func (d ChecklistEntryDefinition) DefinitionTable() string {
	return "DestinyChecklistEntryDefinition"
}
func (d CollectibleAcquisitionBlock) DefinitionTable() string {
	return "DestinyCollectibleAcquisitionBlock"
}
func (d CollectibleDefinition) DefinitionTable() string {
	return "DestinyCollectibleDefinition"
}
func (d CollectibleStateBlock) DefinitionTable() string {
	return "DestinyCollectibleStateBlock"
}
func (d DisplayPropertiesDefinition) DefinitionTable() string {
	return "DestinyDisplayPropertiesDefinition"
}
func (d IconSequenceDefinition) DefinitionTable() string {
	return "DestinyIconSequenceDefinition"
}
func (d PositionDefinition) DefinitionTable() string {
	return "DestinyPositionDefinition"
}
func (d ActivityChallengeDefinition) DefinitionTable() string {
	return "DestinyActivityChallengeDefinition"
}
func (d ActivityDefinition) DefinitionTable() string {
	return "DestinyActivityDefinition"
}
func (d ActivityGraphListEntryDefinition) DefinitionTable() string {
	return "DestinyActivityGraphListEntryDefinition"
}
func (d ActivityGuidedBlockDefinition) DefinitionTable() string {
	return "DestinyActivityGuidedBlockDefinition"
}
func (d ActivityInsertionPointDefinition) DefinitionTable() string {
	return "DestinyActivityInsertionPointDefinition"
}
func (d ActivityLoadoutRequirement) DefinitionTable() string {
	return "DestinyActivityLoadoutRequirement"
}
func (d ActivityLoadoutRequirementSet) DefinitionTable() string {
	return "DestinyActivityLoadoutRequirementSet"
}
func (d ActivityMatchmakingBlockDefinition) DefinitionTable() string {
	return "DestinyActivityMatchmakingBlockDefinition"
}
func (d ActivityModeDefinition) DefinitionTable() string {
	return "DestinyActivityModeDefinition"
}
func (d ActivityModifierReferenceDefinition) DefinitionTable() string {
	return "DestinyActivityModifierReferenceDefinition"
}
func (d ActivityPlaylistItemDefinition) DefinitionTable() string {
	return "DestinyActivityPlaylistItemDefinition"
}
func (d ActivityRequirementLabel) DefinitionTable() string {
	return "DestinyActivityRequirementLabel"
}
func (d ActivityRequirementsBlock) DefinitionTable() string {
	return "DestinyActivityRequirementsBlock"
}
func (d ActivityRewardDefinition) DefinitionTable() string {
	return "DestinyActivityRewardDefinition"
}
func (d ActivityTypeDefinition) DefinitionTable() string {
	return "DestinyActivityTypeDefinition"
}
func (d ActivityUnlockStringDefinition) DefinitionTable() string {
	return "DestinyActivityUnlockStringDefinition"
}
func (d ArrangementRegionFilterDefinition) DefinitionTable() string {
	return "DestinyArrangementRegionFilterDefinition"
}
func (d ArtDyeReference) DefinitionTable() string {
	return "DestinyArtDyeReference"
}
func (d BubbleDefinition) DefinitionTable() string {
	return "DestinyBubbleDefinition"
}
func (d ClassDefinition) DefinitionTable() string {
	return "DestinyClassDefinition"
}
func (d DamageTypeDefinition) DefinitionTable() string {
	return "DestinyDamageTypeDefinition"
}
func (d Definition) DefinitionTable() string {
	return "DestinyDefinition"
}
func (d DestinationBubbleSettingDefinition) DefinitionTable() string {
	return "DestinyDestinationBubbleSettingDefinition"
}
func (d DestinationDefinition) DefinitionTable() string {
	return "DestinyDestinationDefinition"
}
func (d DisplayCategoryDefinition) DefinitionTable() string {
	return "DestinyDisplayCategoryDefinition"
}
func (d EntitySearchResult) DefinitionTable() string {
	return "DestinyEntitySearchResult"
}
func (d EntitySearchResultItem) DefinitionTable() string {
	return "DestinyEntitySearchResultItem"
}
func (d EquipmentSlotDefinition) DefinitionTable() string {
	return "DestinyEquipmentSlotDefinition"
}
func (d EquippingBlockDefinition) DefinitionTable() string {
	return "DestinyEquippingBlockDefinition"
}
func (d FactionDefinition) DefinitionTable() string {
	return "DestinyFactionDefinition"
}
func (d FactionVendorDefinition) DefinitionTable() string {
	return "DestinyFactionVendorDefinition"
}
func (d GearArtArrangementReference) DefinitionTable() string {
	return "DestinyGearArtArrangementReference"
}
func (d GenderDefinition) DefinitionTable() string {
	return "DestinyGenderDefinition"
}
func (d InventoryBucketDefinition) DefinitionTable() string {
	return "DestinyInventoryBucketDefinition"
}
func (d InventoryItemDefinition) DefinitionTable() string {
	return "DestinyInventoryItemDefinition"
}
func (d InventoryItemStatDefinition) DefinitionTable() string {
	return "DestinyInventoryItemStatDefinition"
}
func (d ItemActionBlockDefinition) DefinitionTable() string {
	return "DestinyItemActionBlockDefinition"
}
func (d ItemActionRequiredItemDefinition) DefinitionTable() string {
	return "DestinyItemActionRequiredItemDefinition"
}
func (d ItemCategoryDefinition) DefinitionTable() string {
	return "DestinyItemCategoryDefinition"
}
func (d ItemCraftingBlockBonusPlugDefinition) DefinitionTable() string {
	return "DestinyItemCraftingBlockBonusPlugDefinition"
}
func (d ItemCraftingBlockDefinition) DefinitionTable() string {
	return "DestinyItemCraftingBlockDefinition"
}
func (d ItemCreationEntryLevelDefinition) DefinitionTable() string {
	return "DestinyItemCreationEntryLevelDefinition"
}
func (d ItemGearsetBlockDefinition) DefinitionTable() string {
	return "DestinyItemGearsetBlockDefinition"
}
func (d ItemIntrinsicSocketEntryDefinition) DefinitionTable() string {
	return "DestinyItemIntrinsicSocketEntryDefinition"
}
func (d ItemInventoryBlockDefinition) DefinitionTable() string {
	return "DestinyItemInventoryBlockDefinition"
}
func (d ItemInvestmentStatDefinition) DefinitionTable() string {
	return "DestinyItemInvestmentStatDefinition"
}
func (d ItemMetricBlockDefinition) DefinitionTable() string {
	return "DestinyItemMetricBlockDefinition"
}
func (d ItemObjectiveBlockDefinition) DefinitionTable() string {
	return "DestinyItemObjectiveBlockDefinition"
}
func (d ItemPerkEntryDefinition) DefinitionTable() string {
	return "DestinyItemPerkEntryDefinition"
}
func (d ItemPreviewBlockDefinition) DefinitionTable() string {
	return "DestinyItemPreviewBlockDefinition"
}
func (d ItemQualityBlockDefinition) DefinitionTable() string {
	return "DestinyItemQualityBlockDefinition"
}
func (d ItemSackBlockDefinition) DefinitionTable() string {
	return "DestinyItemSackBlockDefinition"
}
func (d ItemSetBlockDefinition) DefinitionTable() string {
	return "DestinyItemSetBlockDefinition"
}
func (d ItemSetBlockEntryDefinition) DefinitionTable() string {
	return "DestinyItemSetBlockEntryDefinition"
}
func (d ItemSocketBlockDefinition) DefinitionTable() string {
	return "DestinyItemSocketBlockDefinition"
}
func (d ItemSocketCategoryDefinition) DefinitionTable() string {
	return "DestinyItemSocketCategoryDefinition"
}
func (d ItemSocketEntryDefinition) DefinitionTable() string {
	return "DestinyItemSocketEntryDefinition"
}
func (d ItemSocketEntryPlugItemDefinition) DefinitionTable() string {
	return "DestinyItemSocketEntryPlugItemDefinition"
}
func (d ItemSocketEntryPlugItemRandomizedDefinition) DefinitionTable() string {
	return "DestinyItemSocketEntryPlugItemRandomizedDefinition"
}
func (d ItemSourceBlockDefinition) DefinitionTable() string {
	return "DestinyItemSourceBlockDefinition"
}
func (d ItemStatBlockDefinition) DefinitionTable() string {
	return "DestinyItemStatBlockDefinition"
}
func (d ItemSummaryBlockDefinition) DefinitionTable() string {
	return "DestinyItemSummaryBlockDefinition"
}
func (d ItemTalentGridBlockDefinition) DefinitionTable() string {
	return "DestinyItemTalentGridBlockDefinition"
}
func (d ItemTooltipNotification) DefinitionTable() string {
	return "DestinyItemTooltipNotification"
}
func (d ItemTranslationBlockDefinition) DefinitionTable() string {
	return "DestinyItemTranslationBlockDefinition"
}
func (d ItemValueBlockDefinition) DefinitionTable() string {
	return "DestinyItemValueBlockDefinition"
}
func (d ItemVendorSourceReference) DefinitionTable() string {
	return "DestinyItemVendorSourceReference"
}
func (d ItemVersionDefinition) DefinitionTable() string {
	return "DestinyItemVersionDefinition"
}
func (d LocationDefinition) DefinitionTable() string {
	return "DestinyLocationDefinition"
}
func (d LocationReleaseDefinition) DefinitionTable() string {
	return "DestinyLocationReleaseDefinition"
}
func (d MaterialRequirement) DefinitionTable() string {
	return "DestinyMaterialRequirement"
}
func (d MaterialRequirementSetDefinition) DefinitionTable() string {
	return "DestinyMaterialRequirementSetDefinition"
}
func (d MedalTierDefinition) DefinitionTable() string {
	return "DestinyMedalTierDefinition"
}
func (d NodeActivationRequirement) DefinitionTable() string {
	return "DestinyNodeActivationRequirement"
}
func (d NodeSocketReplaceResponse) DefinitionTable() string {
	return "DestinyNodeSocketReplaceResponse"
}
func (d NodeStepDefinition) DefinitionTable() string {
	return "DestinyNodeStepDefinition"
}
func (d ObjectiveDefinition) DefinitionTable() string {
	return "DestinyObjectiveDefinition"
}
func (d ObjectiveDisplayProperties) DefinitionTable() string {
	return "DestinyObjectiveDisplayProperties"
}
func (d ObjectivePerkEntryDefinition) DefinitionTable() string {
	return "DestinyObjectivePerkEntryDefinition"
}
func (d ObjectiveStatEntryDefinition) DefinitionTable() string {
	return "DestinyObjectiveStatEntryDefinition"
}
func (d PlaceDefinition) DefinitionTable() string {
	return "DestinyPlaceDefinition"
}
func (d PlugItemCraftingRequirements) DefinitionTable() string {
	return "DestinyPlugItemCraftingRequirements"
}
func (d PlugItemCraftingUnlockRequirement) DefinitionTable() string {
	return "DestinyPlugItemCraftingUnlockRequirement"
}
func (d ProgressionDefinition) DefinitionTable() string {
	return "DestinyProgressionDefinition"
}
func (d ProgressionDisplayPropertiesDefinition) DefinitionTable() string {
	return "DestinyProgressionDisplayPropertiesDefinition"
}
func (d ProgressionMappingDefinition) DefinitionTable() string {
	return "DestinyProgressionMappingDefinition"
}
func (d ProgressionRewardDefinition) DefinitionTable() string {
	return "DestinyProgressionRewardDefinition"
}
func (d ProgressionRewardItemQuantity) DefinitionTable() string {
	return "DestinyProgressionRewardItemQuantity"
}
func (d ProgressionSocketPlugOverride) DefinitionTable() string {
	return "DestinyProgressionSocketPlugOverride"
}
func (d ProgressionStepDefinition) DefinitionTable() string {
	return "DestinyProgressionStepDefinition"
}
func (d RaceDefinition) DefinitionTable() string {
	return "DestinyRaceDefinition"
}

func (e RewardSourceCategory) Enum() string {
	switch e {
	case RewardSourceCategory_None:
		return "None"
	case RewardSourceCategory_Activity:
		return "Activity"
	case RewardSourceCategory_Vendor:
		return "Vendor"
	case RewardSourceCategory_Aggregate:
		return "Aggregate"
	}
	return fmt.Sprintf("RewardSourceCategory_%d", e)
}
func (d RewardSourceDefinition) DefinitionTable() string {
	return "DestinyRewardSourceDefinition"
}
func (d SandboxPatternDefinition) DefinitionTable() string {
	return "DestinySandboxPatternDefinition"
}
func (d SandboxPerkDefinition) DefinitionTable() string {
	return "DestinySandboxPerkDefinition"
}
func (d StatDefinition) DefinitionTable() string {
	return "DestinyStatDefinition"
}
func (d StatDisplayDefinition) DefinitionTable() string {
	return "DestinyStatDisplayDefinition"
}
func (d StatGroupDefinition) DefinitionTable() string {
	return "DestinyStatGroupDefinition"
}
func (d StatOverrideDefinition) DefinitionTable() string {
	return "DestinyStatOverrideDefinition"
}
func (d TalentExclusiveGroup) DefinitionTable() string {
	return "DestinyTalentExclusiveGroup"
}
func (d TalentGridDefinition) DefinitionTable() string {
	return "DestinyTalentGridDefinition"
}
func (d TalentNodeCategory) DefinitionTable() string {
	return "DestinyTalentNodeCategory"
}
func (d TalentNodeDefinition) DefinitionTable() string {
	return "DestinyTalentNodeDefinition"
}
func (d TalentNodeExclusiveSetDefinition) DefinitionTable() string {
	return "DestinyTalentNodeExclusiveSetDefinition"
}

func (e TalentNodeStepDamageTypes) Enum() string {
	switch e {
	case TalentNodeStepDamageTypes_None:
		return "None"
	case TalentNodeStepDamageTypes_Kinetic:
		return "Kinetic"
	case TalentNodeStepDamageTypes_Arc:
		return "Arc"
	case TalentNodeStepDamageTypes_Solar:
		return "Solar"
	case TalentNodeStepDamageTypes_Void:
		return "Void"
	case TalentNodeStepDamageTypes_All:
		return "All"
	}
	return fmt.Sprintf("TalentNodeStepDamageTypes_%d", e)
}
func (d TalentNodeStepGroups) DefinitionTable() string {
	return "DestinyTalentNodeStepGroups"
}

func (e TalentNodeStepGuardianAttributes) Enum() string {
	switch e {
	case TalentNodeStepGuardianAttributes_None:
		return "None"
	case TalentNodeStepGuardianAttributes_Stats:
		return "Stats"
	case TalentNodeStepGuardianAttributes_Shields:
		return "Shields"
	case TalentNodeStepGuardianAttributes_Health:
		return "Health"
	case TalentNodeStepGuardianAttributes_Revive:
		return "Revive"
	case TalentNodeStepGuardianAttributes_AimUnderFire:
		return "AimUnderFire"
	case TalentNodeStepGuardianAttributes_Radar:
		return "Radar"
	case TalentNodeStepGuardianAttributes_Invisibility:
		return "Invisibility"
	case TalentNodeStepGuardianAttributes_Reputations:
		return "Reputations"
	case TalentNodeStepGuardianAttributes_All:
		return "All"
	}
	return fmt.Sprintf("TalentNodeStepGuardianAttributes_%d", e)
}

func (e TalentNodeStepImpactEffects) Enum() string {
	switch e {
	case TalentNodeStepImpactEffects_None:
		return "None"
	case TalentNodeStepImpactEffects_ArmorPiercing:
		return "ArmorPiercing"
	case TalentNodeStepImpactEffects_Ricochet:
		return "Ricochet"
	case TalentNodeStepImpactEffects_Flinch:
		return "Flinch"
	case TalentNodeStepImpactEffects_CollateralDamage:
		return "CollateralDamage"
	case TalentNodeStepImpactEffects_Disorient:
		return "Disorient"
	case TalentNodeStepImpactEffects_HighlightTarget:
		return "HighlightTarget"
	case TalentNodeStepImpactEffects_All:
		return "All"
	}
	return fmt.Sprintf("TalentNodeStepImpactEffects_%d", e)
}

func (e TalentNodeStepLightAbilities) Enum() string {
	switch e {
	case TalentNodeStepLightAbilities_None:
		return "None"
	case TalentNodeStepLightAbilities_Grenades:
		return "Grenades"
	case TalentNodeStepLightAbilities_Melee:
		return "Melee"
	case TalentNodeStepLightAbilities_MovementModes:
		return "MovementModes"
	case TalentNodeStepLightAbilities_Orbs:
		return "Orbs"
	case TalentNodeStepLightAbilities_SuperEnergy:
		return "SuperEnergy"
	case TalentNodeStepLightAbilities_SuperMods:
		return "SuperMods"
	case TalentNodeStepLightAbilities_All:
		return "All"
	}
	return fmt.Sprintf("TalentNodeStepLightAbilities_%d", e)
}

func (e TalentNodeStepWeaponPerformances) Enum() string {
	switch e {
	case TalentNodeStepWeaponPerformances_None:
		return "None"
	case TalentNodeStepWeaponPerformances_RateOfFire:
		return "RateOfFire"
	case TalentNodeStepWeaponPerformances_Damage:
		return "Damage"
	case TalentNodeStepWeaponPerformances_Accuracy:
		return "Accuracy"
	case TalentNodeStepWeaponPerformances_Range:
		return "Range"
	case TalentNodeStepWeaponPerformances_Zoom:
		return "Zoom"
	case TalentNodeStepWeaponPerformances_Recoil:
		return "Recoil"
	case TalentNodeStepWeaponPerformances_Ready:
		return "Ready"
	case TalentNodeStepWeaponPerformances_Reload:
		return "Reload"
	case TalentNodeStepWeaponPerformances_HairTrigger:
		return "HairTrigger"
	case TalentNodeStepWeaponPerformances_AmmoAndMagazine:
		return "AmmoAndMagazine"
	case TalentNodeStepWeaponPerformances_TrackingAndDetonation:
		return "TrackingAndDetonation"
	case TalentNodeStepWeaponPerformances_ShotgunSpread:
		return "ShotgunSpread"
	case TalentNodeStepWeaponPerformances_ChargeTime:
		return "ChargeTime"
	case TalentNodeStepWeaponPerformances_All:
		return "All"
	}
	return fmt.Sprintf("TalentNodeStepWeaponPerformances_%d", e)
}
func (d UnlockDefinition) DefinitionTable() string {
	return "DestinyUnlockDefinition"
}
func (d UnlockExpressionDefinition) DefinitionTable() string {
	return "DestinyUnlockExpressionDefinition"
}
func (d UnlockValueDefinition) DefinitionTable() string {
	return "DestinyUnlockValueDefinition"
}
func (d VendorAcceptedItemDefinition) DefinitionTable() string {
	return "DestinyVendorAcceptedItemDefinition"
}
func (d VendorActionDefinition) DefinitionTable() string {
	return "DestinyVendorActionDefinition"
}
func (d VendorCategoryEntryDefinition) DefinitionTable() string {
	return "DestinyVendorCategoryEntryDefinition"
}
func (d VendorCategoryOverlayDefinition) DefinitionTable() string {
	return "DestinyVendorCategoryOverlayDefinition"
}
func (d VendorDefinition) DefinitionTable() string {
	return "DestinyVendorDefinition"
}
func (d VendorDisplayPropertiesDefinition) DefinitionTable() string {
	return "DestinyVendorDisplayPropertiesDefinition"
}
func (d VendorGroupDefinition) DefinitionTable() string {
	return "DestinyVendorGroupDefinition"
}
func (d VendorGroupReference) DefinitionTable() string {
	return "DestinyVendorGroupReference"
}
func (d VendorInteractionDefinition) DefinitionTable() string {
	return "DestinyVendorInteractionDefinition"
}
func (d VendorInteractionReplyDefinition) DefinitionTable() string {
	return "DestinyVendorInteractionReplyDefinition"
}
func (d VendorInteractionSackEntryDefinition) DefinitionTable() string {
	return "DestinyVendorInteractionSackEntryDefinition"
}
func (d VendorInventoryFlyoutBucketDefinition) DefinitionTable() string {
	return "DestinyVendorInventoryFlyoutBucketDefinition"
}
func (d VendorInventoryFlyoutDefinition) DefinitionTable() string {
	return "DestinyVendorInventoryFlyoutDefinition"
}
func (d VendorItemDefinition) DefinitionTable() string {
	return "DestinyVendorItemDefinition"
}
func (d VendorItemQuantity) DefinitionTable() string {
	return "DestinyVendorItemQuantity"
}
func (d VendorItemSocketOverride) DefinitionTable() string {
	return "DestinyVendorItemSocketOverride"
}
func (d VendorRequirementDisplayEntryDefinition) DefinitionTable() string {
	return "DestinyVendorRequirementDisplayEntryDefinition"
}
func (d VendorSaleItemActionBlockDefinition) DefinitionTable() string {
	return "DestinyVendorSaleItemActionBlockDefinition"
}
func (d VendorServiceDefinition) DefinitionTable() string {
	return "DestinyVendorServiceDefinition"
}
func (d ActivityGraphArtElementDefinition) DefinitionTable() string {
	return "DestinyActivityGraphArtElementDefinition"
}
func (d ActivityGraphConnectionDefinition) DefinitionTable() string {
	return "DestinyActivityGraphConnectionDefinition"
}
func (d ActivityGraphDefinition) DefinitionTable() string {
	return "DestinyActivityGraphDefinition"
}
func (d ActivityGraphDisplayObjectiveDefinition) DefinitionTable() string {
	return "DestinyActivityGraphDisplayObjectiveDefinition"
}
func (d ActivityGraphDisplayProgressionDefinition) DefinitionTable() string {
	return "DestinyActivityGraphDisplayProgressionDefinition"
}
func (d ActivityGraphNodeActivityDefinition) DefinitionTable() string {
	return "DestinyActivityGraphNodeActivityDefinition"
}
func (d ActivityGraphNodeDefinition) DefinitionTable() string {
	return "DestinyActivityGraphNodeDefinition"
}
func (d ActivityGraphNodeFeaturingStateDefinition) DefinitionTable() string {
	return "DestinyActivityGraphNodeFeaturingStateDefinition"
}
func (d ActivityGraphNodeStateEntry) DefinitionTable() string {
	return "DestinyActivityGraphNodeStateEntry"
}
func (d LinkedGraphDefinition) DefinitionTable() string {
	return "DestinyLinkedGraphDefinition"
}
func (d LinkedGraphEntryDefinition) DefinitionTable() string {
	return "DestinyLinkedGraphEntryDefinition"
}
func (d EnergyTypeDefinition) DefinitionTable() string {
	return "DestinyEnergyTypeDefinition"
}
func (d ActivityGraphReference) DefinitionTable() string {
	return "DestinyActivityGraphReference"
}
func (d ActivityInteractableReference) DefinitionTable() string {
	return "DestinyActivityInteractableReference"
}
func (d FireteamFinderActivityGraphDefinition) DefinitionTable() string {
	return "DestinyFireteamFinderActivityGraphDefinition"
}
func (d FireteamFinderActivitySetDefinition) DefinitionTable() string {
	return "DestinyFireteamFinderActivitySetDefinition"
}
func (d FireteamFinderConstantsDefinition) DefinitionTable() string {
	return "DestinyFireteamFinderConstantsDefinition"
}
func (d FireteamFinderLabelDefinition) DefinitionTable() string {
	return "DestinyFireteamFinderLabelDefinition"
}
func (d FireteamFinderLabelGroupDefinition) DefinitionTable() string {
	return "DestinyFireteamFinderLabelGroupDefinition"
}
func (d FireteamFinderOptionCreatorSettings) DefinitionTable() string {
	return "DestinyFireteamFinderOptionCreatorSettings"
}
func (d FireteamFinderOptionDefinition) DefinitionTable() string {
	return "DestinyFireteamFinderOptionDefinition"
}
func (d FireteamFinderOptionGroupDefinition) DefinitionTable() string {
	return "DestinyFireteamFinderOptionGroupDefinition"
}
func (d FireteamFinderOptionSearcherSettings) DefinitionTable() string {
	return "DestinyFireteamFinderOptionSearcherSettings"
}
func (d FireteamFinderOptionSettingsControl) DefinitionTable() string {
	return "DestinyFireteamFinderOptionSettingsControl"
}
func (d FireteamFinderOptionValueDefinition) DefinitionTable() string {
	return "DestinyFireteamFinderOptionValueDefinition"
}
func (d FireteamFinderOptionValues) DefinitionTable() string {
	return "DestinyFireteamFinderOptionValues"
}
func (d GuardianRankConstantsDefinition) DefinitionTable() string {
	return "DestinyGuardianRankConstantsDefinition"
}
func (d GuardianRankDefinition) DefinitionTable() string {
	return "DestinyGuardianRankDefinition"
}
func (d GuardianRankIconBackgroundsDefinition) DefinitionTable() string {
	return "DestinyGuardianRankIconBackgroundsDefinition"
}
func (d DerivedItemCategoryDefinition) DefinitionTable() string {
	return "DestinyDerivedItemCategoryDefinition"
}
func (d DerivedItemDefinition) DefinitionTable() string {
	return "DestinyDerivedItemDefinition"
}
func (d EnergyCapacityEntry) DefinitionTable() string {
	return "DestinyEnergyCapacityEntry"
}
func (d EnergyCostEntry) DefinitionTable() string {
	return "DestinyEnergyCostEntry"
}
func (d ItemPlugDefinition) DefinitionTable() string {
	return "DestinyItemPlugDefinition"
}
func (d ItemTierTypeDefinition) DefinitionTable() string {
	return "DestinyItemTierTypeDefinition"
}
func (d ItemTierTypeInfusionBlock) DefinitionTable() string {
	return "DestinyItemTierTypeInfusionBlock"
}
func (d ParentItemOverride) DefinitionTable() string {
	return "DestinyParentItemOverride"
}
func (d PlugRuleDefinition) DefinitionTable() string {
	return "DestinyPlugRuleDefinition"
}
func (d LoadoutColorDefinition) DefinitionTable() string {
	return "DestinyLoadoutColorDefinition"
}
func (d LoadoutConstantsDefinition) DefinitionTable() string {
	return "DestinyLoadoutConstantsDefinition"
}
func (d LoadoutIconDefinition) DefinitionTable() string {
	return "DestinyLoadoutIconDefinition"
}
func (d LoadoutNameDefinition) DefinitionTable() string {
	return "DestinyLoadoutNameDefinition"
}
func (d LoreDefinition) DefinitionTable() string {
	return "DestinyLoreDefinition"
}
func (d MetricDefinition) DefinitionTable() string {
	return "DestinyMetricDefinition"
}
func (d MilestoneActivityDefinition) DefinitionTable() string {
	return "DestinyMilestoneActivityDefinition"
}
func (d MilestoneActivityVariantDefinition) DefinitionTable() string {
	return "DestinyMilestoneActivityVariantDefinition"
}
func (d MilestoneChallengeActivityDefinition) DefinitionTable() string {
	return "DestinyMilestoneChallengeActivityDefinition"
}
func (d MilestoneChallengeActivityGraphNodeEntry) DefinitionTable() string {
	return "DestinyMilestoneChallengeActivityGraphNodeEntry"
}
func (d MilestoneChallengeActivityPhase) DefinitionTable() string {
	return "DestinyMilestoneChallengeActivityPhase"
}
func (d MilestoneChallengeDefinition) DefinitionTable() string {
	return "DestinyMilestoneChallengeDefinition"
}
func (d MilestoneDefinition) DefinitionTable() string {
	return "DestinyMilestoneDefinition"
}

func (e MilestoneDisplayPreference) Enum() string {
	switch e {
	case MilestoneDisplayPreference_MilestoneDefinition:
		return "MilestoneDefinition"
	case MilestoneDisplayPreference_CurrentQuestSteps:
		return "CurrentQuestSteps"
	case MilestoneDisplayPreference_CurrentActivityChallenges:
		return "CurrentActivityChallenges"
	}
	return fmt.Sprintf("MilestoneDisplayPreference_%d", e)
}
func (d MilestoneQuestDefinition) DefinitionTable() string {
	return "DestinyMilestoneQuestDefinition"
}
func (d MilestoneQuestRewardItem) DefinitionTable() string {
	return "DestinyMilestoneQuestRewardItem"
}
func (d MilestoneQuestRewardsDefinition) DefinitionTable() string {
	return "DestinyMilestoneQuestRewardsDefinition"
}
func (d MilestoneRewardCategoryDefinition) DefinitionTable() string {
	return "DestinyMilestoneRewardCategoryDefinition"
}
func (d MilestoneRewardEntryDefinition) DefinitionTable() string {
	return "DestinyMilestoneRewardEntryDefinition"
}

func (e MilestoneType) Enum() string {
	switch e {
	case MilestoneType_Unknown:
		return "Unknown"
	case MilestoneType_Tutorial:
		return "Tutorial"
	case MilestoneType_OneTime:
		return "OneTime"
	case MilestoneType_Weekly:
		return "Weekly"
	case MilestoneType_Daily:
		return "Daily"
	case MilestoneType_Special:
		return "Special"
	}
	return fmt.Sprintf("MilestoneType_%d", e)
}
func (d MilestoneValueDefinition) DefinitionTable() string {
	return "DestinyMilestoneValueDefinition"
}
func (d MilestoneVendorDefinition) DefinitionTable() string {
	return "DestinyMilestoneVendorDefinition"
}
func (d PowerCapDefinition) DefinitionTable() string {
	return "DestinyPowerCapDefinition"
}
func (d PresentationChildBlock) DefinitionTable() string {
	return "DestinyPresentationChildBlock"
}
func (d PresentationNodeBaseDefinition) DefinitionTable() string {
	return "DestinyPresentationNodeBaseDefinition"
}
func (d PresentationNodeChildEntry) DefinitionTable() string {
	return "DestinyPresentationNodeChildEntry"
}
func (d PresentationNodeChildEntryBase) DefinitionTable() string {
	return "DestinyPresentationNodeChildEntryBase"
}
func (d PresentationNodeChildrenBlock) DefinitionTable() string {
	return "DestinyPresentationNodeChildrenBlock"
}
func (d PresentationNodeCollectibleChildEntry) DefinitionTable() string {
	return "DestinyPresentationNodeCollectibleChildEntry"
}
func (d PresentationNodeCraftableChildEntry) DefinitionTable() string {
	return "DestinyPresentationNodeCraftableChildEntry"
}
func (d PresentationNodeDefinition) DefinitionTable() string {
	return "DestinyPresentationNodeDefinition"
}
func (d PresentationNodeMetricChildEntry) DefinitionTable() string {
	return "DestinyPresentationNodeMetricChildEntry"
}
func (d PresentationNodeRecordChildEntry) DefinitionTable() string {
	return "DestinyPresentationNodeRecordChildEntry"
}
func (d PresentationNodeRequirementsBlock) DefinitionTable() string {
	return "DestinyPresentationNodeRequirementsBlock"
}
func (d ScoredPresentationNodeBaseDefinition) DefinitionTable() string {
	return "DestinyScoredPresentationNodeBaseDefinition"
}
func (d ProgressionLevelRequirementDefinition) DefinitionTable() string {
	return "DestinyProgressionLevelRequirementDefinition"
}
func (d RecordCompletionBlock) DefinitionTable() string {
	return "DestinyRecordCompletionBlock"
}
func (d RecordDefinition) DefinitionTable() string {
	return "DestinyRecordDefinition"
}
func (d RecordExpirationBlock) DefinitionTable() string {
	return "DestinyRecordExpirationBlock"
}
func (d RecordIntervalBlock) DefinitionTable() string {
	return "DestinyRecordIntervalBlock"
}
func (d RecordIntervalObjective) DefinitionTable() string {
	return "DestinyRecordIntervalObjective"
}
func (d RecordIntervalRewards) DefinitionTable() string {
	return "DestinyRecordIntervalRewards"
}
func (d RecordTitleBlock) DefinitionTable() string {
	return "DestinyRecordTitleBlock"
}
func (d SchemaRecordStateBlock) DefinitionTable() string {
	return "SchemaRecordStateBlock"
}
func (d ReportReasonCategoryDefinition) DefinitionTable() string {
	return "DestinyReportReasonCategoryDefinition"
}
func (d ReportReasonDefinition) DefinitionTable() string {
	return "DestinyReportReasonDefinition"
}
func (d EventCardDefinition) DefinitionTable() string {
	return "DestinyEventCardDefinition"
}
func (d EventCardImages) DefinitionTable() string {
	return "DestinyEventCardImages"
}
func (d SeasonActDefinition) DefinitionTable() string {
	return "DestinySeasonActDefinition"
}
func (d SeasonDefinition) DefinitionTable() string {
	return "DestinySeasonDefinition"
}
func (d SeasonPassDefinition) DefinitionTable() string {
	return "DestinySeasonPassDefinition"
}
func (d SeasonPreviewDefinition) DefinitionTable() string {
	return "DestinySeasonPreviewDefinition"
}
func (d SeasonPreviewImageDefinition) DefinitionTable() string {
	return "DestinySeasonPreviewImageDefinition"
}
func (d SocialCommendationDefinition) DefinitionTable() string {
	return "DestinySocialCommendationDefinition"
}
func (d SocialCommendationNodeDefinition) DefinitionTable() string {
	return "DestinySocialCommendationNodeDefinition"
}
func (d InsertPlugActionDefinition) DefinitionTable() string {
	return "DestinyInsertPlugActionDefinition"
}
func (d PlugSetDefinition) DefinitionTable() string {
	return "DestinyPlugSetDefinition"
}
func (d PlugWhitelistEntryDefinition) DefinitionTable() string {
	return "DestinyPlugWhitelistEntryDefinition"
}
func (d SocketCategoryDefinition) DefinitionTable() string {
	return "DestinySocketCategoryDefinition"
}
func (d SocketTypeDefinition) DefinitionTable() string {
	return "DestinySocketTypeDefinition"
}
func (d SocketTypeScalarMaterialRequirementEntry) DefinitionTable() string {
	return "DestinySocketTypeScalarMaterialRequirementEntry"
}
func (d ItemSourceDefinition) DefinitionTable() string {
	return "DestinyItemSourceDefinition"
}
func (d TraitDefinition) DefinitionTable() string {
	return "DestinyTraitDefinition"
}
func (d VendorLocationDefinition) DefinitionTable() string {
	return "DestinyVendorLocationDefinition"
}

func (e ActivityDifficultyTier) Enum() string {
	switch e {
	case ActivityDifficultyTier_Trivial:
		return "Trivial"
	case ActivityDifficultyTier_Easy:
		return "Easy"
	case ActivityDifficultyTier_Normal:
		return "Normal"
	case ActivityDifficultyTier_Challenging:
		return "Challenging"
	case ActivityDifficultyTier_Hard:
		return "Hard"
	case ActivityDifficultyTier_Brave:
		return "Brave"
	case ActivityDifficultyTier_AlmostImpossible:
		return "AlmostImpossible"
	case ActivityDifficultyTier_Impossible:
		return "Impossible"
	}
	return fmt.Sprintf("ActivityDifficultyTier_%d", e)
}

func (e ActivityModeCategory) Enum() string {
	switch e {
	case ActivityModeCategory_None:
		return "None"
	case ActivityModeCategory_PvE:
		return "PvE"
	case ActivityModeCategory_PvP:
		return "PvP"
	case ActivityModeCategory_PvECompetitive:
		return "PvECompetitive"
	}
	return fmt.Sprintf("ActivityModeCategory_%d", e)
}

func (e ActivityNavPointType) Enum() string {
	switch e {
	case ActivityNavPointType_Inactive:
		return "Inactive"
	case ActivityNavPointType_PrimaryObjective:
		return "PrimaryObjective"
	case ActivityNavPointType_SecondaryObjective:
		return "SecondaryObjective"
	case ActivityNavPointType_TravelObjective:
		return "TravelObjective"
	case ActivityNavPointType_PublicEventObjective:
		return "PublicEventObjective"
	case ActivityNavPointType_AmmoCache:
		return "AmmoCache"
	case ActivityNavPointType_PointTypeFlag:
		return "PointTypeFlag"
	case ActivityNavPointType_CapturePoint:
		return "CapturePoint"
	case ActivityNavPointType_DefensiveEncounter:
		return "DefensiveEncounter"
	case ActivityNavPointType_GhostInteraction:
		return "GhostInteraction"
	case ActivityNavPointType_KillAi:
		return "KillAi"
	case ActivityNavPointType_QuestItem:
		return "QuestItem"
	case ActivityNavPointType_PatrolMission:
		return "PatrolMission"
	case ActivityNavPointType_Incoming:
		return "Incoming"
	case ActivityNavPointType_ArenaObjective:
		return "ArenaObjective"
	case ActivityNavPointType_AutomationHint:
		return "AutomationHint"
	case ActivityNavPointType_TrackedQuest:
		return "TrackedQuest"
	}
	return fmt.Sprintf("ActivityNavPointType_%d", e)
}

func (e AmmunitionType) Enum() string {
	switch e {
	case AmmunitionType_None:
		return "None"
	case AmmunitionType_Primary:
		return "Primary"
	case AmmunitionType_Special:
		return "Special"
	case AmmunitionType_Heavy:
		return "Heavy"
	case AmmunitionType_Unknown:
		return "Unknown"
	}
	return fmt.Sprintf("AmmunitionType_%d", e)
}

func (e BreakerType) Enum() string {
	switch e {
	case BreakerType_None:
		return "None"
	case BreakerType_ShieldPiercing:
		return "ShieldPiercing"
	case BreakerType_Disruption:
		return "Disruption"
	case BreakerType_Stagger:
		return "Stagger"
	}
	return fmt.Sprintf("BreakerType_%d", e)
}

func (e Class) Enum() string {
	switch e {
	case Class_Titan:
		return "Titan"
	case Class_Hunter:
		return "Hunter"
	case Class_Warlock:
		return "Warlock"
	case Class_Unknown:
		return "Unknown"
	}
	return fmt.Sprintf("Class_%d", e)
}

func (e CollectibleState) Enum() string {
	switch e {
	case CollectibleState_None:
		return "None"
	case CollectibleState_NotAcquired:
		return "NotAcquired"
	case CollectibleState_Obscured:
		return "Obscured"
	case CollectibleState_Invisible:
		return "Invisible"
	case CollectibleState_CannotAffordMaterialRequirements:
		return "CannotAffordMaterialRequirements"
	case CollectibleState_InventorySpaceUnavailable:
		return "InventorySpaceUnavailable"
	case CollectibleState_UniquenessViolation:
		return "UniquenessViolation"
	case CollectibleState_PurchaseDisabled:
		return "PurchaseDisabled"
	}
	return fmt.Sprintf("CollectibleState_%d", e)
}

func (e ComponentType) Enum() string {
	switch e {
	case ComponentType_None:
		return "None"
	case ComponentType_Profiles:
		return "Profiles"
	case ComponentType_VendorReceipts:
		return "VendorReceipts"
	case ComponentType_ProfileInventories:
		return "ProfileInventories"
	case ComponentType_ProfileCurrencies:
		return "ProfileCurrencies"
	case ComponentType_ProfileProgression:
		return "ProfileProgression"
	case ComponentType_PlatformSilver:
		return "PlatformSilver"
	case ComponentType_Characters:
		return "Characters"
	case ComponentType_CharacterInventories:
		return "CharacterInventories"
	case ComponentType_CharacterProgressions:
		return "CharacterProgressions"
	case ComponentType_CharacterRenderData:
		return "CharacterRenderData"
	case ComponentType_CharacterActivities:
		return "CharacterActivities"
	case ComponentType_CharacterEquipment:
		return "CharacterEquipment"
	case ComponentType_CharacterLoadouts:
		return "CharacterLoadouts"
	case ComponentType_ItemInstances:
		return "ItemInstances"
	case ComponentType_ItemObjectives:
		return "ItemObjectives"
	case ComponentType_ItemPerks:
		return "ItemPerks"
	case ComponentType_ItemRenderData:
		return "ItemRenderData"
	case ComponentType_ItemStats:
		return "ItemStats"
	case ComponentType_ItemSockets:
		return "ItemSockets"
	case ComponentType_ItemTalentGrids:
		return "ItemTalentGrids"
	case ComponentType_ItemCommonData:
		return "ItemCommonData"
	case ComponentType_ItemPlugStates:
		return "ItemPlugStates"
	case ComponentType_ItemPlugObjectives:
		return "ItemPlugObjectives"
	case ComponentType_ItemReusablePlugs:
		return "ItemReusablePlugs"
	case ComponentType_Vendors:
		return "Vendors"
	case ComponentType_VendorCategories:
		return "VendorCategories"
	case ComponentType_VendorSales:
		return "VendorSales"
	case ComponentType_Kiosks:
		return "Kiosks"
	case ComponentType_CurrencyLookups:
		return "CurrencyLookups"
	case ComponentType_PresentationNodes:
		return "PresentationNodes"
	case ComponentType_Collectibles:
		return "Collectibles"
	case ComponentType_Records:
		return "Records"
	case ComponentType_Transitory:
		return "Transitory"
	case ComponentType_Metrics:
		return "Metrics"
	case ComponentType_StringVariables:
		return "StringVariables"
	case ComponentType_Craftables:
		return "Craftables"
	case ComponentType_SocialCommendations:
		return "SocialCommendations"
	}
	return fmt.Sprintf("ComponentType_%d", e)
}

func (e EnergyType) Enum() string {
	switch e {
	case EnergyType_Any:
		return "Any"
	case EnergyType_Arc:
		return "Arc"
	case EnergyType_Thermal:
		return "Thermal"
	case EnergyType_Void:
		return "Void"
	case EnergyType_Ghost:
		return "Ghost"
	case EnergyType_Subclass:
		return "Subclass"
	case EnergyType_Stasis:
		return "Stasis"
	}
	return fmt.Sprintf("EnergyType_%d", e)
}

func (e GamePrivacySetting) Enum() string {
	switch e {
	case GamePrivacySetting_Open:
		return "Open"
	case GamePrivacySetting_ClanAndFriendsOnly:
		return "ClanAndFriendsOnly"
	case GamePrivacySetting_FriendsOnly:
		return "FriendsOnly"
	case GamePrivacySetting_InvitationOnly:
		return "InvitationOnly"
	case GamePrivacySetting_Closed:
		return "Closed"
	}
	return fmt.Sprintf("GamePrivacySetting_%d", e)
}

func (e GameVersions) Enum() string {
	switch e {
	case GameVersions_None:
		return "None"
	case GameVersions_Destiny2:
		return "Destiny2"
	case GameVersions_DLC1:
		return "DLC1"
	case GameVersions_DLC2:
		return "DLC2"
	case GameVersions_Forsaken:
		return "Forsaken"
	case GameVersions_YearTwoAnnualPass:
		return "YearTwoAnnualPass"
	case GameVersions_Shadowkeep:
		return "Shadowkeep"
	case GameVersions_BeyondLight:
		return "BeyondLight"
	case GameVersions_Anniversary30th:
		return "Anniversary30th"
	case GameVersions_TheWitchQueen:
		return "TheWitchQueen"
	case GameVersions_Lightfall:
		return "Lightfall"
	case GameVersions_TheFinalShape:
		return "TheFinalShape"
	}
	return fmt.Sprintf("GameVersions_%d", e)
}

func (e GatingScope) Enum() string {
	switch e {
	case GatingScope_None:
		return "None"
	case GatingScope_Global:
		return "Global"
	case GatingScope_Clan:
		return "Clan"
	case GatingScope_Profile:
		return "Profile"
	case GatingScope_Character:
		return "Character"
	case GatingScope_Item:
		return "Item"
	case GatingScope_AssumedWorstCase:
		return "AssumedWorstCase"
	}
	return fmt.Sprintf("GatingScope_%d", e)
}

func (e Gender) Enum() string {
	switch e {
	case Gender_Male:
		return "Male"
	case Gender_Female:
		return "Female"
	case Gender_Unknown:
		return "Unknown"
	}
	return fmt.Sprintf("Gender_%d", e)
}

func (e GraphNodeState) Enum() string {
	switch e {
	case GraphNodeState_Hidden:
		return "Hidden"
	case GraphNodeState_Visible:
		return "Visible"
	case GraphNodeState_Teaser:
		return "Teaser"
	case GraphNodeState_Incomplete:
		return "Incomplete"
	case GraphNodeState_Completed:
		return "Completed"
	}
	return fmt.Sprintf("GraphNodeState_%d", e)
}

func (e ItemSortType) Enum() string {
	switch e {
	case ItemSortType_ItemId:
		return "ItemId"
	case ItemSortType_Timestamp:
		return "Timestamp"
	case ItemSortType_StackSize:
		return "StackSize"
	}
	return fmt.Sprintf("ItemSortType_%d", e)
}

func (e ItemSubType) Enum() string {
	switch e {
	case ItemSubType_None:
		return "None"
	case ItemSubType_Crucible:
		return "Crucible"
	case ItemSubType_Vanguard:
		return "Vanguard"
	case ItemSubType_Exotic:
		return "Exotic"
	case ItemSubType_AutoRifle:
		return "AutoRifle"
	case ItemSubType_Shotgun:
		return "Shotgun"
	case ItemSubType_Machinegun:
		return "Machinegun"
	case ItemSubType_HandCannon:
		return "HandCannon"
	case ItemSubType_RocketLauncher:
		return "RocketLauncher"
	case ItemSubType_FusionRifle:
		return "FusionRifle"
	case ItemSubType_SniperRifle:
		return "SniperRifle"
	case ItemSubType_PulseRifle:
		return "PulseRifle"
	case ItemSubType_ScoutRifle:
		return "ScoutRifle"
	case ItemSubType_Crm:
		return "Crm"
	case ItemSubType_Sidearm:
		return "Sidearm"
	case ItemSubType_Sword:
		return "Sword"
	case ItemSubType_Mask:
		return "Mask"
	case ItemSubType_Shader:
		return "Shader"
	case ItemSubType_Ornament:
		return "Ornament"
	case ItemSubType_FusionRifleLine:
		return "FusionRifleLine"
	case ItemSubType_GrenadeLauncher:
		return "GrenadeLauncher"
	case ItemSubType_SubmachineGun:
		return "SubmachineGun"
	case ItemSubType_TraceRifle:
		return "TraceRifle"
	case ItemSubType_HelmetArmor:
		return "HelmetArmor"
	case ItemSubType_GauntletsArmor:
		return "GauntletsArmor"
	case ItemSubType_ChestArmor:
		return "ChestArmor"
	case ItemSubType_LegArmor:
		return "LegArmor"
	case ItemSubType_ClassArmor:
		return "ClassArmor"
	case ItemSubType_Bow:
		return "Bow"
	case ItemSubType_DummyRepeatableBounty:
		return "DummyRepeatableBounty"
	case ItemSubType_Glaive:
		return "Glaive"
	}
	return fmt.Sprintf("ItemSubType_%d", e)
}

func (e ItemType) Enum() string {
	switch e {
	case ItemType_None:
		return "None"
	case ItemType_Currency:
		return "Currency"
	case ItemType_Armor:
		return "Armor"
	case ItemType_Weapon:
		return "Weapon"
	case ItemType_Message:
		return "Message"
	case ItemType_Engram:
		return "Engram"
	case ItemType_Consumable:
		return "Consumable"
	case ItemType_ExchangeMaterial:
		return "ExchangeMaterial"
	case ItemType_MissionReward:
		return "MissionReward"
	case ItemType_QuestStep:
		return "QuestStep"
	case ItemType_QuestStepComplete:
		return "QuestStepComplete"
	case ItemType_Emblem:
		return "Emblem"
	case ItemType_Quest:
		return "Quest"
	case ItemType_Subclass:
		return "Subclass"
	case ItemType_ClanBanner:
		return "ClanBanner"
	case ItemType_Aura:
		return "Aura"
	case ItemType_Mod:
		return "Mod"
	case ItemType_Dummy:
		return "Dummy"
	case ItemType_Ship:
		return "Ship"
	case ItemType_Vehicle:
		return "Vehicle"
	case ItemType_Emote:
		return "Emote"
	case ItemType_Ghost:
		return "Ghost"
	case ItemType_Package:
		return "Package"
	case ItemType_Bounty:
		return "Bounty"
	case ItemType_Wrapper:
		return "Wrapper"
	case ItemType_SeasonalArtifact:
		return "SeasonalArtifact"
	case ItemType_Finisher:
		return "Finisher"
	case ItemType_Pattern:
		return "Pattern"
	}
	return fmt.Sprintf("ItemType_%d", e)
}

func (e JoinClosedReasons) Enum() string {
	switch e {
	case JoinClosedReasons_None:
		return "None"
	case JoinClosedReasons_InMatchmaking:
		return "InMatchmaking"
	case JoinClosedReasons_Loading:
		return "Loading"
	case JoinClosedReasons_SoloMode:
		return "SoloMode"
	case JoinClosedReasons_InternalReasons:
		return "InternalReasons"
	case JoinClosedReasons_DisallowedByGameState:
		return "DisallowedByGameState"
	case JoinClosedReasons_Offline:
		return "Offline"
	}
	return fmt.Sprintf("JoinClosedReasons_%d", e)
}

func (e ObjectiveGrantStyle) Enum() string {
	switch e {
	case ObjectiveGrantStyle_WhenIncomplete:
		return "WhenIncomplete"
	case ObjectiveGrantStyle_WhenComplete:
		return "WhenComplete"
	case ObjectiveGrantStyle_Always:
		return "Always"
	}
	return fmt.Sprintf("ObjectiveGrantStyle_%d", e)
}

func (e ObjectiveUiStyle) Enum() string {
	switch e {
	case ObjectiveUiStyle_None:
		return "None"
	case ObjectiveUiStyle_Highlighted:
		return "Highlighted"
	case ObjectiveUiStyle_CraftingWeaponLevel:
		return "CraftingWeaponLevel"
	case ObjectiveUiStyle_CraftingWeaponLevelProgress:
		return "CraftingWeaponLevelProgress"
	case ObjectiveUiStyle_CraftingWeaponTimestamp:
		return "CraftingWeaponTimestamp"
	case ObjectiveUiStyle_CraftingMementos:
		return "CraftingMementos"
	case ObjectiveUiStyle_CraftingMementoTitle:
		return "CraftingMementoTitle"
	}
	return fmt.Sprintf("ObjectiveUiStyle_%d", e)
}

func (e PartyMemberStates) Enum() string {
	switch e {
	case PartyMemberStates_None:
		return "None"
	case PartyMemberStates_FireteamMember:
		return "FireteamMember"
	case PartyMemberStates_PosseMember:
		return "PosseMember"
	case PartyMemberStates_GroupMember:
		return "GroupMember"
	case PartyMemberStates_PartyLeader:
		return "PartyLeader"
	}
	return fmt.Sprintf("PartyMemberStates_%d", e)
}

func (e PresentationDisplayStyle) Enum() string {
	switch e {
	case PresentationDisplayStyle_Category:
		return "Category"
	case PresentationDisplayStyle_Badge:
		return "Badge"
	case PresentationDisplayStyle_Medals:
		return "Medals"
	case PresentationDisplayStyle_Collectible:
		return "Collectible"
	case PresentationDisplayStyle_Record:
		return "Record"
	case PresentationDisplayStyle_SeasonalTriumph:
		return "SeasonalTriumph"
	case PresentationDisplayStyle_GuardianRank:
		return "GuardianRank"
	case PresentationDisplayStyle_CategoryCollectibles:
		return "CategoryCollectibles"
	case PresentationDisplayStyle_CategoryCurrencies:
		return "CategoryCurrencies"
	case PresentationDisplayStyle_CategoryEmblems:
		return "CategoryEmblems"
	case PresentationDisplayStyle_CategoryEmotes:
		return "CategoryEmotes"
	case PresentationDisplayStyle_CategoryEngrams:
		return "CategoryEngrams"
	case PresentationDisplayStyle_CategoryFinishers:
		return "CategoryFinishers"
	case PresentationDisplayStyle_CategoryGhosts:
		return "CategoryGhosts"
	case PresentationDisplayStyle_CategoryMisc:
		return "CategoryMisc"
	case PresentationDisplayStyle_CategoryMods:
		return "CategoryMods"
	case PresentationDisplayStyle_CategoryOrnaments:
		return "CategoryOrnaments"
	case PresentationDisplayStyle_CategoryShaders:
		return "CategoryShaders"
	case PresentationDisplayStyle_CategoryShips:
		return "CategoryShips"
	case PresentationDisplayStyle_CategorySpawnfx:
		return "CategorySpawnfx"
	case PresentationDisplayStyle_CategoryUpgradeMaterials:
		return "CategoryUpgradeMaterials"
	}
	return fmt.Sprintf("PresentationDisplayStyle_%d", e)
}

func (e PresentationNodeState) Enum() string {
	switch e {
	case PresentationNodeState_None:
		return "None"
	case PresentationNodeState_Invisible:
		return "Invisible"
	case PresentationNodeState_Obscured:
		return "Obscured"
	}
	return fmt.Sprintf("PresentationNodeState_%d", e)
}

func (e PresentationNodeType) Enum() string {
	switch e {
	case PresentationNodeType_Default:
		return "Default"
	case PresentationNodeType_Category:
		return "Category"
	case PresentationNodeType_Collectibles:
		return "Collectibles"
	case PresentationNodeType_Records:
		return "Records"
	case PresentationNodeType_Metric:
		return "Metric"
	case PresentationNodeType_Craftable:
		return "Craftable"
	}
	return fmt.Sprintf("PresentationNodeType_%d", e)
}

func (e PresentationScreenStyle) Enum() string {
	switch e {
	case PresentationScreenStyle_Default:
		return "Default"
	case PresentationScreenStyle_CategorySets:
		return "CategorySets"
	case PresentationScreenStyle_Badge:
		return "Badge"
	}
	return fmt.Sprintf("PresentationScreenStyle_%d", e)
}

func (e ProgressionRewardItemAcquisitionBehavior) Enum() string {
	switch e {
	case ProgressionRewardItemAcquisitionBehavior_Instant:
		return "Instant"
	case ProgressionRewardItemAcquisitionBehavior_PlayerClaimRequired:
		return "PlayerClaimRequired"
	}
	return fmt.Sprintf("ProgressionRewardItemAcquisitionBehavior_%d", e)
}

func (e ProgressionRewardItemState) Enum() string {
	switch e {
	case ProgressionRewardItemState_None:
		return "None"
	case ProgressionRewardItemState_Invisible:
		return "Invisible"
	case ProgressionRewardItemState_Earned:
		return "Earned"
	case ProgressionRewardItemState_Claimed:
		return "Claimed"
	case ProgressionRewardItemState_ClaimAllowed:
		return "ClaimAllowed"
	}
	return fmt.Sprintf("ProgressionRewardItemState_%d", e)
}

func (e ProgressionScope) Enum() string {
	switch e {
	case ProgressionScope_Account:
		return "Account"
	case ProgressionScope_Character:
		return "Character"
	case ProgressionScope_Clan:
		return "Clan"
	case ProgressionScope_Item:
		return "Item"
	case ProgressionScope_ImplicitFromEquipment:
		return "ImplicitFromEquipment"
	case ProgressionScope_Mapped:
		return "Mapped"
	case ProgressionScope_MappedAggregate:
		return "MappedAggregate"
	case ProgressionScope_MappedStat:
		return "MappedStat"
	case ProgressionScope_MappedUnlockValue:
		return "MappedUnlockValue"
	}
	return fmt.Sprintf("ProgressionScope_%d", e)
}

func (e ProgressionStepDisplayEffect) Enum() string {
	switch e {
	case ProgressionStepDisplayEffect_None:
		return "None"
	case ProgressionStepDisplayEffect_Character:
		return "Character"
	case ProgressionStepDisplayEffect_Item:
		return "Item"
	}
	return fmt.Sprintf("ProgressionStepDisplayEffect_%d", e)
}

func (e Race) Enum() string {
	switch e {
	case Race_Human:
		return "Human"
	case Race_Awoken:
		return "Awoken"
	case Race_Exo:
		return "Exo"
	case Race_Unknown:
		return "Unknown"
	}
	return fmt.Sprintf("Race_%d", e)
}

func (e RecordState) Enum() string {
	switch e {
	case RecordState_None:
		return "None"
	case RecordState_RecordRedeemed:
		return "RecordRedeemed"
	case RecordState_RewardUnavailable:
		return "RewardUnavailable"
	case RecordState_ObjectiveNotCompleted:
		return "ObjectiveNotCompleted"
	case RecordState_Obscured:
		return "Obscured"
	case RecordState_Invisible:
		return "Invisible"
	case RecordState_EntitlementUnowned:
		return "EntitlementUnowned"
	case RecordState_CanEquipTitle:
		return "CanEquipTitle"
	}
	return fmt.Sprintf("RecordState_%d", e)
}

func (e RecordToastStyle) Enum() string {
	switch e {
	case RecordToastStyle_None:
		return "None"
	case RecordToastStyle_Record:
		return "Record"
	case RecordToastStyle_Lore:
		return "Lore"
	case RecordToastStyle_Badge:
		return "Badge"
	case RecordToastStyle_MetaRecord:
		return "MetaRecord"
	case RecordToastStyle_MedalComplete:
		return "MedalComplete"
	case RecordToastStyle_SeasonChallengeComplete:
		return "SeasonChallengeComplete"
	case RecordToastStyle_GildedTitleComplete:
		return "GildedTitleComplete"
	case RecordToastStyle_CraftingRecipeUnlocked:
		return "CraftingRecipeUnlocked"
	case RecordToastStyle_ToastGuardianRankDetails:
		return "ToastGuardianRankDetails"
	case RecordToastStyle_PathfinderObjectiveCompleteRituals:
		return "PathfinderObjectiveCompleteRituals"
	case RecordToastStyle_PathfinderObjectiveCompleteSchism:
		return "PathfinderObjectiveCompleteSchism"
	case RecordToastStyle_PathfinderObjectiveCompletePvp:
		return "PathfinderObjectiveCompletePvp"
	case RecordToastStyle_PathfinderObjectiveCompleteStrikes:
		return "PathfinderObjectiveCompleteStrikes"
	case RecordToastStyle_PathfinderObjectiveCompleteGambit:
		return "PathfinderObjectiveCompleteGambit"
	}
	return fmt.Sprintf("RecordToastStyle_%d", e)
}

func (e RecordValueStyle) Enum() string {
	switch e {
	case RecordValueStyle_Integer:
		return "Integer"
	case RecordValueStyle_Percentage:
		return "Percentage"
	case RecordValueStyle_Milliseconds:
		return "Milliseconds"
	case RecordValueStyle_Boolean:
		return "Boolean"
	case RecordValueStyle_Decimal:
		return "Decimal"
	}
	return fmt.Sprintf("RecordValueStyle_%d", e)
}

func (e Scope) Enum() string {
	switch e {
	case Scope_Profile:
		return "Profile"
	case Scope_Character:
		return "Character"
	}
	return fmt.Sprintf("Scope_%d", e)
}

func (e SocketCategoryStyle) Enum() string {
	switch e {
	case SocketCategoryStyle_Unknown:
		return "Unknown"
	case SocketCategoryStyle_Reusable:
		return "Reusable"
	case SocketCategoryStyle_Consumable:
		return "Consumable"
	case SocketCategoryStyle_Unlockable:
		return "Unlockable"
	case SocketCategoryStyle_Intrinsic:
		return "Intrinsic"
	case SocketCategoryStyle_EnergyMeter:
		return "EnergyMeter"
	case SocketCategoryStyle_LargePerk:
		return "LargePerk"
	case SocketCategoryStyle_Abilities:
		return "Abilities"
	case SocketCategoryStyle_Supers:
		return "Supers"
	}
	return fmt.Sprintf("SocketCategoryStyle_%d", e)
}

func (e SocketVisibility) Enum() string {
	switch e {
	case SocketVisibility_Visible:
		return "Visible"
	case SocketVisibility_Hidden:
		return "Hidden"
	case SocketVisibility_HiddenWhenEmpty:
		return "HiddenWhenEmpty"
	case SocketVisibility_HiddenIfNoPlugsAvailable:
		return "HiddenIfNoPlugsAvailable"
	}
	return fmt.Sprintf("SocketVisibility_%d", e)
}

func (e StatAggregationType) Enum() string {
	switch e {
	case StatAggregationType_CharacterAverage:
		return "CharacterAverage"
	case StatAggregationType_Character:
		return "Character"
	case StatAggregationType_Item:
		return "Item"
	}
	return fmt.Sprintf("StatAggregationType_%d", e)
}

func (e StatCategory) Enum() string {
	switch e {
	case StatCategory_Gameplay:
		return "Gameplay"
	case StatCategory_Weapon:
		return "Weapon"
	case StatCategory_Defense:
		return "Defense"
	case StatCategory_Primary:
		return "Primary"
	}
	return fmt.Sprintf("StatCategory_%d", e)
}

func (e TalentNodeState) Enum() string {
	switch e {
	case TalentNodeState_Invalid:
		return "Invalid"
	case TalentNodeState_CanUpgrade:
		return "CanUpgrade"
	case TalentNodeState_NoPoints:
		return "NoPoints"
	case TalentNodeState_NoPrerequisites:
		return "NoPrerequisites"
	case TalentNodeState_NoSteps:
		return "NoSteps"
	case TalentNodeState_NoUnlock:
		return "NoUnlock"
	case TalentNodeState_NoMaterial:
		return "NoMaterial"
	case TalentNodeState_NoGridLevel:
		return "NoGridLevel"
	case TalentNodeState_SwappingLocked:
		return "SwappingLocked"
	case TalentNodeState_MustSwap:
		return "MustSwap"
	case TalentNodeState_Complete:
		return "Complete"
	case TalentNodeState_Unknown:
		return "Unknown"
	case TalentNodeState_CreationOnly:
		return "CreationOnly"
	case TalentNodeState_Hidden:
		return "Hidden"
	}
	return fmt.Sprintf("TalentNodeState_%d", e)
}

func (e UnlockValueUIStyle) Enum() string {
	switch e {
	case UnlockValueUIStyle_Automatic:
		return "Automatic"
	case UnlockValueUIStyle_Fraction:
		return "Fraction"
	case UnlockValueUIStyle_Checkbox:
		return "Checkbox"
	case UnlockValueUIStyle_Percentage:
		return "Percentage"
	case UnlockValueUIStyle_DateTime:
		return "DateTime"
	case UnlockValueUIStyle_FractionFloat:
		return "FractionFloat"
	case UnlockValueUIStyle_Integer:
		return "Integer"
	case UnlockValueUIStyle_TimeDuration:
		return "TimeDuration"
	case UnlockValueUIStyle_Hidden:
		return "Hidden"
	case UnlockValueUIStyle_Multiplier:
		return "Multiplier"
	case UnlockValueUIStyle_GreenPips:
		return "GreenPips"
	case UnlockValueUIStyle_RedPips:
		return "RedPips"
	case UnlockValueUIStyle_ExplicitPercentage:
		return "ExplicitPercentage"
	case UnlockValueUIStyle_RawFloat:
		return "RawFloat"
	case UnlockValueUIStyle_LevelAndReward:
		return "LevelAndReward"
	}
	return fmt.Sprintf("UnlockValueUIStyle_%d", e)
}

func (e VendorFilter) Enum() string {
	switch e {
	case VendorFilter_None:
		return "None"
	case VendorFilter_ApiPurchasable:
		return "ApiPurchasable"
	}
	return fmt.Sprintf("VendorFilter_%d", e)
}

func (e VendorInteractionRewardSelection) Enum() string {
	switch e {
	case VendorInteractionRewardSelection_None:
		return "None"
	case VendorInteractionRewardSelection_One:
		return "One"
	case VendorInteractionRewardSelection_All:
		return "All"
	}
	return fmt.Sprintf("VendorInteractionRewardSelection_%d", e)
}

func (e VendorItemRefundPolicy) Enum() string {
	switch e {
	case VendorItemRefundPolicy_NotRefundable:
		return "NotRefundable"
	case VendorItemRefundPolicy_DeletesItem:
		return "DeletesItem"
	case VendorItemRefundPolicy_RevokesLicense:
		return "RevokesLicense"
	}
	return fmt.Sprintf("VendorItemRefundPolicy_%d", e)
}

func (e VendorItemState) Enum() string {
	switch e {
	case VendorItemState_None:
		return "None"
	case VendorItemState_Incomplete:
		return "Incomplete"
	case VendorItemState_RewardAvailable:
		return "RewardAvailable"
	case VendorItemState_Complete:
		return "Complete"
	case VendorItemState_New:
		return "New"
	case VendorItemState_Featured:
		return "Featured"
	case VendorItemState_Ending:
		return "Ending"
	case VendorItemState_OnSale:
		return "OnSale"
	case VendorItemState_Owned:
		return "Owned"
	case VendorItemState_WideView:
		return "WideView"
	case VendorItemState_NexusAttention:
		return "NexusAttention"
	case VendorItemState_SetDiscount:
		return "SetDiscount"
	case VendorItemState_PriceDrop:
		return "PriceDrop"
	case VendorItemState_DailyOffer:
		return "DailyOffer"
	case VendorItemState_Charity:
		return "Charity"
	case VendorItemState_SeasonalRewardExpiration:
		return "SeasonalRewardExpiration"
	case VendorItemState_BestDeal:
		return "BestDeal"
	case VendorItemState_Popular:
		return "Popular"
	case VendorItemState_Free:
		return "Free"
	case VendorItemState_Locked:
		return "Locked"
	case VendorItemState_Paracausal:
		return "Paracausal"
	case VendorItemState_Cryptarch:
		return "Cryptarch"
	case VendorItemState_ArtifactPerkOwned:
		return "ArtifactPerkOwned"
	case VendorItemState_Savings:
		return "Savings"
	case VendorItemState_Ineligible:
		return "Ineligible"
	case VendorItemState_ArtifactPerkBoosted:
		return "ArtifactPerkBoosted"
	}
	return fmt.Sprintf("VendorItemState_%d", e)
}

func (e VendorProgressionType) Enum() string {
	switch e {
	case VendorProgressionType_Default:
		return "Default"
	case VendorProgressionType_Ritual:
		return "Ritual"
	case VendorProgressionType_NoSeasonalRefresh:
		return "NoSeasonalRefresh"
	}
	return fmt.Sprintf("VendorProgressionType_%d", e)
}

func (e VendorReplyType) Enum() string {
	switch e {
	case VendorReplyType_Accept:
		return "Accept"
	case VendorReplyType_Decline:
		return "Decline"
	case VendorReplyType_Complete:
		return "Complete"
	}
	return fmt.Sprintf("VendorReplyType_%d", e)
}

func (e EquipFailureReason) Enum() string {
	switch e {
	case EquipFailureReason_None:
		return "None"
	case EquipFailureReason_ItemUnequippable:
		return "ItemUnequippable"
	case EquipFailureReason_ItemUniqueEquipRestricted:
		return "ItemUniqueEquipRestricted"
	case EquipFailureReason_ItemFailedUnlockCheck:
		return "ItemFailedUnlockCheck"
	case EquipFailureReason_ItemFailedLevelCheck:
		return "ItemFailedLevelCheck"
	case EquipFailureReason_ItemWrapped:
		return "ItemWrapped"
	case EquipFailureReason_ItemNotLoaded:
		return "ItemNotLoaded"
	case EquipFailureReason_ItemEquipBlocklisted:
		return "ItemEquipBlocklisted"
	case EquipFailureReason_ItemLoadoutRequirementNotMet:
		return "ItemLoadoutRequirementNotMet"
	}
	return fmt.Sprintf("EquipFailureReason_%d", e)
}

func (e EquippingItemBlockAttributes) Enum() string {
	switch e {
	case EquippingItemBlockAttributes_None:
		return "None"
	case EquippingItemBlockAttributes_EquipOnAcquire:
		return "EquipOnAcquire"
	}
	return fmt.Sprintf("EquippingItemBlockAttributes_%d", e)
}

func (e FireteamFinderCodeOptionType) Enum() string {
	switch e {
	case FireteamFinderCodeOptionType_None:
		return "None"
	case FireteamFinderCodeOptionType_ApplicationOnly:
		return "ApplicationOnly"
	case FireteamFinderCodeOptionType_OnlineOnly:
		return "OnlineOnly"
	case FireteamFinderCodeOptionType_PlayerCount:
		return "PlayerCount"
	case FireteamFinderCodeOptionType_Title:
		return "Title"
	case FireteamFinderCodeOptionType_Tags:
		return "Tags"
	case FireteamFinderCodeOptionType_FinderActivityGraph:
		return "FinderActivityGraph"
	case FireteamFinderCodeOptionType_MicrophoneRequired:
		return "MicrophoneRequired"
	}
	return fmt.Sprintf("FireteamFinderCodeOptionType_%d", e)
}

func (e FireteamFinderLabelFieldType) Enum() string {
	switch e {
	case FireteamFinderLabelFieldType_Title:
		return "Title"
	case FireteamFinderLabelFieldType_Label:
		return "Label"
	}
	return fmt.Sprintf("FireteamFinderLabelFieldType_%d", e)
}

func (e FireteamFinderOptionAvailability) Enum() string {
	switch e {
	case FireteamFinderOptionAvailability_None:
		return "None"
	case FireteamFinderOptionAvailability_CreateListingBuilder:
		return "CreateListingBuilder"
	case FireteamFinderOptionAvailability_SearchListingBuilder:
		return "SearchListingBuilder"
	case FireteamFinderOptionAvailability_ListingViewer:
		return "ListingViewer"
	case FireteamFinderOptionAvailability_LobbyViewer:
		return "LobbyViewer"
	}
	return fmt.Sprintf("FireteamFinderOptionAvailability_%d", e)
}

func (e FireteamFinderOptionControlType) Enum() string {
	switch e {
	case FireteamFinderOptionControlType_None:
		return "None"
	case FireteamFinderOptionControlType_ValueCollection:
		return "ValueCollection"
	case FireteamFinderOptionControlType_RadioButton:
		return "RadioButton"
	}
	return fmt.Sprintf("FireteamFinderOptionControlType_%d", e)
}

func (e FireteamFinderOptionDisplayFormat) Enum() string {
	switch e {
	case FireteamFinderOptionDisplayFormat_Text:
		return "Text"
	case FireteamFinderOptionDisplayFormat_Integer:
		return "Integer"
	case FireteamFinderOptionDisplayFormat_Bool:
		return "Bool"
	case FireteamFinderOptionDisplayFormat_FormatString:
		return "FormatString"
	}
	return fmt.Sprintf("FireteamFinderOptionDisplayFormat_%d", e)
}

func (e FireteamFinderOptionSearchFilterType) Enum() string {
	switch e {
	case FireteamFinderOptionSearchFilterType_None:
		return "None"
	case FireteamFinderOptionSearchFilterType_All:
		return "All"
	case FireteamFinderOptionSearchFilterType_Any:
		return "Any"
	case FireteamFinderOptionSearchFilterType_InRangeInclusive:
		return "InRangeInclusive"
	case FireteamFinderOptionSearchFilterType_InRangeExclusive:
		return "InRangeExclusive"
	case FireteamFinderOptionSearchFilterType_GreaterThan:
		return "GreaterThan"
	case FireteamFinderOptionSearchFilterType_GreaterThanOrEqualTo:
		return "GreaterThanOrEqualTo"
	case FireteamFinderOptionSearchFilterType_LessThan:
		return "LessThan"
	case FireteamFinderOptionSearchFilterType_LessThanOrEqualTo:
		return "LessThanOrEqualTo"
	}
	return fmt.Sprintf("FireteamFinderOptionSearchFilterType_%d", e)
}

func (e FireteamFinderOptionValueFlags) Enum() string {
	switch e {
	case FireteamFinderOptionValueFlags_None:
		return "None"
	case FireteamFinderOptionValueFlags_CreateListingDefaultValue:
		return "CreateListingDefaultValue"
	case FireteamFinderOptionValueFlags_SearchFilterDefaultValue:
		return "SearchFilterDefaultValue"
	}
	return fmt.Sprintf("FireteamFinderOptionValueFlags_%d", e)
}

func (e FireteamFinderOptionValueProviderType) Enum() string {
	switch e {
	case FireteamFinderOptionValueProviderType_None:
		return "None"
	case FireteamFinderOptionValueProviderType_Values:
		return "Values"
	case FireteamFinderOptionValueProviderType_PlayerCount:
		return "PlayerCount"
	case FireteamFinderOptionValueProviderType_FireteamFinderLabels:
		return "FireteamFinderLabels"
	case FireteamFinderOptionValueProviderType_FireteamFinderActivityGraph:
		return "FireteamFinderActivityGraph"
	}
	return fmt.Sprintf("FireteamFinderOptionValueProviderType_%d", e)
}

func (e FireteamFinderOptionVisibility) Enum() string {
	switch e {
	case FireteamFinderOptionVisibility_Always:
		return "Always"
	case FireteamFinderOptionVisibility_ShowWhenChangedFromDefault:
		return "ShowWhenChangedFromDefault"
	}
	return fmt.Sprintf("FireteamFinderOptionVisibility_%d", e)
}

func (e ActivityModeType) Enum() string {
	switch e {
	case ActivityModeType_None:
		return "None"
	case ActivityModeType_Story:
		return "Story"
	case ActivityModeType_Strike:
		return "Strike"
	case ActivityModeType_Raid:
		return "Raid"
	case ActivityModeType_AllPvP:
		return "AllPvP"
	case ActivityModeType_Patrol:
		return "Patrol"
	case ActivityModeType_AllPvE:
		return "AllPvE"
	case ActivityModeType_Reserved9:
		return "Reserved9"
	case ActivityModeType_Control:
		return "Control"
	case ActivityModeType_Reserved11:
		return "Reserved11"
	case ActivityModeType_Clash:
		return "Clash"
	case ActivityModeType_Reserved13:
		return "Reserved13"
	case ActivityModeType_CrimsonDoubles:
		return "CrimsonDoubles"
	case ActivityModeType_Nightfall:
		return "Nightfall"
	case ActivityModeType_HeroicNightfall:
		return "HeroicNightfall"
	case ActivityModeType_AllStrikes:
		return "AllStrikes"
	case ActivityModeType_IronBanner:
		return "IronBanner"
	case ActivityModeType_Reserved20:
		return "Reserved20"
	case ActivityModeType_Reserved21:
		return "Reserved21"
	case ActivityModeType_Reserved22:
		return "Reserved22"
	case ActivityModeType_Reserved24:
		return "Reserved24"
	case ActivityModeType_AllMayhem:
		return "AllMayhem"
	case ActivityModeType_Reserved26:
		return "Reserved26"
	case ActivityModeType_Reserved27:
		return "Reserved27"
	case ActivityModeType_Reserved28:
		return "Reserved28"
	case ActivityModeType_Reserved29:
		return "Reserved29"
	case ActivityModeType_Reserved30:
		return "Reserved30"
	case ActivityModeType_Supremacy:
		return "Supremacy"
	case ActivityModeType_PrivateMatchesAll:
		return "PrivateMatchesAll"
	case ActivityModeType_Survival:
		return "Survival"
	case ActivityModeType_Countdown:
		return "Countdown"
	case ActivityModeType_TrialsOfTheNine:
		return "TrialsOfTheNine"
	case ActivityModeType_Social:
		return "Social"
	case ActivityModeType_TrialsCountdown:
		return "TrialsCountdown"
	case ActivityModeType_TrialsSurvival:
		return "TrialsSurvival"
	case ActivityModeType_IronBannerControl:
		return "IronBannerControl"
	case ActivityModeType_IronBannerClash:
		return "IronBannerClash"
	case ActivityModeType_IronBannerSupremacy:
		return "IronBannerSupremacy"
	case ActivityModeType_ScoredNightfall:
		return "ScoredNightfall"
	case ActivityModeType_ScoredHeroicNightfall:
		return "ScoredHeroicNightfall"
	case ActivityModeType_Rumble:
		return "Rumble"
	case ActivityModeType_AllDoubles:
		return "AllDoubles"
	case ActivityModeType_Doubles:
		return "Doubles"
	case ActivityModeType_PrivateMatchesClash:
		return "PrivateMatchesClash"
	case ActivityModeType_PrivateMatchesControl:
		return "PrivateMatchesControl"
	case ActivityModeType_PrivateMatchesSupremacy:
		return "PrivateMatchesSupremacy"
	case ActivityModeType_PrivateMatchesCountdown:
		return "PrivateMatchesCountdown"
	case ActivityModeType_PrivateMatchesSurvival:
		return "PrivateMatchesSurvival"
	case ActivityModeType_PrivateMatchesMayhem:
		return "PrivateMatchesMayhem"
	case ActivityModeType_PrivateMatchesRumble:
		return "PrivateMatchesRumble"
	case ActivityModeType_HeroicAdventure:
		return "HeroicAdventure"
	case ActivityModeType_Showdown:
		return "Showdown"
	case ActivityModeType_Lockdown:
		return "Lockdown"
	case ActivityModeType_Scorched:
		return "Scorched"
	case ActivityModeType_ScorchedTeam:
		return "ScorchedTeam"
	case ActivityModeType_Gambit:
		return "Gambit"
	case ActivityModeType_AllPvECompetitive:
		return "AllPvECompetitive"
	case ActivityModeType_Breakthrough:
		return "Breakthrough"
	case ActivityModeType_BlackArmoryRun:
		return "BlackArmoryRun"
	case ActivityModeType_Salvage:
		return "Salvage"
	case ActivityModeType_IronBannerSalvage:
		return "IronBannerSalvage"
	case ActivityModeType_PvPCompetitive:
		return "PvPCompetitive"
	case ActivityModeType_PvPQuickplay:
		return "PvPQuickplay"
	case ActivityModeType_ClashQuickplay:
		return "ClashQuickplay"
	case ActivityModeType_ClashCompetitive:
		return "ClashCompetitive"
	case ActivityModeType_ControlQuickplay:
		return "ControlQuickplay"
	case ActivityModeType_ControlCompetitive:
		return "ControlCompetitive"
	case ActivityModeType_GambitPrime:
		return "GambitPrime"
	case ActivityModeType_Reckoning:
		return "Reckoning"
	case ActivityModeType_Menagerie:
		return "Menagerie"
	case ActivityModeType_VexOffensive:
		return "VexOffensive"
	case ActivityModeType_NightmareHunt:
		return "NightmareHunt"
	case ActivityModeType_Elimination:
		return "Elimination"
	case ActivityModeType_Momentum:
		return "Momentum"
	case ActivityModeType_Dungeon:
		return "Dungeon"
	case ActivityModeType_Sundial:
		return "Sundial"
	case ActivityModeType_TrialsOfOsiris:
		return "TrialsOfOsiris"
	case ActivityModeType_Dares:
		return "Dares"
	case ActivityModeType_Offensive:
		return "Offensive"
	case ActivityModeType_LostSector:
		return "LostSector"
	case ActivityModeType_Rift:
		return "Rift"
	case ActivityModeType_ZoneControl:
		return "ZoneControl"
	case ActivityModeType_IronBannerRift:
		return "IronBannerRift"
	case ActivityModeType_IronBannerZoneControl:
		return "IronBannerZoneControl"
	case ActivityModeType_Relic:
		return "Relic"
	}
	return fmt.Sprintf("ActivityModeType_%d", e)
}

func (e StatsCategoryType) Enum() string {
	switch e {
	case StatsCategoryType_None:
		return "None"
	case StatsCategoryType_Kills:
		return "Kills"
	case StatsCategoryType_Assists:
		return "Assists"
	case StatsCategoryType_Deaths:
		return "Deaths"
	case StatsCategoryType_Criticals:
		return "Criticals"
	case StatsCategoryType_KDa:
		return "KDa"
	case StatsCategoryType_KD:
		return "KD"
	case StatsCategoryType_Score:
		return "Score"
	case StatsCategoryType_Entered:
		return "Entered"
	case StatsCategoryType_TimePlayed:
		return "TimePlayed"
	case StatsCategoryType_MedalWins:
		return "MedalWins"
	case StatsCategoryType_MedalGame:
		return "MedalGame"
	case StatsCategoryType_MedalSpecialKills:
		return "MedalSpecialKills"
	case StatsCategoryType_MedalSprees:
		return "MedalSprees"
	case StatsCategoryType_MedalMultiKills:
		return "MedalMultiKills"
	case StatsCategoryType_MedalAbilities:
		return "MedalAbilities"
	}
	return fmt.Sprintf("StatsCategoryType_%d", e)
}

func (e StatsGroupType) Enum() string {
	switch e {
	case StatsGroupType_None:
		return "None"
	case StatsGroupType_General:
		return "General"
	case StatsGroupType_Weapons:
		return "Weapons"
	case StatsGroupType_Medals:
		return "Medals"
	case StatsGroupType_ReservedGroups:
		return "ReservedGroups"
	case StatsGroupType_Leaderboard:
		return "Leaderboard"
	case StatsGroupType_Activity:
		return "Activity"
	case StatsGroupType_UniqueWeapon:
		return "UniqueWeapon"
	case StatsGroupType_Internal:
		return "Internal"
	}
	return fmt.Sprintf("StatsGroupType_%d", e)
}

func (e StatsMergeMethod) Enum() string {
	switch e {
	case StatsMergeMethod_Add:
		return "Add"
	case StatsMergeMethod_Min:
		return "Min"
	case StatsMergeMethod_Max:
		return "Max"
	}
	return fmt.Sprintf("StatsMergeMethod_%d", e)
}

func (e PeriodType) Enum() string {
	switch e {
	case PeriodType_None:
		return "None"
	case PeriodType_Daily:
		return "Daily"
	case PeriodType_AllTime:
		return "AllTime"
	case PeriodType_Activity:
		return "Activity"
	}
	return fmt.Sprintf("PeriodType_%d", e)
}

func (e UnitType) Enum() string {
	switch e {
	case UnitType_None:
		return "None"
	case UnitType_Count:
		return "Count"
	case UnitType_PerGame:
		return "PerGame"
	case UnitType_Seconds:
		return "Seconds"
	case UnitType_Points:
		return "Points"
	case UnitType_Team:
		return "Team"
	case UnitType_Distance:
		return "Distance"
	case UnitType_Percent:
		return "Percent"
	case UnitType_Ratio:
		return "Ratio"
	case UnitType_Boolean:
		return "Boolean"
	case UnitType_WeaponType:
		return "WeaponType"
	case UnitType_Standing:
		return "Standing"
	case UnitType_Milliseconds:
		return "Milliseconds"
	case UnitType_CompletionReason:
		return "CompletionReason"
	}
	return fmt.Sprintf("UnitType_%d", e)
}

func (e ItemBindStatus) Enum() string {
	switch e {
	case ItemBindStatus_NotBound:
		return "NotBound"
	case ItemBindStatus_BoundToCharacter:
		return "BoundToCharacter"
	case ItemBindStatus_BoundToAccount:
		return "BoundToAccount"
	case ItemBindStatus_BoundToGuild:
		return "BoundToGuild"
	}
	return fmt.Sprintf("ItemBindStatus_%d", e)
}

func (e ItemLocation) Enum() string {
	switch e {
	case ItemLocation_Unknown:
		return "Unknown"
	case ItemLocation_Inventory:
		return "Inventory"
	case ItemLocation_Vault:
		return "Vault"
	case ItemLocation_Vendor:
		return "Vendor"
	case ItemLocation_Postmaster:
		return "Postmaster"
	}
	return fmt.Sprintf("ItemLocation_%d", e)
}

func (e ItemPerkVisibility) Enum() string {
	switch e {
	case ItemPerkVisibility_Visible:
		return "Visible"
	case ItemPerkVisibility_Disabled:
		return "Disabled"
	case ItemPerkVisibility_Hidden:
		return "Hidden"
	}
	return fmt.Sprintf("ItemPerkVisibility_%d", e)
}

func (e ItemState) Enum() string {
	switch e {
	case ItemState_None:
		return "None"
	case ItemState_Locked:
		return "Locked"
	case ItemState_Tracked:
		return "Tracked"
	case ItemState_Masterwork:
		return "Masterwork"
	case ItemState_Crafted:
		return "Crafted"
	case ItemState_HighlightedObjective:
		return "HighlightedObjective"
	}
	return fmt.Sprintf("ItemState_%d", e)
}

func (e PlugAvailabilityMode) Enum() string {
	switch e {
	case PlugAvailabilityMode_Normal:
		return "Normal"
	case PlugAvailabilityMode_UnavailableIfSocketContainsMatchingPlugCategory:
		return "UnavailableIfSocketContainsMatchingPlugCategory"
	case PlugAvailabilityMode_AvailableIfSocketContainsMatchingPlugCategory:
		return "AvailableIfSocketContainsMatchingPlugCategory"
	}
	return fmt.Sprintf("PlugAvailabilityMode_%d", e)
}

func (e PlugUiStyles) Enum() string {
	switch e {
	case PlugUiStyles_None:
		return "None"
	case PlugUiStyles_Masterwork:
		return "Masterwork"
	}
	return fmt.Sprintf("PlugUiStyles_%d", e)
}

func (e SocketArrayType) Enum() string {
	switch e {
	case SocketArrayType_Default:
		return "Default"
	case SocketArrayType_Intrinsic:
		return "Intrinsic"
	}
	return fmt.Sprintf("SocketArrayType_%d", e)
}

func (e SocketPlugSources) Enum() string {
	switch e {
	case SocketPlugSources_None:
		return "None"
	case SocketPlugSources_InventorySourced:
		return "InventorySourced"
	case SocketPlugSources_ReusablePlugItems:
		return "ReusablePlugItems"
	case SocketPlugSources_ProfilePlugSet:
		return "ProfilePlugSet"
	case SocketPlugSources_CharacterPlugSet:
		return "CharacterPlugSet"
	}
	return fmt.Sprintf("SocketPlugSources_%d", e)
}

func (e SocketTypeActionType) Enum() string {
	switch e {
	case SocketTypeActionType_InsertPlug:
		return "InsertPlug"
	case SocketTypeActionType_InfuseItem:
		return "InfuseItem"
	case SocketTypeActionType_ReinitializeSocket:
		return "ReinitializeSocket"
	}
	return fmt.Sprintf("SocketTypeActionType_%d", e)
}

func (e SpecialItemType) Enum() string {
	switch e {
	case SpecialItemType_None:
		return "None"
	case SpecialItemType_SpecialCurrency:
		return "SpecialCurrency"
	case SpecialItemType_Armor:
		return "Armor"
	case SpecialItemType_Weapon:
		return "Weapon"
	case SpecialItemType_Engram:
		return "Engram"
	case SpecialItemType_Consumable:
		return "Consumable"
	case SpecialItemType_ExchangeMaterial:
		return "ExchangeMaterial"
	case SpecialItemType_MissionReward:
		return "MissionReward"
	case SpecialItemType_Currency:
		return "Currency"
	}
	return fmt.Sprintf("SpecialItemType_%d", e)
}

func (e TierType) Enum() string {
	switch e {
	case TierType_Unknown:
		return "Unknown"
	case TierType_Currency:
		return "Currency"
	case TierType_Basic:
		return "Basic"
	case TierType_Common:
		return "Common"
	case TierType_Rare:
		return "Rare"
	case TierType_Superior:
		return "Superior"
	case TierType_Exotic:
		return "Exotic"
	}
	return fmt.Sprintf("TierType_%d", e)
}

func (e TransferStatuses) Enum() string {
	switch e {
	case TransferStatuses_CanTransfer:
		return "CanTransfer"
	case TransferStatuses_ItemIsEquipped:
		return "ItemIsEquipped"
	case TransferStatuses_NotTransferrable:
		return "NotTransferrable"
	case TransferStatuses_NoRoomInDestination:
		return "NoRoomInDestination"
	}
	return fmt.Sprintf("TransferStatuses_%d", e)
}

func (e VendorDisplayCategorySortOrder) Enum() string {
	switch e {
	case VendorDisplayCategorySortOrder_Default:
		return "Default"
	case VendorDisplayCategorySortOrder_SortByTier:
		return "SortByTier"
	}
	return fmt.Sprintf("VendorDisplayCategorySortOrder_%d", e)
}

func (e VendorInteractionType) Enum() string {
	switch e {
	case VendorInteractionType_Unknown:
		return "Unknown"
	case VendorInteractionType_Undefined:
		return "Undefined"
	case VendorInteractionType_QuestComplete:
		return "QuestComplete"
	case VendorInteractionType_QuestContinue:
		return "QuestContinue"
	case VendorInteractionType_ReputationPreview:
		return "ReputationPreview"
	case VendorInteractionType_RankUpReward:
		return "RankUpReward"
	case VendorInteractionType_TokenTurnIn:
		return "TokenTurnIn"
	case VendorInteractionType_QuestAccept:
		return "QuestAccept"
	case VendorInteractionType_ProgressTab:
		return "ProgressTab"
	case VendorInteractionType_End:
		return "End"
	case VendorInteractionType_Start:
		return "Start"
	}
	return fmt.Sprintf("VendorInteractionType_%d", e)
}

func (e VendorItemStatus) Enum() string {
	switch e {
	case VendorItemStatus_Success:
		return "Success"
	case VendorItemStatus_NoInventorySpace:
		return "NoInventorySpace"
	case VendorItemStatus_NoFunds:
		return "NoFunds"
	case VendorItemStatus_NoProgression:
		return "NoProgression"
	case VendorItemStatus_NoUnlock:
		return "NoUnlock"
	case VendorItemStatus_NoQuantity:
		return "NoQuantity"
	case VendorItemStatus_OutsidePurchaseWindow:
		return "OutsidePurchaseWindow"
	case VendorItemStatus_NotAvailable:
		return "NotAvailable"
	case VendorItemStatus_UniquenessViolation:
		return "UniquenessViolation"
	case VendorItemStatus_UnknownError:
		return "UnknownError"
	case VendorItemStatus_AlreadySelling:
		return "AlreadySelling"
	case VendorItemStatus_Unsellable:
		return "Unsellable"
	case VendorItemStatus_SellingInhibited:
		return "SellingInhibited"
	case VendorItemStatus_AlreadyOwned:
		return "AlreadyOwned"
	case VendorItemStatus_DisplayOnly:
		return "DisplayOnly"
	}
	return fmt.Sprintf("VendorItemStatus_%d", e)
}

func (e PlatformErrorCodes) Enum() string {
	switch e {
	case PlatformErrorCodes_None:
		return "None"
	case PlatformErrorCodes_Success:
		return "Success"
	case PlatformErrorCodes_TransportException:
		return "TransportException"
	case PlatformErrorCodes_UnhandledException:
		return "UnhandledException"
	case PlatformErrorCodes_NotImplemented:
		return "NotImplemented"
	case PlatformErrorCodes_SystemDisabled:
		return "SystemDisabled"
	case PlatformErrorCodes_FailedToLoadAvailableLocalesConfiguration:
		return "FailedToLoadAvailableLocalesConfiguration"
	case PlatformErrorCodes_ParameterParseFailure:
		return "ParameterParseFailure"
	case PlatformErrorCodes_ParameterInvalidRange:
		return "ParameterInvalidRange"
	case PlatformErrorCodes_BadRequest:
		return "BadRequest"
	case PlatformErrorCodes_AuthenticationInvalid:
		return "AuthenticationInvalid"
	case PlatformErrorCodes_DataNotFound:
		return "DataNotFound"
	case PlatformErrorCodes_InsufficientPrivileges:
		return "InsufficientPrivileges"
	case PlatformErrorCodes_Duplicate:
		return "Duplicate"
	case PlatformErrorCodes_UnknownSqlResult:
		return "UnknownSqlResult"
	case PlatformErrorCodes_ValidationError:
		return "ValidationError"
	case PlatformErrorCodes_ValidationMissingFieldError:
		return "ValidationMissingFieldError"
	case PlatformErrorCodes_ValidationInvalidInputError:
		return "ValidationInvalidInputError"
	case PlatformErrorCodes_InvalidParameters:
		return "InvalidParameters"
	case PlatformErrorCodes_ParameterNotFound:
		return "ParameterNotFound"
	case PlatformErrorCodes_UnhandledHttpException:
		return "UnhandledHttpException"
	case PlatformErrorCodes_NotFound:
		return "NotFound"
	case PlatformErrorCodes_WebAuthModuleAsyncFailed:
		return "WebAuthModuleAsyncFailed"
	case PlatformErrorCodes_InvalidReturnValue:
		return "InvalidReturnValue"
	case PlatformErrorCodes_UserBanned:
		return "UserBanned"
	case PlatformErrorCodes_InvalidPostBody:
		return "InvalidPostBody"
	case PlatformErrorCodes_MissingPostBody:
		return "MissingPostBody"
	case PlatformErrorCodes_ExternalServiceTimeout:
		return "ExternalServiceTimeout"
	case PlatformErrorCodes_ValidationLengthError:
		return "ValidationLengthError"
	case PlatformErrorCodes_ValidationRangeError:
		return "ValidationRangeError"
	case PlatformErrorCodes_JsonDeserializationError:
		return "JsonDeserializationError"
	case PlatformErrorCodes_ThrottleLimitExceeded:
		return "ThrottleLimitExceeded"
	case PlatformErrorCodes_ValidationTagError:
		return "ValidationTagError"
	case PlatformErrorCodes_ValidationProfanityError:
		return "ValidationProfanityError"
	case PlatformErrorCodes_ValidationUrlFormatError:
		return "ValidationUrlFormatError"
	case PlatformErrorCodes_ThrottleLimitExceededMinutes:
		return "ThrottleLimitExceededMinutes"
	case PlatformErrorCodes_ThrottleLimitExceededMomentarily:
		return "ThrottleLimitExceededMomentarily"
	case PlatformErrorCodes_ThrottleLimitExceededSeconds:
		return "ThrottleLimitExceededSeconds"
	case PlatformErrorCodes_ExternalServiceUnknown:
		return "ExternalServiceUnknown"
	case PlatformErrorCodes_ValidationWordLengthError:
		return "ValidationWordLengthError"
	case PlatformErrorCodes_ValidationInvisibleUnicode:
		return "ValidationInvisibleUnicode"
	case PlatformErrorCodes_ValidationBadNames:
		return "ValidationBadNames"
	case PlatformErrorCodes_ExternalServiceFailed:
		return "ExternalServiceFailed"
	case PlatformErrorCodes_ServiceRetired:
		return "ServiceRetired"
	case PlatformErrorCodes_UnknownSqlException:
		return "UnknownSqlException"
	case PlatformErrorCodes_UnsupportedLocale:
		return "UnsupportedLocale"
	case PlatformErrorCodes_InvalidPageNumber:
		return "InvalidPageNumber"
	case PlatformErrorCodes_MaximumPageSizeExceeded:
		return "MaximumPageSizeExceeded"
	case PlatformErrorCodes_ServiceUnsupported:
		return "ServiceUnsupported"
	case PlatformErrorCodes_ValidationMaximumUnicodeCombiningCharacters:
		return "ValidationMaximumUnicodeCombiningCharacters"
	case PlatformErrorCodes_ValidationMaximumSequentialCarriageReturns:
		return "ValidationMaximumSequentialCarriageReturns"
	case PlatformErrorCodes_PerEndpointRequestThrottleExceeded:
		return "PerEndpointRequestThrottleExceeded"
	case PlatformErrorCodes_AuthContextCacheAssertion:
		return "AuthContextCacheAssertion"
	case PlatformErrorCodes_ExPlatformStringValidationError:
		return "ExPlatformStringValidationError"
	case PlatformErrorCodes_PerApplicationThrottleExceeded:
		return "PerApplicationThrottleExceeded"
	case PlatformErrorCodes_PerApplicationAnonymousThrottleExceeded:
		return "PerApplicationAnonymousThrottleExceeded"
	case PlatformErrorCodes_PerApplicationAuthenticatedThrottleExceeded:
		return "PerApplicationAuthenticatedThrottleExceeded"
	case PlatformErrorCodes_PerUserThrottleExceeded:
		return "PerUserThrottleExceeded"
	case PlatformErrorCodes_PayloadSignatureVerificationFailure:
		return "PayloadSignatureVerificationFailure"
	case PlatformErrorCodes_InvalidServiceAuthContext:
		return "InvalidServiceAuthContext"
	case PlatformErrorCodes_FailedMinimumAgeCheck:
		return "FailedMinimumAgeCheck"
	case PlatformErrorCodes_ObsoleteCredentialType:
		return "ObsoleteCredentialType"
	case PlatformErrorCodes_UnableToUnPairMobileApp:
		return "UnableToUnPairMobileApp"
	case PlatformErrorCodes_UnableToPairMobileApp:
		return "UnableToPairMobileApp"
	case PlatformErrorCodes_CannotUseMobileAuthWithNonMobileProvider:
		return "CannotUseMobileAuthWithNonMobileProvider"
	case PlatformErrorCodes_MissingDeviceCookie:
		return "MissingDeviceCookie"
	case PlatformErrorCodes_FacebookTokenExpired:
		return "FacebookTokenExpired"
	case PlatformErrorCodes_AuthTicketRequired:
		return "AuthTicketRequired"
	case PlatformErrorCodes_CookieContextRequired:
		return "CookieContextRequired"
	case PlatformErrorCodes_UnknownAuthenticationError:
		return "UnknownAuthenticationError"
	case PlatformErrorCodes_BungieNetAccountCreationRequired:
		return "BungieNetAccountCreationRequired"
	case PlatformErrorCodes_WebAuthRequired:
		return "WebAuthRequired"
	case PlatformErrorCodes_ContentUnknownSqlResult:
		return "ContentUnknownSqlResult"
	case PlatformErrorCodes_ContentNeedUniquePath:
		return "ContentNeedUniquePath"
	case PlatformErrorCodes_ContentSqlException:
		return "ContentSqlException"
	case PlatformErrorCodes_ContentNotFound:
		return "ContentNotFound"
	case PlatformErrorCodes_ContentSuccessWithTagAddFail:
		return "ContentSuccessWithTagAddFail"
	case PlatformErrorCodes_ContentSearchMissingParameters:
		return "ContentSearchMissingParameters"
	case PlatformErrorCodes_ContentInvalidId:
		return "ContentInvalidId"
	case PlatformErrorCodes_ContentPhysicalFileDeletionError:
		return "ContentPhysicalFileDeletionError"
	case PlatformErrorCodes_ContentPhysicalFileCreationError:
		return "ContentPhysicalFileCreationError"
	case PlatformErrorCodes_ContentPerforceSubmissionError:
		return "ContentPerforceSubmissionError"
	case PlatformErrorCodes_ContentPerforceInitializationError:
		return "ContentPerforceInitializationError"
	case PlatformErrorCodes_ContentDeploymentPackageNotReadyError:
		return "ContentDeploymentPackageNotReadyError"
	case PlatformErrorCodes_ContentUploadFailed:
		return "ContentUploadFailed"
	case PlatformErrorCodes_ContentTooManyResults:
		return "ContentTooManyResults"
	case PlatformErrorCodes_ContentInvalidState:
		return "ContentInvalidState"
	case PlatformErrorCodes_ContentNavigationParentNotFound:
		return "ContentNavigationParentNotFound"
	case PlatformErrorCodes_ContentNavigationParentUpdateError:
		return "ContentNavigationParentUpdateError"
	case PlatformErrorCodes_DeploymentPackageNotEditable:
		return "DeploymentPackageNotEditable"
	case PlatformErrorCodes_ContentValidationError:
		return "ContentValidationError"
	case PlatformErrorCodes_ContentPropertiesValidationError:
		return "ContentPropertiesValidationError"
	case PlatformErrorCodes_ContentTypeNotFound:
		return "ContentTypeNotFound"
	case PlatformErrorCodes_DeploymentPackageNotFound:
		return "DeploymentPackageNotFound"
	case PlatformErrorCodes_ContentSearchInvalidParameters:
		return "ContentSearchInvalidParameters"
	case PlatformErrorCodes_ContentItemPropertyAggregationError:
		return "ContentItemPropertyAggregationError"
	case PlatformErrorCodes_DeploymentPackageFileNotFound:
		return "DeploymentPackageFileNotFound"
	case PlatformErrorCodes_ContentPerforceFileHistoryNotFound:
		return "ContentPerforceFileHistoryNotFound"
	case PlatformErrorCodes_ContentAssetZipCreationFailure:
		return "ContentAssetZipCreationFailure"
	case PlatformErrorCodes_ContentAssetZipCreationBusy:
		return "ContentAssetZipCreationBusy"
	case PlatformErrorCodes_ContentProjectNotFound:
		return "ContentProjectNotFound"
	case PlatformErrorCodes_ContentFolderNotFound:
		return "ContentFolderNotFound"
	case PlatformErrorCodes_ContentPackagesInconsistent:
		return "ContentPackagesInconsistent"
	case PlatformErrorCodes_ContentPackagesInvalidState:
		return "ContentPackagesInvalidState"
	case PlatformErrorCodes_ContentPackagesInconsistentType:
		return "ContentPackagesInconsistentType"
	case PlatformErrorCodes_ContentCannotDeletePackage:
		return "ContentCannotDeletePackage"
	case PlatformErrorCodes_ContentLockedForChanges:
		return "ContentLockedForChanges"
	case PlatformErrorCodes_ContentFileUploadFailed:
		return "ContentFileUploadFailed"
	case PlatformErrorCodes_ContentNotReviewed:
		return "ContentNotReviewed"
	case PlatformErrorCodes_ContentPermissionDenied:
		return "ContentPermissionDenied"
	case PlatformErrorCodes_ContentInvalidExternalUrl:
		return "ContentInvalidExternalUrl"
	case PlatformErrorCodes_ContentExternalFileCannotBeImportedLocally:
		return "ContentExternalFileCannotBeImportedLocally"
	case PlatformErrorCodes_ContentTagSaveFailure:
		return "ContentTagSaveFailure"
	case PlatformErrorCodes_ContentPerforceUnmatchedFileError:
		return "ContentPerforceUnmatchedFileError"
	case PlatformErrorCodes_ContentPerforceChangelistResultNotFound:
		return "ContentPerforceChangelistResultNotFound"
	case PlatformErrorCodes_ContentPerforceChangelistFileItemsNotFound:
		return "ContentPerforceChangelistFileItemsNotFound"
	case PlatformErrorCodes_ContentPerforceInvalidRevisionError:
		return "ContentPerforceInvalidRevisionError"
	case PlatformErrorCodes_ContentUnloadedSaveResult:
		return "ContentUnloadedSaveResult"
	case PlatformErrorCodes_ContentPropertyInvalidNumber:
		return "ContentPropertyInvalidNumber"
	case PlatformErrorCodes_ContentPropertyInvalidUrl:
		return "ContentPropertyInvalidUrl"
	case PlatformErrorCodes_ContentPropertyInvalidDate:
		return "ContentPropertyInvalidDate"
	case PlatformErrorCodes_ContentPropertyInvalidSet:
		return "ContentPropertyInvalidSet"
	case PlatformErrorCodes_ContentPropertyCannotDeserialize:
		return "ContentPropertyCannotDeserialize"
	case PlatformErrorCodes_ContentRegexValidationFailOnProperty:
		return "ContentRegexValidationFailOnProperty"
	case PlatformErrorCodes_ContentMaxLengthFailOnProperty:
		return "ContentMaxLengthFailOnProperty"
	case PlatformErrorCodes_ContentPropertyUnexpectedDeserializationError:
		return "ContentPropertyUnexpectedDeserializationError"
	case PlatformErrorCodes_ContentPropertyRequired:
		return "ContentPropertyRequired"
	case PlatformErrorCodes_ContentCannotCreateFile:
		return "ContentCannotCreateFile"
	case PlatformErrorCodes_ContentInvalidMigrationFile:
		return "ContentInvalidMigrationFile"
	case PlatformErrorCodes_ContentMigrationAlteringProcessedItem:
		return "ContentMigrationAlteringProcessedItem"
	case PlatformErrorCodes_ContentPropertyDefinitionNotFound:
		return "ContentPropertyDefinitionNotFound"
	case PlatformErrorCodes_ContentReviewDataChanged:
		return "ContentReviewDataChanged"
	case PlatformErrorCodes_ContentRollbackRevisionNotInPackage:
		return "ContentRollbackRevisionNotInPackage"
	case PlatformErrorCodes_ContentItemNotBasedOnLatestRevision:
		return "ContentItemNotBasedOnLatestRevision"
	case PlatformErrorCodes_ContentUnauthorized:
		return "ContentUnauthorized"
	case PlatformErrorCodes_ContentCannotCreateDeploymentPackage:
		return "ContentCannotCreateDeploymentPackage"
	case PlatformErrorCodes_ContentUserNotFound:
		return "ContentUserNotFound"
	case PlatformErrorCodes_ContentLocalePermissionDenied:
		return "ContentLocalePermissionDenied"
	case PlatformErrorCodes_ContentInvalidLinkToInternalEnvironment:
		return "ContentInvalidLinkToInternalEnvironment"
	case PlatformErrorCodes_ContentInvalidBlacklistedContent:
		return "ContentInvalidBlacklistedContent"
	case PlatformErrorCodes_ContentMacroMalformedNoContentId:
		return "ContentMacroMalformedNoContentId"
	case PlatformErrorCodes_ContentMacroMalformedNoTemplateType:
		return "ContentMacroMalformedNoTemplateType"
	case PlatformErrorCodes_ContentIllegalBNetMembershipId:
		return "ContentIllegalBNetMembershipId"
	case PlatformErrorCodes_ContentLocaleDidNotMatchExpected:
		return "ContentLocaleDidNotMatchExpected"
	case PlatformErrorCodes_ContentBabelCallFailed:
		return "ContentBabelCallFailed"
	case PlatformErrorCodes_ContentEnglishPostLiveForbidden:
		return "ContentEnglishPostLiveForbidden"
	case PlatformErrorCodes_ContentLocaleEditPermissionDenied:
		return "ContentLocaleEditPermissionDenied"
	case PlatformErrorCodes_ContentStackUnknownError:
		return "ContentStackUnknownError"
	case PlatformErrorCodes_ContentStackNotFound:
		return "ContentStackNotFound"
	case PlatformErrorCodes_ContentStackRateLimited:
		return "ContentStackRateLimited"
	case PlatformErrorCodes_ContentStackTimeout:
		return "ContentStackTimeout"
	case PlatformErrorCodes_ContentStackServiceError:
		return "ContentStackServiceError"
	case PlatformErrorCodes_ContentStackDeserializationFailure:
		return "ContentStackDeserializationFailure"
	case PlatformErrorCodes_UserNonUniqueName:
		return "UserNonUniqueName"
	case PlatformErrorCodes_UserManualLinkingStepRequired:
		return "UserManualLinkingStepRequired"
	case PlatformErrorCodes_UserCreateUnknownSqlResult:
		return "UserCreateUnknownSqlResult"
	case PlatformErrorCodes_UserCreateUnknownSqlException:
		return "UserCreateUnknownSqlException"
	case PlatformErrorCodes_UserMalformedMembershipId:
		return "UserMalformedMembershipId"
	case PlatformErrorCodes_UserCannotFindRequestedUser:
		return "UserCannotFindRequestedUser"
	case PlatformErrorCodes_UserCannotLoadAccountCredentialLinkInfo:
		return "UserCannotLoadAccountCredentialLinkInfo"
	case PlatformErrorCodes_UserInvalidMobileAppType:
		return "UserInvalidMobileAppType"
	case PlatformErrorCodes_UserMissingMobilePairingInfo:
		return "UserMissingMobilePairingInfo"
	case PlatformErrorCodes_UserCannotGenerateMobileKeyWhileUsingMobileCredential:
		return "UserCannotGenerateMobileKeyWhileUsingMobileCredential"
	case PlatformErrorCodes_UserGenerateMobileKeyExistingSlotCollision:
		return "UserGenerateMobileKeyExistingSlotCollision"
	case PlatformErrorCodes_UserDisplayNameMissingOrInvalid:
		return "UserDisplayNameMissingOrInvalid"
	case PlatformErrorCodes_UserCannotLoadAccountProfileData:
		return "UserCannotLoadAccountProfileData"
	case PlatformErrorCodes_UserCannotSaveUserProfileData:
		return "UserCannotSaveUserProfileData"
	case PlatformErrorCodes_UserEmailMissingOrInvalid:
		return "UserEmailMissingOrInvalid"
	case PlatformErrorCodes_UserTermsOfUseRequired:
		return "UserTermsOfUseRequired"
	case PlatformErrorCodes_UserCannotCreateNewAccountWhileLoggedIn:
		return "UserCannotCreateNewAccountWhileLoggedIn"
	case PlatformErrorCodes_UserCannotResolveCentralAccount:
		return "UserCannotResolveCentralAccount"
	case PlatformErrorCodes_UserInvalidAvatar:
		return "UserInvalidAvatar"
	case PlatformErrorCodes_UserMissingCreatedUserResult:
		return "UserMissingCreatedUserResult"
	case PlatformErrorCodes_UserCannotChangeUniqueNameYet:
		return "UserCannotChangeUniqueNameYet"
	case PlatformErrorCodes_UserCannotChangeDisplayNameYet:
		return "UserCannotChangeDisplayNameYet"
	case PlatformErrorCodes_UserCannotChangeEmail:
		return "UserCannotChangeEmail"
	case PlatformErrorCodes_UserUniqueNameMustStartWithLetter:
		return "UserUniqueNameMustStartWithLetter"
	case PlatformErrorCodes_UserNoLinkedAccountsSupportFriendListings:
		return "UserNoLinkedAccountsSupportFriendListings"
	case PlatformErrorCodes_UserAcknowledgmentTableFull:
		return "UserAcknowledgmentTableFull"
	case PlatformErrorCodes_UserCreationDestinyMembershipRequired:
		return "UserCreationDestinyMembershipRequired"
	case PlatformErrorCodes_UserFriendsTokenNeedsRefresh:
		return "UserFriendsTokenNeedsRefresh"
	case PlatformErrorCodes_UserEmailValidationUnknown:
		return "UserEmailValidationUnknown"
	case PlatformErrorCodes_UserEmailValidationLimit:
		return "UserEmailValidationLimit"
	case PlatformErrorCodes_TransactionEmailSendFailure:
		return "TransactionEmailSendFailure"
	case PlatformErrorCodes_MailHookPermissionFailure:
		return "MailHookPermissionFailure"
	case PlatformErrorCodes_MailServiceRateLimit:
		return "MailServiceRateLimit"
	case PlatformErrorCodes_UserEmailMustBeVerified:
		return "UserEmailMustBeVerified"
	case PlatformErrorCodes_UserMustAllowCustomerServiceEmails:
		return "UserMustAllowCustomerServiceEmails"
	case PlatformErrorCodes_NonTransactionalEmailSendFailure:
		return "NonTransactionalEmailSendFailure"
	case PlatformErrorCodes_UnknownErrorSettingGlobalDisplayName:
		return "UnknownErrorSettingGlobalDisplayName"
	case PlatformErrorCodes_DuplicateGlobalDisplayName:
		return "DuplicateGlobalDisplayName"
	case PlatformErrorCodes_ErrorRunningNameValidationChecks:
		return "ErrorRunningNameValidationChecks"
	case PlatformErrorCodes_ErrorDatabaseGlobalName:
		return "ErrorDatabaseGlobalName"
	case PlatformErrorCodes_ErrorNoAvailableNameChanges:
		return "ErrorNoAvailableNameChanges"
	case PlatformErrorCodes_ErrorNameAlreadySetToInput:
		return "ErrorNameAlreadySetToInput"
	case PlatformErrorCodes_UserDisplayNameLessThanMinLength:
		return "UserDisplayNameLessThanMinLength"
	case PlatformErrorCodes_UserDisplayNameGreaterThanMaxLength:
		return "UserDisplayNameGreaterThanMaxLength"
	case PlatformErrorCodes_UserDisplayNameContainsUnacceptableOrInvalidContent:
		return "UserDisplayNameContainsUnacceptableOrInvalidContent"
	case PlatformErrorCodes_EmailValidationOffline:
		return "EmailValidationOffline"
	case PlatformErrorCodes_EmailValidationFailOldCode:
		return "EmailValidationFailOldCode"
	case PlatformErrorCodes_EmailValidationFailBadLink:
		return "EmailValidationFailBadLink"
	case PlatformErrorCodes_EmailUnsubscribeFail:
		return "EmailUnsubscribeFail"
	case PlatformErrorCodes_EmailUnsubscribeFailNew:
		return "EmailUnsubscribeFailNew"
	case PlatformErrorCodes_MessagingUnknownError:
		return "MessagingUnknownError"
	case PlatformErrorCodes_MessagingSelfError:
		return "MessagingSelfError"
	case PlatformErrorCodes_MessagingSendThrottle:
		return "MessagingSendThrottle"
	case PlatformErrorCodes_MessagingNoBody:
		return "MessagingNoBody"
	case PlatformErrorCodes_MessagingTooManyUsers:
		return "MessagingTooManyUsers"
	case PlatformErrorCodes_MessagingCanNotLeaveConversation:
		return "MessagingCanNotLeaveConversation"
	case PlatformErrorCodes_MessagingUnableToSend:
		return "MessagingUnableToSend"
	case PlatformErrorCodes_MessagingDeletedUserForbidden:
		return "MessagingDeletedUserForbidden"
	case PlatformErrorCodes_MessagingCannotDeleteExternalConversation:
		return "MessagingCannotDeleteExternalConversation"
	case PlatformErrorCodes_MessagingGroupChatDisabled:
		return "MessagingGroupChatDisabled"
	case PlatformErrorCodes_MessagingMustIncludeSelfInPrivateMessage:
		return "MessagingMustIncludeSelfInPrivateMessage"
	case PlatformErrorCodes_MessagingSenderIsBanned:
		return "MessagingSenderIsBanned"
	case PlatformErrorCodes_MessagingGroupOptionalChatExceededMaximum:
		return "MessagingGroupOptionalChatExceededMaximum"
	case PlatformErrorCodes_PrivateMessagingRequiresDestinyMembership:
		return "PrivateMessagingRequiresDestinyMembership"
	case PlatformErrorCodes_MessagingSendDailyThrottle:
		return "MessagingSendDailyThrottle"
	case PlatformErrorCodes_AddSurveyAnswersUnknownSqlException:
		return "AddSurveyAnswersUnknownSqlException"
	case PlatformErrorCodes_ForumBodyCannotBeEmpty:
		return "ForumBodyCannotBeEmpty"
	case PlatformErrorCodes_ForumSubjectCannotBeEmptyOnTopicPost:
		return "ForumSubjectCannotBeEmptyOnTopicPost"
	case PlatformErrorCodes_ForumCannotLocateParentPost:
		return "ForumCannotLocateParentPost"
	case PlatformErrorCodes_ForumThreadLockedForReplies:
		return "ForumThreadLockedForReplies"
	case PlatformErrorCodes_ForumUnknownSqlResultDuringCreatePost:
		return "ForumUnknownSqlResultDuringCreatePost"
	case PlatformErrorCodes_ForumUnknownTagCreationError:
		return "ForumUnknownTagCreationError"
	case PlatformErrorCodes_ForumUnknownSqlResultDuringTagItem:
		return "ForumUnknownSqlResultDuringTagItem"
	case PlatformErrorCodes_ForumUnknownExceptionCreatePost:
		return "ForumUnknownExceptionCreatePost"
	case PlatformErrorCodes_ForumQuestionMustBeTopicPost:
		return "ForumQuestionMustBeTopicPost"
	case PlatformErrorCodes_ForumExceptionDuringTagSearch:
		return "ForumExceptionDuringTagSearch"
	case PlatformErrorCodes_ForumExceptionDuringTopicRetrieval:
		return "ForumExceptionDuringTopicRetrieval"
	case PlatformErrorCodes_ForumAliasedTagError:
		return "ForumAliasedTagError"
	case PlatformErrorCodes_ForumCannotLocateThread:
		return "ForumCannotLocateThread"
	case PlatformErrorCodes_ForumUnknownExceptionEditPost:
		return "ForumUnknownExceptionEditPost"
	case PlatformErrorCodes_ForumCannotLocatePost:
		return "ForumCannotLocatePost"
	case PlatformErrorCodes_ForumUnknownExceptionGetOrCreateTags:
		return "ForumUnknownExceptionGetOrCreateTags"
	case PlatformErrorCodes_ForumEditPermissionDenied:
		return "ForumEditPermissionDenied"
	case PlatformErrorCodes_ForumUnknownSqlResultDuringTagIdRetrieval:
		return "ForumUnknownSqlResultDuringTagIdRetrieval"
	case PlatformErrorCodes_ForumCannotGetRating:
		return "ForumCannotGetRating"
	case PlatformErrorCodes_ForumUnknownExceptionGetRating:
		return "ForumUnknownExceptionGetRating"
	case PlatformErrorCodes_ForumRatingsAccessError:
		return "ForumRatingsAccessError"
	case PlatformErrorCodes_ForumRelatedPostAccessError:
		return "ForumRelatedPostAccessError"
	case PlatformErrorCodes_ForumLatestReplyAccessError:
		return "ForumLatestReplyAccessError"
	case PlatformErrorCodes_ForumUserStatusAccessError:
		return "ForumUserStatusAccessError"
	case PlatformErrorCodes_ForumAuthorAccessError:
		return "ForumAuthorAccessError"
	case PlatformErrorCodes_ForumGroupAccessError:
		return "ForumGroupAccessError"
	case PlatformErrorCodes_ForumUrlExpectedButMissing:
		return "ForumUrlExpectedButMissing"
	case PlatformErrorCodes_ForumRepliesCannotBeEmpty:
		return "ForumRepliesCannotBeEmpty"
	case PlatformErrorCodes_ForumRepliesCannotBeInDifferentGroups:
		return "ForumRepliesCannotBeInDifferentGroups"
	case PlatformErrorCodes_ForumSubTopicCannotBeCreatedAtThisThreadLevel:
		return "ForumSubTopicCannotBeCreatedAtThisThreadLevel"
	case PlatformErrorCodes_ForumCannotCreateContentTopic:
		return "ForumCannotCreateContentTopic"
	case PlatformErrorCodes_ForumTopicDoesNotExist:
		return "ForumTopicDoesNotExist"
	case PlatformErrorCodes_ForumContentCommentsNotAllowed:
		return "ForumContentCommentsNotAllowed"
	case PlatformErrorCodes_ForumUnknownSqlResultDuringEditPost:
		return "ForumUnknownSqlResultDuringEditPost"
	case PlatformErrorCodes_ForumUnknownSqlResultDuringGetPost:
		return "ForumUnknownSqlResultDuringGetPost"
	case PlatformErrorCodes_ForumPostValidationBadUrl:
		return "ForumPostValidationBadUrl"
	case PlatformErrorCodes_ForumBodyTooLong:
		return "ForumBodyTooLong"
	case PlatformErrorCodes_ForumSubjectTooLong:
		return "ForumSubjectTooLong"
	case PlatformErrorCodes_ForumAnnouncementNotAllowed:
		return "ForumAnnouncementNotAllowed"
	case PlatformErrorCodes_ForumCannotShareOwnPost:
		return "ForumCannotShareOwnPost"
	case PlatformErrorCodes_ForumEditNoOp:
		return "ForumEditNoOp"
	case PlatformErrorCodes_ForumUnknownDatabaseErrorDuringGetPost:
		return "ForumUnknownDatabaseErrorDuringGetPost"
	case PlatformErrorCodes_ForumExceeedMaximumRowLimit:
		return "ForumExceeedMaximumRowLimit"
	case PlatformErrorCodes_ForumCannotSharePrivatePost:
		return "ForumCannotSharePrivatePost"
	case PlatformErrorCodes_ForumCannotCrossPostBetweenGroups:
		return "ForumCannotCrossPostBetweenGroups"
	case PlatformErrorCodes_ForumIncompatibleCategories:
		return "ForumIncompatibleCategories"
	case PlatformErrorCodes_ForumCannotUseTheseCategoriesOnNonTopicPost:
		return "ForumCannotUseTheseCategoriesOnNonTopicPost"
	case PlatformErrorCodes_ForumCanOnlyDeleteTopics:
		return "ForumCanOnlyDeleteTopics"
	case PlatformErrorCodes_ForumDeleteSqlException:
		return "ForumDeleteSqlException"
	case PlatformErrorCodes_ForumDeleteSqlUnknownResult:
		return "ForumDeleteSqlUnknownResult"
	case PlatformErrorCodes_ForumTooManyTags:
		return "ForumTooManyTags"
	case PlatformErrorCodes_ForumCanOnlyRateTopics:
		return "ForumCanOnlyRateTopics"
	case PlatformErrorCodes_ForumBannedPostsCannotBeEdited:
		return "ForumBannedPostsCannotBeEdited"
	case PlatformErrorCodes_ForumThreadRootIsBanned:
		return "ForumThreadRootIsBanned"
	case PlatformErrorCodes_ForumCannotUseOfficialTagCategoryAsTag:
		return "ForumCannotUseOfficialTagCategoryAsTag"
	case PlatformErrorCodes_ForumAnswerCannotBeMadeOnCreatePost:
		return "ForumAnswerCannotBeMadeOnCreatePost"
	case PlatformErrorCodes_ForumAnswerCannotBeMadeOnEditPost:
		return "ForumAnswerCannotBeMadeOnEditPost"
	case PlatformErrorCodes_ForumAnswerPostIdIsNotADirectReplyOfQuestion:
		return "ForumAnswerPostIdIsNotADirectReplyOfQuestion"
	case PlatformErrorCodes_ForumAnswerTopicIdIsNotAQuestion:
		return "ForumAnswerTopicIdIsNotAQuestion"
	case PlatformErrorCodes_ForumUnknownExceptionDuringMarkAnswer:
		return "ForumUnknownExceptionDuringMarkAnswer"
	case PlatformErrorCodes_ForumUnknownSqlResultDuringMarkAnswer:
		return "ForumUnknownSqlResultDuringMarkAnswer"
	case PlatformErrorCodes_ForumCannotRateYourOwnPosts:
		return "ForumCannotRateYourOwnPosts"
	case PlatformErrorCodes_ForumPollsMustBeTheFirstPostInTopic:
		return "ForumPollsMustBeTheFirstPostInTopic"
	case PlatformErrorCodes_ForumInvalidPollInput:
		return "ForumInvalidPollInput"
	case PlatformErrorCodes_ForumGroupAdminEditNonMember:
		return "ForumGroupAdminEditNonMember"
	case PlatformErrorCodes_ForumCannotEditModeratorEditedPost:
		return "ForumCannotEditModeratorEditedPost"
	case PlatformErrorCodes_ForumRequiresDestinyMembership:
		return "ForumRequiresDestinyMembership"
	case PlatformErrorCodes_ForumUnexpectedError:
		return "ForumUnexpectedError"
	case PlatformErrorCodes_ForumAgeLock:
		return "ForumAgeLock"
	case PlatformErrorCodes_ForumMaxPages:
		return "ForumMaxPages"
	case PlatformErrorCodes_ForumMaxPagesOldestFirst:
		return "ForumMaxPagesOldestFirst"
	case PlatformErrorCodes_ForumCannotApplyForumIdWithoutTags:
		return "ForumCannotApplyForumIdWithoutTags"
	case PlatformErrorCodes_ForumCannotApplyForumIdToNonTopics:
		return "ForumCannotApplyForumIdToNonTopics"
	case PlatformErrorCodes_ForumCannotDownvoteCommunityCreations:
		return "ForumCannotDownvoteCommunityCreations"
	case PlatformErrorCodes_ForumTopicsMustHaveOfficialCategory:
		return "ForumTopicsMustHaveOfficialCategory"
	case PlatformErrorCodes_ForumRecruitmentTopicMalformed:
		return "ForumRecruitmentTopicMalformed"
	case PlatformErrorCodes_ForumRecruitmentTopicNotFound:
		return "ForumRecruitmentTopicNotFound"
	case PlatformErrorCodes_ForumRecruitmentTopicNoSlotsRemaining:
		return "ForumRecruitmentTopicNoSlotsRemaining"
	case PlatformErrorCodes_ForumRecruitmentTopicKickBan:
		return "ForumRecruitmentTopicKickBan"
	case PlatformErrorCodes_ForumRecruitmentTopicRequirementsNotMet:
		return "ForumRecruitmentTopicRequirementsNotMet"
	case PlatformErrorCodes_ForumRecruitmentTopicNoPlayers:
		return "ForumRecruitmentTopicNoPlayers"
	case PlatformErrorCodes_ForumRecruitmentApproveFailMessageBan:
		return "ForumRecruitmentApproveFailMessageBan"
	case PlatformErrorCodes_ForumRecruitmentGlobalBan:
		return "ForumRecruitmentGlobalBan"
	case PlatformErrorCodes_ForumUserBannedFromThisTopic:
		return "ForumUserBannedFromThisTopic"
	case PlatformErrorCodes_ForumRecruitmentFireteamMembersOnly:
		return "ForumRecruitmentFireteamMembersOnly"
	case PlatformErrorCodes_ForumRequiresDestiny2Progress:
		return "ForumRequiresDestiny2Progress"
	case PlatformErrorCodes_ForumRequiresDestiny2EntitlementPurchase:
		return "ForumRequiresDestiny2EntitlementPurchase"
	case PlatformErrorCodes_GroupMembershipApplicationAlreadyResolved:
		return "GroupMembershipApplicationAlreadyResolved"
	case PlatformErrorCodes_GroupMembershipAlreadyApplied:
		return "GroupMembershipAlreadyApplied"
	case PlatformErrorCodes_GroupMembershipInsufficientPrivileges:
		return "GroupMembershipInsufficientPrivileges"
	case PlatformErrorCodes_GroupIdNotReturnedFromCreation:
		return "GroupIdNotReturnedFromCreation"
	case PlatformErrorCodes_GroupSearchInvalidParameters:
		return "GroupSearchInvalidParameters"
	case PlatformErrorCodes_GroupMembershipPendingApplicationNotFound:
		return "GroupMembershipPendingApplicationNotFound"
	case PlatformErrorCodes_GroupInvalidId:
		return "GroupInvalidId"
	case PlatformErrorCodes_GroupInvalidMembershipId:
		return "GroupInvalidMembershipId"
	case PlatformErrorCodes_GroupInvalidMembershipType:
		return "GroupInvalidMembershipType"
	case PlatformErrorCodes_GroupMissingTags:
		return "GroupMissingTags"
	case PlatformErrorCodes_GroupMembershipNotFound:
		return "GroupMembershipNotFound"
	case PlatformErrorCodes_GroupInvalidRating:
		return "GroupInvalidRating"
	case PlatformErrorCodes_GroupUserFollowingAccessError:
		return "GroupUserFollowingAccessError"
	case PlatformErrorCodes_GroupUserMembershipAccessError:
		return "GroupUserMembershipAccessError"
	case PlatformErrorCodes_GroupCreatorAccessError:
		return "GroupCreatorAccessError"
	case PlatformErrorCodes_GroupAdminAccessError:
		return "GroupAdminAccessError"
	case PlatformErrorCodes_GroupPrivatePostNotViewable:
		return "GroupPrivatePostNotViewable"
	case PlatformErrorCodes_GroupMembershipNotLoggedIn:
		return "GroupMembershipNotLoggedIn"
	case PlatformErrorCodes_GroupNotDeleted:
		return "GroupNotDeleted"
	case PlatformErrorCodes_GroupUnknownErrorUndeletingGroup:
		return "GroupUnknownErrorUndeletingGroup"
	case PlatformErrorCodes_GroupDeleted:
		return "GroupDeleted"
	case PlatformErrorCodes_GroupNotFound:
		return "GroupNotFound"
	case PlatformErrorCodes_GroupMemberBanned:
		return "GroupMemberBanned"
	case PlatformErrorCodes_GroupMembershipClosed:
		return "GroupMembershipClosed"
	case PlatformErrorCodes_GroupPrivatePostOverrideError:
		return "GroupPrivatePostOverrideError"
	case PlatformErrorCodes_GroupNameTaken:
		return "GroupNameTaken"
	case PlatformErrorCodes_GroupDeletionGracePeriodExpired:
		return "GroupDeletionGracePeriodExpired"
	case PlatformErrorCodes_GroupCannotCheckBanStatus:
		return "GroupCannotCheckBanStatus"
	case PlatformErrorCodes_GroupMaximumMembershipCountReached:
		return "GroupMaximumMembershipCountReached"
	case PlatformErrorCodes_NoDestinyAccountForClanPlatform:
		return "NoDestinyAccountForClanPlatform"
	case PlatformErrorCodes_AlreadyRequestingMembershipForClanPlatform:
		return "AlreadyRequestingMembershipForClanPlatform"
	case PlatformErrorCodes_AlreadyClanMemberOnPlatform:
		return "AlreadyClanMemberOnPlatform"
	case PlatformErrorCodes_GroupJoinedCannotSetClanName:
		return "GroupJoinedCannotSetClanName"
	case PlatformErrorCodes_GroupLeftCannotClearClanName:
		return "GroupLeftCannotClearClanName"
	case PlatformErrorCodes_GroupRelationshipRequestPending:
		return "GroupRelationshipRequestPending"
	case PlatformErrorCodes_GroupRelationshipRequestBlocked:
		return "GroupRelationshipRequestBlocked"
	case PlatformErrorCodes_GroupRelationshipRequestNotFound:
		return "GroupRelationshipRequestNotFound"
	case PlatformErrorCodes_GroupRelationshipBlockNotFound:
		return "GroupRelationshipBlockNotFound"
	case PlatformErrorCodes_GroupRelationshipNotFound:
		return "GroupRelationshipNotFound"
	case PlatformErrorCodes_GroupAlreadyAllied:
		return "GroupAlreadyAllied"
	case PlatformErrorCodes_GroupAlreadyMember:
		return "GroupAlreadyMember"
	case PlatformErrorCodes_GroupRelationshipAlreadyExists:
		return "GroupRelationshipAlreadyExists"
	case PlatformErrorCodes_InvalidGroupTypesForRelationshipRequest:
		return "InvalidGroupTypesForRelationshipRequest"
	case PlatformErrorCodes_GroupAtMaximumAlliances:
		return "GroupAtMaximumAlliances"
	case PlatformErrorCodes_GroupCannotSetClanOnlySettings:
		return "GroupCannotSetClanOnlySettings"
	case PlatformErrorCodes_ClanCannotSetTwoDefaultPostTypes:
		return "ClanCannotSetTwoDefaultPostTypes"
	case PlatformErrorCodes_GroupMemberInvalidMemberType:
		return "GroupMemberInvalidMemberType"
	case PlatformErrorCodes_GroupInvalidPlatformType:
		return "GroupInvalidPlatformType"
	case PlatformErrorCodes_GroupMemberInvalidSort:
		return "GroupMemberInvalidSort"
	case PlatformErrorCodes_GroupInvalidResolveState:
		return "GroupInvalidResolveState"
	case PlatformErrorCodes_ClanAlreadyEnabledForPlatform:
		return "ClanAlreadyEnabledForPlatform"
	case PlatformErrorCodes_ClanNotEnabledForPlatform:
		return "ClanNotEnabledForPlatform"
	case PlatformErrorCodes_ClanEnabledButCouldNotJoinNoAccount:
		return "ClanEnabledButCouldNotJoinNoAccount"
	case PlatformErrorCodes_ClanEnabledButCouldNotJoinAlreadyMember:
		return "ClanEnabledButCouldNotJoinAlreadyMember"
	case PlatformErrorCodes_ClanCannotJoinNoCredential:
		return "ClanCannotJoinNoCredential"
	case PlatformErrorCodes_NoClanMembershipForPlatform:
		return "NoClanMembershipForPlatform"
	case PlatformErrorCodes_GroupToGroupFollowLimitReached:
		return "GroupToGroupFollowLimitReached"
	case PlatformErrorCodes_ChildGroupAlreadyInAlliance:
		return "ChildGroupAlreadyInAlliance"
	case PlatformErrorCodes_OwnerGroupAlreadyInAlliance:
		return "OwnerGroupAlreadyInAlliance"
	case PlatformErrorCodes_AllianceOwnerCannotJoinAlliance:
		return "AllianceOwnerCannotJoinAlliance"
	case PlatformErrorCodes_GroupNotInAlliance:
		return "GroupNotInAlliance"
	case PlatformErrorCodes_ChildGroupCannotInviteToAlliance:
		return "ChildGroupCannotInviteToAlliance"
	case PlatformErrorCodes_GroupToGroupAlreadyFollowed:
		return "GroupToGroupAlreadyFollowed"
	case PlatformErrorCodes_GroupToGroupNotFollowing:
		return "GroupToGroupNotFollowing"
	case PlatformErrorCodes_ClanMaximumMembershipReached:
		return "ClanMaximumMembershipReached"
	case PlatformErrorCodes_ClanNameNotValid:
		return "ClanNameNotValid"
	case PlatformErrorCodes_ClanNameNotValidError:
		return "ClanNameNotValidError"
	case PlatformErrorCodes_AllianceOwnerNotDefined:
		return "AllianceOwnerNotDefined"
	case PlatformErrorCodes_AllianceChildNotDefined:
		return "AllianceChildNotDefined"
	case PlatformErrorCodes_ClanCultureIllegalCharacters:
		return "ClanCultureIllegalCharacters"
	case PlatformErrorCodes_ClanTagIllegalCharacters:
		return "ClanTagIllegalCharacters"
	case PlatformErrorCodes_ClanRequiresInvitation:
		return "ClanRequiresInvitation"
	case PlatformErrorCodes_ClanMembershipClosed:
		return "ClanMembershipClosed"
	case PlatformErrorCodes_ClanInviteAlreadyMember:
		return "ClanInviteAlreadyMember"
	case PlatformErrorCodes_GroupInviteAlreadyMember:
		return "GroupInviteAlreadyMember"
	case PlatformErrorCodes_GroupJoinApprovalRequired:
		return "GroupJoinApprovalRequired"
	case PlatformErrorCodes_ClanTagRequired:
		return "ClanTagRequired"
	case PlatformErrorCodes_GroupNameCannotStartOrEndWithWhiteSpace:
		return "GroupNameCannotStartOrEndWithWhiteSpace"
	case PlatformErrorCodes_ClanCallsignCannotStartOrEndWithWhiteSpace:
		return "ClanCallsignCannotStartOrEndWithWhiteSpace"
	case PlatformErrorCodes_ClanMigrationFailed:
		return "ClanMigrationFailed"
	case PlatformErrorCodes_ClanNotEnabledAlreadyMemberOfAnotherClan:
		return "ClanNotEnabledAlreadyMemberOfAnotherClan"
	case PlatformErrorCodes_GroupModerationNotPermittedOnNonMembers:
		return "GroupModerationNotPermittedOnNonMembers"
	case PlatformErrorCodes_ClanCreationInWorldServerFailed:
		return "ClanCreationInWorldServerFailed"
	case PlatformErrorCodes_ClanNotFound:
		return "ClanNotFound"
	case PlatformErrorCodes_ClanMembershipLevelDoesNotPermitThatAction:
		return "ClanMembershipLevelDoesNotPermitThatAction"
	case PlatformErrorCodes_ClanMemberNotFound:
		return "ClanMemberNotFound"
	case PlatformErrorCodes_ClanMissingMembershipApprovers:
		return "ClanMissingMembershipApprovers"
	case PlatformErrorCodes_ClanInWrongStateForRequestedAction:
		return "ClanInWrongStateForRequestedAction"
	case PlatformErrorCodes_ClanNameAlreadyUsed:
		return "ClanNameAlreadyUsed"
	case PlatformErrorCodes_ClanTooFewMembers:
		return "ClanTooFewMembers"
	case PlatformErrorCodes_ClanInfoCannotBeWhitespace:
		return "ClanInfoCannotBeWhitespace"
	case PlatformErrorCodes_GroupCultureThrottle:
		return "GroupCultureThrottle"
	case PlatformErrorCodes_ClanTargetDisallowsInvites:
		return "ClanTargetDisallowsInvites"
	case PlatformErrorCodes_ClanInvalidOperation:
		return "ClanInvalidOperation"
	case PlatformErrorCodes_ClanFounderCannotLeaveWithoutAbdication:
		return "ClanFounderCannotLeaveWithoutAbdication"
	case PlatformErrorCodes_ClanNameReserved:
		return "ClanNameReserved"
	case PlatformErrorCodes_ClanApplicantInClanSoNowInvited:
		return "ClanApplicantInClanSoNowInvited"
	case PlatformErrorCodes_ActivitiesUnknownException:
		return "ActivitiesUnknownException"
	case PlatformErrorCodes_ActivitiesParameterNull:
		return "ActivitiesParameterNull"
	case PlatformErrorCodes_ActivityCountsDiabled:
		return "ActivityCountsDiabled"
	case PlatformErrorCodes_ActivitySearchInvalidParameters:
		return "ActivitySearchInvalidParameters"
	case PlatformErrorCodes_ActivityPermissionDenied:
		return "ActivityPermissionDenied"
	case PlatformErrorCodes_ShareAlreadyShared:
		return "ShareAlreadyShared"
	case PlatformErrorCodes_ActivityLoggingDisabled:
		return "ActivityLoggingDisabled"
	case PlatformErrorCodes_ClanRequiresExistingDestinyAccount:
		return "ClanRequiresExistingDestinyAccount"
	case PlatformErrorCodes_ClanNameRestricted:
		return "ClanNameRestricted"
	case PlatformErrorCodes_ClanCreationBan:
		return "ClanCreationBan"
	case PlatformErrorCodes_ClanCreationTenureRequirementsNotMet:
		return "ClanCreationTenureRequirementsNotMet"
	case PlatformErrorCodes_ClanFieldContainsReservedTerms:
		return "ClanFieldContainsReservedTerms"
	case PlatformErrorCodes_ClanFieldContainsInappropriateContent:
		return "ClanFieldContainsInappropriateContent"
	case PlatformErrorCodes_ItemAlreadyFollowed:
		return "ItemAlreadyFollowed"
	case PlatformErrorCodes_ItemNotFollowed:
		return "ItemNotFollowed"
	case PlatformErrorCodes_CannotFollowSelf:
		return "CannotFollowSelf"
	case PlatformErrorCodes_GroupFollowLimitExceeded:
		return "GroupFollowLimitExceeded"
	case PlatformErrorCodes_TagFollowLimitExceeded:
		return "TagFollowLimitExceeded"
	case PlatformErrorCodes_UserFollowLimitExceeded:
		return "UserFollowLimitExceeded"
	case PlatformErrorCodes_FollowUnsupportedEntityType:
		return "FollowUnsupportedEntityType"
	case PlatformErrorCodes_NoValidTagsInList:
		return "NoValidTagsInList"
	case PlatformErrorCodes_BelowMinimumSuggestionLength:
		return "BelowMinimumSuggestionLength"
	case PlatformErrorCodes_CannotGetSuggestionsOnMultipleTagsSimultaneously:
		return "CannotGetSuggestionsOnMultipleTagsSimultaneously"
	case PlatformErrorCodes_NotAValidPartialTag:
		return "NotAValidPartialTag"
	case PlatformErrorCodes_TagSuggestionsUnknownSqlResult:
		return "TagSuggestionsUnknownSqlResult"
	case PlatformErrorCodes_TagsUnableToLoadPopularTagsFromDatabase:
		return "TagsUnableToLoadPopularTagsFromDatabase"
	case PlatformErrorCodes_TagInvalid:
		return "TagInvalid"
	case PlatformErrorCodes_TagNotFound:
		return "TagNotFound"
	case PlatformErrorCodes_SingleTagExpected:
		return "SingleTagExpected"
	case PlatformErrorCodes_TagsExceededMaximumPerItem:
		return "TagsExceededMaximumPerItem"
	case PlatformErrorCodes_IgnoreInvalidParameters:
		return "IgnoreInvalidParameters"
	case PlatformErrorCodes_IgnoreSqlException:
		return "IgnoreSqlException"
	case PlatformErrorCodes_IgnoreErrorRetrievingGroupPermissions:
		return "IgnoreErrorRetrievingGroupPermissions"
	case PlatformErrorCodes_IgnoreErrorInsufficientPermission:
		return "IgnoreErrorInsufficientPermission"
	case PlatformErrorCodes_IgnoreErrorRetrievingItem:
		return "IgnoreErrorRetrievingItem"
	case PlatformErrorCodes_IgnoreCannotIgnoreSelf:
		return "IgnoreCannotIgnoreSelf"
	case PlatformErrorCodes_IgnoreIllegalType:
		return "IgnoreIllegalType"
	case PlatformErrorCodes_IgnoreNotFound:
		return "IgnoreNotFound"
	case PlatformErrorCodes_IgnoreUserGloballyIgnored:
		return "IgnoreUserGloballyIgnored"
	case PlatformErrorCodes_IgnoreUserIgnored:
		return "IgnoreUserIgnored"
	case PlatformErrorCodes_TargetUserIgnored:
		return "TargetUserIgnored"
	case PlatformErrorCodes_NotificationSettingInvalid:
		return "NotificationSettingInvalid"
	case PlatformErrorCodes_PsnApiExpiredAccessToken:
		return "PsnApiExpiredAccessToken"
	case PlatformErrorCodes_PSNExForbidden:
		return "PSNExForbidden"
	case PlatformErrorCodes_PSNExSystemDisabled:
		return "PSNExSystemDisabled"
	case PlatformErrorCodes_PsnApiErrorCodeUnknown:
		return "PsnApiErrorCodeUnknown"
	case PlatformErrorCodes_PsnApiErrorWebException:
		return "PsnApiErrorWebException"
	case PlatformErrorCodes_PsnApiBadRequest:
		return "PsnApiBadRequest"
	case PlatformErrorCodes_PsnApiAccessTokenRequired:
		return "PsnApiAccessTokenRequired"
	case PlatformErrorCodes_PsnApiInvalidAccessToken:
		return "PsnApiInvalidAccessToken"
	case PlatformErrorCodes_PsnApiBannedUser:
		return "PsnApiBannedUser"
	case PlatformErrorCodes_PsnApiAccountUpgradeRequired:
		return "PsnApiAccountUpgradeRequired"
	case PlatformErrorCodes_PsnApiServiceTemporarilyUnavailable:
		return "PsnApiServiceTemporarilyUnavailable"
	case PlatformErrorCodes_PsnApiServerBusy:
		return "PsnApiServerBusy"
	case PlatformErrorCodes_PsnApiUnderMaintenance:
		return "PsnApiUnderMaintenance"
	case PlatformErrorCodes_PsnApiProfileUserNotFound:
		return "PsnApiProfileUserNotFound"
	case PlatformErrorCodes_PsnApiProfilePrivacyRestriction:
		return "PsnApiProfilePrivacyRestriction"
	case PlatformErrorCodes_PsnApiProfileUnderMaintenance:
		return "PsnApiProfileUnderMaintenance"
	case PlatformErrorCodes_PsnApiAccountAttributeMissing:
		return "PsnApiAccountAttributeMissing"
	case PlatformErrorCodes_PsnApiNoPermission:
		return "PsnApiNoPermission"
	case PlatformErrorCodes_PsnApiTargetUserBlocked:
		return "PsnApiTargetUserBlocked"
	case PlatformErrorCodes_PsnApiJwksMissing:
		return "PsnApiJwksMissing"
	case PlatformErrorCodes_PsnApiJwtMalformedHeader:
		return "PsnApiJwtMalformedHeader"
	case PlatformErrorCodes_PsnApiJwtMalformedPayload:
		return "PsnApiJwtMalformedPayload"
	case PlatformErrorCodes_XblExSystemDisabled:
		return "XblExSystemDisabled"
	case PlatformErrorCodes_XblExUnknownError:
		return "XblExUnknownError"
	case PlatformErrorCodes_XblApiErrorWebException:
		return "XblApiErrorWebException"
	case PlatformErrorCodes_XblStsTokenInvalid:
		return "XblStsTokenInvalid"
	case PlatformErrorCodes_XblStsMissingToken:
		return "XblStsMissingToken"
	case PlatformErrorCodes_XblStsExpiredToken:
		return "XblStsExpiredToken"
	case PlatformErrorCodes_XblAccessToTheSandboxDenied:
		return "XblAccessToTheSandboxDenied"
	case PlatformErrorCodes_XblMsaResponseMissing:
		return "XblMsaResponseMissing"
	case PlatformErrorCodes_XblMsaAccessTokenExpired:
		return "XblMsaAccessTokenExpired"
	case PlatformErrorCodes_XblMsaInvalidRequest:
		return "XblMsaInvalidRequest"
	case PlatformErrorCodes_XblMsaFriendsRequireSignIn:
		return "XblMsaFriendsRequireSignIn"
	case PlatformErrorCodes_XblUserActionRequired:
		return "XblUserActionRequired"
	case PlatformErrorCodes_XblParentalControls:
		return "XblParentalControls"
	case PlatformErrorCodes_XblDeveloperAccount:
		return "XblDeveloperAccount"
	case PlatformErrorCodes_XblUserTokenExpired:
		return "XblUserTokenExpired"
	case PlatformErrorCodes_XblUserTokenInvalid:
		return "XblUserTokenInvalid"
	case PlatformErrorCodes_XblOffline:
		return "XblOffline"
	case PlatformErrorCodes_XblUnknownErrorCode:
		return "XblUnknownErrorCode"
	case PlatformErrorCodes_XblMsaInvalidGrant:
		return "XblMsaInvalidGrant"
	case PlatformErrorCodes_ReportNotYetResolved:
		return "ReportNotYetResolved"
	case PlatformErrorCodes_ReportOverturnDoesNotChangeDecision:
		return "ReportOverturnDoesNotChangeDecision"
	case PlatformErrorCodes_ReportNotFound:
		return "ReportNotFound"
	case PlatformErrorCodes_ReportAlreadyReported:
		return "ReportAlreadyReported"
	case PlatformErrorCodes_ReportInvalidResolution:
		return "ReportInvalidResolution"
	case PlatformErrorCodes_ReportNotAssignedToYou:
		return "ReportNotAssignedToYou"
	case PlatformErrorCodes_LegacyGameStatsSystemDisabled:
		return "LegacyGameStatsSystemDisabled"
	case PlatformErrorCodes_LegacyGameStatsUnknownError:
		return "LegacyGameStatsUnknownError"
	case PlatformErrorCodes_LegacyGameStatsMalformedSneakerNetCode:
		return "LegacyGameStatsMalformedSneakerNetCode"
	case PlatformErrorCodes_DestinyAccountAcquisitionFailure:
		return "DestinyAccountAcquisitionFailure"
	case PlatformErrorCodes_DestinyAccountNotFound:
		return "DestinyAccountNotFound"
	case PlatformErrorCodes_DestinyBuildStatsDatabaseError:
		return "DestinyBuildStatsDatabaseError"
	case PlatformErrorCodes_DestinyCharacterStatsDatabaseError:
		return "DestinyCharacterStatsDatabaseError"
	case PlatformErrorCodes_DestinyPvPStatsDatabaseError:
		return "DestinyPvPStatsDatabaseError"
	case PlatformErrorCodes_DestinyPvEStatsDatabaseError:
		return "DestinyPvEStatsDatabaseError"
	case PlatformErrorCodes_DestinyGrimoireStatsDatabaseError:
		return "DestinyGrimoireStatsDatabaseError"
	case PlatformErrorCodes_DestinyStatsParameterMembershipTypeParseError:
		return "DestinyStatsParameterMembershipTypeParseError"
	case PlatformErrorCodes_DestinyStatsParameterMembershipIdParseError:
		return "DestinyStatsParameterMembershipIdParseError"
	case PlatformErrorCodes_DestinyStatsParameterRangeParseError:
		return "DestinyStatsParameterRangeParseError"
	case PlatformErrorCodes_DestinyStringItemHashNotFound:
		return "DestinyStringItemHashNotFound"
	case PlatformErrorCodes_DestinyStringSetNotFound:
		return "DestinyStringSetNotFound"
	case PlatformErrorCodes_DestinyContentLookupNotFoundForKey:
		return "DestinyContentLookupNotFoundForKey"
	case PlatformErrorCodes_DestinyContentItemNotFound:
		return "DestinyContentItemNotFound"
	case PlatformErrorCodes_DestinyContentSectionNotFound:
		return "DestinyContentSectionNotFound"
	case PlatformErrorCodes_DestinyContentPropertyNotFound:
		return "DestinyContentPropertyNotFound"
	case PlatformErrorCodes_DestinyContentConfigNotFound:
		return "DestinyContentConfigNotFound"
	case PlatformErrorCodes_DestinyContentPropertyBucketValueNotFound:
		return "DestinyContentPropertyBucketValueNotFound"
	case PlatformErrorCodes_DestinyUnexpectedError:
		return "DestinyUnexpectedError"
	case PlatformErrorCodes_DestinyInvalidAction:
		return "DestinyInvalidAction"
	case PlatformErrorCodes_DestinyCharacterNotFound:
		return "DestinyCharacterNotFound"
	case PlatformErrorCodes_DestinyInvalidFlag:
		return "DestinyInvalidFlag"
	case PlatformErrorCodes_DestinyInvalidRequest:
		return "DestinyInvalidRequest"
	case PlatformErrorCodes_DestinyItemNotFound:
		return "DestinyItemNotFound"
	case PlatformErrorCodes_DestinyInvalidCustomizationChoices:
		return "DestinyInvalidCustomizationChoices"
	case PlatformErrorCodes_DestinyVendorItemNotFound:
		return "DestinyVendorItemNotFound"
	case PlatformErrorCodes_DestinyInternalError:
		return "DestinyInternalError"
	case PlatformErrorCodes_DestinyVendorNotFound:
		return "DestinyVendorNotFound"
	case PlatformErrorCodes_DestinyRecentActivitiesDatabaseError:
		return "DestinyRecentActivitiesDatabaseError"
	case PlatformErrorCodes_DestinyItemBucketNotFound:
		return "DestinyItemBucketNotFound"
	case PlatformErrorCodes_DestinyInvalidMembershipType:
		return "DestinyInvalidMembershipType"
	case PlatformErrorCodes_DestinyVersionIncompatibility:
		return "DestinyVersionIncompatibility"
	case PlatformErrorCodes_DestinyItemAlreadyInInventory:
		return "DestinyItemAlreadyInInventory"
	case PlatformErrorCodes_DestinyBucketNotFound:
		return "DestinyBucketNotFound"
	case PlatformErrorCodes_DestinyCharacterNotInTower:
		return "DestinyCharacterNotInTower"
	case PlatformErrorCodes_DestinyCharacterNotLoggedIn:
		return "DestinyCharacterNotLoggedIn"
	case PlatformErrorCodes_DestinyDefinitionsNotLoaded:
		return "DestinyDefinitionsNotLoaded"
	case PlatformErrorCodes_DestinyInventoryFull:
		return "DestinyInventoryFull"
	case PlatformErrorCodes_DestinyItemFailedLevelCheck:
		return "DestinyItemFailedLevelCheck"
	case PlatformErrorCodes_DestinyItemFailedUnlockCheck:
		return "DestinyItemFailedUnlockCheck"
	case PlatformErrorCodes_DestinyItemUnequippable:
		return "DestinyItemUnequippable"
	case PlatformErrorCodes_DestinyItemUniqueEquipRestricted:
		return "DestinyItemUniqueEquipRestricted"
	case PlatformErrorCodes_DestinyNoRoomInDestination:
		return "DestinyNoRoomInDestination"
	case PlatformErrorCodes_DestinyServiceFailure:
		return "DestinyServiceFailure"
	case PlatformErrorCodes_DestinyServiceRetired:
		return "DestinyServiceRetired"
	case PlatformErrorCodes_DestinyTransferFailed:
		return "DestinyTransferFailed"
	case PlatformErrorCodes_DestinyTransferNotFoundForSourceBucket:
		return "DestinyTransferNotFoundForSourceBucket"
	case PlatformErrorCodes_DestinyUnexpectedResultInVendorTransferCheck:
		return "DestinyUnexpectedResultInVendorTransferCheck"
	case PlatformErrorCodes_DestinyUniquenessViolation:
		return "DestinyUniquenessViolation"
	case PlatformErrorCodes_DestinyErrorDeserializationFailure:
		return "DestinyErrorDeserializationFailure"
	case PlatformErrorCodes_DestinyValidAccountTicketRequired:
		return "DestinyValidAccountTicketRequired"
	case PlatformErrorCodes_DestinyShardRelayClientTimeout:
		return "DestinyShardRelayClientTimeout"
	case PlatformErrorCodes_DestinyShardRelayProxyTimeout:
		return "DestinyShardRelayProxyTimeout"
	case PlatformErrorCodes_DestinyPGCRNotFound:
		return "DestinyPGCRNotFound"
	case PlatformErrorCodes_DestinyAccountMustBeOffline:
		return "DestinyAccountMustBeOffline"
	case PlatformErrorCodes_DestinyCanOnlyEquipInGame:
		return "DestinyCanOnlyEquipInGame"
	case PlatformErrorCodes_DestinyCannotPerformActionOnEquippedItem:
		return "DestinyCannotPerformActionOnEquippedItem"
	case PlatformErrorCodes_DestinyQuestAlreadyCompleted:
		return "DestinyQuestAlreadyCompleted"
	case PlatformErrorCodes_DestinyQuestAlreadyTracked:
		return "DestinyQuestAlreadyTracked"
	case PlatformErrorCodes_DestinyTrackableQuestsFull:
		return "DestinyTrackableQuestsFull"
	case PlatformErrorCodes_DestinyItemNotTransferrable:
		return "DestinyItemNotTransferrable"
	case PlatformErrorCodes_DestinyVendorPurchaseNotAllowed:
		return "DestinyVendorPurchaseNotAllowed"
	case PlatformErrorCodes_DestinyContentVersionMismatch:
		return "DestinyContentVersionMismatch"
	case PlatformErrorCodes_DestinyItemActionForbidden:
		return "DestinyItemActionForbidden"
	case PlatformErrorCodes_DestinyRefundInvalid:
		return "DestinyRefundInvalid"
	case PlatformErrorCodes_DestinyPrivacyRestriction:
		return "DestinyPrivacyRestriction"
	case PlatformErrorCodes_DestinyActionInsufficientPrivileges:
		return "DestinyActionInsufficientPrivileges"
	case PlatformErrorCodes_DestinyInvalidClaimException:
		return "DestinyInvalidClaimException"
	case PlatformErrorCodes_DestinyLegacyPlatformRestricted:
		return "DestinyLegacyPlatformRestricted"
	case PlatformErrorCodes_DestinyLegacyPlatformInUse:
		return "DestinyLegacyPlatformInUse"
	case PlatformErrorCodes_DestinyLegacyPlatformInaccessible:
		return "DestinyLegacyPlatformInaccessible"
	case PlatformErrorCodes_DestinyCannotPerformActionAtThisLocation:
		return "DestinyCannotPerformActionAtThisLocation"
	case PlatformErrorCodes_DestinyThrottledByGameServer:
		return "DestinyThrottledByGameServer"
	case PlatformErrorCodes_DestinyItemNotTransferrableHasSideEffects:
		return "DestinyItemNotTransferrableHasSideEffects"
	case PlatformErrorCodes_DestinyItemLocked:
		return "DestinyItemLocked"
	case PlatformErrorCodes_DestinyCannotAffordMaterialRequirements:
		return "DestinyCannotAffordMaterialRequirements"
	case PlatformErrorCodes_DestinyFailedPlugInsertionRules:
		return "DestinyFailedPlugInsertionRules"
	case PlatformErrorCodes_DestinySocketNotFound:
		return "DestinySocketNotFound"
	case PlatformErrorCodes_DestinySocketActionNotAllowed:
		return "DestinySocketActionNotAllowed"
	case PlatformErrorCodes_DestinySocketAlreadyHasPlug:
		return "DestinySocketAlreadyHasPlug"
	case PlatformErrorCodes_DestinyPlugItemNotAvailable:
		return "DestinyPlugItemNotAvailable"
	case PlatformErrorCodes_DestinyCharacterLoggedInNotAllowed:
		return "DestinyCharacterLoggedInNotAllowed"
	case PlatformErrorCodes_DestinyPublicAccountNotAccessible:
		return "DestinyPublicAccountNotAccessible"
	case PlatformErrorCodes_DestinyClaimsItemAlreadyClaimed:
		return "DestinyClaimsItemAlreadyClaimed"
	case PlatformErrorCodes_DestinyClaimsNoInventorySpace:
		return "DestinyClaimsNoInventorySpace"
	case PlatformErrorCodes_DestinyClaimsRequiredLevelNotMet:
		return "DestinyClaimsRequiredLevelNotMet"
	case PlatformErrorCodes_DestinyClaimsInvalidState:
		return "DestinyClaimsInvalidState"
	case PlatformErrorCodes_DestinyNotEnoughRoomForMultipleRewards:
		return "DestinyNotEnoughRoomForMultipleRewards"
	case PlatformErrorCodes_DestinyDirectBabelClientTimeout:
		return "DestinyDirectBabelClientTimeout"
	case PlatformErrorCodes_FbInvalidRequest:
		return "FbInvalidRequest"
	case PlatformErrorCodes_FbRedirectMismatch:
		return "FbRedirectMismatch"
	case PlatformErrorCodes_FbAccessDenied:
		return "FbAccessDenied"
	case PlatformErrorCodes_FbUnsupportedResponseType:
		return "FbUnsupportedResponseType"
	case PlatformErrorCodes_FbInvalidScope:
		return "FbInvalidScope"
	case PlatformErrorCodes_FbUnsupportedGrantType:
		return "FbUnsupportedGrantType"
	case PlatformErrorCodes_FbInvalidGrant:
		return "FbInvalidGrant"
	case PlatformErrorCodes_InvitationExpired:
		return "InvitationExpired"
	case PlatformErrorCodes_InvitationUnknownType:
		return "InvitationUnknownType"
	case PlatformErrorCodes_InvitationInvalidResponseStatus:
		return "InvitationInvalidResponseStatus"
	case PlatformErrorCodes_InvitationInvalidType:
		return "InvitationInvalidType"
	case PlatformErrorCodes_InvitationAlreadyPending:
		return "InvitationAlreadyPending"
	case PlatformErrorCodes_InvitationInsufficientPermission:
		return "InvitationInsufficientPermission"
	case PlatformErrorCodes_InvitationInvalidCode:
		return "InvitationInvalidCode"
	case PlatformErrorCodes_InvitationInvalidTargetState:
		return "InvitationInvalidTargetState"
	case PlatformErrorCodes_InvitationCannotBeReactivated:
		return "InvitationCannotBeReactivated"
	case PlatformErrorCodes_InvitationNoRecipients:
		return "InvitationNoRecipients"
	case PlatformErrorCodes_InvitationGroupCannotSendToSelf:
		return "InvitationGroupCannotSendToSelf"
	case PlatformErrorCodes_InvitationTooManyRecipients:
		return "InvitationTooManyRecipients"
	case PlatformErrorCodes_InvitationInvalid:
		return "InvitationInvalid"
	case PlatformErrorCodes_InvitationNotFound:
		return "InvitationNotFound"
	case PlatformErrorCodes_TokenInvalid:
		return "TokenInvalid"
	case PlatformErrorCodes_TokenBadFormat:
		return "TokenBadFormat"
	case PlatformErrorCodes_TokenAlreadyClaimed:
		return "TokenAlreadyClaimed"
	case PlatformErrorCodes_TokenAlreadyClaimedSelf:
		return "TokenAlreadyClaimedSelf"
	case PlatformErrorCodes_TokenThrottling:
		return "TokenThrottling"
	case PlatformErrorCodes_TokenUnknownRedemptionFailure:
		return "TokenUnknownRedemptionFailure"
	case PlatformErrorCodes_TokenPurchaseClaimFailedAfterTokenClaimed:
		return "TokenPurchaseClaimFailedAfterTokenClaimed"
	case PlatformErrorCodes_TokenUserAlreadyOwnsOffer:
		return "TokenUserAlreadyOwnsOffer"
	case PlatformErrorCodes_TokenInvalidOfferKey:
		return "TokenInvalidOfferKey"
	case PlatformErrorCodes_TokenEmailNotValidated:
		return "TokenEmailNotValidated"
	case PlatformErrorCodes_TokenProvisioningBadVendorOrOffer:
		return "TokenProvisioningBadVendorOrOffer"
	case PlatformErrorCodes_TokenPurchaseHistoryUnknownError:
		return "TokenPurchaseHistoryUnknownError"
	case PlatformErrorCodes_TokenThrottleStateUnknownError:
		return "TokenThrottleStateUnknownError"
	case PlatformErrorCodes_TokenUserAgeNotVerified:
		return "TokenUserAgeNotVerified"
	case PlatformErrorCodes_TokenExceededOfferMaximum:
		return "TokenExceededOfferMaximum"
	case PlatformErrorCodes_TokenNoAvailableUnlocks:
		return "TokenNoAvailableUnlocks"
	case PlatformErrorCodes_TokenMarketplaceInvalidPlatform:
		return "TokenMarketplaceInvalidPlatform"
	case PlatformErrorCodes_TokenNoMarketplaceCodesFound:
		return "TokenNoMarketplaceCodesFound"
	case PlatformErrorCodes_TokenOfferNotAvailableForRedemption:
		return "TokenOfferNotAvailableForRedemption"
	case PlatformErrorCodes_TokenUnlockPartialFailure:
		return "TokenUnlockPartialFailure"
	case PlatformErrorCodes_TokenMarketplaceInvalidRegion:
		return "TokenMarketplaceInvalidRegion"
	case PlatformErrorCodes_TokenOfferExpired:
		return "TokenOfferExpired"
	case PlatformErrorCodes_RAFExceededMaximumReferrals:
		return "RAFExceededMaximumReferrals"
	case PlatformErrorCodes_RAFDuplicateBond:
		return "RAFDuplicateBond"
	case PlatformErrorCodes_RAFNoValidVeteranDestinyMembershipsFound:
		return "RAFNoValidVeteranDestinyMembershipsFound"
	case PlatformErrorCodes_RAFNotAValidVeteranUser:
		return "RAFNotAValidVeteranUser"
	case PlatformErrorCodes_RAFCodeAlreadyClaimedOrNotFound:
		return "RAFCodeAlreadyClaimedOrNotFound"
	case PlatformErrorCodes_RAFMismatchedDestinyMembershipType:
		return "RAFMismatchedDestinyMembershipType"
	case PlatformErrorCodes_RAFUnableToAccessPurchaseHistory:
		return "RAFUnableToAccessPurchaseHistory"
	case PlatformErrorCodes_RAFUnableToCreateBond:
		return "RAFUnableToCreateBond"
	case PlatformErrorCodes_RAFUnableToFindBond:
		return "RAFUnableToFindBond"
	case PlatformErrorCodes_RAFUnableToRemoveBond:
		return "RAFUnableToRemoveBond"
	case PlatformErrorCodes_RAFCannotBondToSelf:
		return "RAFCannotBondToSelf"
	case PlatformErrorCodes_RAFInvalidPlatform:
		return "RAFInvalidPlatform"
	case PlatformErrorCodes_RAFGenerateThrottled:
		return "RAFGenerateThrottled"
	case PlatformErrorCodes_RAFUnableToCreateBondVersionMismatch:
		return "RAFUnableToCreateBondVersionMismatch"
	case PlatformErrorCodes_RAFUnableToRemoveBondVersionMismatch:
		return "RAFUnableToRemoveBondVersionMismatch"
	case PlatformErrorCodes_RAFRedeemThrottled:
		return "RAFRedeemThrottled"
	case PlatformErrorCodes_NoAvailableDiscountCode:
		return "NoAvailableDiscountCode"
	case PlatformErrorCodes_DiscountAlreadyClaimed:
		return "DiscountAlreadyClaimed"
	case PlatformErrorCodes_DiscountClaimFailure:
		return "DiscountClaimFailure"
	case PlatformErrorCodes_DiscountConfigurationFailure:
		return "DiscountConfigurationFailure"
	case PlatformErrorCodes_DiscountGenerationFailure:
		return "DiscountGenerationFailure"
	case PlatformErrorCodes_DiscountAlreadyExists:
		return "DiscountAlreadyExists"
	case PlatformErrorCodes_TokenRequiresCredentialXuid:
		return "TokenRequiresCredentialXuid"
	case PlatformErrorCodes_TokenRequiresCredentialPsnid:
		return "TokenRequiresCredentialPsnid"
	case PlatformErrorCodes_OfferRequired:
		return "OfferRequired"
	case PlatformErrorCodes_UnknownEververseHistoryError:
		return "UnknownEververseHistoryError"
	case PlatformErrorCodes_MissingEververseHistoryError:
		return "MissingEververseHistoryError"
	case PlatformErrorCodes_BungieRewardEmailStateInvalid:
		return "BungieRewardEmailStateInvalid"
	case PlatformErrorCodes_BungieRewardNotYetClaimable:
		return "BungieRewardNotYetClaimable"
	case PlatformErrorCodes_MissingOfferConfig:
		return "MissingOfferConfig"
	case PlatformErrorCodes_RAFQuestEntitlementRequiresBnet:
		return "RAFQuestEntitlementRequiresBnet"
	case PlatformErrorCodes_RAFQuestEntitlementTransportFailure:
		return "RAFQuestEntitlementTransportFailure"
	case PlatformErrorCodes_RAFQuestEntitlementUnknownFailure:
		return "RAFQuestEntitlementUnknownFailure"
	case PlatformErrorCodes_RAFVeteranRewardUnknownFailure:
		return "RAFVeteranRewardUnknownFailure"
	case PlatformErrorCodes_RAFTooEarlyToCancelBond:
		return "RAFTooEarlyToCancelBond"
	case PlatformErrorCodes_LoyaltyRewardAlreadyRedeemed:
		return "LoyaltyRewardAlreadyRedeemed"
	case PlatformErrorCodes_UnclaimedLoyaltyRewardEntryNotFound:
		return "UnclaimedLoyaltyRewardEntryNotFound"
	case PlatformErrorCodes_PartnerOfferPartialFailure:
		return "PartnerOfferPartialFailure"
	case PlatformErrorCodes_PartnerOfferAlreadyClaimed:
		return "PartnerOfferAlreadyClaimed"
	case PlatformErrorCodes_PartnerOfferSkuNotFound:
		return "PartnerOfferSkuNotFound"
	case PlatformErrorCodes_PartnerOfferSkuExpired:
		return "PartnerOfferSkuExpired"
	case PlatformErrorCodes_PartnerOfferPermissionFailure:
		return "PartnerOfferPermissionFailure"
	case PlatformErrorCodes_PartnerOfferNoDestinyAccount:
		return "PartnerOfferNoDestinyAccount"
	case PlatformErrorCodes_PartnerOfferApplyDataNotFound:
		return "PartnerOfferApplyDataNotFound"
	case PlatformErrorCodes_ApiExceededMaxKeys:
		return "ApiExceededMaxKeys"
	case PlatformErrorCodes_ApiInvalidOrExpiredKey:
		return "ApiInvalidOrExpiredKey"
	case PlatformErrorCodes_ApiKeyMissingFromRequest:
		return "ApiKeyMissingFromRequest"
	case PlatformErrorCodes_ApplicationDisabled:
		return "ApplicationDisabled"
	case PlatformErrorCodes_ApplicationExceededMax:
		return "ApplicationExceededMax"
	case PlatformErrorCodes_ApplicationDisallowedByScope:
		return "ApplicationDisallowedByScope"
	case PlatformErrorCodes_AuthorizationCodeInvalid:
		return "AuthorizationCodeInvalid"
	case PlatformErrorCodes_OriginHeaderDoesNotMatchKey:
		return "OriginHeaderDoesNotMatchKey"
	case PlatformErrorCodes_AccessNotPermittedByApplicationScope:
		return "AccessNotPermittedByApplicationScope"
	case PlatformErrorCodes_ApplicationNameIsTaken:
		return "ApplicationNameIsTaken"
	case PlatformErrorCodes_RefreshTokenNotYetValid:
		return "RefreshTokenNotYetValid"
	case PlatformErrorCodes_AccessTokenHasExpired:
		return "AccessTokenHasExpired"
	case PlatformErrorCodes_ApplicationTokenFormatNotValid:
		return "ApplicationTokenFormatNotValid"
	case PlatformErrorCodes_ApplicationNotConfiguredForBungieAuth:
		return "ApplicationNotConfiguredForBungieAuth"
	case PlatformErrorCodes_ApplicationNotConfiguredForOAuth:
		return "ApplicationNotConfiguredForOAuth"
	case PlatformErrorCodes_OAuthAccessTokenExpired:
		return "OAuthAccessTokenExpired"
	case PlatformErrorCodes_ApplicationTokenKeyIdDoesNotExist:
		return "ApplicationTokenKeyIdDoesNotExist"
	case PlatformErrorCodes_ProvidedTokenNotValidRefreshToken:
		return "ProvidedTokenNotValidRefreshToken"
	case PlatformErrorCodes_RefreshTokenExpired:
		return "RefreshTokenExpired"
	case PlatformErrorCodes_AuthorizationRecordInvalid:
		return "AuthorizationRecordInvalid"
	case PlatformErrorCodes_TokenPreviouslyRevoked:
		return "TokenPreviouslyRevoked"
	case PlatformErrorCodes_TokenInvalidMembership:
		return "TokenInvalidMembership"
	case PlatformErrorCodes_AuthorizationCodeStale:
		return "AuthorizationCodeStale"
	case PlatformErrorCodes_AuthorizationRecordExpired:
		return "AuthorizationRecordExpired"
	case PlatformErrorCodes_AuthorizationRecordRevoked:
		return "AuthorizationRecordRevoked"
	case PlatformErrorCodes_AuthorizationRecordInactiveApiKey:
		return "AuthorizationRecordInactiveApiKey"
	case PlatformErrorCodes_AuthorizationRecordApiKeyMatching:
		return "AuthorizationRecordApiKeyMatching"
	case PlatformErrorCodes_PartnershipInvalidType:
		return "PartnershipInvalidType"
	case PlatformErrorCodes_PartnershipValidationError:
		return "PartnershipValidationError"
	case PlatformErrorCodes_PartnershipValidationTimeout:
		return "PartnershipValidationTimeout"
	case PlatformErrorCodes_PartnershipAccessFailure:
		return "PartnershipAccessFailure"
	case PlatformErrorCodes_PartnershipAccountInvalid:
		return "PartnershipAccountInvalid"
	case PlatformErrorCodes_PartnershipGetAccountInfoFailure:
		return "PartnershipGetAccountInfoFailure"
	case PlatformErrorCodes_PartnershipDisabled:
		return "PartnershipDisabled"
	case PlatformErrorCodes_PartnershipAlreadyExists:
		return "PartnershipAlreadyExists"
	case PlatformErrorCodes_CommunityStreamingUnavailable:
		return "CommunityStreamingUnavailable"
	case PlatformErrorCodes_TwitchNotLinked:
		return "TwitchNotLinked"
	case PlatformErrorCodes_TwitchAccountNotFound:
		return "TwitchAccountNotFound"
	case PlatformErrorCodes_TwitchCouldNotLoadDestinyInfo:
		return "TwitchCouldNotLoadDestinyInfo"
	case PlatformErrorCodes_TwitchCouldNotRegisterUser:
		return "TwitchCouldNotRegisterUser"
	case PlatformErrorCodes_TwitchCouldNotUnregisterUser:
		return "TwitchCouldNotUnregisterUser"
	case PlatformErrorCodes_TwitchRequiresRelinking:
		return "TwitchRequiresRelinking"
	case PlatformErrorCodes_TwitchNoPlatformChosen:
		return "TwitchNoPlatformChosen"
	case PlatformErrorCodes_TwitchDropHistoryPermissionFailure:
		return "TwitchDropHistoryPermissionFailure"
	case PlatformErrorCodes_TwitchDropsRepairPartialFailure:
		return "TwitchDropsRepairPartialFailure"
	case PlatformErrorCodes_TwitchNotAuthorized:
		return "TwitchNotAuthorized"
	case PlatformErrorCodes_TwitchUnknownAuthorizationFailure:
		return "TwitchUnknownAuthorizationFailure"
	case PlatformErrorCodes_TrendingCategoryNotFound:
		return "TrendingCategoryNotFound"
	case PlatformErrorCodes_TrendingEntryTypeNotSupported:
		return "TrendingEntryTypeNotSupported"
	case PlatformErrorCodes_ReportOffenderNotInPgcr:
		return "ReportOffenderNotInPgcr"
	case PlatformErrorCodes_ReportRequestorNotInPgcr:
		return "ReportRequestorNotInPgcr"
	case PlatformErrorCodes_ReportSubmissionFailed:
		return "ReportSubmissionFailed"
	case PlatformErrorCodes_ReportCannotReportSelf:
		return "ReportCannotReportSelf"
	case PlatformErrorCodes_AwaTypeDisabled:
		return "AwaTypeDisabled"
	case PlatformErrorCodes_AwaTooManyPendingRequests:
		return "AwaTooManyPendingRequests"
	case PlatformErrorCodes_AwaTheFeatureRequiresARegisteredDevice:
		return "AwaTheFeatureRequiresARegisteredDevice"
	case PlatformErrorCodes_AwaRequestWasUnansweredForTooLong:
		return "AwaRequestWasUnansweredForTooLong"
	case PlatformErrorCodes_AwaWriteRequestMissingOrInvalidToken:
		return "AwaWriteRequestMissingOrInvalidToken"
	case PlatformErrorCodes_AwaWriteRequestTokenExpired:
		return "AwaWriteRequestTokenExpired"
	case PlatformErrorCodes_AwaWriteRequestTokenUsageLimitReached:
		return "AwaWriteRequestTokenUsageLimitReached"
	case PlatformErrorCodes_SteamWebApiError:
		return "SteamWebApiError"
	case PlatformErrorCodes_SteamWebNullResponseError:
		return "SteamWebNullResponseError"
	case PlatformErrorCodes_SteamAccountRequired:
		return "SteamAccountRequired"
	case PlatformErrorCodes_SteamNotAuthorized:
		return "SteamNotAuthorized"
	case PlatformErrorCodes_ClanFireteamNotFound:
		return "ClanFireteamNotFound"
	case PlatformErrorCodes_ClanFireteamAddNoAlternatesForImmediate:
		return "ClanFireteamAddNoAlternatesForImmediate"
	case PlatformErrorCodes_ClanFireteamFull:
		return "ClanFireteamFull"
	case PlatformErrorCodes_ClanFireteamAltFull:
		return "ClanFireteamAltFull"
	case PlatformErrorCodes_ClanFireteamBlocked:
		return "ClanFireteamBlocked"
	case PlatformErrorCodes_ClanFireteamPlayerEntryNotFound:
		return "ClanFireteamPlayerEntryNotFound"
	case PlatformErrorCodes_ClanFireteamPermissions:
		return "ClanFireteamPermissions"
	case PlatformErrorCodes_ClanFireteamInvalidPlatform:
		return "ClanFireteamInvalidPlatform"
	case PlatformErrorCodes_ClanFireteamCannotAdjustSlotCount:
		return "ClanFireteamCannotAdjustSlotCount"
	case PlatformErrorCodes_ClanFireteamInvalidPlayerPlatform:
		return "ClanFireteamInvalidPlayerPlatform"
	case PlatformErrorCodes_ClanFireteamNotReadyForInvitesNotEnoughPlayers:
		return "ClanFireteamNotReadyForInvitesNotEnoughPlayers"
	case PlatformErrorCodes_ClanFireteamGameInvitesNotSupportForPlatform:
		return "ClanFireteamGameInvitesNotSupportForPlatform"
	case PlatformErrorCodes_ClanFireteamPlatformInvitePreqFailure:
		return "ClanFireteamPlatformInvitePreqFailure"
	case PlatformErrorCodes_ClanFireteamInvalidAuthContext:
		return "ClanFireteamInvalidAuthContext"
	case PlatformErrorCodes_ClanFireteamInvalidAuthProviderPsn:
		return "ClanFireteamInvalidAuthProviderPsn"
	case PlatformErrorCodes_ClanFireteamPs4SessionFull:
		return "ClanFireteamPs4SessionFull"
	case PlatformErrorCodes_ClanFireteamInvalidAuthToken:
		return "ClanFireteamInvalidAuthToken"
	case PlatformErrorCodes_ClanFireteamScheduledFireteamsDisabled:
		return "ClanFireteamScheduledFireteamsDisabled"
	case PlatformErrorCodes_ClanFireteamNotReadyForInvitesNotScheduledYet:
		return "ClanFireteamNotReadyForInvitesNotScheduledYet"
	case PlatformErrorCodes_ClanFireteamNotReadyForInvitesClosed:
		return "ClanFireteamNotReadyForInvitesClosed"
	case PlatformErrorCodes_ClanFireteamScheduledFireteamsRequireAdminPermissions:
		return "ClanFireteamScheduledFireteamsRequireAdminPermissions"
	case PlatformErrorCodes_ClanFireteamNonPublicMustHaveClan:
		return "ClanFireteamNonPublicMustHaveClan"
	case PlatformErrorCodes_ClanFireteamPublicCreationRestriction:
		return "ClanFireteamPublicCreationRestriction"
	case PlatformErrorCodes_ClanFireteamAlreadyJoined:
		return "ClanFireteamAlreadyJoined"
	case PlatformErrorCodes_ClanFireteamScheduledFireteamsRange:
		return "ClanFireteamScheduledFireteamsRange"
	case PlatformErrorCodes_ClanFireteamPublicCreationRestrictionExtended:
		return "ClanFireteamPublicCreationRestrictionExtended"
	case PlatformErrorCodes_ClanFireteamExpired:
		return "ClanFireteamExpired"
	case PlatformErrorCodes_ClanFireteamInvalidAuthProvider:
		return "ClanFireteamInvalidAuthProvider"
	case PlatformErrorCodes_ClanFireteamInvalidAuthProviderXuid:
		return "ClanFireteamInvalidAuthProviderXuid"
	case PlatformErrorCodes_ClanFireteamThrottle:
		return "ClanFireteamThrottle"
	case PlatformErrorCodes_ClanFireteamTooManyOpenScheduledFireteams:
		return "ClanFireteamTooManyOpenScheduledFireteams"
	case PlatformErrorCodes_ClanFireteamCannotReopenScheduledFireteams:
		return "ClanFireteamCannotReopenScheduledFireteams"
	case PlatformErrorCodes_ClanFireteamJoinNoAccountSpecified:
		return "ClanFireteamJoinNoAccountSpecified"
	case PlatformErrorCodes_ClanFireteamMinDestiny2ProgressForCreation:
		return "ClanFireteamMinDestiny2ProgressForCreation"
	case PlatformErrorCodes_ClanFireteamMinDestiny2ProgressForJoin:
		return "ClanFireteamMinDestiny2ProgressForJoin"
	case PlatformErrorCodes_ClanFireteamSMSOrPurchaseRequiredCreate:
		return "ClanFireteamSMSOrPurchaseRequiredCreate"
	case PlatformErrorCodes_ClanFireteamPurchaseRequiredCreate:
		return "ClanFireteamPurchaseRequiredCreate"
	case PlatformErrorCodes_ClanFireteamSMSOrPurchaseRequiredJoin:
		return "ClanFireteamSMSOrPurchaseRequiredJoin"
	case PlatformErrorCodes_ClanFireteamPurchaseRequiredJoin:
		return "ClanFireteamPurchaseRequiredJoin"
	case PlatformErrorCodes_FireteamFinderInvalidMembershipType:
		return "FireteamFinderInvalidMembershipType"
	case PlatformErrorCodes_FireteamFinderInvalidMembershipId:
		return "FireteamFinderInvalidMembershipId"
	case PlatformErrorCodes_FireteamFinderInvalidCharacterId:
		return "FireteamFinderInvalidCharacterId"
	case PlatformErrorCodes_FireteamFinderInvalidListingOptions:
		return "FireteamFinderInvalidListingOptions"
	case PlatformErrorCodes_FireteamFinderInvalidRequestData:
		return "FireteamFinderInvalidRequestData"
	case PlatformErrorCodes_FireteamFinderListingApplicationFailed:
		return "FireteamFinderListingApplicationFailed"
	case PlatformErrorCodes_FireteamFinderListingAutoJoinFailed:
		return "FireteamFinderListingAutoJoinFailed"
	case PlatformErrorCodes_FireteamFinderPlayerApplicationsParsingFailed:
		return "FireteamFinderPlayerApplicationsParsingFailed"
	case PlatformErrorCodes_FireteamFinderJoinLobbyHostFailed:
		return "FireteamFinderJoinLobbyHostFailed"
	case PlatformErrorCodes_FireteamFinderPlayerNotInGame:
		return "FireteamFinderPlayerNotInGame"
	case PlatformErrorCodes_FireteamFinderActivationFailed:
		return "FireteamFinderActivationFailed"
	case PlatformErrorCodes_FireteamFinderApplicationNotFound:
		return "FireteamFinderApplicationNotFound"
	case PlatformErrorCodes_FireteamFinderUserAlreadyAppliedToListing:
		return "FireteamFinderUserAlreadyAppliedToListing"
	case PlatformErrorCodes_FireteamFinderApplicationClosedForUpdates:
		return "FireteamFinderApplicationClosedForUpdates"
	case PlatformErrorCodes_FireteamFinderListingAtMaxOpenApplicationsLimit:
		return "FireteamFinderListingAtMaxOpenApplicationsLimit"
	case PlatformErrorCodes_FireteamFinderUserNotInApplication:
		return "FireteamFinderUserNotInApplication"
	case PlatformErrorCodes_FireteamFinderApplicationUserAlreadyListingOwner:
		return "FireteamFinderApplicationUserAlreadyListingOwner"
	case PlatformErrorCodes_FireteamFinderOfferNotFound:
		return "FireteamFinderOfferNotFound"
	case PlatformErrorCodes_FireteamFinderOfferClosedForUpdates:
		return "FireteamFinderOfferClosedForUpdates"
	case PlatformErrorCodes_FireteamFinderOfferUserNotTarget:
		return "FireteamFinderOfferUserNotTarget"
	case PlatformErrorCodes_FireteamFinderLobbyNotFound:
		return "FireteamFinderLobbyNotFound"
	case PlatformErrorCodes_FireteamFinderListingNotFound:
		return "FireteamFinderListingNotFound"
	case PlatformErrorCodes_FireteamFinderLobbyFull:
		return "FireteamFinderLobbyFull"
	case PlatformErrorCodes_FireteamFinderUserNotListingOwner:
		return "FireteamFinderUserNotListingOwner"
	case PlatformErrorCodes_FireteamFinderUserNotLobbyOwner:
		return "FireteamFinderUserNotLobbyOwner"
	case PlatformErrorCodes_FireteamFinderLobbyClosedForUpdates:
		return "FireteamFinderLobbyClosedForUpdates"
	case PlatformErrorCodes_FireteamFinderUserNotInLobby:
		return "FireteamFinderUserNotInLobby"
	case PlatformErrorCodes_FireteamFinderDisabledSettingsValue:
		return "FireteamFinderDisabledSettingsValue"
	case PlatformErrorCodes_FireteamFinderOwnerInActiveLobby:
		return "FireteamFinderOwnerInActiveLobby"
	case PlatformErrorCodes_FireteamFinderApplicationClosedToOfflinePlayers:
		return "FireteamFinderApplicationClosedToOfflinePlayers"
	case PlatformErrorCodes_FireteamFinderUserNotApplicationOwner:
		return "FireteamFinderUserNotApplicationOwner"
	case PlatformErrorCodes_FireteamFinderInviteValidationFailed:
		return "FireteamFinderInviteValidationFailed"
	case PlatformErrorCodes_FireteamFinderOwnerNotInGame:
		return "FireteamFinderOwnerNotInGame"
	case PlatformErrorCodes_FireteamFinderPlayerAtMaxLobbyLimit:
		return "FireteamFinderPlayerAtMaxLobbyLimit"
	case PlatformErrorCodes_FireteamFinderLobbyTooFarInTheFuture:
		return "FireteamFinderLobbyTooFarInTheFuture"
	case PlatformErrorCodes_FireteamFinderApplicantNotInGame:
		return "FireteamFinderApplicantNotInGame"
	case PlatformErrorCodes_FireteamFinderResponseUndefined:
		return "FireteamFinderResponseUndefined"
	case PlatformErrorCodes_FireteamFinderResponseMoved:
		return "FireteamFinderResponseMoved"
	case PlatformErrorCodes_FireteamFinderResponseLoggingIn:
		return "FireteamFinderResponseLoggingIn"
	case PlatformErrorCodes_FireteamFinderResponseBadRequest:
		return "FireteamFinderResponseBadRequest"
	case PlatformErrorCodes_FireteamFinderResponseUnauthorized:
		return "FireteamFinderResponseUnauthorized"
	case PlatformErrorCodes_FireteamFinderResponseForbidden:
		return "FireteamFinderResponseForbidden"
	case PlatformErrorCodes_FireteamFinderResponseNotFound:
		return "FireteamFinderResponseNotFound"
	case PlatformErrorCodes_FireteamFinderInternalServerError:
		return "FireteamFinderInternalServerError"
	case PlatformErrorCodes_FireteamFinderServiceUnavailable:
		return "FireteamFinderServiceUnavailable"
	case PlatformErrorCodes_FireteamFinderInternalServerErrorNonFatal:
		return "FireteamFinderInternalServerErrorNonFatal"
	case PlatformErrorCodes_CrossSaveOverriddenAccountNotFound:
		return "CrossSaveOverriddenAccountNotFound"
	case PlatformErrorCodes_CrossSaveTooManyOverriddenPlatforms:
		return "CrossSaveTooManyOverriddenPlatforms"
	case PlatformErrorCodes_CrossSaveNoOverriddenPlatforms:
		return "CrossSaveNoOverriddenPlatforms"
	case PlatformErrorCodes_CrossSavePrimaryAccountNotFound:
		return "CrossSavePrimaryAccountNotFound"
	case PlatformErrorCodes_CrossSaveRequestInvalid:
		return "CrossSaveRequestInvalid"
	case PlatformErrorCodes_CrossSaveBungieAccountValidationFailure:
		return "CrossSaveBungieAccountValidationFailure"
	case PlatformErrorCodes_CrossSaveOverriddenPlatformNotAllowed:
		return "CrossSaveOverriddenPlatformNotAllowed"
	case PlatformErrorCodes_CrossSaveThresholdExceeded:
		return "CrossSaveThresholdExceeded"
	case PlatformErrorCodes_CrossSaveIncompatibleMembershipType:
		return "CrossSaveIncompatibleMembershipType"
	case PlatformErrorCodes_CrossSaveCouldNotFindLinkedAccountForMembershipType:
		return "CrossSaveCouldNotFindLinkedAccountForMembershipType"
	case PlatformErrorCodes_CrossSaveCouldNotCreateDestinyProfileForMembershipType:
		return "CrossSaveCouldNotCreateDestinyProfileForMembershipType"
	case PlatformErrorCodes_CrossSaveErrorCreatingDestinyProfileForMembershipType:
		return "CrossSaveErrorCreatingDestinyProfileForMembershipType"
	case PlatformErrorCodes_CrossSaveCannotOverrideSelf:
		return "CrossSaveCannotOverrideSelf"
	case PlatformErrorCodes_CrossSaveRecentSilverPurchase:
		return "CrossSaveRecentSilverPurchase"
	case PlatformErrorCodes_CrossSaveSilverBalanceNegative:
		return "CrossSaveSilverBalanceNegative"
	case PlatformErrorCodes_CrossSaveAccountNotAuthenticated:
		return "CrossSaveAccountNotAuthenticated"
	case PlatformErrorCodes_ErrorOneAccountAlreadyActive:
		return "ErrorOneAccountAlreadyActive"
	case PlatformErrorCodes_ErrorOneAccountDestinyRestriction:
		return "ErrorOneAccountDestinyRestriction"
	case PlatformErrorCodes_CrossSaveMustMigrateToSteam:
		return "CrossSaveMustMigrateToSteam"
	case PlatformErrorCodes_CrossSaveSteamAlreadyPaired:
		return "CrossSaveSteamAlreadyPaired"
	case PlatformErrorCodes_CrossSaveCannotPairJustSteamAndBlizzard:
		return "CrossSaveCannotPairJustSteamAndBlizzard"
	case PlatformErrorCodes_CrossSaveCannotPairSteamAloneBeforeShadowkeep:
		return "CrossSaveCannotPairSteamAloneBeforeShadowkeep"
	case PlatformErrorCodes_AuthVerificationNotLinkedToAccount:
		return "AuthVerificationNotLinkedToAccount"
	case PlatformErrorCodes_PCMigrationMissingBlizzard:
		return "PCMigrationMissingBlizzard"
	case PlatformErrorCodes_PCMigrationMissingSteam:
		return "PCMigrationMissingSteam"
	case PlatformErrorCodes_PCMigrationInvalidBlizzard:
		return "PCMigrationInvalidBlizzard"
	case PlatformErrorCodes_PCMigrationInvalidSteam:
		return "PCMigrationInvalidSteam"
	case PlatformErrorCodes_PCMigrationUnknownFailure:
		return "PCMigrationUnknownFailure"
	case PlatformErrorCodes_PCMigrationUnknownException:
		return "PCMigrationUnknownException"
	case PlatformErrorCodes_PCMigrationNotLinked:
		return "PCMigrationNotLinked"
	case PlatformErrorCodes_PCMigrationAccountsAlreadyUsed:
		return "PCMigrationAccountsAlreadyUsed"
	case PlatformErrorCodes_PCMigrationStepFailed:
		return "PCMigrationStepFailed"
	case PlatformErrorCodes_PCMigrationInvalidBlizzardCrossSaveState:
		return "PCMigrationInvalidBlizzardCrossSaveState"
	case PlatformErrorCodes_PCMigrationDestinationBanned:
		return "PCMigrationDestinationBanned"
	case PlatformErrorCodes_PCMigrationDestinyFailure:
		return "PCMigrationDestinyFailure"
	case PlatformErrorCodes_PCMigrationSilverTransferFailed:
		return "PCMigrationSilverTransferFailed"
	case PlatformErrorCodes_PCMigrationEntitlementTransferFailed:
		return "PCMigrationEntitlementTransferFailed"
	case PlatformErrorCodes_PCMigrationCannotStompClanFounder:
		return "PCMigrationCannotStompClanFounder"
	case PlatformErrorCodes_UnsupportedBrowser:
		return "UnsupportedBrowser"
	case PlatformErrorCodes_StadiaAccountRequired:
		return "StadiaAccountRequired"
	case PlatformErrorCodes_ErrorPhoneValidationTooManyUses:
		return "ErrorPhoneValidationTooManyUses"
	case PlatformErrorCodes_ErrorPhoneValidationNoAssociatedPhone:
		return "ErrorPhoneValidationNoAssociatedPhone"
	case PlatformErrorCodes_ErrorPhoneValidationCodeInvalid:
		return "ErrorPhoneValidationCodeInvalid"
	case PlatformErrorCodes_ErrorPhoneValidationBanned:
		return "ErrorPhoneValidationBanned"
	case PlatformErrorCodes_ErrorPhoneValidationCodeTooRecentlySent:
		return "ErrorPhoneValidationCodeTooRecentlySent"
	case PlatformErrorCodes_ErrorPhoneValidationCodeExpired:
		return "ErrorPhoneValidationCodeExpired"
	case PlatformErrorCodes_ErrorPhoneValidationInvalidNumberType:
		return "ErrorPhoneValidationInvalidNumberType"
	case PlatformErrorCodes_ErrorPhoneValidationCodeTooRecentlyChecked:
		return "ErrorPhoneValidationCodeTooRecentlyChecked"
	case PlatformErrorCodes_ErrorPhoneValidationRecentlyPlayedDestiny2AccountRequired:
		return "ErrorPhoneValidationRecentlyPlayedDestiny2AccountRequired"
	case PlatformErrorCodes_ApplePushErrorUnknown:
		return "ApplePushErrorUnknown"
	case PlatformErrorCodes_ApplePushErrorNull:
		return "ApplePushErrorNull"
	case PlatformErrorCodes_ApplePushErrorTimeout:
		return "ApplePushErrorTimeout"
	case PlatformErrorCodes_ApplePushBadRequest:
		return "ApplePushBadRequest"
	case PlatformErrorCodes_ApplePushFailedAuth:
		return "ApplePushFailedAuth"
	case PlatformErrorCodes_ApplePushThrottled:
		return "ApplePushThrottled"
	case PlatformErrorCodes_ApplePushServiceUnavailable:
		return "ApplePushServiceUnavailable"
	case PlatformErrorCodes_NotAnImageOrVideo:
		return "NotAnImageOrVideo"
	case PlatformErrorCodes_ErrorBungieFriendsBlockFailed:
		return "ErrorBungieFriendsBlockFailed"
	case PlatformErrorCodes_ErrorBungieFriendsAutoReject:
		return "ErrorBungieFriendsAutoReject"
	case PlatformErrorCodes_ErrorBungieFriendsNoRequestFound:
		return "ErrorBungieFriendsNoRequestFound"
	case PlatformErrorCodes_ErrorBungieFriendsAlreadyFriends:
		return "ErrorBungieFriendsAlreadyFriends"
	case PlatformErrorCodes_ErrorBungieFriendsUnableToRemoveRequest:
		return "ErrorBungieFriendsUnableToRemoveRequest"
	case PlatformErrorCodes_ErrorBungieFriendsUnableToRemove:
		return "ErrorBungieFriendsUnableToRemove"
	case PlatformErrorCodes_ErrorBungieFriendsIdenticalSourceTarget:
		return "ErrorBungieFriendsIdenticalSourceTarget"
	case PlatformErrorCodes_ErrorBungieFriendsSelf:
		return "ErrorBungieFriendsSelf"
	case PlatformErrorCodes_ErrorBungieBlockSelf:
		return "ErrorBungieBlockSelf"
	case PlatformErrorCodes_ErrorBungieFriendsListFull:
		return "ErrorBungieFriendsListFull"
	case PlatformErrorCodes_ErrorBungieBlockListFull:
		return "ErrorBungieBlockListFull"
	case PlatformErrorCodes_ErrorBungieFriendNotFound:
		return "ErrorBungieFriendNotFound"
	case PlatformErrorCodes_ErrorBungieFriendInvalidMembershipType:
		return "ErrorBungieFriendInvalidMembershipType"
	case PlatformErrorCodes_ErrorEgsUnknown:
		return "ErrorEgsUnknown"
	case PlatformErrorCodes_ErrorEgsBadRequest:
		return "ErrorEgsBadRequest"
	case PlatformErrorCodes_ErrorEgsNotAuthorized:
		return "ErrorEgsNotAuthorized"
	case PlatformErrorCodes_ErrorEgsForbidden:
		return "ErrorEgsForbidden"
	case PlatformErrorCodes_ErrorEgsAccountNotFound:
		return "ErrorEgsAccountNotFound"
	case PlatformErrorCodes_ErrorEgsWebException:
		return "ErrorEgsWebException"
	case PlatformErrorCodes_ErrorEgsUnavailable:
		return "ErrorEgsUnavailable"
	case PlatformErrorCodes_ErrorEgsJwksMissing:
		return "ErrorEgsJwksMissing"
	case PlatformErrorCodes_ErrorEgsJwtMalformedHeader:
		return "ErrorEgsJwtMalformedHeader"
	case PlatformErrorCodes_ErrorEgsJwtMalformedPayload:
		return "ErrorEgsJwtMalformedPayload"
	}
	return fmt.Sprintf("PlatformErrorCodes_%d", e)
}

func (e FireteamDateRange) Enum() string {
	switch e {
	case FireteamDateRange_All:
		return "All"
	case FireteamDateRange_Now:
		return "Now"
	case FireteamDateRange_TwentyFourHours:
		return "TwentyFourHours"
	case FireteamDateRange_FortyEightHours:
		return "FortyEightHours"
	case FireteamDateRange_ThisWeek:
		return "ThisWeek"
	}
	return fmt.Sprintf("FireteamDateRange_%d", e)
}

func (e FireteamPlatform) Enum() string {
	switch e {
	case FireteamPlatform_Any:
		return "Any"
	case FireteamPlatform_Playstation4:
		return "Playstation4"
	case FireteamPlatform_XboxOne:
		return "XboxOne"
	case FireteamPlatform_Blizzard:
		return "Blizzard"
	case FireteamPlatform_Steam:
		return "Steam"
	case FireteamPlatform_Stadia:
		return "Stadia"
	case FireteamPlatform_Egs:
		return "Egs"
	}
	return fmt.Sprintf("FireteamPlatform_%d", e)
}

func (e FireteamPlatformInviteResult) Enum() string {
	switch e {
	case FireteamPlatformInviteResult_None:
		return "None"
	case FireteamPlatformInviteResult_Success:
		return "Success"
	case FireteamPlatformInviteResult_AlreadyInFireteam:
		return "AlreadyInFireteam"
	case FireteamPlatformInviteResult_Throttled:
		return "Throttled"
	case FireteamPlatformInviteResult_ServiceError:
		return "ServiceError"
	}
	return fmt.Sprintf("FireteamPlatformInviteResult_%d", e)
}

func (e FireteamPublicSearchOption) Enum() string {
	switch e {
	case FireteamPublicSearchOption_PublicAndPrivate:
		return "PublicAndPrivate"
	case FireteamPublicSearchOption_PublicOnly:
		return "PublicOnly"
	case FireteamPublicSearchOption_PrivateOnly:
		return "PrivateOnly"
	}
	return fmt.Sprintf("FireteamPublicSearchOption_%d", e)
}

func (e FireteamSlotSearch) Enum() string {
	switch e {
	case FireteamSlotSearch_NoSlotRestriction:
		return "NoSlotRestriction"
	case FireteamSlotSearch_HasOpenPlayerSlots:
		return "HasOpenPlayerSlots"
	case FireteamSlotSearch_HasOpenPlayerOrAltSlots:
		return "HasOpenPlayerOrAltSlots"
	}
	return fmt.Sprintf("FireteamSlotSearch_%d", e)
}

func (e FireteamFinderApplicationState) Enum() string {
	switch e {
	case FireteamFinderApplicationState_Unknown:
		return "Unknown"
	case FireteamFinderApplicationState_WaitingForApplicants:
		return "WaitingForApplicants"
	case FireteamFinderApplicationState_WaitingForLobbyOwner:
		return "WaitingForLobbyOwner"
	case FireteamFinderApplicationState_Accepted:
		return "Accepted"
	case FireteamFinderApplicationState_Rejected:
		return "Rejected"
	case FireteamFinderApplicationState_Deleted:
		return "Deleted"
	case FireteamFinderApplicationState_Expired:
		return "Expired"
	}
	return fmt.Sprintf("FireteamFinderApplicationState_%d", e)
}

func (e FireteamFinderApplicationType) Enum() string {
	switch e {
	case FireteamFinderApplicationType_Unknown:
		return "Unknown"
	case FireteamFinderApplicationType_Creator:
		return "Creator"
	case FireteamFinderApplicationType_Search:
		return "Search"
	case FireteamFinderApplicationType_Invite:
		return "Invite"
	case FireteamFinderApplicationType_Friend:
		return "Friend"
	case FireteamFinderApplicationType_Encounter:
		return "Encounter"
	case FireteamFinderApplicationType_Public:
		return "Public"
	}
	return fmt.Sprintf("FireteamFinderApplicationType_%d", e)
}

func (e FireteamFinderListingFilterMatchType) Enum() string {
	switch e {
	case FireteamFinderListingFilterMatchType_Unknown:
		return "Unknown"
	case FireteamFinderListingFilterMatchType_MustNot:
		return "MustNot"
	case FireteamFinderListingFilterMatchType_Should:
		return "Should"
	case FireteamFinderListingFilterMatchType_Filter:
		return "Filter"
	}
	return fmt.Sprintf("FireteamFinderListingFilterMatchType_%d", e)
}

func (e FireteamFinderListingFilterRangeType) Enum() string {
	switch e {
	case FireteamFinderListingFilterRangeType_Unknown:
		return "Unknown"
	case FireteamFinderListingFilterRangeType_All:
		return "All"
	case FireteamFinderListingFilterRangeType_Any:
		return "Any"
	case FireteamFinderListingFilterRangeType_InRangeInclusive:
		return "InRangeInclusive"
	case FireteamFinderListingFilterRangeType_InRangeExclusive:
		return "InRangeExclusive"
	case FireteamFinderListingFilterRangeType_GreaterThan:
		return "GreaterThan"
	case FireteamFinderListingFilterRangeType_GreaterThanOrEqualTo:
		return "GreaterThanOrEqualTo"
	case FireteamFinderListingFilterRangeType_LessThan:
		return "LessThan"
	case FireteamFinderListingFilterRangeType_LessThanOrEqualTo:
		return "LessThanOrEqualTo"
	}
	return fmt.Sprintf("FireteamFinderListingFilterRangeType_%d", e)
}

func (e FireteamFinderLobbyPrivacyScope) Enum() string {
	switch e {
	case FireteamFinderLobbyPrivacyScope_Unknown:
		return "Unknown"
	case FireteamFinderLobbyPrivacyScope_Open:
		return "Open"
	case FireteamFinderLobbyPrivacyScope_Applications:
		return "Applications"
	case FireteamFinderLobbyPrivacyScope_Clan:
		return "Clan"
	case FireteamFinderLobbyPrivacyScope_Friends:
		return "Friends"
	}
	return fmt.Sprintf("FireteamFinderLobbyPrivacyScope_%d", e)
}

func (e FireteamFinderLobbyState) Enum() string {
	switch e {
	case FireteamFinderLobbyState_Unknown:
		return "Unknown"
	case FireteamFinderLobbyState_Inactive:
		return "Inactive"
	case FireteamFinderLobbyState_Active:
		return "Active"
	case FireteamFinderLobbyState_Expired:
		return "Expired"
	case FireteamFinderLobbyState_Closed:
		return "Closed"
	case FireteamFinderLobbyState_Canceled:
		return "Canceled"
	case FireteamFinderLobbyState_Deleted:
		return "Deleted"
	}
	return fmt.Sprintf("FireteamFinderLobbyState_%d", e)
}

func (e FireteamFinderOfferState) Enum() string {
	switch e {
	case FireteamFinderOfferState_Unknown:
		return "Unknown"
	case FireteamFinderOfferState_Pending:
		return "Pending"
	case FireteamFinderOfferState_Accepted:
		return "Accepted"
	case FireteamFinderOfferState_Rejected:
		return "Rejected"
	case FireteamFinderOfferState_Deleted:
		return "Deleted"
	case FireteamFinderOfferState_Expired:
		return "Expired"
	}
	return fmt.Sprintf("FireteamFinderOfferState_%d", e)
}

func (e FireteamFinderPlayerReadinessState) Enum() string {
	switch e {
	case FireteamFinderPlayerReadinessState_Unknown:
		return "Unknown"
	case FireteamFinderPlayerReadinessState_Reserved:
		return "Reserved"
	case FireteamFinderPlayerReadinessState_Disconnected:
		return "Disconnected"
	case FireteamFinderPlayerReadinessState_InLobbyUnready:
		return "InLobbyUnready"
	case FireteamFinderPlayerReadinessState_InLobbyReady:
		return "InLobbyReady"
	case FireteamFinderPlayerReadinessState_Summoned:
		return "Summoned"
	}
	return fmt.Sprintf("FireteamFinderPlayerReadinessState_%d", e)
}

func (e CommunityContentSortMode) Enum() string {
	switch e {
	case CommunityContentSortMode_Trending:
		return "Trending"
	case CommunityContentSortMode_Latest:
		return "Latest"
	case CommunityContentSortMode_HighestRated:
		return "HighestRated"
	}
	return fmt.Sprintf("CommunityContentSortMode_%d", e)
}

func (e ForumMediaType) Enum() string {
	switch e {
	case ForumMediaType_None:
		return "None"
	case ForumMediaType_Image:
		return "Image"
	case ForumMediaType_Video:
		return "Video"
	case ForumMediaType_Youtube:
		return "Youtube"
	}
	return fmt.Sprintf("ForumMediaType_%d", e)
}

func (e ForumPostPopularity) Enum() string {
	switch e {
	case ForumPostPopularity_Empty:
		return "Empty"
	case ForumPostPopularity_Default:
		return "Default"
	case ForumPostPopularity_Discussed:
		return "Discussed"
	case ForumPostPopularity_CoolStory:
		return "CoolStory"
	case ForumPostPopularity_HeatingUp:
		return "HeatingUp"
	case ForumPostPopularity_Hot:
		return "Hot"
	}
	return fmt.Sprintf("ForumPostPopularity_%d", e)
}

func (e ForumPostSort) Enum() string {
	switch e {
	case ForumPostSort_Default:
		return "Default"
	case ForumPostSort_OldestFirst:
		return "OldestFirst"
	}
	return fmt.Sprintf("ForumPostSort_%d", e)
}

func (e ForumRecruitmentIntensityLabel) Enum() string {
	switch e {
	case ForumRecruitmentIntensityLabel_None:
		return "None"
	case ForumRecruitmentIntensityLabel_Casual:
		return "Casual"
	case ForumRecruitmentIntensityLabel_Professional:
		return "Professional"
	}
	return fmt.Sprintf("ForumRecruitmentIntensityLabel_%d", e)
}

func (e ForumRecruitmentToneLabel) Enum() string {
	switch e {
	case ForumRecruitmentToneLabel_None:
		return "None"
	case ForumRecruitmentToneLabel_FamilyFriendly:
		return "FamilyFriendly"
	case ForumRecruitmentToneLabel_Rowdy:
		return "Rowdy"
	}
	return fmt.Sprintf("ForumRecruitmentToneLabel_%d", e)
}

func (e ForumTopicsCategoryFilters) Enum() string {
	switch e {
	case ForumTopicsCategoryFilters_None:
		return "None"
	case ForumTopicsCategoryFilters_Links:
		return "Links"
	case ForumTopicsCategoryFilters_Questions:
		return "Questions"
	case ForumTopicsCategoryFilters_AnsweredQuestions:
		return "AnsweredQuestions"
	case ForumTopicsCategoryFilters_Media:
		return "Media"
	case ForumTopicsCategoryFilters_TextOnly:
		return "TextOnly"
	case ForumTopicsCategoryFilters_Announcement:
		return "Announcement"
	case ForumTopicsCategoryFilters_BungieOfficial:
		return "BungieOfficial"
	case ForumTopicsCategoryFilters_Polls:
		return "Polls"
	}
	return fmt.Sprintf("ForumTopicsCategoryFilters_%d", e)
}

func (e ForumTopicsQuickDate) Enum() string {
	switch e {
	case ForumTopicsQuickDate_All:
		return "All"
	case ForumTopicsQuickDate_LastYear:
		return "LastYear"
	case ForumTopicsQuickDate_LastMonth:
		return "LastMonth"
	case ForumTopicsQuickDate_LastWeek:
		return "LastWeek"
	case ForumTopicsQuickDate_LastDay:
		return "LastDay"
	}
	return fmt.Sprintf("ForumTopicsQuickDate_%d", e)
}

func (e ForumTopicsSort) Enum() string {
	switch e {
	case ForumTopicsSort_Default:
		return "Default"
	case ForumTopicsSort_LastReplied:
		return "LastReplied"
	case ForumTopicsSort_MostReplied:
		return "MostReplied"
	case ForumTopicsSort_Popularity:
		return "Popularity"
	case ForumTopicsSort_Controversiality:
		return "Controversiality"
	case ForumTopicsSort_Liked:
		return "Liked"
	case ForumTopicsSort_HighestRated:
		return "HighestRated"
	case ForumTopicsSort_MostUpvoted:
		return "MostUpvoted"
	}
	return fmt.Sprintf("ForumTopicsSort_%d", e)
}

func (e ForumFlags) Enum() string {
	switch e {
	case ForumFlags_None:
		return "None"
	case ForumFlags_BungieStaffPost:
		return "BungieStaffPost"
	case ForumFlags_ForumNinjaPost:
		return "ForumNinjaPost"
	case ForumFlags_ForumMentorPost:
		return "ForumMentorPost"
	case ForumFlags_TopicBungieStaffPosted:
		return "TopicBungieStaffPosted"
	case ForumFlags_TopicBungieVolunteerPosted:
		return "TopicBungieVolunteerPosted"
	case ForumFlags_QuestionAnsweredByBungie:
		return "QuestionAnsweredByBungie"
	case ForumFlags_QuestionAnsweredByNinja:
		return "QuestionAnsweredByNinja"
	case ForumFlags_CommunityContent:
		return "CommunityContent"
	}
	return fmt.Sprintf("ForumFlags_%d", e)
}

func (e ForumPostCategory) Enum() string {
	switch e {
	case ForumPostCategory_None:
		return "None"
	case ForumPostCategory_TextOnly:
		return "TextOnly"
	case ForumPostCategory_Media:
		return "Media"
	case ForumPostCategory_Link:
		return "Link"
	case ForumPostCategory_Poll:
		return "Poll"
	case ForumPostCategory_Question:
		return "Question"
	case ForumPostCategory_Answered:
		return "Answered"
	case ForumPostCategory_Announcement:
		return "Announcement"
	case ForumPostCategory_ContentComment:
		return "ContentComment"
	case ForumPostCategory_BungieOfficial:
		return "BungieOfficial"
	case ForumPostCategory_NinjaOfficial:
		return "NinjaOfficial"
	case ForumPostCategory_Recruitment:
		return "Recruitment"
	}
	return fmt.Sprintf("ForumPostCategory_%d", e)
}

func (e GlobalAlertLevel) Enum() string {
	switch e {
	case GlobalAlertLevel_Unknown:
		return "Unknown"
	case GlobalAlertLevel_Blue:
		return "Blue"
	case GlobalAlertLevel_Yellow:
		return "Yellow"
	case GlobalAlertLevel_Red:
		return "Red"
	}
	return fmt.Sprintf("GlobalAlertLevel_%d", e)
}

func (e GlobalAlertType) Enum() string {
	switch e {
	case GlobalAlertType_GlobalAlert:
		return "GlobalAlert"
	case GlobalAlertType_StreamingAlert:
		return "StreamingAlert"
	}
	return fmt.Sprintf("GlobalAlertType_%d", e)
}

func (e Capabilities) Enum() string {
	switch e {
	case Capabilities_None:
		return "None"
	case Capabilities_Leaderboards:
		return "Leaderboards"
	case Capabilities_Callsign:
		return "Callsign"
	case Capabilities_OptionalConversations:
		return "OptionalConversations"
	case Capabilities_ClanBanner:
		return "ClanBanner"
	case Capabilities_D2InvestmentData:
		return "D2InvestmentData"
	case Capabilities_Tags:
		return "Tags"
	case Capabilities_Alliances:
		return "Alliances"
	}
	return fmt.Sprintf("Capabilities_%d", e)
}

func (e ChatSecuritySetting) Enum() string {
	switch e {
	case ChatSecuritySetting_Group:
		return "Group"
	case ChatSecuritySetting_Admins:
		return "Admins"
	}
	return fmt.Sprintf("ChatSecuritySetting_%d", e)
}

func (e GroupAllianceStatus) Enum() string {
	switch e {
	case GroupAllianceStatus_Unallied:
		return "Unallied"
	case GroupAllianceStatus_Parent:
		return "Parent"
	case GroupAllianceStatus_Child:
		return "Child"
	}
	return fmt.Sprintf("GroupAllianceStatus_%d", e)
}

func (e GroupApplicationResolveState) Enum() string {
	switch e {
	case GroupApplicationResolveState_Unresolved:
		return "Unresolved"
	case GroupApplicationResolveState_Accepted:
		return "Accepted"
	case GroupApplicationResolveState_Denied:
		return "Denied"
	case GroupApplicationResolveState_Rescinded:
		return "Rescinded"
	}
	return fmt.Sprintf("GroupApplicationResolveState_%d", e)
}

func (e GroupDateRange) Enum() string {
	switch e {
	case GroupDateRange_All:
		return "All"
	case GroupDateRange_PastDay:
		return "PastDay"
	case GroupDateRange_PastWeek:
		return "PastWeek"
	case GroupDateRange_PastMonth:
		return "PastMonth"
	case GroupDateRange_PastYear:
		return "PastYear"
	}
	return fmt.Sprintf("GroupDateRange_%d", e)
}

func (e GroupHomepage) Enum() string {
	switch e {
	case GroupHomepage_Wall:
		return "Wall"
	case GroupHomepage_Forum:
		return "Forum"
	case GroupHomepage_AllianceForum:
		return "AllianceForum"
	}
	return fmt.Sprintf("GroupHomepage_%d", e)
}

func (e GroupMemberCountFilter) Enum() string {
	switch e {
	case GroupMemberCountFilter_All:
		return "All"
	case GroupMemberCountFilter_OneToTen:
		return "OneToTen"
	case GroupMemberCountFilter_ElevenToOneHundred:
		return "ElevenToOneHundred"
	case GroupMemberCountFilter_GreaterThanOneHundred:
		return "GreaterThanOneHundred"
	}
	return fmt.Sprintf("GroupMemberCountFilter_%d", e)
}

func (e GroupPostPublicity) Enum() string {
	switch e {
	case GroupPostPublicity_Public:
		return "Public"
	case GroupPostPublicity_Alliance:
		return "Alliance"
	case GroupPostPublicity_Private:
		return "Private"
	}
	return fmt.Sprintf("GroupPostPublicity_%d", e)
}

func (e GroupPotentialMemberStatus) Enum() string {
	switch e {
	case GroupPotentialMemberStatus_None:
		return "None"
	case GroupPotentialMemberStatus_Applicant:
		return "Applicant"
	case GroupPotentialMemberStatus_Invitee:
		return "Invitee"
	}
	return fmt.Sprintf("GroupPotentialMemberStatus_%d", e)
}

func (e GroupSortBy) Enum() string {
	switch e {
	case GroupSortBy_Name:
		return "Name"
	case GroupSortBy_Date:
		return "Date"
	case GroupSortBy_Popularity:
		return "Popularity"
	case GroupSortBy_Id:
		return "Id"
	}
	return fmt.Sprintf("GroupSortBy_%d", e)
}

func (e GroupType) Enum() string {
	switch e {
	case GroupType_General:
		return "General"
	case GroupType_Clan:
		return "Clan"
	}
	return fmt.Sprintf("GroupType_%d", e)
}

func (e GroupsForMemberFilter) Enum() string {
	switch e {
	case GroupsForMemberFilter_All:
		return "All"
	case GroupsForMemberFilter_Founded:
		return "Founded"
	case GroupsForMemberFilter_NonFounded:
		return "NonFounded"
	}
	return fmt.Sprintf("GroupsForMemberFilter_%d", e)
}

func (e HostGuidedGamesPermissionLevel) Enum() string {
	switch e {
	case HostGuidedGamesPermissionLevel_None:
		return "None"
	case HostGuidedGamesPermissionLevel_Beginner:
		return "Beginner"
	case HostGuidedGamesPermissionLevel_Member:
		return "Member"
	}
	return fmt.Sprintf("HostGuidedGamesPermissionLevel_%d", e)
}

func (e MembershipOption) Enum() string {
	switch e {
	case MembershipOption_Reviewed:
		return "Reviewed"
	case MembershipOption_Open:
		return "Open"
	case MembershipOption_Closed:
		return "Closed"
	}
	return fmt.Sprintf("MembershipOption_%d", e)
}

func (e RuntimeGroupMemberType) Enum() string {
	switch e {
	case RuntimeGroupMemberType_None:
		return "None"
	case RuntimeGroupMemberType_Beginner:
		return "Beginner"
	case RuntimeGroupMemberType_Member:
		return "Member"
	case RuntimeGroupMemberType_Admin:
		return "Admin"
	case RuntimeGroupMemberType_ActingFounder:
		return "ActingFounder"
	case RuntimeGroupMemberType_Founder:
		return "Founder"
	}
	return fmt.Sprintf("RuntimeGroupMemberType_%d", e)
}

func (e IgnoreLength) Enum() string {
	switch e {
	case IgnoreLength_None:
		return "None"
	case IgnoreLength_Week:
		return "Week"
	case IgnoreLength_TwoWeeks:
		return "TwoWeeks"
	case IgnoreLength_ThreeWeeks:
		return "ThreeWeeks"
	case IgnoreLength_Month:
		return "Month"
	case IgnoreLength_ThreeMonths:
		return "ThreeMonths"
	case IgnoreLength_SixMonths:
		return "SixMonths"
	case IgnoreLength_Year:
		return "Year"
	case IgnoreLength_Forever:
		return "Forever"
	case IgnoreLength_ThreeMinutes:
		return "ThreeMinutes"
	case IgnoreLength_Hour:
		return "Hour"
	case IgnoreLength_ThirtyDays:
		return "ThirtyDays"
	}
	return fmt.Sprintf("IgnoreLength_%d", e)
}

func (e IgnoreStatus) Enum() string {
	switch e {
	case IgnoreStatus_NotIgnored:
		return "NotIgnored"
	case IgnoreStatus_IgnoredUser:
		return "IgnoredUser"
	case IgnoreStatus_IgnoredGroup:
		return "IgnoredGroup"
	case IgnoreStatus_IgnoredByGroup:
		return "IgnoredByGroup"
	case IgnoreStatus_IgnoredPost:
		return "IgnoredPost"
	case IgnoreStatus_IgnoredTag:
		return "IgnoredTag"
	case IgnoreStatus_IgnoredGlobal:
		return "IgnoredGlobal"
	}
	return fmt.Sprintf("IgnoreStatus_%d", e)
}

func (e FriendRelationshipState) Enum() string {
	switch e {
	case FriendRelationshipState_Unknown:
		return "Unknown"
	case FriendRelationshipState_Friend:
		return "Friend"
	case FriendRelationshipState_IncomingRequest:
		return "IncomingRequest"
	case FriendRelationshipState_OutgoingRequest:
		return "OutgoingRequest"
	}
	return fmt.Sprintf("FriendRelationshipState_%d", e)
}

func (e PlatformFriendType) Enum() string {
	switch e {
	case PlatformFriendType_Unknown:
		return "Unknown"
	case PlatformFriendType_Xbox:
		return "Xbox"
	case PlatformFriendType_PSN:
		return "PSN"
	case PlatformFriendType_Steam:
		return "Steam"
	case PlatformFriendType_Egs:
		return "Egs"
	}
	return fmt.Sprintf("PlatformFriendType_%d", e)
}

func (e PresenceOnlineStateFlags) Enum() string {
	switch e {
	case PresenceOnlineStateFlags_None:
		return "None"
	case PresenceOnlineStateFlags_Destiny1:
		return "Destiny1"
	case PresenceOnlineStateFlags_Destiny2:
		return "Destiny2"
	}
	return fmt.Sprintf("PresenceOnlineStateFlags_%d", e)
}

func (e PresenceStatus) Enum() string {
	switch e {
	case PresenceStatus_OfflineOrUnknown:
		return "OfflineOrUnknown"
	case PresenceStatus_Online:
		return "Online"
	}
	return fmt.Sprintf("PresenceStatus_%d", e)
}

func (e DropState) Enum() string {
	switch e {
	case DropState_Claimed:
		return "Claimed"
	case DropState_Applied:
		return "Applied"
	case DropState_Fulfilled:
		return "Fulfilled"
	}
	return fmt.Sprintf("DropState_%d", e)
}

func (e TrendingEntryType) Enum() string {
	switch e {
	case TrendingEntryType_News:
		return "News"
	case TrendingEntryType_DestinyItem:
		return "DestinyItem"
	case TrendingEntryType_DestinyActivity:
		return "DestinyActivity"
	case TrendingEntryType_DestinyRitual:
		return "DestinyRitual"
	case TrendingEntryType_SupportArticle:
		return "SupportArticle"
	case TrendingEntryType_Creation:
		return "Creation"
	case TrendingEntryType_Stream:
		return "Stream"
	case TrendingEntryType_Update:
		return "Update"
	case TrendingEntryType_Link:
		return "Link"
	case TrendingEntryType_ForumTag:
		return "ForumTag"
	case TrendingEntryType_Container:
		return "Container"
	case TrendingEntryType_Release:
		return "Release"
	}
	return fmt.Sprintf("TrendingEntryType_%d", e)
}

func (e OptInFlags) Enum() string {
	switch e {
	case OptInFlags_None:
		return "None"
	case OptInFlags_Newsletter:
		return "Newsletter"
	case OptInFlags_System:
		return "System"
	case OptInFlags_Marketing:
		return "Marketing"
	case OptInFlags_UserResearch:
		return "UserResearch"
	case OptInFlags_CustomerService:
		return "CustomerService"
	case OptInFlags_Social:
		return "Social"
	case OptInFlags_PlayTests:
		return "PlayTests"
	case OptInFlags_PlayTestsLocal:
		return "PlayTestsLocal"
	case OptInFlags_Careers:
		return "Careers"
	}
	return fmt.Sprintf("OptInFlags_%d", e)
}
